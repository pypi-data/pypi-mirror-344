# Copyright 2025 Rahul Kaushal
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
OpenAPI Parser module for parsing OpenAPI (Swagger) specifications.
Supports both OpenAPI v2 (Swagger 2.0) and OpenAPI v3 specifications.
"""

from typing import Any, Optional, Union
from .base_parser import BaseParser, ParserError, SpecFormat
from ..dataclasses import Endpoint, Parameter, RequestBody


class OpenAPIParser(BaseParser):
    """Parser for OpenAPI/Swagger specifications."""

    def __init__(self, source: Union[str, dict[str, Any]]):
        self.components_schemas: dict[str, Any] = {}
        self.visited_refs: set[str] = set()
        super().__init__(source)

    def _parse(self):
        """Parse OpenAPI specification from a URL or file path."""
        try:
            self.format = self.get_format()

            if self.format == SpecFormat.UNKNOWN:
                raise ParserError("Unsupported API specification format")

            self._extract_servers()
            self._extract_security_schemes()
            self._extract_components_schemas()
            self._extract_endpoints()

            self.logger.info(
                f"Successfully parsed {len(self.endpoints)} endpoints from specification"
            )

        except Exception as e:
            self.logger.error(f"Error parsing OpenAPI specification: {str(e)}")
            raise ParserError(f"Failed to parse OpenAPI specification: {str(e)}") from e

    def get_format(self) -> SpecFormat:
        """Get the format of the API specification."""
        if "swagger" in self.spec and self.spec["swagger"].startswith("2."):
            self.logger.debug("Detected OpenAPI v2 (Swagger) specification")
            return SpecFormat.OPENAPI_V2
        elif "openapi" in self.spec and self.spec["openapi"].startswith("3."):
            self.logger.debug("Detected OpenAPI v3 specification")
            return SpecFormat.OPENAPI_V3
        else:
            self.logger.warning("Unable to determine API specification format")
            return SpecFormat.UNKNOWN

    def _extract_servers(self):
        """Extract server URLs from the specification."""
        try:
            if self.format == SpecFormat.OPENAPI_V3 and "servers" in self.spec:
                self.servers = [server["url"] for server in self.spec["servers"]]
                self.logger.debug(
                    f"Extracted {len(self.servers)} servers from OpenAPI v3 spec"
                )
            elif self.format == SpecFormat.OPENAPI_V2:
                # Swagger 2.0 uses 'schemes', 'host', and 'basePath' fields
                schemes = self.spec.get("schemes", ["http"])
                host = self.spec.get("host", "")
                base_path = self.spec.get("basePath", "/")

                if host:
                    self.servers = [
                        f"{scheme}://{host}{base_path}" for scheme in schemes
                    ]
                    self.logger.debug(
                        f"Extracted {len(self.servers)} servers from Swagger 2.0 spec"
                    )
                else:
                    self.logger.warning(
                        "No host defined in Swagger 2.0 spec, unable to extract server URLs"
                    )
        except Exception as e:
            self.logger.error(f"Error extracting servers: {str(e)}")
            self.servers = []

    def _extract_security_schemes(self) -> None:
        """Extract security schemes from the specification."""
        try:
            if self.format == SpecFormat.OPENAPI_V3 and "components" in self.spec:
                self.security_schemes = self.spec["components"].get(
                    "securitySchemes", {}
                )
                self.logger.debug(
                    f"Extracted {len(self.security_schemes)} security schemes from OpenAPI v3 spec"
                )
            elif self.format == SpecFormat.OPENAPI_V2:
                self.security_schemes = self.spec.get("securityDefinitions", {})
                self.logger.debug(
                    f"Extracted {len(self.security_schemes)} security schemes from Swagger 2.0 spec"
                )
        except Exception as e:
            self.logger.error(f"Error extracting security schemes: {str(e)}")
            self.security_schemes = {}

    def _extract_components_schemas(self) -> None:
        """Extract components/definitions schemas from the specification."""
        try:
            if self.format == SpecFormat.OPENAPI_V3 and "components" in self.spec:
                self.components_schemas = self.spec["components"].get("schemas", {})
                self.logger.debug(
                    f"Extracted {len(self.components_schemas)} component schemas from OpenAPI v3 spec"
                )
            elif self.format == SpecFormat.OPENAPI_V2:
                self.components_schemas = self.spec.get("definitions", {})
                self.logger.debug(
                    f"Extracted {len(self.components_schemas)} definitions from Swagger 2.0 spec"
                )
        except Exception as e:
            self.logger.error(f"Error extracting component schemas: {str(e)}")
            self.components_schemas = {}

    def _extract_endpoints(self) -> None:
        """Extract endpoints from the specification."""
        try:
            paths = self.spec.get("paths", {})
            endpoint_count = 0

            for path, path_item in paths.items():
                for method, operation in path_item.items():
                    if method not in [
                        "get",
                        "post",
                        "put",
                        "patch",
                        "delete",
                        "options",
                        "head",
                    ]:
                        continue

                    try:
                        parameters = self._parse_parameters(
                            path_item.get("parameters", [])
                            + operation.get("parameters", [])
                        )
                        request_body = self._parse_request_body(operation)

                        endpoint = Endpoint(
                            path=path,
                            method=method,
                            operation_id=operation.get("operationId"),
                            summary=operation.get("summary"),
                            description=operation.get("description"),
                            parameters=parameters,
                            request_body=request_body,
                            responses=operation.get("responses", {}),
                            security=operation.get(
                                "security", self.spec.get("security", [])
                            ),
                            tags=operation.get("tags", []),
                            deprecated=operation.get("deprecated", False),
                        )

                        self.endpoints.append(endpoint)
                        endpoint_count += 1
                        self.logger.debug(
                            f"Extracted endpoint: {method.upper()} {path}"
                        )
                    except Exception as e:
                        self.logger.warning(
                            f"Error processing endpoint {method.upper()} {path}: {str(e)}"
                        )
                        # Continue processing other endpoints

            self.logger.info(f"Extracted {endpoint_count} endpoints from specification")
        except Exception as e:
            self.logger.error(f"Error extracting endpoints: {str(e)}")
            raise ParserError(f"Failed to extract endpoints: {str(e)}") from e

    def _parse_parameters(self, parameters: list[dict[str, Any]]) -> list[Parameter]:
        """Parse parameters from the specification."""
        result = []

        for param in parameters:
            try:
                if "$ref" in param:
                    ref_path = param["$ref"]
                    self.logger.debug(f"Resolving parameter reference: {ref_path}")
                    param = self._resolve_reference(ref_path)
                    if not param:
                        self.logger.warning(
                            f"Failed to resolve parameter reference: {ref_path}"
                        )
                        continue

                # Check for required fields
                if "name" not in param:
                    self.logger.warning(
                        "Parameter missing required 'name' field, skipping"
                    )
                    continue

                schema = param.get("schema", {})
                if "$ref" in schema:
                    self.logger.debug(f"Resolving schema reference: {schema['$ref']}")
                    resolved_schema = self._resolve_reference(schema["$ref"])
                    if resolved_schema:
                        schema.update(resolved_schema)
                        schema.pop("$ref", None)
                    else:
                        self.logger.warning(
                            f"Failed to resolve schema reference: {schema['$ref']}"
                        )

                parameter = Parameter(
                    name=param["name"],
                    location=param.get("in", "query"),
                    required=param.get("required", False),
                    type=param.get("type") or schema.get("type", "string"),
                    format=param.get("format") or schema.get("format"),
                    description=param.get("description"),
                    enum=param.get("enum", []) or schema.get("enum", []),
                    example=param.get("example") or schema.get("example"),
                    pattern=param.get("pattern") or schema.get("pattern"),
                    min_length=param.get("minLength") or schema.get("minLength"),
                    max_length=param.get("maxLength") or schema.get("maxLength"),
                    minimum=param.get("minimum") or schema.get("minimum"),
                    maximum=param.get("maximum") or schema.get("maximum"),
                    schema=schema,
                )

                result.append(parameter)
                self.logger.debug(
                    f"Parsed parameter: {param['name']} ({param.get('in', 'query')})"
                )
            except Exception as e:
                param_name = param.get("name", "unnamed")
                self.logger.warning(f"Error parsing parameter '{param_name}': {str(e)}")
                # Continue processing other parameters

        return result

    def _parse_request_body(self, operation: dict[str, Any]) -> Optional[RequestBody]:
        """Parse request body from the operation."""
        try:
            if self.format == SpecFormat.OPENAPI_V3:
                if "requestBody" not in operation:
                    return None

                request_body = operation["requestBody"]

                # Handle request body reference
                if "$ref" in request_body:
                    ref_path = request_body["$ref"]
                    self.logger.debug(f"Resolving request body reference: {ref_path}")
                    request_body = self._resolve_reference(ref_path)
                    if not request_body:
                        self.logger.warning(
                            f"Failed to resolve request body reference: {ref_path}"
                        )
                        return None

                content = request_body.get("content", {})
                if not content:
                    self.logger.debug("Request body has no content, skipping")
                    return None

                # Get the first content type
                try:
                    content_type, content_schema = next(iter(content.items()))
                except StopIteration:
                    self.logger.warning("Request body content is empty")
                    return None

                schema = content_schema.get("schema", {})

                # Resolve schema reference if needed
                resolved_schema = {}
                if "$ref" in schema:
                    ref_path = schema["$ref"]
                    self.logger.debug(f"Resolving schema reference: {ref_path}")
                    resolved_schema = self._resolve_reference(ref_path)
                    if not resolved_schema:
                        self.logger.warning(
                            f"Failed to resolve schema reference: {ref_path}"
                        )

                properties = {}
                if "properties" in schema:
                    properties = schema["properties"]
                elif "properties" in resolved_schema:
                    properties = resolved_schema["properties"]

                # Resolve property references
                resolved_properties = self._resolve_property_references(properties)

                self.logger.debug(
                    f"Parsed OpenAPI v3 request body with content type: {content_type}"
                )
                return RequestBody(
                    content_type=content_type,
                    schema=schema,
                    required=request_body.get("required", False),
                    example=content_schema.get("example"),
                    properties=resolved_properties,
                    resolved_schema=resolved_schema,
                )

            elif self.format == SpecFormat.OPENAPI_V2:
                # In Swagger 2.0, request body is defined in parameters with "in": "body"
                for param in operation.get("parameters", []):
                    if param.get("in") == "body" and "schema" in param:
                        schema = param["schema"]

                        # Resolve schema reference if needed
                        resolved_schema = {}
                        if "$ref" in schema:
                            ref_path = schema["$ref"]
                            self.logger.debug(f"Resolving schema reference: {ref_path}")
                            resolved_schema = self._resolve_reference(ref_path)
                            if not resolved_schema:
                                self.logger.warning(
                                    f"Failed to resolve schema reference: {ref_path}"
                                )

                        properties = {}
                        if "properties" in schema:
                            properties = schema["properties"]
                        elif "properties" in resolved_schema:
                            properties = resolved_schema["properties"]

                        # Resolve property references
                        resolved_properties = self._resolve_property_references(
                            properties
                        )

                        self.logger.debug("Parsed Swagger 2.0 request body")
                        return RequestBody(
                            content_type="application/json",  # Default for Swagger 2.0
                            schema=schema,
                            required=param.get("required", False),
                            example=param.get("example"),
                            properties=resolved_properties,
                            resolved_schema=resolved_schema,
                        )
                self.logger.debug("No request body found in Swagger 2.0 specification")
            return None
        except Exception as e:
            self.logger.error(f"Error parsing request body: {str(e)}")
            return None

    def _resolve_property_references(
        self, properties: dict[str, Any]
    ) -> dict[str, Any]:
        """Recursively resolve references in properties."""
        resolved = {}

        for prop_name, prop_schema in properties.items():
            try:
                if "$ref" in prop_schema:
                    ref_path = prop_schema["$ref"]
                    self.logger.debug(
                        f"Resolving property reference: {ref_path} for property {prop_name}"
                    )
                    ref_schema = self._resolve_reference(ref_path)
                    if not ref_schema:
                        self.logger.warning(
                            f"Failed to resolve property reference: {ref_path} for property {prop_name}"
                        )
                        resolved[prop_name] = prop_schema
                        continue

                    # Create a new dict to avoid modifying the original schema
                    resolved_prop = {**prop_schema, **ref_schema}
                    resolved_prop.pop("$ref", None)
                    resolved[prop_name] = resolved_prop
                elif (
                    prop_schema.get("type") == "object" and "properties" in prop_schema
                ):
                    # Recursively resolve nested properties
                    nested_props = self._resolve_property_references(
                        prop_schema["properties"]
                    )
                    resolved_prop = {**prop_schema, "properties": nested_props}
                    resolved[prop_name] = resolved_prop
                elif prop_schema.get("type") == "array" and "items" in prop_schema:
                    items = prop_schema["items"]
                    if "$ref" in items:
                        ref_path = items["$ref"]
                        self.logger.debug(
                            f"Resolving array items reference: {ref_path} for property {prop_name}"
                        )
                        ref_items = self._resolve_reference(ref_path)
                        if not ref_items:
                            self.logger.warning(
                                f"Failed to resolve array items reference: {ref_path}"
                            )
                            resolved[prop_name] = prop_schema
                            continue

                        resolved_items = {**items, **ref_items}
                        resolved_items.pop("$ref", None)

                        # Handle nested object in array items
                        if (
                            resolved_items.get("type") == "object"
                            and "properties" in resolved_items
                        ):
                            nested_props = self._resolve_property_references(
                                resolved_items["properties"]
                            )
                            resolved_items["properties"] = nested_props

                        resolved_prop = {**prop_schema, "items": resolved_items}
                        resolved[prop_name] = resolved_prop
                    else:
                        resolved[prop_name] = prop_schema
                else:
                    resolved[prop_name] = prop_schema
            except Exception as e:
                self.logger.warning(f"Error resolving property {prop_name}: {str(e)}")
                resolved[prop_name] = (
                    prop_schema  # Use original schema if resolution fails
                )

        return resolved

    def _resolve_reference(self, ref: str) -> dict[str, Any]:
        """Resolve a reference in the specification."""
        if not ref:
            self.logger.warning("Empty reference provided")
            return {}

        try:
            if ref in self.visited_refs:
                # Prevent infinite recursion with circular references
                self.logger.warning(f"Circular reference detected: {ref}")
                return {}

            self.visited_refs.add(ref)

            # Handle local references
            if ref.startswith("#/"):
                parts = ref.split("/")[1:]

                # Navigate through the spec
                current = self.spec
                for part in parts:
                    if part not in current:
                        self.logger.warning(
                            f"Reference part '{part}' not found in {list(current.keys())}"
                        )
                        self.visited_refs.remove(ref)
                        return {}
                    current = current[part]

                # If the resolved object has further references, resolve them too
                if isinstance(current, dict) and "$ref" in current:
                    nested_ref = current["$ref"]
                    self.logger.debug(f"Resolving nested reference: {nested_ref}")
                    resolved = self._resolve_reference(nested_ref)
                    # Merge with the original object, but keep the original values if they exist
                    for key, value in resolved.items():
                        if key not in current:
                            current[key] = value

                self.visited_refs.remove(ref)
                return current

            # External references not supported yet
            self.logger.warning(f"External references not supported: {ref}")
            self.visited_refs.remove(ref)
            return {}
        except Exception as e:
            self.logger.error(f"Error resolving reference {ref}: {str(e)}")
            if ref in self.visited_refs:
                self.visited_refs.remove(ref)
            return {}
