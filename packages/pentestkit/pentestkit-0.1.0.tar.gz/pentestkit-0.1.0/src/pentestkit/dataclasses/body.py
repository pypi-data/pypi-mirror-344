# Copyright 2025 Rahul Kaushal
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import random
from ..utils import generate_test_value
from dataclasses import dataclass, field
from typing import Any, Optional, Union


@dataclass
class RequestBody:
    """Represents a request body."""

    content_type: str
    schema: dict[str, Any]
    required: bool = False
    example: Optional[Any] = None
    properties: dict[str, Any] = field(default_factory=dict)
    resolved_schema: dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """Generates example values if not provided"""
        if self.example is None:
            self.example = generate_example_body(self)


def generate_example_body(request_body: RequestBody) -> Any:

    content_type_handlers = {
        "application/json": lambda: generate_json_example(request_body.properties),
    }

    handler = content_type_handlers.get(request_body.content_type)
    return handler() if handler else None


def generate_json_example(properties: dict[str, Any]) -> dict[str, Any]:
    result = {}
    for prop_name, prop_schema in properties.items():
        # Handle anyOf case
        if "anyOf" in prop_schema:
            for schema_option in prop_schema["anyOf"]:
                if schema_option.get("type") != "null":
                    result[prop_name] = generate_property_value(schema_option)
                    break
            continue

        # Handle normal types
        result[prop_name] = generate_property_value(prop_schema)

    return result


def generate_property_value(schema: dict[str, Any]) -> Any:

    prop_type = schema.get("type", "string")

    if prop_type == "string":
        return generate_string_property(schema)
    elif prop_type == "number" or prop_type == "integer":
        return generate_numerical_property(schema, prop_type == "integer")
    elif prop_type == "boolean":
        return random.choice([True, False])
    elif prop_type == "object":
        return generate_object_property(schema)
    elif prop_type == "array":
        return generate_array_property(schema)

    # Default fallback
    return "example"


def generate_string_property(schema: dict[str, Any]) -> str:

    for attr in ("examples", "enum", "example"):
        if values := schema.get(attr):
            return random.choice(values) if isinstance(values, list) else values

    pattern = schema.get("pattern")
    min_length = schema.get("minLength", 3)
    max_length = schema.get("maxLength", 50)

    if pattern:
        return generate_test_value(pattern, min_length, max_length)

    format_values = {
        "date": "2025-04-23",
        "date-time": "2025-04-23T14:30:00Z",
        "email": "user@example.com",
        "uri": "https://example.com/resource",
        "uuid": "123e4567-e89b-12d3-a456-426614174000",
        "hostname": "example.com",
        "ipv4": "192.168.1.1",
        "ipv6": "2001:0db8:85a3:0000:0000:8a2e:0370:7334",
    }

    return format_values.get(schema.get("format", "none"), "example")


def generate_numerical_property(
    schema: dict[str, Any], is_integer: bool
) -> Union[int, float]:
    for attr in ("examples", "enum", "example"):
        if values := schema.get(attr):
            try:
                value = random.choice(values) if isinstance(values, list) else values
                return int(value) if is_integer else float(value)
            except (ValueError, TypeError):
                pass

    try:
        if "exclusiveMinimum" in schema:
            minimum = schema["exclusiveMinimum"] + (1 if is_integer else 0.01)
        else:
            minimum = schema.get("minimum", 1)

        if "exclusiveMaximum" in schema:
            maximum = schema["exclusiveMaximum"] - (1 if is_integer else 0.01)
        else:
            maximum = schema.get("maximum", 100)

        # Ensure min doesn't exceed max
        if minimum > maximum:
            minimum, maximum = maximum, minimum

        if is_integer:
            return random.randint(int(minimum), int(maximum))

        multiple_of = schema.get("multipleOf")
        if multiple_of:
            value = random.uniform(float(minimum), float(maximum))
            return round(value / multiple_of) * multiple_of

        return round(random.uniform(float(minimum), float(maximum)), 2)

    except (ValueError, TypeError):
        return 1 if is_integer else 1.0


def generate_object_property(schema: dict[str, Any]) -> dict[str, Any]:
    try:
        if "properties" in schema:
            return generate_json_example(schema.get("properties", {}))
        elif "additionalProperties" in schema and isinstance(
            schema["additionalProperties"], dict
        ):
            sample_props = {
                "key1": generate_property_value(schema["additionalProperties"]),
                "key2": generate_property_value(schema["additionalProperties"]),
            }
            return sample_props
        return {"example": "object-value"}
    except Exception:
        return {"example": "object-value"}


def generate_array_property(schema: dict[str, Any]) -> list[Any]:
    try:
        items_schema = schema.get("items", {})
        min_items = schema.get("minItems", 1)
        max_items = schema.get("maxItems", 3)
        num_items = min(min_items, max_items)

        result = []
        for _ in range(num_items):
            result.append(generate_property_value(items_schema))
        return result
    except Exception:
        return ["example"]
