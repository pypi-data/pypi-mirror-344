Metadata-Version: 2.4
Name: transformative_harmonization
Version: 0.2.2
Summary: A Python library for Transformative Harmonization, a novel similarity metric
Home-page: https://github.com/Zayn/transformative_harmonization
Author: Zayn
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
Requires-Python: >=3.7
Description-Content-Type: text/markdown
License-File: LICENSE.txt
Requires-Dist: numpy>=1.21.0
Requires-Dist: scikit-learn>=1.0.0
Dynamic: author
Dynamic: classifier
Dynamic: description
Dynamic: description-content-type
Dynamic: home-page
Dynamic: license-file
Dynamic: requires-dist
Dynamic: requires-python
Dynamic: summary

Transformative Harmonization
A Python library for Transformative Harmonization, a novel mathematical operation designed by Zayn. This operation combines numbers, vectors, or matrices in a context-aware, harmonious manner, offering a new similarity metric for data science and machine learning applications.
Features

Harmonization of numbers, vectors, and matrices with customizable context parameters.
Optimized for machine learning tasks (clustering, classification, recommendation systems).
Comprehensive mathematical properties (commutativity, continuity) and unit tests.
Extensive documentation with practical examples.
MIT licensed for open-source use.

Installation
Install via pip:
pip install transformative-harmonization

Published on PyPI: https://pypi.org/project/transformative-harmonization/


Quick Start
Basic Harmonization (Numbers)
from transformative_harmonization import TransformativeHarmonization

th = TransformativeHarmonization(context={'weight': 1.0, 'scale': 1.0})
result = th.harmonize(3, 4)
print(result)  # Output: ~3.50

Vector Harmonization (Machine Learning)
import numpy as np
from transformative_harmonization import VectorHarmonization

vh = VectorHarmonization(context={'weight': 1.0, 'scale': 1.0})
v1 = np.array([1, 0])
v2 = np.array([0, 1])
result = vh.harmonize(v1, v2)
print(result)  # Output: Harmonized vector

Custom Harmonization
from transformative_harmonization import CustomHarmonization

def custom_harmony(a, b, context):
    return context['scale'] * (a + b) / 2
ch = CustomHarmonization(custom_harmony, context={'scale': 2.0})
result = ch.harmonize(3, 5)
print(result)  # Output: 8.0

Running Tests
To run the unit tests:
pip install numpy scikit-learn
python -m unittest discover tests

Documentation
Full documentation is available at Read the Docs.
Mathematical Properties

Commutative: Yes (H(a, b) = H(b, a)).
Associative: No (H(H(a, b), c) â‰  H(a, H(b, c))).
Continuous: Yes for all inputs except a + b = 0.
Contextual: Adjustable via weight and scale parameters.

Contributing
Contributions are welcome! Please:

Fork the repository.
Create

 a feature branch.3. Submit a pull request with clear documentation and tests.
See CONTRIBUTING.md for details.
License
This project is licensed under the MIT License. See the LICENSE file for details.
Contact
For questions or feedback, please open an issue on GitHub or contact Zayn.
