"""Module containing class to parse devicetree format ZMK keymaps."""

import logging
import re
from functools import cache
from itertools import chain
from pathlib import Path
from typing import Sequence

from keymap_drawer.config import ParseConfig
from keymap_drawer.dts import DeviceTree
from keymap_drawer.keymap import ComboSpec, KeymapData, LayoutKey
from keymap_drawer.parse.parse import KeymapParser, ParseError

logger = logging.getLogger(__name__)

ZMK_LAYOUTS_PATH = Path(__file__).parent.parent.parent / "resources" / "zmk_keyboard_layouts.yaml"
ZMK_DEFINES_PATH = Path(__file__).parent.parent.parent / "resources" / "zmk_defines.h"
GLOVE80_MARKER = "THIS FILE WAS GENERATED BY GLOVE80 LAYOUT EDITOR"


class ZmkKeymapParser(KeymapParser):
    """Parser for ZMK devicetree keymaps, using C preprocessor and tree-sitter-devicetree."""

    _numbers_re = re.compile(r"N(UM(BER)?_)?(\d)")
    _modifier_fn_to_std = {
        "LC": ["left_ctrl"],
        "LS": ["left_shift"],
        "LA": ["left_alt"],
        "LG": ["left_gui"],
        "RC": ["right_ctrl"],
        "RS": ["right_shift"],
        "RA": ["right_alt"],
        "RG": ["right_gui"],
    }

    def __init__(
        self,
        config: ParseConfig,
        columns: int | None,
        base_keymap: KeymapData | None = None,
        layer_names: list[str] | None = None,
        virtual_layers: list[str] | None = None,
    ):
        super().__init__(config, columns, base_keymap, layer_names, virtual_layers)
        self.hold_taps = {"&mt": ["&kp", "&kp"], "&lt": ["&mo", "&kp"]}
        self.mod_morphs = {"&gresc": ["&kp ESC", "&kp GRAVE"]}
        self.sticky_keys = {"&sk": ["&kp"], "&sl": ["&mo"]}
        self._prefix_re: re.Pattern | None
        if prefixes := self.cfg.zmk_remove_keycode_prefix:
            self._prefix_re = re.compile(r"\b(" + "|".join(re.escape(prefix) for prefix in set(prefixes)) + ")")
        else:
            self._prefix_re = None

    def _update_raw_binding_map(self, dts: DeviceTree) -> None:
        raw_keys = list(self.raw_binding_map.keys())
        prep_keys = dts.preprocess_extra_data("\n".join(raw_keys)).splitlines()
        assert len(raw_keys) == len(
            prep_keys
        ), "Keys in parse_config.raw_binding_map did not preprocess properly, please check for issues"
        for old, new in zip(raw_keys, prep_keys):
            if new != old:
                self.raw_binding_map[new] = self.raw_binding_map[old]
                del self.raw_binding_map[old]
        logger.debug("updated raw_binding_map: %s", self.raw_binding_map)

    def _str_to_key(  # pylint: disable=too-many-return-statements,too-many-locals
        self, binding: str, current_layer: int | None, key_positions: Sequence[int], no_shifted: bool = False
    ) -> LayoutKey:
        if binding in self.raw_binding_map:
            return LayoutKey.from_key_spec(self.raw_binding_map[binding])
        binding_parts = binding.split()
        if binding_parts[0] in self.raw_binding_map:
            return LayoutKey.from_key_spec(self.raw_binding_map[binding_parts[0]])
        if self.cfg.skip_binding_parsing:
            return LayoutKey(tap=binding)

        assert self.layer_names is not None
        assert self.layer_legends is not None

        def mapped(key: str) -> LayoutKey:
            if entry := self.cfg.zmk_keycode_map.get(key):
                return LayoutKey.from_key_spec(entry)
            key, mods = self.parse_modifier_fns(key)
            if self._prefix_re is not None:
                key = self._prefix_re.sub("", key)
            mapped = LayoutKey.from_key_spec(
                self.cfg.zmk_keycode_map.get(
                    key,
                    self._numbers_re.sub(r"\3", key)
                    .removeprefix("C_")
                    .removeprefix("K_")
                    .replace("BT_SEL", "BT")
                    .replace("_", " "),
                )
            )
            if no_shifted:
                mapped.shifted = ""
            if mods:
                mapped.apply_formatter(lambda key: self.format_modified_keys(key, mods))
            return mapped

        match binding_parts:
            case ["&none", *_]:
                return LayoutKey()
            case ["&trans"]:
                return self.trans_key
            case [ref, *_] if ref in self.mod_morphs:
                tap_key = self._str_to_key(self.mod_morphs[ref][0], current_layer, key_positions)
                shifted_key = self._str_to_key(self.mod_morphs[ref][1], current_layer, key_positions)
                return LayoutKey(tap=tap_key.tap, hold=tap_key.hold, shifted=shifted_key.tap)
            case ["&kp", *pars]:
                return mapped(" ".join(pars))
            case ["&kt", *pars]:
                l_key = mapped(" ".join(pars))
                return LayoutKey(tap=l_key.tap, hold=self.cfg.toggle_label, shifted=l_key.shifted)
            case [ref, *pars] if ref in self.sticky_keys:
                l_key = self._str_to_key(f"{self.sticky_keys[ref][0]} {' '.join(pars)}", current_layer, key_positions)
                return LayoutKey(tap=l_key.tap, hold=self.cfg.sticky_label, shifted=l_key.shifted)
            case ["&bt", *pars]:
                mapped_action = mapped(pars[0])
                if len(pars) == 1:
                    return mapped_action
                return LayoutKey(tap=mapped_action.tap, shifted=mapped_action.shifted, hold=pars[1])
            case [("&out" | "&ext_power" | "&rgb_ug"), *pars]:
                return LayoutKey(tap=" ".join(pars).replace("_", " "))
            case [("&mo" | "&to" | "&tog") as behavior, par]:
                if behavior in ("&mo",):
                    self.update_layer_activated_from(
                        [current_layer] if current_layer is not None else [], int(par), key_positions
                    )
                    return LayoutKey(tap=self.layer_legends[int(par)])
                return LayoutKey(tap=self.layer_legends[int(par)], hold=self.cfg.toggle_label)
            case [ref, hold_par, tap_par] if ref in self.hold_taps:
                hold_key = self._str_to_key(f"{self.hold_taps[ref][0]} {hold_par}", current_layer, key_positions)
                tap_key = self._str_to_key(f"{self.hold_taps[ref][1]} {tap_par}", current_layer, key_positions)
                return LayoutKey(tap=tap_key.tap, hold=hold_key.tap, shifted=tap_key.shifted)
            case [ref] | [ref, "0"]:
                return LayoutKey(tap=ref)
        return LayoutKey(tap=binding)

    def _update_behaviors(self, dts: DeviceTree) -> None:
        def get_behavior_bindings(compatible_value: str, n_bindings: int) -> dict[str, list[str]]:
            out = {}
            for node in dts.get_compatible_nodes(compatible_value):
                if not (bindings := node.get_phandle_array("bindings")):
                    raise ParseError(f'Cannot parse bindings for behavior "{node.name}"')
                if node.label is None:
                    raise ParseError(f'Cannot find label for behavior "{node.name}"')
                if len(bindings) < n_bindings:
                    raise ParseError(f'Could not find {n_bindings} bindings in definition of behavior "{node.name}"')
                out[f"&{node.label}"] = bindings[:n_bindings]
            return out

        self.hold_taps |= get_behavior_bindings("zmk,behavior-hold-tap", 2)
        logger.debug("found hold-tap bindings: %s", self.hold_taps)
        self.mod_morphs |= get_behavior_bindings("zmk,behavior-mod-morph", 2)
        logger.debug("found mod-morph bindings: %s", self.mod_morphs)
        self.sticky_keys |= get_behavior_bindings("zmk,behavior-sticky-key", 1)
        logger.debug("found sticky keys bindings: %s", self.sticky_keys)

    def _update_conditional_layers(self, dts: DeviceTree) -> None:
        cl_parents = dts.get_compatible_nodes("zmk,conditional-layers")
        cl_nodes = [node for parent in cl_parents for node in parent.children]
        for node in cl_nodes:
            if not (then_layer_val := node.get_array("then-layer")):
                raise ParseError(f'Could not parse `then-layer` for conditional layer node "{node.name}"')
            if not (if_layers := node.get_array("if-layers")):
                raise ParseError(f'Could not parse `if-layers` for conditional layer node "{node.name}"')
            self.conditional_layers[int(then_layer_val[0])] = [int(val) for val in if_layers]
        logger.debug("found conditional layers: %s", self.conditional_layers)

    def _get_layers(self, dts: DeviceTree) -> dict[str, list[LayoutKey]]:
        if not (layer_parents := dts.get_compatible_nodes("zmk,keymap")):
            raise ParseError('Could not find any keymap nodes with "zmk,keymap" compatible property')

        if not (
            layer_nodes := [
                node for parent in layer_parents for node in parent.children if node.get_string("status") != "reserved"
            ]
        ):
            raise ParseError("Could not find any layers under the keymap node")

        if self.layer_names is None:
            self.update_layer_names(
                [
                    node.get_string("label|display-name") or node.name.removeprefix("layer_").removesuffix("_layer")
                    for node in layer_nodes
                ]
            )
        else:
            assert (l_u := len(self.layer_names)) == (
                l_p := len(layer_nodes)
            ), f"Length of provided layer name list ({l_u}) does not match the number of parsed layers ({l_p})"

        assert self.layer_names is not None
        layers: dict[str, list[LayoutKey]] = {}
        for layer_ind, node in enumerate(layer_nodes):
            layer_name = self.layer_names[layer_ind]
            if bindings := node.get_phandle_array("bindings"):
                layers[layer_name] = []
                for ind, binding in enumerate(bindings):
                    try:
                        layers[layer_name].append(self._str_to_key(binding, layer_ind, [ind]))
                    except Exception as err:
                        raise ParseError(
                            f'Could not parse binding "{binding}" in layer "{layer_name}" with exception "{err}"'
                        ) from err
            else:
                raise ParseError(f'Could not parse `bindings` property under layer node "{node.name}"')
        return layers

    def _get_combos(self, dts: DeviceTree) -> list[ComboSpec]:

        def parse_layers(layers: list[str], node_name) -> list[str]:
            assert self.layer_names is not None
            out: list[str] = []
            for layer in layers:
                try:
                    out.append(self.layer_names[int(layer)])
                except ValueError as exc:
                    raise ParseError(f'Cannot parse layer name "{layer}" in combo node "{node_name}"') from exc
                except IndexError as exc:
                    raise ParseError(
                        f'Layer index {int(layer)} specified in combo node "{node_name}" does not exist in keymap'
                    ) from exc
            return out

        if not (combo_parents := dts.get_compatible_nodes("zmk,combos")):
            return []
        combo_nodes = chain.from_iterable(parent.children for parent in combo_parents)

        combos = []
        for node in combo_nodes:
            if not (bindings := node.get_phandle_array("bindings")):
                raise ParseError(f'Could not parse `bindings` for combo node "{node.name}"')
            if not (key_pos_strs := node.get_array("key-positions")):
                raise ParseError(f'Could not parse `key-positions` for combo node "{node.name}"')

            try:
                key_pos = [int(pos) for pos in key_pos_strs]
            except ValueError as exc:
                raise ParseError(f'Cannot parse key positions "{key_pos_strs}" in combo node "{node.name}"') from exc

            try:
                # ignore current layer for combos
                parsed_key = self._str_to_key(bindings[0], None, key_pos, no_shifted=True)
            except Exception as err:
                raise ParseError(
                    f'Could not parse binding "{bindings[0]}" in combo node "{node.name}" with exception "{err}"'
                ) from err

            combo = {"k": parsed_key, "p": key_pos}
            if (layers := node.get_array("layers")) and layers[0].lower() != "0xff":
                combo["l"] = parse_layers(layers, node.name)

            # see if combo had additional properties specified in the config, if so merge them in
            combos.append(ComboSpec(**(combo | ComboSpec.normalize_fields(self.cfg.zmk_combos.get(node.name, {})))))
        return combos

    def _get_physical_layout(self, file_name: str | None, dts: DeviceTree) -> dict[str, str]:
        if not file_name:
            return {}

        keyboard_name = Path(file_name).stem
        layout_name = (
            dts.get_chosen_property("zmk,physical-layout")
            or dts.get_chosen_property("zmk,physical_layout")
            or dts.get_chosen_property("zmk,matrix-transform")
            or dts.get_chosen_property("zmk,matrix_transform")
        )  # None if none is found
        logger.debug("inferred ZMK keyboard name %s and layout %s", keyboard_name, layout_name)
        return {"zmk_keyboard": keyboard_name} | ({"layout_name": layout_name} if layout_name else {})

    def _parse(self, in_str: str, file_name: str | None = None) -> tuple[dict, KeymapData]:
        """
        Parse a ZMK keymap with its content and path and return the layout spec and KeymapData to be dumped to YAML.
        """
        dts = DeviceTree(
            in_str,
            file_name,
            self.cfg.preprocess,
            preamble=self.cfg.zmk_preamble + "\n" + _get_zmk_defines(),
            additional_includes=self.cfg.zmk_additional_includes,
        )

        if self.cfg.preprocess and self.raw_binding_map:
            self._update_raw_binding_map(dts)

        self._update_behaviors(dts)
        self._update_conditional_layers(dts)
        layers = self._get_layers(dts)
        layers = self.append_virtual_layers(layers)
        combos = self._get_combos(dts)
        layers = self.add_held_keys(layers)

        keymap_data = KeymapData(layers=layers, combos=combos, layout=None, config=None)
        physical_layout = (
            {"zmk_keyboard": "glove80"} if GLOVE80_MARKER in in_str else self._get_physical_layout(file_name, dts)
        )
        return physical_layout, keymap_data


@cache
def _get_zmk_defines() -> str:
    with open(ZMK_DEFINES_PATH, "r", encoding="utf-8") as f:
        return f.read()
