from __future__ import annotations

import abc
import enum
import os
from typing import Callable

from amapy_contents.content import Content, HASH_SEP
from amapy_contents.content_factory import ContentFactory
from amapy_core.objects.object_source import ObjectSource
from amapy_core.objects.object_stat import ObjectStat
from amapy_core.objects.state import ObjectState, ObjectEditStatus
from amapy_db.file_db import FileDB
from amapy_utils.common import exceptions
from amapy_utils.utils import time_now, date_to_string
from amapy_utils.utils.file_utils import FileUtils
from amapy_utils.utils.log_utils import LoggingMixin


class ObjectViews(enum.Enum):
    # CLONE = "clone"
    RAW = "raw"
    DATA = "data"
    # UPLOAD = "upload"


class AssetObject(LoggingMixin):
    views = ObjectViews  # view options
    view: ObjectViews = None

    ID_SEP = "::"
    HASH_SEP = HASH_SEP
    states = ObjectState
    edit_statuses = ObjectEditStatus
    id: str
    url_id: int
    created_by: str
    created_at: str
    path: str  # relative path in asset
    content: Content

    object_type: str = None

    def __init__(self,
                 id=None,
                 url_id=None,
                 content=None,
                 created_by=None,
                 created_at=None,
                 **kwargs):
        """
        Parameters
        ----------
        id: str
            object id, which a combination of content id and path
        url_id: int
            url_id for storing in bucket (this is generated by server)
        content: Content.
            content of the Object
        created_by: str
            user id
        created_at: str
            timestamp
            reference to the Asset to which the object belongs
        """
        self.id = id
        self.url_id = url_id
        self.created_by = created_by
        self.created_at = created_at
        self.content = content

    @property
    def path(self):
        return self.__class__.parse_id(self.id)[1]

    @property
    def asset(self):
        # parent asset
        return self._asset

    @asset.setter
    def asset(self, x):
        self._asset = x

    @abc.abstractmethod
    def add_to_asset(self, asset, **kwargs):
        """subclass can must implement
        """
        raise NotImplementedError

    def __eq__(self, other):
        if isinstance(other, AssetObject):
            return self.__hash__() == other.__hash__()
        return False

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return hash(self.unique_repr)

    def __repr__(self):
        return '<{} {}>'.format(self.__class__.__name__, self.unique_repr)

    @classmethod
    def bulk_create(cls,
                    factory,
                    sources: [ObjectSource],
                    callback: Callable = None,
                    repo_dir: str = None) -> [AssetObject]:
        """
        Parameters
        ----------
        factory: ObjectFactory # todo: refactor such that there is no circular dependency if we import ObjectFactory
        sources: [ObjectSource]
        callback
        repo_dir

        Returns
        -------

        """
        created = []
        for object_src in sources:
            obj = cls.create(content=object_src.content, path=object_src.path_in_asset)
            created.append(obj)
            if object_src.callback:
                object_src.callback(obj)
            elif callback:
                callback(obj)
        return created

    @classmethod
    def create(cls,
               content: Content,
               path: str,
               callback: Callable = None,
               proxy: bool = False) -> AssetObject:
        """Creates an object from file

        Parameters
        ----------
        content
        path
        callback
        proxy

        Returns
        -------

        """
        if not content:
            raise Exception("missing referenced content for the object")

        obj = cls(
            id=cls.create_id(content=content, path=path),
            content=content,
            created_at=date_to_string(dt=time_now()),
            created_by=os.getenv("ASSET_USER"))

        if callback:
            callback(obj)

        return obj

    @classmethod
    def create_id(cls, content, path):
        if not path:
            raise Exception("required param path can not be null")
        if not content:
            raise Exception("required param content can not be null")
        return cls.ID_SEP.join([content.id, path])

    @classmethod
    def parse_id(cls, id):
        """splits id into content_id and path"""
        content_id, path = id.split(cls.ID_SEP)
        return content_id, path

    @property
    def unique_repr(self):
        """return a unique representation of the object, important to add more explanation here.
        -  The main user interface for the object is its path, i.e. users will add, modify, delete an object
           using its path.
        -  path is unique, i.e. no two objects in an asset can share the same path
        -  its more straight forward to track an object using its path
        """
        return self.path

    @property
    def can_commit(self) -> bool:
        # already committed object so no need to commit
        if self.is_committed:
            return False
        # content is not staged yet, so can't be committed
        if self.content.can_stage:
            return False
        return True

    @property
    def is_committed(self):
        # if state is pending or committing, then its local object else remote
        return self.get_state() not in [self.states.PENDING, self.states.COMMITTING]

    @property
    def can_update(self):
        """subclass can deactivate update by overriding this method"""
        return True

    @property
    def has_raw_mode(self):
        """subclass can override this method to indicate if the object has raw view"""
        return False

    def toggle_view(self, view: ObjectViews, update: bool = False):
        """For complex objects to toggle between raw view and data view or any other views we might support in future"""
        raise NotImplementedError

    def has_raw_view(self):
        """subclass can override this method to indicate if the object has raw view"""
        return False

    @classmethod
    def serialize_fields(cls):
        return [
            "id",
            "url_id",
            "created_by",
            "created_at",
            "object_type",
            "content"
        ]

    @property
    def mime_type(self):
        return self.content.mime_type or FileUtils.mime_type(self.path)

    def file(self):
        if not self.exists():
            raise exceptions.AssetException(f"file not found at {self.path}")
        try:
            return FileUtils.read_file_mime_type(self.linked_path, self.mime_type)
        except Exception as e:
            raise exceptions.AssetException(f"failed to read file {self.path}: {e}")

    def serialize(self, *fields) -> dict:
        """serializes for storing in yaml"""
        fields = fields or self.__class__.serialize_fields()
        data = {}
        for field in fields:
            val = getattr(self, field)
            data[field] = val if field != "content" else val.serialize()
        return data

    @classmethod
    def de_serialize(cls, asset, data: dict) -> AssetObject:
        obj = cls.from_dict(asset=asset, data=data)
        obj.update_asset()
        return obj

    @classmethod
    def from_dict(cls, asset, data: dict) -> AssetObject:
        kwargs = data.copy()
        kwargs["content"] = ContentFactory().de_serialize(asset=asset, data=data.get("content", {}))
        obj = cls(**kwargs)
        obj.asset = asset
        obj.view = asset.view  # track view in object also, in case asset toggles its view
        return obj

    def update_asset(self):
        # create reverse link to content
        # no need save - to write to file again
        self.asset.objects.add(self)
        self.content.linked_objects.add(self)

    def get_state(self):
        try:
            return self._state
        except AttributeError:
            self._state = self.asset.states_db.get_object_states().get(self.unique_repr)

    def set_state(self, x, save=False):
        self._state = x
        if save:
            self.asset.states_db.add_object_states(**{self.unique_repr: self._state})

    @property
    def linked_path(self):
        """ Returns the linked path (absolute path) of the file mime_type object"""
        return os.path.join(self.asset.linked_dir, self.path)

    @abc.abstractmethod
    def link_to_store(self, callback: Callable = None, save: bool = False):
        raise NotImplementedError

    def link_from_store(self, callback: Callable = None, save: bool = False) -> bool:
        raise NotImplementedError

    def unlink(self, delete=True, callback=None):
        # remove reverse link
        self.content.remove_ref(object=self, save=True)
        # remove stat
        self.set_object_stat(None, save=True)
        if delete:
            if os.path.exists(self.linked_path):
                os.unlink(self.linked_path)
        if callback:
            callback(self)

    def exists(self, path=None) -> bool:
        """Checks if the file pointed by the object, exists or not.

        If the file at linked path exists then it's not been deleted, or
        path might exist but may be a directory, we treat this as a delete event as well
        """
        path = path or self.linked_path
        return bool(os.path.exists(path) and os.path.isfile(path))

    def linked(self):
        stat = self.get_object_stat()
        return bool(stat and stat.linked)

    @property
    def file_stats_db(self) -> FileDB:
        return self.asset.object_stats_db

    def compute_stat(self, path=None) -> ObjectStat:
        """Calculates the file stat
        we use cache_path here because the user may have deleted the file after adding an asset
        """
        path = path or self.linked_path
        if not self.exists(path):
            # user didn't download the asset but is modifying it, which is allowed
            return None
        stat = ObjectStat(id=self.path, src=path)
        return stat

    def get_object_stat(self) -> ObjectStat:
        try:
            return self._stat
        except AttributeError:
            stored = self.file_stats_db.get_stats().get(self.unique_repr)
            self._stat = ObjectStat.de_serialize(stored) if stored else None
            return self._stat

    def set_object_stat(self, x: ObjectStat, save=False):
        self._stat = x
        if save:
            self.file_stats_db.add_stats(**{
                self.unique_repr: self._stat.serialize() if self._stat else None
            })

    def update_object_stat(self, save: bool = False):
        # create stat
        stat = self.compute_stat(path=self.linked_path)
        if stat:
            stat.linked = True
            self.set_object_stat(stat, save=save)

    def edit_status(self) -> str:
        """This reflects the untracked changes to an object.

        Which is if the object was edited and the changes are not updated in the asset yet, for example
         - an object got added but altered before being committed,
         - an asset is downloaded and its objects are edited but have not been committed yet
         preserve the order of checking i.e. deleted, renamed and then modified
        """
        # user didn't download the asset but is trying to modify it - which is allowed
        if not self.linked():
            return ObjectEditStatus.UNCHANGED

        # check if deleted
        if not (self.exists()):
            return ObjectEditStatus.DELETED

        # file exists, so we check if its renamed
        # if linked path exists, then there are 2 possibilities
        # 1. its the correct file
        # 2. its the wrong file
        # if they are different, so we flag the file as modified
        current_stats = self.compute_stat()
        # deactivating same_file check, because some editors change the inode number when you press the save button
        # if not self.is_same_file(stat=current_stats):
        #     return ObjectEditStatus.MODIFIED

        # file was not deleted and is linked to the correct path, next we check if content was modified
        # we do this in the end because this is potentially the most expensive call
        if self.is_modified(current_stats):
            return ObjectEditStatus.MODIFIED

        return ObjectEditStatus.UNCHANGED

    def is_same_file(self, stat=None):
        """Checks if the object is pointing to the same file as it was added. There are two possibilities:

        1. it's the correct file
        2. it's the wrong file
            - user pasted another file with the same name
            - user deleted the file and renamed another file to its name

        Here is an example
         -  User adds a file abc.txt
         -  User deletes the file abc.txt
         -  User copies another file def.txt and renames it as abc.txt, the object should be able to
            detect that it's not the same file. We need this check so that we can avoid the md5 checks
            which are expensive operations.
        We compare the inode numbers to see if they are different
        """
        # if they are same file then inode numbers would be same
        current_stats = stat or self.compute_stat(self.linked_path)
        stored_stats = self.get_object_stat()
        if not current_stats or not stored_stats:
            return False
        return current_stats.inode == stored_stats.inode

    def is_modified(self, stat=None) -> bool:
        """ Checks if an object was modified before its staged.

        Returns
        -------
        bool
            True if the file was modified, False otherwise
        """
        # do a stats again of the file and compare with the stored stats
        # If last-modified time has changed, then compute md5 and compare with stored md5
        current_stats = stat or self.compute_stat(self.linked_path)
        stored_stats = self.get_object_stat()
        if not current_stats or not stored_stats:
            return False

        # first check if m_time has changed, compute hash could be expensive for large files
        # combine with inode number check, because some editors change the inode number when you press save
        if current_stats.inode == stored_stats.inode and stored_stats.content_time == current_stats.content_time:
            return False

        # if time has changed, then lets compare size
        if stored_stats.size != current_stats.size:
            self.log.info("size comparison: {}".format(self.path))
            return True

        # if time has changed, but size is same - then we have to compare hashes
        self.log.info("hash comparison: {}".format(self.path))
        hash_type, new_hash = self.content.__class__.compute_hash(src=self.linked_path)
        return self.content.hash_value != new_hash or self.content.hash_type != hash_type

    def is_file_metadata_changed(self, stat=None) -> bool:
        """Checks a file was renamed before being staged.

        Use is_renamed, is_modified and is_deleted together because
        each of them assumes the other one has been called so it doesn't
        address all possible scenarios
        """
        current_stats = stat or self.compute_stat(self.linked_path)
        stored_stats = self.get_object_stat()

        # st_ctime has not changed, then its not been renamed
        return stored_stats.metadata_time != current_stats.metadata_time
