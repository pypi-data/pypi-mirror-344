import os
import logging
from typing import Optional
import openai
from ..._core import Core
from ..._util import CreatorRole, ChatCompletionConfig, MessageBlock, TokenUsage
from .base import DeepSeekCore

logger = logging.getLogger(__name__)


class Reasoner_Core(Core, DeepSeekCore):
    # https://api-docs.deepseek.com/guides/reasoning_model
    SUPPORTED_MODELS = "deepseek-reasoner"

    def __init__(
        self,
        system_prompt: str,
        config: ChatCompletionConfig,
    ):
        if config.name not in self.SUPPORTED_MODELS:
            raise ValueError(
                f"{config.name} is not supported. Supported models: {self.SUPPORTED_MODELS}"
            )
        Core.__init__(self, system_prompt, config)
        DeepSeekCore.__init__(self)
        self.profile = self.build_profile(config.name)

    @staticmethod
    def preprocessing(
        system_prompt: str, query: str, context: Optional[list[MessageBlock | dict]]
    ) -> list[MessageBlock | dict]:
        """
        Preprocess the input messages to be sent to the LLM model.

        Rules:
        1. System instruction is added under the USER role.
        2. Ensure user/assistant role are interleaved.

        Args:
            system_prompt (str): The system prompt to be sent to the LLM model.
            query (str): The query to be processed by the LLM model.
            context (list[MessageBlock | dict] | None): The context to be used for the LLM model.

        Returns:
            list[MessageBlock | dict]: The preprocessed messages to be sent to the LLM model.
        """
        msgs: list[MessageBlock | dict] = [
            MessageBlock(role=CreatorRole.SYSTEM.value, content=system_prompt)
        ]

        if context:
            msgs.extend(context)

        msgs.append(MessageBlock(role=CreatorRole.USER.value, content=query))

        outputs: list[MessageBlock | dict] = []

        a_role = msgs[0]["role"]
        content = msgs[0]["content"]

        for msg in msgs[1:]:
            if msg["role"] == a_role:
                content += "\n" + msg["content"]
            else:
                outputs.append({"role": a_role, "content": content})
                a_role = msg["role"]
                content = msg["content"]

        outputs.append({"role": a_role, "content": content})
        return outputs

    async def run_async(
        self, query: str, context: list[MessageBlock | dict] | None, **kwargs
    ) -> tuple[list[MessageBlock | dict], TokenUsage]:
        """
        Asynchronously run the LLM model with the given query and context.

        Args:
            query (str): The query to be processed by the LLM model.
            context (list[MessageBlock | dict] | None): The context to be used for the LLM model.
            include_rc (bool): Whether to include `reasoning content` in the output, default is True.
            **kwargs: Additional keyword arguments.

        Returns:
            list[MessageBlock | dict]: The list of messages generated by the LLM model.
            TokenUsage: The recorded token usage.

        Notes:
        * No system prompt!
        * max_tokens -> max_completion_tokens
        """
        include_rc: bool = kwargs.get("include_rc", True)
        msgs: list[MessageBlock | dict] = self.preprocessing(
            self.system_prompt, query, context
        )

        # Determine the maximum number of tokens allowed for the response
        MAX_TOKENS = min(self.config.max_tokens, self.context_length)
        MAX_OUTPUT_TOKENS = min(
            MAX_TOKENS, self.max_output_tokens, self.config.max_output_tokens
        )
        prompt_token_count = self.calculate_token_count(msgs, tools=None)
        max_output_tokens = min(
            MAX_OUTPUT_TOKENS,
            self.context_length - prompt_token_count,
        )

        if max_output_tokens <= 0:
            raise ValueError(
                f"max_output_tokens <= 0. Prompt token count: {prompt_token_count}"
            )

        try:
            client = openai.AsyncOpenAI(
                api_key=os.environ["DEEPSEEK_API_KEY"],
                base_url=os.environ["DEEPSEEK_BASE_URL"],
            )
            response = await client.chat.completions.create(
                model=self.model_name,
                messages=msgs,  # type: ignore
                max_tokens=max_output_tokens,
            )

            choice = response.choices[0]
            _content = getattr(choice.message, "content", None)
            _reasoning_content = getattr(choice.message, "reasoning_content", None)

            token_usage = self.update_usage(response.usage)
            if _content:
                response_string = _content
                if _reasoning_content and include_rc:
                    response_string = (
                        f"<REASONING>\n{_reasoning_content}\n</REASONING>\n"
                        + response_string
                    )
                return [
                    {"role": CreatorRole.ASSISTANT.value, "content": response_string}
                ], token_usage

            failed_reason = choice.finish_reason
            raise RuntimeError(failed_reason)
        except Exception as e:
            logger.error("Exception: %s", e, exc_info=True, stack_info=True)
            raise

    def run(
        self, query: str, context: list[MessageBlock | dict] | None, **kwargs
    ) -> tuple[list[MessageBlock | dict], TokenUsage]:
        """
        Synchronously generate text based on the given query and context.

        Args:
            query (str): The query to generate text for.
            context (list): A list of context messages or dictionaries.
            include_rc (bool): Whether to include `reasoning content` in the output, default is True.
            **kwargs: Additional keyword arguments.

        Returns:
            list[MessageBlock | dict]: The list of messages generated by the LLM model.
            TokenUsage: The recorded token usage.

        Notes:
        * No system prompt!
        * max_tokens -> max_completion_tokens
        """

        include_rc: bool = kwargs.get("include_rc", True)
        msgs: list[MessageBlock | dict] = self.preprocessing(
            self.system_prompt, query, context
        )

        # Determine the maximum number of tokens allowed for the response
        MAX_TOKENS = min(self.config.max_tokens, self.context_length)
        MAX_OUTPUT_TOKENS = min(
            MAX_TOKENS, self.max_output_tokens, self.config.max_output_tokens
        )
        prompt_token_count = self.calculate_token_count(msgs, tools=None)
        max_output_tokens = min(
            MAX_OUTPUT_TOKENS,
            self.context_length - prompt_token_count,
        )

        if max_output_tokens <= 0:
            raise ValueError(
                f"max_output_tokens <= 0. Prompt token count: {prompt_token_count}"
            )

        try:
            client = openai.OpenAI(
                api_key=os.environ["DEEPSEEK_API_KEY"],
                base_url=os.environ["DEEPSEEK_BASE_URL"],
            )

            response = client.chat.completions.create(
                model=self.model_name,
                messages=msgs,  # type: ignore
                max_tokens=max_output_tokens,
            )

            choice = response.choices[0]
            _content = getattr(choice.message, "content", None)
            _reasoning_content = getattr(choice.message, "reasoning_content", None)

            token_usage = self.update_usage(response.usage)
            if _content:
                response_string = _content
                if _reasoning_content and include_rc:
                    response_string = (
                        f"<REASONING>\n{_reasoning_content}\n</REASONING>\n"
                        + response_string
                    )  # re.sub(r"<COT>.*?</COT>\n*", "", x, flags=re.DOTALL)
                return [
                    {"role": CreatorRole.ASSISTANT.value, "content": response_string}
                ], token_usage
            failed_reason = choice.finish_reason
            raise RuntimeError(failed_reason)
        except RuntimeError as rte:
            logger.error("RuntimeError: %s", rte, exc_info=True, stack_info=True)
            raise
        except Exception as e:
            logger.error("Exception: %s", e, exc_info=True, stack_info=True)
            raise
