"""Download files workflow task"""

import fnmatch
from collections.abc import Sequence
from pathlib import Path

from cmem_plugin_base.dataintegration.context import ExecutionContext, ExecutionReport
from cmem_plugin_base.dataintegration.description import Icon, Plugin, PluginAction, PluginParameter
from cmem_plugin_base.dataintegration.entity import Entities
from cmem_plugin_base.dataintegration.parameter.password import Password, PasswordParameterType
from cmem_plugin_base.dataintegration.plugins import WorkflowPlugin
from cmem_plugin_base.dataintegration.ports import (
    FixedNumberOfInputs,
    FixedSchemaPort,
)
from cmem_plugin_base.dataintegration.typed_entities.file import FileEntitySchema, LocalFile
from nc_py_api import FsNode, Nextcloud

from cmem_plugin_nextcloud.autocomplete import DirectoryParameterType
from cmem_plugin_nextcloud.list import ListFiles


@Plugin(
    label="Download Nextcloud files",
    plugin_id="cmem_plugin_nextcloud-Download",
    description="Download files from a given Nextcloud instance.",
    documentation="""
This workflow task downloads files from a specified Nextcloud service instance.

Given the URL of the target Nextcloud instance along with your credentials, you can specify any
directory from which files should be downloaded. Additionally, you may define file patterns to
include or exclude specific files within the selected directory.

#### Nextcloud List Files input
If this workflow has an input, it will take the data that comes in instead of the selected values.
This works only with the schema used in the **Nextcloud List Files** Plugin.
Make sure you still add the appropriate URL, identification and token.

#### Important:
To establish a secure connection, you must generate a dedicated [app-specific password and username](https://docs.nextcloud.com/server/latest/user_manual/de/session_management.html)
in the Security section of your Nextcloud account settings. Do not use your standard login
credentials.
    """,
    icon=Icon(file_name="nextcloud.svg", package=__package__),
    actions=[
        PluginAction(
            name="result_preview",
            label="Preview (max. 10)",
            description="Lists 10 entries based on the current configuration.",
        )
    ],
    parameters=[
        PluginParameter(
            name="base_url",
            label="Nextcloud URL",
            description="The Base URL of your Nextcloud service, e.g. `https://cloud.example.com`.",
        ),
        PluginParameter(
            name="user",
            label="API identification",
            description="The identification generated by the app-password function in Nextcloud.",
        ),
        PluginParameter(
            name="token",
            label="API token",
            description="The token generated by the app-password function in Nextcloud.",
            param_type=PasswordParameterType(),
        ),
        PluginParameter(
            name="path",
            label="File or directory path",
            description="The path to a specific directory from which to download files."
            "Includes all the subdirectories. Leave empty or type '/' for root directory."
            "When pasting a directory path, select 'Custom entry:' to trigger autocompletion and"
            "check if the folder is recognized.",
            default_value="",
            param_type=DirectoryParameterType("directories", "Folder"),
        ),
        PluginParameter(
            name="file_expression",
            label="File expression using *",
            description="A filepath for searching specified files through the given path. "
            "E.g. searching for *.txt results in all .txt files under the given "
            "directory and its subdirectories.",
            default_value="",
        ),
        PluginParameter(
            name="error_on_empty_result",
            label="Error on empty result",
            description="A flag indicating weather an empty output will throw an error.",
        ),
        PluginParameter(
            name="no_subfolder",
            label="Exclude files in subfolders from download.",
            description="A flag indicating whether files located in subfolders should be excluded"
            " from the download.",
        ),
    ],
)
class DownloadFiles(WorkflowPlugin):
    """Nextcloud Workflow Plugin: Data downloading"""

    def __init__(  # noqa: PLR0913
        self,
        base_url: str,
        user: str,
        token: Password | str,
        path: str,
        file_expression: str,
        error_on_empty_result: bool = False,
        no_subfolder: bool = False,
    ) -> None:
        self.base_url = base_url
        self.user = user
        self.token = token if isinstance(token, str) else token.decrypt()
        self.path = path
        self.file_expression = file_expression
        self.error_on_empty_result = error_on_empty_result
        self.no_subfolder = no_subfolder
        self.input_ports = FixedNumberOfInputs(
            [FixedSchemaPort(schema=ListFiles.generate_schema())]
        )
        self.output_port = FixedSchemaPort(schema=FileEntitySchema())
        self.download_dir = Path()
        self.nc = Nextcloud(
            nextcloud_url=self.base_url, nc_auth_user=self.user, nc_auth_pass=str(self.token)
        )

    def result_preview(self) -> str:
        """Plugin Action to preview the results"""
        files = []
        if self.file_expression == "":
            if self.no_subfolder:
                files = self.generate_files_rec(files=[], directory=self.path, depth=1)
            else:
                files = self.generate_files_rec(files=[], directory=self.path)
        else:
            files = self.receive_filesystem_nodes()[:10]
        if len(files) == 0:
            raise ValueError("No results found with the given instructions.")
        output = [f"The Following {len(files)} entities were found:", ""]
        output.extend(f"- {file.user_path}" for file in files)
        return "\n".join(output)

    def generate_files_rec(  # noqa: PLR0913
        self,
        files: list[FsNode],
        directory: str = "",
        no_of_max_hits: int = 10,
        no_of_curr_hits: int = 0,
        depth: int = 11,
        curr_depth: int = 0,
    ) -> list[FsNode]:
        """Generate files up to a certain maximum number of hits"""
        if (no_of_max_hits != -1 and no_of_curr_hits >= no_of_max_hits) or (
            depth != -1 and curr_depth >= depth
        ):
            return files

        for node in self.nc.files.listdir(directory, depth=1):
            if no_of_max_hits != -1 and no_of_curr_hits >= no_of_max_hits:
                break

            if not node.is_dir:
                files.append(node)

            else:
                files = self.generate_files_rec(
                    directory=node.user_path,
                    no_of_max_hits=no_of_max_hits,
                    no_of_curr_hits=len(files),
                    files=files,
                    depth=depth,
                    curr_depth=curr_depth + 1,
                )
            if no_of_max_hits != -1 and len(files) >= no_of_max_hits:
                break

        return files

    def execute(self, inputs: Sequence[Entities], context: ExecutionContext) -> Entities:
        """Run the workflow operator"""
        if len(inputs) == 0:
            local_files = self.download_files_no_input(context)
            schema = FileEntitySchema()
            entities = [schema.to_entity(file) for file in local_files]
            context.report.update(
                ExecutionReport(
                    entity_count=len(entities),
                    operation="write",
                    operation_desc="files downloaded",
                    sample_entities=Entities(entities=iter(entities[:10]), schema=schema),
                )
            )
            return Entities(entities=iter(entities), schema=schema)

        schema = FileEntitySchema()
        local_files = self.download_files_input(inputs, context)
        entities = [schema.to_entity(file) for file in local_files]
        context.report.update(
            ExecutionReport(
                entity_count=len(entities),
                operation="write",
                operation_desc="files downloaded",
                sample_entities=Entities(entities=iter(entities[:10]), schema=schema),
            )
        )
        return Entities(entities=iter(entities), schema=schema)

    def receive_filesystem_nodes(self) -> list[FsNode]:
        """Generate the files from Nextcloud"""
        files = []
        if self.file_expression == "":
            if self.no_subfolder:
                files = [i for i in self.nc.files.listdir(path=self.path, depth=1) if not i.is_dir]
            else:
                files = [i for i in self.nc.files.listdir(path=self.path, depth=-1) if not i.is_dir]
        elif self.no_subfolder:
            files = [i for i in self.nc.files.listdir(path=self.path, depth=1) if not i.is_dir]
            files = [file for file in files if fnmatch.fnmatch(file.name, self.file_expression)]
        else:
            op = "like" if "*" in self.file_expression else "eq"
            new_expression = self.file_expression.replace("*", "%")
            files = [
                i
                for i in self.nc.files.find(req=[op, "name", new_expression], path=self.path)
                if not i.is_dir
            ]
        if self.error_on_empty_result and len(files) == 0:
            raise ValueError("Results are empty!")
        return files

    def download_files_no_input(self, context: ExecutionContext) -> list[LocalFile]:
        """Download the files from Nextcloud"""
        context.report.update(
            ExecutionReport(operation="read", operation_desc="retrieving Nextcloud files.")
        )
        nc_files = self.receive_filesystem_nodes()
        local_files = []
        for file in nc_files:
            local_path = self.download_dir / Path(file.user_path.split("/")[-1])
            with local_path.open("wb") as f:
                self.nc.files.download2stream(path=file.user_path, fp=f)

            local_files.append(LocalFile(str(local_path), file.info.mimetype))
            context.report.update(
                ExecutionReport(
                    entity_count=len(local_files),
                    operation="write",
                    operation_desc="files downloaded",
                )
            )
        return local_files

    def download_files_input(
        self, inputs: Sequence[Entities], context: ExecutionContext
    ) -> list[LocalFile]:
        """Download the files from Nextcloud of a specific input"""
        local_files = []
        for entity in inputs[0].entities:
            if entity.values[1][0] == "Folder":
                continue
            local_path = self.download_dir / Path(entity.values[2][0].split("/")[-1])
            with local_path.open("wb") as f:
                self.nc.files.download2stream(path=entity.values[2][0], fp=f)
            local_files.append(LocalFile(entity.values[2][0].split("/")[-1], entity.values[17][0]))
            context.report.update(
                ExecutionReport(
                    entity_count=len(local_files),
                    operation="write",
                    operation_desc="files downloaded",
                )
            )
        return local_files
