#
# Copyright 2018-2025 Fragment Contributors
# SPDX-License-Identifier: Apache-2.0
#
import enum
import re
from typing import Dict, Iterable, TextIO

import numpy as np

from conformer.systems import Atom, NamedSystem

# Matches an element and charge
ELEMENT_REG = re.compile(r"([A-z]{1,2})([0-9]?)([-+]?)")

class PDBCols_12(enum.IntEnum):
    """Space delimited columns for 12-column format wit chains"""
    RES_TYPE = 0  # Residue or hetero atom
    ATOM_NO = 1
    ATOM_TYPE_DISTINCT = 2 # This is not just atom type but also
                           # distinct type (i.e. alpha carbon in backbone = CA)
    RES_NAME = 3 # Three-letter name of residue
    CHAIN_ID = 4
    RES_NUM = 5
    X = 6
    Y = 7
    Z = 8
    ATOM_TYPE = 11

# Space delimited columns for 11-column format without chains
class PDBCols_11(enum.IntEnum):
    """Space delimited columns for 11-column format without chains"""
    RES_TYPE = 0  # Residue or hetero atom
    ATOM_NO = 1
    ATOM_TYPE_DISTINCT = 2 # This is not just atom type but also
                           # distinct type (i.e. alpha carbon in backbone = CA)
    RES_NAME = 3 # Three-letter name of residue
    RES_NUM = 4
    X = 5
    Y = 6
    Z = 7
    ATOM_TYPE = 10


def PDBRead(file: TextIO, charges: Dict[int, int] = {}) -> NamedSystem:
    """
    Parses PDB-formatted file and estracts the ATOM and HETATOM entries into
    a system

    PDB data is preserved in the Atom.meta field
    """
    atoms = []
    global max_atom
    max_atom = 0

    # Parse file line-by-line
    content = file.readlines()
    for line in content:
        if line.startswith("ATOM"):
            atoms.append(read_atom(line))
        elif line.startswith("HETATM"):
            atoms.append(read_atom(line))
        else:
            pass

    # Sort by chain and residue ID
    # Assign frag groups to chained atoms
    atoms.sort(key = lambda a: a.meta['pdb_atom_no'])
    atoms.sort(key = lambda a: a.meta['pdb_chain'])
    set_frag_groups(atoms)

    # Handle charge overrides
    for a in atoms:
        if a.meta['pdb_atom_no'] in charges:
            a.charge = charges[a.meta['pdb_atom_no']]

    return NamedSystem(atoms)


def read_atom(line: str):
    """Reads a pdb formatted line"""
    try:
        # TODO: Detect if this is in fixed-width format or whitespace mode
        raise ValueError("Not implemented yet!")
    except ValueError:
        return _read_atom_whitespace(line)


def _read_atom_whitespace(line: str) -> Atom:
    """
    Parses atom line using whitespace. This can be fragile
    """
    data = line.split()
    if len(data) == 12:
        PDBCols = PDBCols_12
        chain_id = str(data[PDBCols.CHAIN_ID])
    elif len(data) == 11:
        PDBCols = PDBCols_11
        chain_id = "A"
    else:
        raise ValueError(f"Cannot parse PDB entry with {len(data)} columns")

    # Parse metadata
    frag_type = data[PDBCols.RES_TYPE]
    res_name = str(data[PDBCols.RES_NAME])
    atom_type = str(data[PDBCols.ATOM_TYPE_DISTINCT])
    atom_id = int(data[PDBCols.ATOM_NO])
    res_id = int(data[PDBCols.RES_NUM])  

    # assign x,y,z coordinates 
    x = float(data[PDBCols.X])
    y = float(data[PDBCols.Y])
    z = float(data[PDBCols.Z])

    # Parse charge and element type
    t = data[PDBCols.ATOM_TYPE]
    type, charge = get_charge(t)

    return Atom(
        type,
        np.array([x, y, z]),
        charge=charge,
        meta={
            "pdb_entry_type": frag_type,
            "pdb_atom_no": atom_id,
            "pdb_residue_no": res_id,
            "pdb_chain": chain_id,
            "pdb_residue_name": res_name,
            "pdb_atom_type": atom_type,
        }
    )

def get_charge(line: str) -> tuple[str, int]:
    """
    Take in ATOM_TYPE, modifies to only contain letters (alphabetical) and assigns charge (if present)
    This can be overwritten by strategy file
    """

    # Parse element and charge using regular expressions
    m = re.match(ELEMENT_REG, line)

    if not m:
        raise ValueError("Could not parse element or charge from '{line}`")
    t = m[1] # Should always be present

    if m[2]:
        charge = int(m[2])
        if m[3]:
            sign = 1 if m[3] == "+" else -1
            charge *= sign
    else:
        charge = 0

    # Return title case. I've seen some cases where Zn is written ZN
    return t.title(), charge

def _clear_carboxyl_buffer(buffer, gid):
    for a in buffer:
        a.meta['frag_group'] = gid 
    buffer.clear()

def set_frag_groups(atoms: Iterable[Atom]) -> None:
    """
    Assigns frag groups by breaking the C-CA bond instead of the N-C bond bond
    Ensures that monomers are generated by breaking C-CA bond in backbone
    """
    
    # Track the chain and residue number
    residue = ("", -1) 
    carboxyl_buffer = [] # Keep the carboxyl group from the last AA
    residue_size = 0
    group_id = 0
    last_aa = 0 # In case there are hetatms between start and end of chain

    for atom in atoms:
        new_residue = (atom.meta['pdb_chain'], atom.meta['pdb_residue_no'])
        # No further processing for hetatms
        if atom.meta['pdb_entry_type'] == "HETATM":
            # Fragment as indicated by the PDB
            if residue != new_residue:
                residue = new_residue
                residue_size = 0
                group_id += 1
    
            atom.meta['frag_group'] = group_id
            continue

        # Handle protein backbones
        # Assumes first four residues are N C CA O
        # NOTE: Is this a valid assumption?
        # Handle R groups and N/CA atoms
        if residue != new_residue:
            # Update counters
            residue = new_residue
            residue_size = 0
            group_id += 1
            last_aa = group_id

            # Add carboxyl atoms from PREVIOUS residue
            _clear_carboxyl_buffer(carboxyl_buffer, group_id)

        residue_size += 1

        # Carboxyl groups should be part of the next amino acid
        if residue_size == 3:
            assert atom.t == "C"
            carboxyl_buffer.append(atom)
            continue
        elif residue_size == 4:
            assert atom.t == "O"
            carboxyl_buffer.append(atom)
            continue
        else:
            atom.meta['frag_group'] = group_id
    
    # Handle terminal end of the chain
    _clear_carboxyl_buffer(carboxyl_buffer, last_aa)