#!/usr/bin/env python3
"""
Certificate management functionality for TeddyCloudStarter.
"""
import os
import shutil
import time
import platform
import subprocess
import re
from pathlib import Path
from typing import Optional
from rich.console import Console
from rich.panel import Panel
from rich import box
from .lets_encrypt import LetsEncrypt

# Global console instance for rich output
console = Console()


class CertificateManager:
    """Handles certificate operations for TeddyCloudStarter."""
    
    def __init__(self, base_dir: str = None, translator=None):
        # Use provided base_dir or try to get project path from config
        if base_dir is None:
            # Import here to avoid circular imports
            from .config_manager import ConfigManager
            config_manager = ConfigManager()
            project_path = None
            try:
                if config_manager and config_manager.config:
                    project_path = config_manager.config.get("environment", {}).get("path")
            except Exception:
                pass
            self.base_dir = Path(project_path) if project_path else Path(".")
        else:
            self.base_dir = Path(base_dir)
            
        self.client_certs_dir = self.base_dir / "data" / "client_certs"
        self.ca_dir = self.client_certs_dir / "ca"
        self.clients_dir = self.client_certs_dir / "clients"
        self.server_dir = self.client_certs_dir / "server"
        self.crl_dir = self.client_certs_dir / "crl"
        self.translator = translator
        
        # Create LetsEncrypt instance for certificate operations
        self.lets_encrypt = LetsEncrypt(translator=translator)

    
    def _translate(self, text):
        """Helper method to translate text if translator is available."""
        if self.translator:
            return self.translator.get(text)
        return text
    
    def _check_openssl(self) -> bool:
        """Check if OpenSSL is available."""
        try:
            subprocess.run(["openssl", "version"], check=True, capture_output=True)
            return True
        except (subprocess.SubprocessError, FileNotFoundError):
            console.print(Panel(
                f"[bold red]{self._translate('OpenSSL is not available on your system.')}[/]\n\n"
                f"[bold yellow]{self._translate('Installation instructions:')}[/]\n"
                f"- [bold]{self._translate('Windows:')}[/] {self._translate('Download and install from https://slproweb.com/products/Win32OpenSSL.html')}\n"
                f"- [bold]{self._translate('macOS:')}[/] {self._translate('Use Homebrew: \'brew install openssl\'')}\n"
                f"- [bold]{self._translate('Linux (Debian/Ubuntu):')}[/] {self._translate('Run \'sudo apt install openssl\'')}\n"
                f"- [bold]{self._translate('Linux (Fedora/RHEL):')}[/] {self._translate('Run \'sudo dnf install openssl\'')}\n\n"
                f"{self._translate('After installing OpenSSL, restart the wizard or choose a different option.')}",
                box=box.ROUNDED,
                border_style="red"
            ))
            return False
    
    def _create_ca_info_file(self) -> bool:
        """Create an info file in the CA directory with version information.
        
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Get OpenSSL version
            openssl_version = "Unknown"
            try:
                result = subprocess.run(
                    ["openssl", "version"],
                    capture_output=True, text=True, check=True
                )
                openssl_version = result.stdout.strip()
            except subprocess.SubprocessError:
                pass
            
            # Get current date and time
            current_datetime = time.strftime("%Y-%m-%d %H:%M:%S")
            
            # Get operating system info
            os_info = f"{platform.system()} {platform.release()}"
            
            # TeddyCloudStarter version - hardcoded for now, could be dynamic in the future
            teddycloudstarter_version = "1.0.0"  # This should ideally come from a central version
            
            # Create the info file
            info_file = self.ca_dir / "ca_info.txt"
            with open(info_file, "w") as f:
                f.write(f"""# TeddyCloudStarter CA Certificate Information
# ======================================

Generated on: {current_datetime}
Operating System: {os_info}
OpenSSL Version: {openssl_version}
TeddyCloudStarter Version: {teddycloudstarter_version}

This Certificate Authority was generated by TeddyCloudStarter.
The CA is used to sign client certificates for secure access to TeddyCloud.

Files in this directory:
- ca.key: The Certificate Authority private key (KEEP SECURE!)
- ca.crt: The Certificate Authority public certificate
- ca_info.txt: This information file

For more information, visit: https://github.com/quentendo64/teddycloudstarter
""")
            
            return True
        except Exception as e:
            error_msg = f"Warning: Could not create CA info file: {e}"
            console.print(f"[bold yellow]{self._translate(error_msg)}[/]")
            return False
    
    def _update_certificate_info_in_config(self, client_name, safe_name, serial, creation_date, valid_till):
        """Update certificate information in config.json."""
        try:
            # Find the correct config file to update
            from .config_manager import ConfigManager
            
            # First try the project-specific config
            if self.base_dir and self.base_dir != Path("."):
                project_config_path = Path(self.base_dir) / "config.json"
                if project_config_path.exists():
                    config_manager = ConfigManager(config_path=str(project_config_path))
                else:
                    # If project config doesn't exist, fall back to default
                    config_manager = ConfigManager()
            else:
                # Use default config if no project path
                config_manager = ConfigManager()
            
            if config_manager and config_manager.config:
                # Create certificate info dictionary
                cert_info = {
                    "client_name": client_name,
                    "safe_name": safe_name,
                    "serial": serial,
                    "creation_date": creation_date,
                    "valid_till": valid_till,
                    "revoked": False,
                    "path": str(self.clients_dir / f"{safe_name}.p12")
                }
                
                # Initialize security section if it doesn't exist
                if "security" not in config_manager.config:
                    config_manager.config["security"] = {}
                
                # Initialize client_certificates array if it doesn't exist
                if "client_certificates" not in config_manager.config["security"]:
                    config_manager.config["security"]["client_certificates"] = []
                
                # Add certificate info to the array
                config_manager.config["security"]["client_certificates"].append(cert_info)
                config_manager.save()
                
                # Debug info
                console.print(f"[green]{self._translate('Certificate information saved to')} {config_manager.config_path}[/]")
                
        except Exception as e:
            error_msg = f"Warning: Could not update config with certificate info: {e}"
            console.print(f"[bold yellow]{self._translate(error_msg)}[/]")
    
    def generate_client_certificate(self, client_name: Optional[str] = None, project_path: Optional[str] = None, passout: Optional[str] = None) -> bool:
        """Generate client certificates using OpenSSL.
        
        Args:
            client_name: Optional name for the client certificate. If not provided, will use default
            project_path: Optional path to the project directory. If provided, will override the base_dir
            passout: Optional password for the PKCS#12 file. If not provided, will use default "teddycloud"
            
        Returns:
            bool: True if successful, False otherwise
        """
        console.print(f"[bold cyan]{self._translate('Generating client certificates...')}[/]")
        
        try:
            # If project_path is provided, update the base_dir and related paths
            if project_path:
                self.base_dir = Path(project_path)
                self.client_certs_dir = self.base_dir / "data" / "client_certs"
                self.ca_dir = self.client_certs_dir / "ca"
                self.clients_dir = self.client_certs_dir / "clients"
                self.server_dir = self.client_certs_dir / "server"
                self.crl_dir = self.client_certs_dir / "crl"
            
            # Ensure directories exist
            self.client_certs_dir.mkdir(parents=True, exist_ok=True)
            self.server_dir.mkdir(exist_ok=True)
            self.clients_dir.mkdir(exist_ok=True)
            self.ca_dir.mkdir(exist_ok=True)
            
            # Check if OpenSSL is available
            if not self._check_openssl():
                return False
            
            # Use default name if none provided
            if not client_name:
                client_name = "TeddyCloudClient"
            
            # Store whether this is a default password for display purposes
            is_default_password = not passout
            
            # Use default password if none provided
            if not passout:
                passout = "teddycloud"
            
            # Ensure client_name is valid as file name by removing special chars
            safe_name = re.sub(r'[^\w\-\.]', '_', client_name)
            
            # Check if CA exists, if not create it
            ca_key_path = self.ca_dir / "ca.key"
            ca_crt_path = self.ca_dir / "ca.crt"
            server_created = False
            
            # Create CA if it doesn't exist
            if not ca_key_path.exists() or not ca_crt_path.exists():
                # Generate CA key and certificate
                subprocess.run([
                    "openssl", "req", "-x509", "-newkey", "rsa:4096", "-nodes",
                    "-keyout", str(ca_key_path),
                    "-out", str(ca_crt_path),
                    "-subj", "/CN=TeddyCloudStarterCA",
                    "-days", "3650"
                ], check=True)
                
                # Generate server key and CSR
                server_key = self.server_dir / "server.key"
                server_csr = self.server_dir / "server.csr"
                server_crt = self.server_dir / "server.crt"
                
                subprocess.run([
                    "openssl", "req", "-newkey", "rsa:4096", "-nodes",
                    "-keyout", str(server_key),
                    "-out", str(server_csr),
                    "-subj", "/CN=TeddyCloudServer"
                ], check=True)
                
                # Sign server certificate with CA
                subprocess.run([
                    "openssl", "x509", "-req",
                    "-in", str(server_csr),
                    "-CA", str(ca_crt_path),
                    "-CAkey", str(ca_key_path),
                    "-CAcreateserial",
                    "-out", str(server_crt),
                    "-days", "3650"
                ], check=True)
                
                
                # Create CA info file
                self._create_ca_info_file()
                
                server_created = True
            
            # Generate client key and CSR with the provided name
            client_key = self.clients_dir / f"{safe_name}.key"
            client_csr = self.clients_dir / f"{safe_name}.csr"
            client_crt = self.clients_dir / f"{safe_name}.crt"
            client_p12 = self.clients_dir / f"{safe_name}.p12"
            
            subprocess.run([
                "openssl", "req", "-newkey", "rsa:4096", "-nodes",
                "-keyout", str(client_key),
                "-out", str(client_csr),
                "-subj", f"/CN={client_name}"
            ], check=True)
            
            # Sign client certificate with CA
            subprocess.run([
                "openssl", "x509", "-req",
                "-in", str(client_csr),
                "-CA", str(ca_crt_path),
                "-CAkey", str(ca_key_path),
                "-CAcreateserial",
                "-out", str(client_crt),
                "-days", "3650"
            ], check=True)
            
            # Create PKCS#12 file for client with provided or default password
            subprocess.run([
                "openssl", "pkcs12", "-export",
                "-inkey", str(client_key),
                "-in", str(client_crt),
                "-certfile", str(ca_crt_path),
                "-out", str(client_p12),
                "-passout", f"pass:{passout}"
            ], check=True)
            
            # Get certificate serial number for tracking
            result = subprocess.run(
                ["openssl", "x509", "-noout", "-serial", "-in", str(client_crt)],
                capture_output=True, text=True, check=True
            )
            serial = result.stdout.strip().split('=')[1]
            
            # Add the last 8 characters of serial to the filename to avoid overwriting
            serial_suffix = serial[-8:]
            new_safe_name = f"{safe_name}_{serial_suffix}"
            
            # Rename files to include serial suffix
            client_p12_with_serial = self.clients_dir / f"{new_safe_name}.p12"
            client_key_with_serial = self.clients_dir / f"{new_safe_name}.key"
            client_crt_with_serial = self.clients_dir / f"{new_safe_name}.crt"
            
            # Rename the files
            shutil.move(str(client_p12), str(client_p12_with_serial))
            shutil.move(str(client_key), str(client_key_with_serial))
            shutil.move(str(client_crt), str(client_crt_with_serial))
            
            # Update our variables to use the new filenames
            client_p12 = client_p12_with_serial
            client_key = client_key_with_serial
            client_crt = client_crt_with_serial
            
            # Get certificate expiration date
            result = subprocess.run(
                ["openssl", "x509", "-noout", "-enddate", "-in", str(client_crt)],
                capture_output=True, text=True, check=True
            )
            end_date = result.stdout.strip().split('=')[1]
            
            # Format the end date
            from datetime import datetime
            try:
                # Parse the date format from OpenSSL (e.g., "May 14 12:00:00 2026 GMT")
                parsed_date = datetime.strptime(end_date, "%b %d %H:%M:%S %Y %Z")
                formatted_end_date = parsed_date.strftime("%Y-%m-%d")
            except ValueError:
                formatted_end_date = end_date  # Use original format if parsing fails
                
            # Add certificate info to config.json
            self._update_certificate_info_in_config(
                client_name=client_name,
                safe_name=new_safe_name,
                serial=serial,
                creation_date=datetime.now().strftime("%Y-%m-%d"),
                valid_till=formatted_end_date
            )
            
            message = f"[bold green]{self._translate('Client certificate generated successfully!')}[/]\n\n"
            if server_created:
                message += f"{self._translate('CA certificate has been created in the ca subfolder.')}\n"
                message += f"{self._translate('Server certificate has been created in the server subfolder.')}\n\n"
            
            message += f"{self._translate('Client certificate')} '{client_name}' {self._translate('has been created in the clients subfolder:')}\n"
            message += f"- {client_key}: {self._translate('The client private key')}\n"
            message += f"- {client_crt}: {self._translate('The client certificate')}\n"
            
            # Display password differently based on whether it's the default or a custom one
            if is_default_password:
                message += f"- {client_p12}: {self._translate('Client certificate bundle (password: ')} {passout})\n\n"
            else:
                message += f"- {client_p12}: {self._translate('Client certificate bundle (password: ')} ******)\n\n"
            
            message += f"{self._translate('Install the .p12 file on devices that need to access TeddyCloud.')}"
            
            console.print(Panel(
                message,
                box=box.ROUNDED,
                border_style="green"
            ))
            
            return True
        except subprocess.SubprocessError as e:
            error_msg = f"Error generating certificates: {e}"
            console.print(f"[bold red]{self._translate(error_msg)}[/]")
            return False
        except Exception as e:
            error_msg = f"Error: {e}"
            console.print(f"[bold red]{self._translate(error_msg)}[/]")
            return False
    
    def revoke_client_certificate(self, cert_name: Optional[str] = None) -> bool:
        """Revoke a client certificate.
        
        Args:
            cert_name: Optional name of the certificate to revoke. If not provided, will prompt user
            
        Returns:
            bool: True if successful, False otherwise
        """
        console.print(f"[bold cyan]{self._translate('Revoking client certificate...')}[/]")
        
        try:
            if not self.client_certs_dir.exists():
                console.print(f"[bold red]{self._translate('No client certificates directory found.')}[/]")
                return False
            
            # Get certificate information from config.json
            from .config_manager import ConfigManager
            config_manager = ConfigManager()
            
            # Check if certificates are stored in the config
            certificates = []
            if (config_manager and config_manager.config and 
                "security" in config_manager.config and 
                "client_certificates" in config_manager.config["security"]):
                certificates = config_manager.config["security"]["client_certificates"]
            
            # Check if we have any certificates to revoke
            if not certificates:
                # Fall back to checking file system if no certificates in config
                if not self.clients_dir.exists() or not any(self.clients_dir.glob('*.crt')):
                    console.print(f"[bold red]{self._translate('No client certificates found to revoke.')}[/]")
                    return False
            
            # Create crl subfolder if it doesn't exist
            self.crl_dir.mkdir(exist_ok=True)
            
            # Check if CA exists
            ca_key_path = self.ca_dir / "ca.key"
            ca_crt_path = self.ca_dir / "ca.crt"
            
            # If CA files not found in ca subfolder, look for them in the root directory
            if not ca_key_path.exists() or not ca_crt_path.exists():
                root_ca_crt = self.client_certs_dir / "ca.crt"
                root_ca_key = self.client_certs_dir / "ca.key"
                
                # Check if CA exists in root directory (backwards compatibility)
                if root_ca_crt.exists() and root_ca_key.exists():
                    # Use root directory CA files
                    ca_crt_path = root_ca_crt
                    ca_key_path = root_ca_key
                else:
                    console.print(f"[bold red]{self._translate('CA certificate or key not found. Cannot revoke certificate.')}[/]")
                    return False
            
            # Validate the certificate name or find it in the config
            cert_info = None
            safe_name = None
            
            if cert_name:
                # Try to find the certificate in the config first
                for cert in certificates:
                    if cert.get("client_name") == cert_name or cert.get("safe_name") == cert_name:
                        cert_info = cert
                        safe_name = cert.get("safe_name")
                        break
                
                # If not found in config, check file directly
                if not cert_info:
                    # Try to find the file directly
                    cert_file = self.clients_dir / f"{cert_name}.crt"
                    if not cert_file.exists():
                        error_msg = f"Certificate {cert_name}.crt not found."
                        console.print(f"[bold red]{self._translate(error_msg)}[/]")
                        return False
                    safe_name = cert_name
            else:
                # If no cert_name provided and we have certificates in config, use the first one as an example
                if certificates:
                    cert_info = certificates[0]
                    cert_name = cert_info.get("client_name")
                    safe_name = cert_info.get("safe_name")
                else:
                    # If no certificates in config, check file system
                    cert_files = list(self.clients_dir.glob('*.crt'))
                    if not cert_files:
                        console.print(f"[bold red]{self._translate('No client certificates found to revoke.')}[/]")
                        return False
                    cert_file = cert_files[0]
                    cert_name = cert_file.stem
                    safe_name = cert_name
            
            # Initialize or update the certificate index file
            index_file = self.ca_dir / "index.txt"
            if not index_file.exists():
                # Create an empty index file
                with open(index_file, "w") as f:
                    pass
            
            # Create serial file if it doesn't exist
            serial_file = self.ca_dir / "serial"
            if not serial_file.exists():
                with open(serial_file, "w") as f:
                    f.write("01")
            
            # Create crlnumber file if it doesn't exist
            crlnumber_file = self.ca_dir / "crlnumber"
            if not crlnumber_file.exists():
                with open(crlnumber_file, "w") as f:
                    f.write("01")
            
            # Get the certificate path from safe_name
            cert_path = self.clients_dir / f"{safe_name}.crt"
            
            # Get the certificate serial number
            serial = None
            if cert_info and "serial" in cert_info:
                serial = cert_info["serial"]
            else:
                try:
                    result = subprocess.run(
                        ["openssl", "x509", "-noout", "-serial", "-in", str(cert_path)],
                        capture_output=True, text=True, check=True
                    )
                    serial = result.stdout.strip().split('=')[1]
                except Exception as e:
                    error_msg = f"Could not get certificate serial number: {e}"
                    console.print(f"[bold yellow]{self._translate(error_msg)}[/]")
            
            # Create OpenSSL config file for revocation
            openssl_conf_file = self.ca_dir / "openssl.cnf"
            if not openssl_conf_file.exists():
                # Create minimal OpenSSL configuration
                with open(openssl_conf_file, "w") as f:
                    f.write("""
[ ca ]
default_ca = CA_default

[ CA_default ]
dir               = ./
database         = $dir/index.txt
serial           = $dir/serial
new_certs_dir    = $dir/newcerts
certificate      = $dir/ca.crt
private_key      = $dir/ca.key
default_days     = 3650
default_crl_days = 30
default_md       = sha256
policy           = policy_any
crlnumber        = $dir/crlnumber

[ policy_any ]
countryName            = optional
stateOrProvinceName    = optional
organizationName       = optional
organizationalUnitName = optional
commonName             = supplied
emailAddress           = optional

[ v3_ca ]
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer
basicConstraints = critical,CA:true

[ crl_ext ]
authorityKeyIdentifier=keyid:always
""")
            
            # Create newcerts directory if it doesn't exist
            newcerts_dir = self.ca_dir / "newcerts"
            newcerts_dir.mkdir(exist_ok=True)
            
            # Revoke the certificate
            try:
                # Ensure we're in the CA directory for relative paths in the config
                original_dir = os.getcwd()
                os.chdir(str(self.ca_dir.absolute()))
                
                # Always proceed with full revocation
                console.print(f"[bold cyan]{self._translate('Fully revoking certificate with CA...')}[/]")
                
                # Revoke the certificate using OpenSSL
                subprocess.run([
                    "openssl", "ca", "-config", "openssl.cnf",
                    "-revoke", str(cert_path),
                    "-keyfile", str(ca_key_path),
                    "-cert", str(ca_crt_path)
                ], check=True)
                
                # Generate CRL
                subprocess.run([
                    "openssl", "ca", "-config", "openssl.cnf",
                    "-gencrl",
                    "-keyfile", str(ca_key_path),
                    "-cert", str(ca_crt_path),
                    "-out", str(self.crl_dir / "ca.crl")
                ], check=True)
                
                # Return to original directory
                os.chdir(original_dir)
                
                # Update certificate status in config.json
                if config_manager and certificates:
                    for i, cert in enumerate(certificates):
                        if (cert.get("client_name") == cert_name or 
                            cert.get("safe_name") == safe_name or 
                            (serial and cert.get("serial") == serial)):
                            config_manager.config["security"]["client_certificates"][i]["revoked"] = True
                            config_manager.config["security"]["client_certificates"][i]["revocation_date"] = time.strftime("%Y-%m-%d")
                            config_manager.save()
                            break
                
                # Regenerate Docker Compose and nginx configurations if in nginx mode with client certificate auth
                try:
                    # Only proceed if we're in nginx mode with client certificate authentication
                    if config_manager and config_manager.config.get("mode") == "nginx" and \
                       config_manager.config.get("nginx", {}).get("security", {}).get("type") == "client_cert":
                        console.print(f"[cyan]{self._translate('Regenerating Docker Compose configuration...')}[/]")
                        
                        # Import required modules for configuration regeneration
                        from .configuration.generator import generate_docker_compose, generate_nginx_configs
                        from .configurations import TEMPLATES
                        
                        # Get the project path
                        project_path = config_manager.config.get("environment", {}).get("path", str(self.base_dir))
                        
                        # Regenerate Docker Compose configuration
                        if generate_docker_compose(config_manager.config, self.translator, TEMPLATES):
                            console.print(f"[green]{self._translate('Docker Compose configuration regenerated successfully')}[/]")
                            
                            # Regenerate nginx configs
                            if generate_nginx_configs(config_manager.config, self.translator, TEMPLATES):
                                console.print(f"[green]{self._translate('Nginx configuration regenerated successfully')}[/]")
                                
                                # Ask if user wants to restart services to apply changes
                                from rich.prompt import Confirm
                                restart_service = Confirm.ask(
                                    f"[yellow]{self._translate('Would you like to restart the nginx-auth service to apply the changes?')}[/]"
                                )
                                
                                if restart_service:
                                    # Import and use DockerManager to restart only the nginx-auth service
                                    from .docker_manager import DockerManager
                                    docker_manager = DockerManager(translator=self.translator)
                                    
                                    if docker_manager.restart_service("nginx-auth", project_path=project_path):
                                        console.print(f"[bold green]{self._translate('nginx-auth service restarted successfully')}[/]")
                                    else:
                                        console.print(f"[bold yellow]{self._translate('Failed to restart nginx-auth service. You may need to restart it manually.')}[/]")
                            else:
                                console.print(f"[bold yellow]{self._translate('Failed to regenerate Nginx configuration')}[/]")
                        else:
                            console.print(f"[bold yellow]{self._translate('Failed to regenerate Docker Compose configuration')}[/]")
                except Exception as e:
                    console.print(f"[bold yellow]{self._translate('Error during configuration regeneration:')} {e}[/]")
                
                success_msg = f"Certificate {cert_name} has been revoked successfully."
                console.print(f"[bold green]{self._translate(success_msg)}[/]")
                update_msg = "The Certificate Revocation List (CRL) has been updated."
                console.print(f"[cyan]{self._translate(update_msg)}[/]")
                restart_msg = "You may need to restart services for the changes to take effect."
                console.print(f"[cyan]{self._translate(restart_msg)}[/]")
                
                return True
                
            except subprocess.SubprocessError as e:
                error_msg = f"Error revoking certificate: {e}"
                console.print(f"[bold red]{self._translate(error_msg)}[/]")
                # Return to original directory on error
                os.chdir(original_dir)
                return False
            
        except Exception as e:
            error_msg = f"Error during certificate revocation: {e}"
            console.print(f"[bold red]{self._translate(error_msg)}[/]")
            return False

    # Forward Let's Encrypt related methods to the new class
    def test_domain_for_letsencrypt(self, domain: str) -> bool:
        """
        Test if a domain is properly set up for Let's Encrypt.
        
        Delegates to the new LetsEncrypt class.
        
        Args:
            domain: Domain name to test
            
        Returns:
            bool: True if domain passed at least one test, False otherwise
        """
        return self.lets_encrypt.test_domain_for_letsencrypt(domain)
    
    def request_letsencrypt_certificate(self, domain: str, 
                                       staging: bool = False, 
                                       email: Optional[str] = None,
                                       additional_domains: Optional[list] = None) -> bool:
        """
        Request a Let's Encrypt certificate using webroot mode.
        
        Delegates to the new LetsEncrypt class.
        
        Args:
            domain: Domain name for the certificate
            staging: Whether to use staging environment (default is False)
            email: Optional email address for registration
            additional_domains: Optional list of additional domain names (SANs)
            
        Returns:
            bool: True if successful, False otherwise
        """
        return self.lets_encrypt.request_certificate(
            domain=domain,
            mode="webroot",
            staging=staging,
            email=email,
            additional_domains=additional_domains
        )
        
    def request_letsencrypt_certificate_standalone(self, domain: str, 
                                                 staging: bool = True,
                                                 email: Optional[str] = None,
                                                 additional_domains: Optional[list] = None) -> bool:
        """
        Request Let's Encrypt certificate using standalone mode.
        
        Delegates to the new LetsEncrypt class.
        
        Args:
            domain: Domain name for the certificate
            staging: Whether to use staging environment (default is True)
            email: Optional email address for registration
            additional_domains: Optional list of additional domain names (SANs)
            
        Returns:
            bool: True if successful, False otherwise
        """
        return self.lets_encrypt.request_certificate(
            domain=domain,
            mode="standalone",
            staging=staging,
            email=email, 
            additional_domains=additional_domains
        )
    
    def force_refresh_letsencrypt_certificates(self, domain: str, 
                                             email: Optional[str] = None,
                                             additional_domains: Optional[list] = None) -> bool:
        """
        Force refresh Let's Encrypt certificates.
        
        Delegates to the new LetsEncrypt class.
        
        Args:
            domain: Domain name for the certificate
            email: Optional email address for notifications
            additional_domains: Optional list of additional domain names (SANs)
            
        Returns:
            bool: True if successful, False otherwise
        """
        return self.lets_encrypt.force_refresh_certificates(
            domain=domain,
            email=email,
            additional_domains=additional_domains
        )