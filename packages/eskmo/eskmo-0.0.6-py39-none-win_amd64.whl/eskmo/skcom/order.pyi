from eskmo.base.mvtype import *
from eskmo.const.skcom import *
from eskmo.const.event import *
from eskmo.skcom.function import *
from _typeshed import Incomplete
from eskmo import symbol as symbol
from eskmo.base.handler import APIEventHandler as APIEventHandler, APIHandler as APIHandler
from eskmo.base.types import EVENT_HANDLER_REPLY as EVENT_HANDLER_REPLY, RUNNER_NAME as RUNNER_NAME
from eskmo.skcom.handler import SkcomHandler as SkcomHandler
from eskmo.skcom.proxy import SKProxyStockAlterOrder as SKProxyStockAlterOrder
from eskmo.skcom.recipe import SKMITOrderRecipe as SKMITOrderRecipe, SKOrderRecipe as SKOrderRecipe
from eskmo.skcom.reply import ReplyEventHandler as ReplyEventHandler
from eskmo.symbol.future import FutureInfo as FutureInfo, FutureInfoHandler as FutureInfoHandler
from eskmo.symbol.stock import StockInfo as StockInfo, StockInfoHandler as StockInfoHandler
from eskmo.utils.logger import Logger as Logger
from eskmo.utils.misc import getDictFromSKCOMStream as getDictFromSKCOMStream, hashId as hashId, isSKCOMStreamFinished as isSKCOMStreamFinished, toADDateStr as toADDateStr, toMinguoDateStr as toMinguoDateStr

CANCEL_ORDER_ON_RETRY_MAX: int
CANCEL_ORDER_FUNCTIONS: Incomplete
STR_PROXY_ORDER_NO: Incomplete
STR_PROXY_SEQ_NO: Incomplete
STR_PROXY_ORKEY: Incomplete
STR_PROXY_ACTION: Incomplete
STR_PROXY_BLOCK_NUM: Incomplete

class OrderEventHandler(APIEventHandler):
    sid: Incomplete
    sid2: Incomplete
    events: Incomplete
    api: APIHandler
    globals: Incomplete
    pendingOrderHandlingLock: Incomplete
    pendingNewOrders: Incomplete
    pendingCancelOrders: Incomplete
    doneOrders: Incomplete
    clientIds: Incomplete
    queueMaxsize: int
    onMarginPurchaseAmountLimitCount: int
    lastMarginLimitSymbolCode: Incomplete
    pnlQueryCount: int
    isPnlQueryStarted: bool
    proxyOrderInfo: Incomplete
    cancelOrderCheckQueue: Incomplete
    retryFinishedOrderSeqNos: Incomplete
    runnerTagSwitchCount: int
    def __init__(self, api, handlerDict) -> None: ...
    def retryCancelOrder(self) -> None: ...
    def cancelOrderOnRetry(self, order, retryLimit=...) -> None: ...
    def getMITOrderDict(self, obj): ...
    def getOrderDict(self, obj): ...
    def putToOrderCheckQueue(self, func, data) -> None: ...
    def afterModifyOrderPrice(self, data, ret) -> None: ...
    def afterDecreaseOrderQty(self, data, ret) -> None: ...
    def afterCancelManyByBuysellAndPrice(self, data: dict, ret): ...
    def afterCancelBySeqNo(self, data: dict, ret): ...
    def alterOrder(self, orderType, seqNo: str = '', bookNo: str = ''): ...
    def modifyOrderPrice(self, data) -> None: ...
    def decreaseOrderQty(self, data) -> None: ...
    def cancelBySeqNo(self, data, quiet: bool = False) -> None: ...
    def afterCancelByStockNo(self, data, ret) -> None: ...
    def cancelByStockNo(self, data) -> None: ...
    def afterCancelByBookNo(self, data, ret) -> None: ...
    def cancelByBookNo(self, data) -> None: ...
    def afterCancelAll(self, data, ret) -> None: ...
    def cancelAll(self, data) -> None: ...
    def cancelManyMITBySeqNos(self, data) -> None: ...
    def afterCancelManyMITBySeqNos(self, data, ret) -> None: ...
    def cancelManyByBuysellAndPrice(self, data: dict): ...
    def cancelManyBySeqNos(self, data) -> None: ...
    def afterCancelMITOrderBySeqNo(self, data, ret) -> None: ...
    def cancelMITOrderBySeqNo(self, data, quiet: bool = False) -> None: ...
    def sendProxyOrder(self, data) -> None: ...
    def sendOrderOnStart(self, data): ...
    def afterSendFutureOrderCall(self, startTime, fromPid, orderDict: dict, isSuccessCalled, status, callbackId): ...
    def checkSendProxyOrderStatus(self, status, isProxyOrder: bool = False): ...
    def afterSendOrderCall(self, startTime, fromPid, orderDict: dict, isSuccessCalled, status, callbackId, isProxyOrder: bool = False): ...
    def afterSendFutureOrder(self, data, ret) -> None: ...
    def afterSendOrder(self, data, ret) -> None: ...
    @staticmethod
    def getBreakDownVolumeList(qty, breakUnit): ...
    def sendNormalOrder(self, data) -> None: ...
    def sendOrder(self, data) -> None: ...
    def sendBreakDownOrder(self, data) -> None: ...
    def prepareSendingOrderDict(self, data, runnerName): ...
    def afterSendMITOrder(self, data, ret) -> None: ...
    def sendMITOrder(self, data) -> None: ...
    def afterSendCBOrder(self, data, ret) -> None: ...
    def sendCBOrder(self, data) -> None: ...
    def afterFastOCOOrder(self, data, ret) -> None: ...
    def sendFastOCOOrder(self, data) -> None: ...
    def afterSendOCOOrder(self, data, ret) -> None: ...
    def sendOCOOrder(self, data) -> None: ...
    def sendOddLotOrder(self, orderDict): ...
    def send(self, orderObj): ...
    def getOrderByThreadID(self, threadID): ...
    def OnMarginPurchaseAmountLimit(self, serialNumber, runnerName, bstrData) -> None: ...
    def OnRealBalanceReport(self, serialNumber, runnerName, bstrData) -> None: ...
    def OnBalanceQuery(self, serialNumber, runnerName, bstrData) -> None: ...
    def buildUnrealizedPnLQuery(self, queryDict): ...
    def buildRealizedPnLQuery(self, queryDict): ...
    def buildDayTradePnLQuery(self, queryDict): ...
    def toTSProfitLossGWQuery(self, queryDict): ...
    def OnAccount(self, serialNumber, runnerName, bstrLogInID, bstrAccountData) -> None: ...
    def OnProfitLossGWReport(self, serialNumber, runnerName, bstrData) -> None: ...
    def OnTSSmartStrategyReport(self, serialNumber, runnerName, bstrData) -> None: ...
    def OnProxyStatus(self, serialNumber, runnerName, bstrUserID, nCode) -> None: ...
    @staticmethod
    def getOrderIDFromReservationMessage(msg): ...
    @staticmethod
    def isStockOrderID(msg): ...
    @staticmethod
    def isIntraDayOrderSuccessFromMessage(nCode, bstrMessage): ...
    @staticmethod
    def isIntraDayOrderSuccess(nCode, msg): ...
    @staticmethod
    def isStrategyOrder(bstrMessage): ...
    def OnOpenInterest(self, serialNumber, runnerName, data) -> None: ...
    def OnStopLossReport(self, serialNumber, runnerName, data) -> None: ...
    def OnOverseaFuture(self, serialNumber, runnerName, data) -> None: ...
    def OnOverseaOption(self, serialNumber, runnerName, data) -> None: ...
    def OnFutureRights(self, serialNumber, runnerName, data) -> None: ...
    def OnOverSeaFutureRight(self, serialNumber, runnerName, data) -> None: ...
    def OnAsyncOrderOLID(self, serialNumber, runnerName, data) -> None: ...
    def OnOverseaFutureOpenInterest(self, serialNumber, runnerName, data) -> None: ...
    def OnOverseaFutureOpenInterestGW(self, serialNumber, runnerName, data) -> None: ...
    def OnTelnetTest(self, serialNumber, runnerName, data) -> None: ...
    def OnReservationOrder(self, runnerName, order, key, bstrMessage) -> None: ...
    def publishNewReservationOrder(self, order, orderId, key, errorMsg: str = '', isProxy: bool = False) -> None: ...
    def movePendingToOpened(self, order, orderId, key) -> None: ...
    def movePendingToDeleted(self, order, key) -> None: ...
    def OnIntraDayOrder(self, runnerName, order, key, bstrMessage) -> None: ...
    def publishNewIntraDayOrder(self, order, orderId, key, errorMsg: str = '', isProxy: bool = False) -> None: ...
    def OnStrategyOrder(self, runnerName, order, key, bstrMessage) -> None: ...
    def publishNewOrderFailed(self, order, errors=[], errorCode: Incomplete | None = None) -> None: ...
    def publishNewOrderSuccess(self, order, msgObj) -> None: ...
    def publishCancelOrderFailed(self, order, errors, errorCode: Incomplete | None = None, isAlreadyCancelled: bool = False) -> None: ...
    def publishCancelOrderSuccess(self, order, msgObj={}) -> None: ...
    def OnNewOrder(self, runnerName, nThreadID, nCode, bstrMessage) -> None: ...
    def isAlreadyCanceledInMessage(self, bstrMessage): ...
    def addToRetryFinished(self, seqNo) -> None: ...
    def OnCancelOrder(self, runnerName, nThreadID, nCode, bstrMessage) -> None: ...
    def parseProxyOrderMessage(self, bstrMessage: str): ...
    def saveProxyOrderInfo(self, proxyInfo): ...
    def onProxyActionInfo(self, proxyInfo): ...
    def onProxyOrderSuccess(self, proxyInfo, phase) -> None: ...
    def onProxyOrderFailed(self, proxyInfo, phase) -> None: ...
    def onCancelProxyOrder(self, proxyInfo: dict): ...
    def publishCancelOrder(self, order, orderMsg, key, nCode, keySource=...) -> None: ...
    def onNewProxyOrder(self, proxyInfo: dict): ...
    def OnProxyOrder(self, serialNumber, runnerName, nStampID, nCode, bstrMessage) -> None: ...
    def OnAsyncOrder(self, serialNumber, runnerName, nThreadID, nCode, bstrMessage) -> None: ...
    def WaitForAsyncOrder(self, serialNumber, runnerName, nThreadID, nCode, bstrMessage) -> None: ...
