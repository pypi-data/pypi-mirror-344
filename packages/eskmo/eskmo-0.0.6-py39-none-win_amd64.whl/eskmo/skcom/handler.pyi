from eskmo.base.types import *
from eskmo.const.event import *
from eskmo.skcom.function import *
from eskmo.const.skcom import *
from eskmo.base.mvtype import *
from _typeshed import Incomplete
from eskmo.base.handler import APIHandler as APIHandler
from eskmo.skcom.mapping import apiMapping as apiMapping
from eskmo.skcom.order import OrderEventHandler as OrderEventHandler
from eskmo.skcom.quote import QuoteEventHandler as QuoteEventHandler
from eskmo.skcom.recipe import SKCBOrderRecipe as SKCBOrderRecipe, SKFastOCOOrderRecipe as SKFastOCOOrderRecipe, SKFutureOrderRecipe as SKFutureOrderRecipe, SKMITOrderRecipe as SKMITOrderRecipe, SKOCOOrderRecipe as SKOCOOrderRecipe, SKOddLotOrderRecipe as SKOddLotOrderRecipe, SKOrderRecipe as SKOrderRecipe
from eskmo.skcom.reply import ReplyEventHandler as ReplyEventHandler
from eskmo.skcom.runner import SkcomRunner as SkcomRunner
from eskmo.symbol.stock import E_PNL_NOTIFY_MAPS as E_PNL_NOTIFY_MAPS
from eskmo.utils.logger import Logger as Logger
from eskmo.utils.reconnect import getRequestSymbolsOnReconnectTimeString as getRequestSymbolsOnReconnectTimeString, shouldRequestSymbolsOnReconnect as shouldRequestSymbolsOnReconnect
from functools import partial as partial

API_SKCOM: str

class SkcomHandler(APIHandler):
    sendOrderCounter: Incomplete
    loginStats: Incomplete
    isFirstTimeLogin: bool
    isKeepCheckMarginLimitRunning: bool
    isKeepRequestServerTimeRunning: bool
    replyReady: bool
    symbolReady: bool
    accountPnL: Incomplete
    proxy: bool
    def __init__(self, handlerDict={}, processConn: Incomplete | None = None, name=..., isReplay: bool = False) -> None: ...
    def addToAccountPnL(self, pnl: dict, accountId: str, pnlIdx: frozenset): ...
    def updateAccountPnL(self, pnl: dict, pnlType: int, pnlFormat: int): ...
    def retryCancelIfOrderNotCancel(self, seqNos) -> None: ...
    def resetGlobals(self, runnerName) -> None: ...
    def call(self, runnerName, fromPid, apiFunc, *args, **kwargs): ...
    def callNoWait(self, runnerName, fromPid, apiFunc, callbackInfo, *args, **kwargs): ...
    def orderCall(self, runnerName, fromPid, action, *args, **kwargs) -> None: ...
    def callAndSuccess(self, runnerName, fromPid, successCode, func, *args, **kwargs): ...
    def callAndWait(self, runnerName, fromPid, func, *args, **kwargs): ...
    def batchCallAndWait(self, tasks): ...
    def batchCallNoWait(self, tasks, callbackInfo={}) -> None: ...
    def doneAfterLogin(self, runnerName, task, message) -> None: ...
    def afterLoginSuccess(self, runnerName) -> None: ...
    page: Incomplete
    onSubscribeQuote: bool
    def resubscribeQuote(self, runnerName) -> None: ...
    def resubscribeBest5(self, runnerName) -> None: ...
    def subscribeAgainCheck(self, runnerName) -> None: ...
    def runAfterLoginSuccess(self, runnerName) -> None: ...
    def keepRequestServerTime(self, loginId) -> None: ...
    exchanges: Incomplete
    isExchangeFinished: Incomplete
    def onSymbolReadyAfterServerTimeCall(self, data, ret) -> None: ...
    def onSymbolReady(self, runnerName) -> None: ...
    def afterSymbolReady(self, runnerName: Incomplete | None = None) -> None: ...
    def afterGetAvgCost(self, data, ret) -> None: ...
    def checkBalance(self, fromPid=..., runnerName: Incomplete | None = None) -> None: ...
    def pnlUpdateCall(self, pnlQueryType: int = ..., format: int = ..., data: dict = {}, fromPid=..., runnerName: Incomplete | None = None): ...
    def checkVersion(self, fromPid=..., runnerName: Incomplete | None = None) -> None: ...
    def afterGetSKAPIVersionAndBit(self, data, ret) -> None: ...
    def checkNetwork(self, fromPid=..., runnerName: Incomplete | None = None) -> None: ...
    def request(self, fromPid, account, tag) -> None: ...
    def getSubscribeSpec(self): ...
    def getRequestSpec(self): ...
    def getRequestSpecFunc(self): ...
