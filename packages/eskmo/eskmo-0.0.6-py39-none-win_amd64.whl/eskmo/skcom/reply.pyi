from eskmo.const.event import *
from eskmo.const.mapping import *
from eskmo.const.skcom import *
from eskmo.base.mvtype import *
from _typeshed import Incomplete
from eskmo.base.handler import APIEventHandler as APIEventHandler, APIHandler as APIHandler
from eskmo.const.skcom import SKError as SKError, SK_ERRORS as SK_ERRORS
from eskmo.skcom.function import SK_REPLY as SK_REPLY
from eskmo.utils.datetime import parseDatetime as parseDatetime
from eskmo.utils.logger import Logger as Logger

STRICT_SEQUENTIAL_REPLY_EVENTS: Incomplete

class StrategyReply:
    bstrUserID: Incomplete
    bstrData: Incomplete
    def __init__(self, bstrUserID, bstrData, serialNumber: int = 0) -> None: ...
    @staticmethod
    def extractCommonPart(msgs): ...
    def getTradeKind(msgs): ...
    @staticmethod
    def extractCommonPart(msgs): ...
    @staticmethod
    def extractFastOCOCommonPart(msgs): ...
    @staticmethod
    def extractTradeKindPart(msgs, orderList, commonList=...): ...
    @staticmethod
    def extractFromCommonList(msgs, common): ...
    @staticmethod
    def getFastOCOReplyOrderedList(dataDict): ...
    @staticmethod
    def getReplyDict(bstrUserID, bstrData): ...
    def dict(self): ...

class Reply:
    replyAttrs: Incomplete
    replyKeyNos: Incomplete
    bstrList: Incomplete
    infoDict: Incomplete
    def __init__(self, bstrList, serialNumber: int = 0) -> None: ...
    @staticmethod
    def extractCommonPart(bstrList): ...
    @staticmethod
    def extractByMarket(bstrList, market): ...
    @staticmethod
    def mappingValueByMarket(replyDict, market): ...
    @staticmethod
    def getReplyDict(serialNumber, bstrList): ...
    def dict(self): ...
    def isFinished(self): ...

class FutureReply(Reply):
    replyInfo: Incomplete
    infoDict: Incomplete
    def __init__(self, replyInfo, serialNumber: int = 0) -> None: ...

class ReplyEventHandler(APIEventHandler):
    events: Incomplete
    api: APIHandler
    globals: Incomplete
    replyDict: Incomplete
    serialNumbers: Incomplete
    quickCallQueue: Incomplete
    def __init__(self, api, handlerDict) -> None: ...
    def findReplyBySeqNo(self, seqNo): ...
    def findReplyByBookNo(self, bookNo): ...
    def listenQuickCall(self) -> None: ...
    def hasCanceledReplyBySeqNo(self, seqNo): ...
    def getSubscribers(self, queueName, symbolCode) -> None: ...
    def subscribe(self, tag, pid, data) -> None: ...
    def unsubscribe(self, tag, pid, data) -> None: ...
    def request(self, tag, pid, data) -> None: ...
    def OnSolaceReplyConnection(self, serialNumber, runnerName, bstrUserID, nErrorCode) -> None: ...
    def OnDisconnect(self, serialNumber, runnerName, bstrUserID, nErrorCode) -> None: ...
    def OnConnect(self, serialNumber, runnerName, bstrUserID, nErrorCode) -> None: ...
    def OnSolaceReplyDisconnect(self, serialNumber, runnerName, bstrUserID, nErrorCode) -> None: ...
    def OnComplete(self, serialNumber, runnerName, bstrUserID) -> None: ...
    def OnReplyMessage(self, serialNumber, runnerName, bstrUserID, bstrMessages): ...
    def OnNewData(self, serialNumber, runnerName, bstrUserID, bstrData) -> None: ...
    def OnStrategyData(self, serialNumber, runnerName, bstrUserID, bstrData) -> None: ...
    def onMITReply(self, serialNumber, runnerName, bstrUserID, bstrData) -> None: ...
    def onFastOCOReply(self, serialNumber, runnerName, bstrUserID, bstrData) -> None: ...
    def onOCOReply(self, serialNumber, runnerName, bstrUserID, bstrData) -> None: ...
