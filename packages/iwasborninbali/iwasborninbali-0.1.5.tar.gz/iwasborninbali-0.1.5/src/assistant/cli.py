#!/usr/bin/env python3
"""
demo_chat_completions.py ‚Äì –ø—Ä–∏–º–µ—Ä –≤—ã–∑–æ–≤–∞ Chat Completions API c o3 –∏ –∫–∞—Å—Ç–æ–º–Ω—ã–º —Ç—É–ª–æ–º 'ask'.
–ü—Ä–∏–Ω–∏–º–∞–µ—Ç –∑–∞–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∫–∞–∫ –∞—Ä–≥—É–º–µ–Ω—Ç –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏.
–ò—Å–ø–æ–ª—å–∑—É–µ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —Ü–∏–∫–ª Chat Completions API —Å —Ä—É—á–Ω—ã–º –≤–µ–¥–µ–Ω–∏–µ–º –∏—Å—Ç–æ—Ä–∏–∏.
"""

import os
import json
import subprocess
import sys
import copy
from openai import OpenAI
from pathlib import Path
import logging
import shlex
import click
import logging.handlers  # Added for FileHandler
from typing import Optional, List, Tuple

# Import config first to load .env before other imports might need env vars
from .core import config

from . import __version__
from .input_utils import get_multiline, prompt_toolkit_available
from .ui_utils import wrap_print, rich_available

# --- –ò–º–ø–æ—Ä—Ç –≤–µ—Ä—Å–∏–∏ (—É–∂–µ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ –≤—ã—à–µ) ---
# try:
#     from . import __version__
# except ImportError: # –ï—Å–ª–∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –Ω–µ –∫–∞–∫ –ø–∞–∫–µ—Ç
#     __version__ = "unknown"

# --- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ü—É—Ç–µ–π –∏ –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è ---
# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–µ–ø–µ—Ä—å –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å LOG_LEVEL –∏–∑ config
# –ò—Å–ø–æ–ª—å–∑—É–µ–º Path.cwd() –¥–ª—è –ø—É—Ç–µ–π –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞–ø—É—Å–∫–∞
CWD = Path.cwd()
DATA_DIR = CWD / "data" / "thread_history"
LOGS_DIR = CWD / "logs"
HISTORY_FILE = DATA_DIR / "messages.json"

# –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
DATA_DIR.mkdir(parents=True, exist_ok=True)
LOGS_DIR.mkdir(parents=True, exist_ok=True)

# –§–∞–π–ª –ª–æ–≥–∞
cli_log_file = LOGS_DIR / "assistant_cli.log"

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–µ—Ä–∞ –¥–ª—è —ç—Ç–æ–≥–æ –º–æ–¥—É–ª—è –î–û –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ö–µ–Ω–¥–ª–µ—Ä–æ–≤
logger = logging.getLogger(__name__)  # Get root logger or specific one


def setup_logging(verbose: bool = False):
    """Configures logging with file and console handlers."""
    log_level_console = logging.INFO if verbose else logging.WARNING
    log_level_file = logging.DEBUG  # Always DEBUG for file

    log_formatter = logging.Formatter(
        "%(asctime)s - %(levelname)s - %(name)s - %(message)s"
    )

    # –ü–æ–ª—É—á–∞–µ–º –∫–æ—Ä–Ω–µ–≤–æ–π –ª–æ–≥–≥–µ—Ä
    root_logger = logging.getLogger()
    root_logger.setLevel(log_level_file)  # Set root logger level to lowest (DEBUG)

    # –£–¥–∞–ª—è–µ–º –≤—Å–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Ö–µ–Ω–¥–ª–µ—Ä—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π basicConfig)
    for handler in root_logger.handlers[:]:
        root_logger.removeHandler(handler)
        handler.close()  # –ó–∞–∫—Ä—ã–≤–∞–µ–º —Ö–µ–Ω–¥–ª–µ—Ä –ø–µ—Ä–µ–¥ —É–¥–∞–ª–µ–Ω–∏–µ–º

    # --- File Handler ---
    file_handler = logging.FileHandler(cli_log_file, mode="a", encoding="utf-8")
    file_handler.setFormatter(log_formatter)
    file_handler.setLevel(log_level_file)
    root_logger.addHandler(file_handler)

    # --- Console Handler ---
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º RichHandler –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω, –∏–Ω–∞—á–µ StreamHandler
    try:
        # Check if rich is available and not explicitly disabled
        if rich_available:
            from rich.logging import RichHandler

            console_handler = RichHandler(
                rich_tracebacks=True,
                show_time=False,  # Keep console less noisy
                show_level=True,
                show_path=False,
                log_time_format="[%X]",  # Example time format
            )
        else:
            raise ImportError(
                "Rich not available or disabled"
            )  # Fallback to StreamHandler
    except ImportError:
        console_handler = logging.StreamHandler(
            sys.stderr
        )  # Log warnings/errors to stderr
        console_handler.setFormatter(log_formatter)  # Use standard format for fallback

    console_handler.setLevel(log_level_console)
    root_logger.addHandler(console_handler)

    logger.info(
        f"Logging setup complete. Console level: {logging.getLevelName(log_level_console)}, File level: {logging.getLevelName(log_level_file)}"
    )
    logger.debug(f"Verbose mode: {verbose}")


# --- –£–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–∞—Ä–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è ---
# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ç–µ–ø–µ—Ä—å –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ config.py
# def load_env_variable(var_name: str, env_file_path: Path) -> str | None:
#     ...
# ENV_FILE_PATH = ...
# OPENAI_API_KEY = ...
# GEMINI_API_KEY = ...
# PERPLEXITY_API_KEY = ...

# --- –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –∫–ª—é—á–µ–π API (–ø–µ—Ä–µ–º–µ—â–µ–Ω–∞ –≤ main) ---
# --- –ö–æ–Ω–µ—Ü –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–ª—é—á–µ–π API ---

# --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ OpenAI ---
# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ –¢–ï–ü–ï–†–¨ –î–û–õ–ñ–ù–ê –ë–´–¢–¨ –í–ù–£–¢–†–ò main(), –ü–û–°–õ–ï –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–ª—é—á–µ–π
# try:
#     client = OpenAI(api_key=config.OPENAI_API_KEY)
#     logger.info("–ö–ª–∏–µ–Ω—Ç OpenAI —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω.")
# except Exception as e:
#     logger.critical(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–ª–∏–µ–Ω—Ç–∞ OpenAI: {e}", exc_info=True)
#     print(f"\nüí• Error initializing OpenAI client: {e}", file=sys.stderr)
#     print("Please ensure the SDK version is compatible and OPENAI_API_KEY is set.", file=sys.stderr)
#     sys.exit(1)
# --- –ö–æ–Ω–µ—Ü –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–ª–∏–µ–Ω—Ç–∞ OpenAI ---

# --- –ù–ê–°–¢–†–û–ô–ö–ê –ò–ù–°–¢–†–£–ú–ï–ù–¢–û–í ---

# ‚ù∑ –°—Ö–µ–º–∞ –¥–ª—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ 'ask' (—Ñ–æ—Ä–º–∞—Ç Chat Completions)
#    –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ: type="function" –æ—Å—Ç–∞–µ—Ç—Å—è, –Ω–æ name —É–±–∏—Ä–∞–µ—Ç—Å—è —Å –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è
ASK_TOOL_SCHEMA = {
    "type": "function",
    "function": {
        "name": "ask",
        "description": "Consults the Lead Software Engineer (ask.py) about the current project. Use this for questions about code implementation, project structure, or high-level advice. The tool has access to the project files and directory tree.",
        "parameters": {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": "The user's request or question for the Lead Software Engineer.",
                },
            },
            "required": ["query"],
        },
    },
}

# –°—Ö–µ–º–∞ –¥–ª—è execute_terminal_command
TERMINAL_TOOL_SCHEMA = {
    "type": "function",
    "function": {
        "name": "execute_terminal_command",
        "description": "Executes a shell command in the project workspace and returns the output. Use carefully for tasks like listing files (`ls -l`), checking configurations (`cat some_config.json`), running linters, or simple scripts. Specify the command and optionally stdin or a working directory.",
        "parameters": {
            "type": "object",
            "properties": {
                "command": {
                    "type": "string",
                    "description": "The shell command to execute.",
                },
                "stdin": {
                    "type": ["string", "null"],
                    "description": "Optional standard input to pass to the command.",
                },
                "cwd": {
                    "type": ["string", "null"],
                    "description": "Optional working directory to run the command in (relative to project root).",
                },
            },
            "required": ["command"],
        },
    },
}

# –°—Ö–µ–º–∞ –¥–ª—è create_file
CREATE_FILE_TOOL_SCHEMA = {
    "type": "function",
    "function": {
        "name": "create_file",
        "description": "Creates a new file or overwrites an existing file with the specified content. Provide the target file path (relative to project root) and the full content.",
        "parameters": {
            "type": "object",
            "properties": {
                "target_file": {
                    "type": "string",
                    "description": "The path of the file to create or overwrite (relative to project root).",
                },
                "content": {
                    "type": "string",
                    "description": "The full content to write into the file.",
                },
            },
            "required": ["target_file", "content"],
        },
    },
}

# –°—Ö–µ–º–∞ –¥–ª—è apply_diff (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç file_modifier.py)
APPLY_DIFF_TOOL_SCHEMA = {
    "type": "function",
    "function": {
        "name": "apply_diff",
        "description": "Modifies an existing file based on a requested change or a provided patch/diff. Provide the target file path and either a description of the change or the patch content.",
        "parameters": {
            "type": "object",
            "properties": {
                "target_file": {
                    "type": "string",
                    "description": "The path of the file to modify (relative to project root).",
                },
                "diff_content": {
                    "type": "string",
                    "description": "A description of the desired change OR the patch content (e.g., unified diff format) to apply.",
                },
            },
            "required": ["target_file", "diff_content"],
        },
    },
}

# –°—Ö–µ–º–∞ –¥–ª—è Perplexity
PERPLEXITY_TOOL_SCHEMA = {
    "type": "function",
    "function": {
        "name": "query_perplexity",
        "description": "Queries the Perplexity AI API (sonar-reasoning-pro model) with a given query and optional file attachments for context. Useful for research, finding code examples, best practices, or external information related to the attached files.",
        "parameters": {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": "The query to send to Perplexity AI.",
                },
                "attachments": {
                    "type": "array",
                    "items": {"type": "string"},
                    "description": "Optional list of file paths (relative to project root) to attach as context to the query.",
                },
            },
            "required": ["query"],
        },
    },
}

# ‚ù∏ –û–ø–∏—Å—ã–≤–∞–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
# –í–∫–ª—é—á–∞–µ–º –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Å—Ö–µ–º—ã –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
TOOLS = [
    ASK_TOOL_SCHEMA,
    TERMINAL_TOOL_SCHEMA,
    CREATE_FILE_TOOL_SCHEMA,
    APPLY_DIFF_TOOL_SCHEMA,
    PERPLEXITY_TOOL_SCHEMA,
]
TOOL_CHOICE = "auto"  # –ú–æ–¥–µ–ª—å —Å–∞–º–∞ –≤—ã–±–∏—Ä–∞–µ—Ç –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç

# --- –ò–º–ø–æ—Ä—Ç—ã –±—ç–∫–µ–Ω–¥-—Ñ—É–Ω–∫—Ü–∏–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ ---
try:
    from assistant.tools import (
        execute_terminal_command,
        handle_create_file,
        handle_apply_diff,
        query_perplexity,  # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º query_perplexity
    )

    logger.info("–ë—ç–∫–µ–Ω–¥—ã –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ —É—Å–ø–µ—à–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã.")
except ImportError as e:
    logger.critical(
        f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –±—ç–∫–µ–Ω–¥—ã –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤: {e}",
        exc_info=True,
    )
    print(f"Error: Could not import tool backends: {e}", file=sys.stderr)

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∑–∞–≥–ª—É—à–∫–∏...
    def execute_terminal_command(*args, **kwargs):
        return {"status": "error", "error_message": "Tool backend unavailable"}

    def handle_create_file(*args, **kwargs):
        return False, "Tool backend unavailable"

    def handle_apply_diff(*args, **kwargs):
        return False, "Tool backend unavailable", None

    def query_perplexity(*args, **kwargs):
        return {
            "error": {"message": "Tool backend unavailable"}
        }  # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è query_perplexity

# --- –ö–û–ù–ï–¶ –ù–ê–°–¢–†–û–ô–ö–ò –ò–ù–°–¢–†–£–ú–ï–ù–¢–û–í ---


# --- –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –†–∞–±–æ—Ç—ã —Å –ò—Å—Ç–æ—Ä–∏–µ–π ---
def load_history() -> list:
    """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –ü–û–õ–ù–£–Æ –∏—Å—Ç–æ—Ä–∏—é —Å–æ–æ–±—â–µ–Ω–∏–π –∏–∑ JSON —Ñ–∞–π–ª–∞."""
    if not HISTORY_FILE.exists():
        logger.info(f"–§–∞–π–ª –∏—Å—Ç–æ—Ä–∏–∏ {HISTORY_FILE} –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—É—é.")
        return []
    try:
        with open(HISTORY_FILE, "r", encoding="utf-8") as f:
            content = f.read()
            if not content:
                logger.info(f"–§–∞–π–ª –∏—Å—Ç–æ—Ä–∏–∏ {HISTORY_FILE} –ø—É—Å—Ç, –Ω–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—É—é.")
                return []
            history = json.loads(content)
            logger.info(
                f"–ò—Å—Ç–æ—Ä–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –∏–∑ {HISTORY_FILE} ({len(history)} —Å–æ–æ–±—â–µ–Ω–∏–π)."
            )
            # TODO: –î–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É —Ñ–æ—Ä–º–∞—Ç–∞ –∏—Å—Ç–æ—Ä–∏–∏?
            if isinstance(history, list):
                return history
            else:
                logger.warning(
                    f"–§–∞–π–ª –∏—Å—Ç–æ—Ä–∏–∏ {HISTORY_FILE} —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ —Å–ø–∏—Å–æ–∫, –∞ {type(history)}. –ù–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—É—é –∏—Å—Ç–æ—Ä–∏—é."
                )
                return []
    except json.JSONDecodeError:
        logger.warning(
            f"–§–∞–π–ª –∏—Å—Ç–æ—Ä–∏–∏ {HISTORY_FILE} –ø–æ–≤—Ä–µ–∂–¥–µ–Ω (JSONDecodeError). –ù–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—É—é –∏—Å—Ç–æ—Ä–∏—é.",
            exc_info=True,
        )
        # TODO: –ú–æ–∂–µ—Ç –±—ã—Ç—å, –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–Ω—ã–π —Ñ–∞–π–ª?
        return []
    except Exception as e:
        logger.error(
            f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏—Å—Ç–æ—Ä–∏–∏ –∏–∑ {HISTORY_FILE}: {e}", exc_info=True
        )
        return []


def save_history(messages_to_save: list):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –ü–û–õ–ù–£–Æ –∏—Å—Ç–æ—Ä–∏—é —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —Ñ–∞–π–ª JSON."""
    logger.debug(f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ {len(messages_to_save)} —Å–æ–æ–±—â–µ–Ω–∏–π –≤ {HISTORY_FILE}")
    try:
        # –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å—É—â–µ—Å—Ç–≤—É–µ—Ç (—Ö–æ—Ç—è –æ–Ω–∞ —Å–æ–∑–¥–∞–µ—Ç—Å—è –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ)
        DATA_DIR.mkdir(parents=True, exist_ok=True)
        with open(HISTORY_FILE, "w", encoding="utf-8") as f:
            json.dump(messages_to_save, f, indent=2, ensure_ascii=False)
        logger.info(
            f"–ò—Å—Ç–æ—Ä–∏—è ({len(messages_to_save)} —Å–æ–æ–±—â–µ–Ω–∏–π) —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ {HISTORY_FILE}."
        )
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏ –≤ {HISTORY_FILE}: {e}", exc_info=True)


# --- –ò–º–ø–æ—Ä—Ç —É—Ç–∏–ª–∏—Ç ---
try:
    from assistant.utils.summarizer import call_gemini_flash as call_gemini_for_summary
except ImportError:
    logger.error(
        "–ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å call_gemini_flash –∏–∑ utils.summarizer. –°—É–º–º–∞—Ä–∏–∑–∞—Ü–∏—è –Ω–µ –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å."
    )

    def call_gemini_for_summary(*args, **kwargs):
        return None
# --- –ö–æ–Ω–µ—Ü –∏–º–ø–æ—Ä—Ç–∞ —É—Ç–∏–ª–∏—Ç ---

# --- –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –°—É–º–º–∞—Ä–∏–∑–∞—Ü–∏–∏ (–º–æ–∂–Ω–æ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —á–µ—Ä–µ–∑ env) ---
SUMMARY_THRESHOLD = int(os.environ.get("O3_SUMMARY_THRESHOLD", 20))
SUMMARY_BATCH = int(
    os.environ.get("O3_SUMMARY_BATCH", 10)
)  # –ö–æ–ª-–≤–æ —Å—Ç–∞—Ä—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è —Å–∞–º–º–∞—Ä–∏
KEEP_RECENT = int(
    os.environ.get("O3_KEEP_RECENT", 10)
)  # –ö–æ–ª-–≤–æ –Ω–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
logger.info(
    f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—É–º–º–∞—Ä–∏–∑–∞—Ü–∏–∏: THRESHOLD={SUMMARY_THRESHOLD}, BATCH={SUMMARY_BATCH}, KEEP_RECENT={KEEP_RECENT}"
)
# --- –ö–æ–Ω–µ—Ü –ö–æ–Ω—Å—Ç–∞–Ω—Ç –¥–ª—è –°—É–º–º–∞—Ä–∏–∑–∞—Ü–∏–∏ ---

# --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ö–æ–Ω—Ç–µ–∫—Å—Ç–∞ –¥–ª—è API ---
SYSTEM_PROMPT_CONTENT = (
    "You are a helpful assistant. Use the available tools when appropriate.\n"
    "- 'ask': Consults the Lead Software Engineer (simulated) for high-level advice, plans, or questions about project structure. It has context of the project files.\n"
    "- 'execute_terminal_command': Runs shell commands in the current working directory (CWD). Use carefully for simple tasks like `ls`, `cat`, etc.\n"
    "- 'create_file': Creates or overwrites a file in the CWD.\n"
    "- 'apply_diff': Applies a patch/diff to an existing file in the CWD.\n"
    "- 'query_perplexity': Queries Perplexity AI for research, code examples, best practices, or external information. Use this when information is likely outside the current project."  # –î–æ–±–∞–≤–ª–µ–Ω–æ
)

# –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è –∏—Å—Ç–æ—Ä–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
messages = []
# --- –ö–æ–Ω–µ—Ü –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ö–æ–Ω—Ç–µ–∫—Å—Ç–∞ ---

# --- –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ (–ø—Ä–∏–º–µ—Ä –¥–ª—è 'ask') ---


def ask_tool_backend(query: str):
    """–ë—ç–∫–µ–Ω–¥-—Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–∑–æ–≤–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ 'ask'."""
    logger.info(f"–í—ã–∑–æ–≤ ask_tool_backend —Å query: '{query[:50]}...'")
    # –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –∏–º–ø–æ—Ä—Ç, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Ç—è–∂–µ–ª—ã—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
    try:
        from assistant.tools.ask import handle_ask

        # –ü–µ—Ä–µ–¥–∞–µ–º API –∫–ª—é—á –∏ –º–æ–¥–µ–ª—å –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        return handle_ask(
            query=query, api_key=config.GEMINI_API_KEY, model_name=config.MODEL_ASK
        )
    except ImportError as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ handle_ask: {e}", exc_info=True)
        return {
            "status": "error",
            "message": "Ask tool backend not found or import error.",
        }
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è handle_ask: {e}", exc_info=True)
        return {"status": "error", "message": f"Error executing ask tool: {e}"}


# --- –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è CLI ---
@click.command()
@click.option(
    "--plain", is_flag=True, help="Disable Rich formatting and advanced input."
)
@click.option(
    "--editor", is_flag=True, help="Use external editor ($EDITOR) for multiline input."
)
@click.option("--user-arg", default="default_value", help="Example custom argument.")
@click.option(
    "--verbose",
    is_flag=True,
    default=False,
    help="Enable INFO level logging to console.",
)
@click.version_option(__version__)
def main(plain, editor, user_arg, verbose):
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è CLI."""
    # --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –ü–ï–†–ï–î —á–µ–º-–ª–∏–±–æ –µ—â–µ) ---
    setup_logging(verbose=verbose)
    logger.info(f"Platform AI Assistant CLI v{__version__} started. PID: {os.getpid()}")
    logger.debug(
        f"Rich available: {rich_available}, Prompt toolkit available: {prompt_toolkit_available}"
    )
    logger.debug(
        f"CLI args: plain={plain}, editor={editor}, user_arg={user_arg}, verbose={verbose}"
    )
    logger.info(f"Current working directory: {CWD}")
    logger.info(f"History file: {HISTORY_FILE}")
    logger.info(f"Log file: {cli_log_file}")

    # --- –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª—é—á–µ–π API (–ø–æ—Å–ª–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–æ–Ω—Ñ–∏–≥–∞) ---
    required_keys = {
        "OpenAI": config.OPENAI_API_KEY,
        "Gemini": config.GEMINI_API_KEY,  # Assuming you have this in config
        "Perplexity": config.PERPLEXITY_API_KEY,  # Assuming you have this in config
    }
    missing_keys = [name for name, key in required_keys.items() if not key]

    if missing_keys:
        error_message = f"Required API key(s) missing in environment or .env file: {', '.join(missing_keys)}"
        logger.critical(error_message)
        print(f"\nüí• {error_message}", file=sys.stderr)
        print(
            "Please set them as environment variables or in a .env file.",
            file=sys.stderr,
        )
        sys.exit(1)
    else:
        logger.info("All required API keys found.")

    # --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ OpenAI (—Ç–µ–ø–µ—Ä—å –±–µ–∑–æ–ø–∞—Å–Ω–æ) ---
    try:
        client = OpenAI(api_key=config.OPENAI_API_KEY)
        logger.info("OpenAI client initialized successfully.")
    except Exception as e:
        logger.critical(
            f"Critical error initializing OpenAI client: {e}", exc_info=True
        )
        print(f"\nüí• Error initializing OpenAI client: {e}", file=sys.stderr)
        sys.exit(1)

    # --- –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ —Ü–∏–∫–ª—É ---
    use_rich = rich_available and not plain
    use_editor = editor
    if use_editor and not os.getenv("EDITOR"):
        logger.warning(
            "Editor mode requested but $EDITOR environment variable is not set. Falling back."
        )
        print(
            "Warning: --editor flag used, but $EDITOR environment variable is not set. Falling back to standard input.",
            file=sys.stderr,
        )
        use_editor = False

    # –°–æ–æ–±—â–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –æ —Ä–µ–∂–∏–º–µ —Ä–∞–±–æ—Ç—ã
    wrap_print(
        f"Assistant CLI v{__version__}. Rich: {use_rich}. Editor: {use_editor}. Logging to: {cli_log_file}",
        role="system",
    )
    wrap_print(
        "Enter your message below. Use /quit or Ctrl+C/Ctrl+D to exit.", role="system"
    )

    # ‚ù∂ –ó–∞–≥—Ä—É–∂–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é —Å–æ–æ–±—â–µ–Ω–∏–π –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –ø—É—Å—Ç—É—é
    messages = load_history()
    if not messages:
        # –î–æ–±–∞–≤–ª—è–µ–º —Å–∏—Å—Ç–µ–º–Ω—É—é –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é, –µ—Å–ª–∏ –∏—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞
        messages.append(
            {"role": "system", "content": "You are a helpful AI assistant."}
        )
        logger.info("Initialized new conversation history with system prompt.")
    else:
        logger.info(f"Loaded {len(messages)} messages from history.")

    # ‚ùπ –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –ø—Ä–æ–≥—Ä–∞–º–º—ã
    while True:
        try:
            # –ü–æ–ª—É—á–∞–µ–º –≤–≤–æ–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            wrap_print("Enter your message:", role="user")  # Prompt for input
            user_input = get_multiline(
                prompt_str="",  # Use empty prompt, wrap_print handles it
                use_editor=use_editor,
                use_prompt_toolkit=use_rich,  # Use rich flag to control prompt_toolkit
            )

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –∫–æ–º–∞–Ω–¥—É –≤—ã—Ö–æ–¥–∞ –∏–ª–∏ –æ—Ç–º–µ–Ω—É (Ctrl+C/Ctrl+D)
            if user_input is None:
                logger.info("User cancelled input (Ctrl+C/Ctrl+D). Exiting.")
                wrap_print("Exiting on user request.", role="system")
                break  # Break the loop instead

            user_input_lower = user_input.strip().lower()
            if user_input_lower == "/quit":
                logger.info("User entered /quit. Exiting.")
                wrap_print("Exiting on user request.", role="system")
                break  # –í—ã—Ö–æ–¥ –∏–∑ —Ü–∏–∫–ª–∞

            if not user_input.strip():
                logger.warning("User entered empty input. Skipping.")
                continue  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç–æ–π –≤–≤–æ–¥

            # –õ–æ–≥–∏—Ä—É–µ–º –∏ –¥–æ–±–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –∏—Å—Ç–æ—Ä–∏—é
            logger.info(f"User input: {user_input[:100]}...")  # Log truncated input
            messages.append({"role": "user", "content": user_input})

            # --- –í—ã–∑–æ–≤ API ---
            # ‚ù∫ –í—ã–∑—ã–≤–∞–µ–º API —Å –∏—Å—Ç–æ—Ä–∏–µ–π —Å–æ–æ–±—â–µ–Ω–∏–π –∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º–∏
            logger.debug(
                f"Calling OpenAI API with {len(messages)} messages. Tools: {len(TOOLS)}. Choice: {TOOL_CHOICE}"
            )
            logger.debug(f"Messages sent: {messages}")  # Log full message history

            try:
                api_response = client.chat.completions.create(
                    model="gpt-4o",  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –¥–æ—Å—Ç—É–ø–Ω—É—é –º–æ–¥–µ–ª—å
                    messages=messages,
                    tools=TOOLS,
                    tool_choice=TOOL_CHOICE,
                    # max_tokens=150, # –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –æ–≥—Ä–∞–Ω–∏—á–∏—Ç—å –¥–ª–∏–Ω—É –æ—Ç–≤–µ—Ç–∞
                )
                logger.debug(f"API Response received: {api_response}")

                # ‚ùª –ü–æ–ª—É—á–∞–µ–º –æ—Ç–≤–µ—Ç –º–æ–¥–µ–ª–∏
                response_message = api_response.choices[0].message
                tool_calls = (
                    response_message.tool_calls
                )  # ‚ùº –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –≤—ã–∑–æ–≤—ã –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤

                # ‚ùΩ –ï—Å–ª–∏ –µ—Å—Ç—å –≤—ã–∑–æ–≤—ã –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤:
                if tool_calls:
                    # –ù–µ –¥–æ–±–∞–≤–ª—è–µ–º –∏—Å—Ö–æ–¥–Ω—ã–π –æ—Ç–≤–µ—Ç –º–æ–¥–µ–ª–∏ —Å tool_calls –≤ –∏—Å—Ç–æ—Ä–∏—é
                    # –ú—ã –¥–æ–±–∞–≤–∏–º tool_calls –∏ –∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∑–∂–µ
                    logger.info(f"Assistant requested {len(tool_calls)} tool call(s).")

                    # –ö–æ–ø–∏—Ä—É–µ–º –∏—Å—Ç–æ—Ä–∏—é –î–û –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
                    # –≠—Ç–æ –≤–∞–∂–Ω–æ, —Ç–∞–∫ –∫–∞–∫ –æ—Ç–≤–µ—Ç –º–æ–¥–µ–ª–∏ —Å—Å—ã–ª–∞–µ—Ç—Å—è –Ω–∞ —ç—Ç—É –∏—Å—Ç–æ—Ä–∏—é
                    messages_before_tool_results = copy.deepcopy(messages)
                    messages_before_tool_results.append(
                        response_message
                    )  # Add assistant msg with tool calls

                    # ‚ùæ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—ã–π –≤—ã–∑–æ–≤ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
                    for tool_call in tool_calls:
                        function_name = tool_call.function.name
                        function_args_raw = tool_call.function.arguments
                        tool_call_id = tool_call.id
                        logger.info(
                            f"Processing tool call ID: {tool_call_id}, Function: {function_name}, Args: {function_args_raw}"
                        )

                        # --- –õ–æ–≥–∏–∫–∞ –≤—ã–∑–æ–≤–∞ –±—ç–∫–µ–Ω–¥–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ ---
                        tool_response_content = None
                        tool_backend_function = None

                        try:
                            # –ü–∞—Ä—Å–∏–º –∞—Ä–≥—É–º–µ–Ω—Ç—ã JSON
                            function_args = json.loads(function_args_raw)

                            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫–∞–∫–æ–π –±—ç–∫–µ–Ω–¥ –≤—ã–∑–≤–∞—Ç—å
                            if function_name == "ask":
                                tool_backend_function = ask_tool_backend
                            elif function_name == "execute_terminal_command":
                                tool_backend_function = execute_terminal_command
                            elif function_name == "create_file":
                                tool_backend_function = (
                                    handle_create_file  # Use wrapper
                                )
                            elif function_name == "apply_diff":
                                tool_backend_function = handle_apply_diff  # Use wrapper
                            elif function_name == "query_perplexity":
                                tool_backend_function = query_perplexity  # Use wrapper

                            # –ï—Å–ª–∏ –Ω–∞—à–ª–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é —Ñ—É–Ω–∫—Ü–∏—é
                            if tool_backend_function:
                                # *** –°–æ–æ–±—â–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –æ –≤—ã–∑–æ–≤–µ ***
                                wrap_print(
                                    f"Calling tool `{function_name}` with args: {function_args_raw}",
                                    role="tool_call",
                                )

                                # –í—ã–∑—ã–≤–∞–µ–º –±—ç–∫–µ–Ω–¥-—Ñ—É–Ω–∫—Ü–∏—é
                                tool_result = tool_backend_function(**function_args)
                                logger.debug(
                                    f"Raw tool result for '{function_name}': {tool_result} (Type: {type(tool_result)})"
                                )

                                # --- –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ ---
                                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –∏ –∏–∑–≤–ª–µ–∫–∞–µ–º —Å—Ç—Ä–æ–∫—É –¥–ª—è API
                                if isinstance(tool_result, tuple):
                                    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–æ—Ä—Ç–µ–∂–∏ –æ—Ç create_file / apply_diff
                                    # (ok: bool, msg: str, diff?: Optional[str])
                                    # –ú—ã —Ö–æ—Ç–∏–º –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–æ–ª—å–∫–æ 'msg' –æ–±—Ä–∞—Ç–Ω–æ –≤ API
                                    tool_response_content = tool_result[
                                        1
                                    ]  # –ë–µ—Ä–µ–º –≤—Ç–æ—Ä–æ–π —ç–ª–µ–º–µ–Ω—Ç - —Å–æ–æ–±—â–µ–Ω–∏–µ
                                    # –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –ª–æ–≥–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–ª–Ω–æ–≥–æ –∫–æ—Ä—Ç–µ–∂–∞ —É–∂–µ –µ—Å—Ç—å –≤—ã—à–µ
                                elif isinstance(tool_result, dict):
                                    # –î–ª—è execute_terminal_command –∏–ª–∏ –¥—Ä—É–≥–∏—Ö, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∏—Ö dict
                                    tool_response_content = json.dumps(
                                        tool_result
                                    )  # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º dict –≤ JSON-—Å—Ç—Ä–æ–∫—É
                                elif isinstance(tool_result, str):
                                    tool_response_content = tool_result
                                else:
                                    # –ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π —Ç–∏–ø - –ª–æ–≥–∏—Ä—É–µ–º –∏ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —Å—Ç—Ä–æ–∫—É
                                    logger.warning(
                                        f"Unexpected result type from tool '{function_name}': {type(tool_result)}. Converting to string."
                                    )
                                    tool_response_content = str(tool_result)

                                # *** –°–æ–æ–±—â–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ ***
                                wrap_print(
                                    f"‚úì `{function_name}` finished.",
                                    role="tool_response",
                                )

                            else:
                                logger.error(
                                    f"Error: Function '{function_name}' not found."
                                )
                                tool_response_content = f'{{"error": "Function {function_name} not found."}}'
                                wrap_print(
                                    f"Error: Tool `{function_name}` not found.",
                                    role="system",
                                )  # Inform user

                        except json.JSONDecodeError as e:
                            logger.error(
                                f"Error decoding JSON arguments for {function_name}: {e}\\nArguments: {function_args_raw}",
                                exc_info=True,
                            )
                            tool_response_content = (
                                f'{{"error": "Invalid JSON arguments: {e}"}}'
                            )
                            wrap_print(
                                f"Error decoding arguments for `{function_name}`.",
                                role="system",
                            )
                        except TypeError as e:
                            # –õ–æ–≤–∏–º –æ—à–∏–±–∫–∏, –µ—Å–ª–∏ –∞—Ä–≥—É–º–µ–Ω—Ç—ã –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç —Å–∏–≥–Ω–∞—Ç—É—Ä–µ —Ñ—É–Ω–∫—Ü–∏–∏
                            logger.error(
                                f"TypeError calling tool backend '{function_name}' with args {function_args}: {e}",
                                exc_info=True,
                            )
                            tool_response_content = f'{{"error": "TypeError calling backend function: {e}"}}'
                            wrap_print(
                                f"Error calling tool `{function_name}`: {e}",
                                role="system",
                            )
                        except Exception as e:
                            # –û–±—â–∏–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ –±—ç–∫–µ–Ω–¥–∞
                            logger.error(
                                f"Error executing tool backend '{function_name}' with args {function_args_raw}: {e}",
                                exc_info=True,
                            )
                            tool_response_content = (
                                f'{{"error": "Error executing tool: {e}"}}'
                            )
                            wrap_print(
                                f"Error during `{function_name}` execution: {e}",
                                role="system",
                            )

                        # ‚ùø –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–∑–æ–≤–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –≤ –∏—Å—Ç–æ—Ä–∏—é –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —à–∞–≥–∞
                        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ò–°–•–û–î–ù–£–Æ –∏—Å—Ç–æ—Ä–∏—é (messages_before_tool_results)
                        messages_before_tool_results.append(
                            {
                                "tool_call_id": tool_call_id,
                                "role": "tool",
                                "name": function_name,
                                "content": tool_response_content,  # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–∑–≤–ª–µ—á–µ–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É
                            }
                        )
                        logger.debug(
                            f"Appended tool result for {tool_call_id} to temporary history."
                        )

                    # ‚ì´ –í—ã–∑—ã–≤–∞–µ–º API –µ—â–µ —Ä–∞–∑, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏–≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
                    logger.info("Calling API again with tool results.")
                    logger.debug(
                        f"Messages with tool results: {messages_before_tool_results}"
                    )
                    second_api_response = client.chat.completions.create(
                        model="gpt-4o",
                        messages=messages_before_tool_results,  # –ü–µ—Ä–µ–¥–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
                    )
                    logger.debug(f"Second API response: {second_api_response}")

                    # –ü–æ–ª—É—á–∞–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –º–æ–¥–µ–ª–∏ –ø–æ—Å–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
                    final_response_message = second_api_response.choices[0].message
                    messages.append(
                        response_message
                    )  # –î–æ–±–∞–≤–ª—è–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞ —Å tool_calls
                    # –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è tool –∏–∑ –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∏—Å—Ç–æ—Ä–∏–∏
                    for msg in messages_before_tool_results:
                        if msg["role"] == "tool":
                            messages.append(msg)
                    messages.append(final_response_message)  # –î–æ–±–∞–≤–ª—è–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç
                    assistant_response_content = final_response_message.content
                    logger.info("Assistant final response after tool use.")

                # ‚ì¨ –ï—Å–ª–∏ –≤—ã–∑–æ–≤–æ–≤ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –Ω–µ –±—ã–ª–æ, –ø—Ä–æ—Å—Ç–æ –±–µ—Ä–µ–º –æ—Ç–≤–µ—Ç –º–æ–¥–µ–ª–∏
                else:
                    assistant_response_content = response_message.content
                    messages.append(
                        response_message
                    )  # –î–æ–±–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞ –≤ –∏—Å—Ç–æ—Ä–∏—é
                    logger.info("Assistant response received (no tool calls).")

                # --- –í—ã–≤–æ–¥ –æ—Ç–≤–µ—Ç–∞ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞ ---
                if assistant_response_content:
                    wrap_print(assistant_response_content, role="assistant")
                    logger.debug(
                        f"Assistant response content: {assistant_response_content[:100]}..."
                    )
                else:
                    # –°–ª—É—á–∞–π, –∫–æ–≥–¥–∞ –Ω–µ—Ç –Ω–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞, –Ω–∏ tool calls (–º–∞–ª–æ–≤–µ—Ä–æ—è—Ç–Ω–æ, –Ω–æ –≤–æ–∑–º–æ–∂–Ω–æ)
                    logger.warning(
                        "Assistant response was empty (no content or tool calls)."
                    )
                    wrap_print("[Assistant provided an empty response]", role="system")

            except Exception as e:
                logger.error(f"Error during API call or processing: {e}", exc_info=True)
                # wrap_print(f"An error occurred: {e}", "error") # Or use system role
                wrap_print(
                    f"An error occurred: {e}", role="system"
                )  # Using system role for errors

        except KeyboardInterrupt:
            logger.info("KeyboardInterrupt received. Exiting.")
            wrap_print("Exiting on user request.", role="system")
            break
        except EOFError:  # –û–±—Ä–∞–±–æ—Ç–∫–∞ Ctrl+D –≤ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —Ç–µ—Ä–º–∏–Ω–∞–ª–∞—Ö
            logger.info("EOFError received (Ctrl+D). Exiting.")
            wrap_print("Exiting on user request.", role="system")
            break

    # --- –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ ---
    save_history(messages)  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ç–æ—Ä–∏—é –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ
    logger.info("Exiting CLI application. History saved.")


def _format_tool_result_for_print(
    tool_name: str, tool_result: dict | str, tool_args: str
) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –¥–ª—è –≤—ã–≤–æ–¥–∞ –≤ –∫–æ–Ω—Å–æ–ª—å."""
    result_str = ""
    # ... (–æ—Å—Ç–∞–ª—å–Ω–∞—è —á–∞—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
    return result_str


# --- –§—É–Ω–∫—Ü–∏–∏-–æ–±–µ—Ä—Ç–∫–∏ –¥–ª—è –±—ç–∫–µ–Ω–¥–æ–≤ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ ---
# –≠—Ç–∏ —Ñ—É–Ω–∫—Ü–∏–∏ –∑–∞–ø—É—Å–∫–∞—é—Ç —Å–∫—Ä–∏–ø—Ç—ã –≤ –ø–æ–¥–ø—Ä–æ—Ü–µ—Å—Å–∞—Ö


def handle_create_file(target_file: str, content: str) -> Tuple[bool, str]:
    """–í—ã–∑—ã–≤–∞–µ—Ç file_modifier.py create –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç (success, message)."""
    script_path = Path(__file__).parent / "tools" / "file_modifier.py"
    command = [sys.executable, str(script_path), "create", target_file]
    logger.info(f"Executing file modifier: {' '.join(command)}")
    try:
        process = subprocess.run(
            command,
            input=content,
            text=True,
            capture_output=True,
            check=False,  # Don't raise exception on non-zero exit code
            encoding="utf-8",
        )
        logger.debug(f"file_modifier create stdout: {process.stdout}")
        logger.debug(f"file_modifier create stderr: {process.stderr}")

        if process.returncode == 0:
            logger.info(f"File '{target_file}' created/overwritten successfully.")
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º stdout –∫–∞–∫ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—Ö–µ
            return (
                True,
                process.stdout.strip() or f"File '{target_file}' created/overwritten.",
            )
        else:
            error_msg = (
                process.stderr.strip()
                or f"Unknown error creating file '{target_file}'."
            )
            logger.error(f"Error creating file '{target_file}': {error_msg}")
            return False, f"Error: {error_msg}"
    except Exception as e:
        logger.exception(f"Failed to run file_modifier create for '{target_file}'")
        return False, f"Failed to execute file creation: {e}"


def handle_apply_diff(
    target_file: str, diff_content: str
) -> Tuple[bool, str, Optional[str]]:
    """–í—ã–∑—ã–≤–∞–µ—Ç file_modifier.py apply –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç (success, message, actual_diff)."""
    script_path = Path(__file__).parent / "tools" / "file_modifier.py"
    command = [sys.executable, str(script_path), "apply", target_file]
    logger.info(f"Executing file modifier apply: {' '.join(command)}")
    try:
        process = subprocess.run(
            command,
            input=diff_content,
            text=True,
            capture_output=True,
            check=False,
            encoding="utf-8",
        )
        logger.debug(f"file_modifier apply stdout: {process.stdout}")
        logger.debug(f"file_modifier apply stderr: {process.stderr}")

        if process.returncode == 0:
            # Diff applied successfully, stdout might contain the actual diff applied
            actual_diff = process.stdout.strip()
            message = f"Changes applied to '{target_file}'."
            logger.info(message)
            return True, message, actual_diff if actual_diff else None
        else:
            error_msg = (
                process.stderr.strip()
                or f"Unknown error applying diff to '{target_file}'."
            )
            logger.error(f"Error applying diff to '{target_file}': {error_msg}")
            return False, f"Error: {error_msg}", None
    except Exception as e:
        logger.exception(f"Failed to run file_modifier apply for '{target_file}'")
        return False, f"Failed to execute diff application: {e}", None


def query_perplexity_backend(
    query: str, attachments: Optional[List[str]] = None
) -> str:
    """–í—ã–∑—ã–≤–∞–µ—Ç perplexity_tool.py –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—Ç–≤–µ—Ç."""
    script_path = Path(__file__).parent / "tools" / "perplexity_tool.py"
    command = [sys.executable, str(script_path)]
    if attachments:
        for attachment in attachments:
            command.extend(["--attach", attachment])
    command.extend(["--query", query])  # Add query last

    logger.info(
        f"Executing Perplexity tool: {' '.join(shlex.quote(c) for c in command)}"
    )
    try:
        process = subprocess.run(
            command,
            capture_output=True,
            text=True,
            check=True,  # Raise exception on non-zero exit
            encoding="utf-8",
        )
        logger.debug(
            f"Perplexity tool stdout: {process.stdout[:200]}..."
        )  # Log truncated output
        return process.stdout.strip()
    except subprocess.CalledProcessError as e:
        error_msg = f"Error executing Perplexity tool: {e}. Stderr: {e.stderr.strip()}"
        logger.error(error_msg)
        return f'{{"error": "{error_msg}"}}'  # Return error as JSON string
    except Exception as e:
        logger.exception("Failed to run Perplexity tool script")
        return f'{{"error": "Failed to execute Perplexity tool script: {e}"}}'


if __name__ == "__main__":
    main()
