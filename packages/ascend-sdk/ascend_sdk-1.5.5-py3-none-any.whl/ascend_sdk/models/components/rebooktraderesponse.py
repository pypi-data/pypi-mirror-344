"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .lot import Lot, LotTypedDict
from .yieldrecord import YieldRecord, YieldRecordTypedDict
from ascend_sdk import utils
from ascend_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from ascend_sdk.utils import validate_open_enum
from enum import Enum
from pydantic import model_serializer
from pydantic.functional_validators import PlainValidator
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class RebookTradeResponseBrokerCapacity(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Used to calculate broadridge blotter code"""

    CAPACITY_UNSPECIFIED = "CAPACITY_UNSPECIFIED"
    AGENCY = "AGENCY"
    PRINCIPAL = "PRINCIPAL"
    MIXED = "MIXED"


class RebookTradeResponsePrevailingMarketPriceTypedDict(TypedDict):
    r"""The price for the instrument that is prevailing in the market."""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class RebookTradeResponsePrevailingMarketPrice(BaseModel):
    r"""The price for the instrument that is prevailing in the market."""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class RebookTradeResponsePriceAdjustmentAmountTypedDict(TypedDict):
    r"""Total monetary value of the price_adjustment"""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class RebookTradeResponsePriceAdjustmentAmount(BaseModel):
    r"""Total monetary value of the price_adjustment"""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class RebookTradeResponsePriceAdjustmentPercentTypedDict(TypedDict):
    r"""The percent at which the price was adjusted. Expressed as a number from 0.00-100 (rounded to 2 decimals)"""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class RebookTradeResponsePriceAdjustmentPercent(BaseModel):
    r"""The percent at which the price was adjusted. Expressed as a number from 0.00-100 (rounded to 2 decimals)"""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class RebookTradeResponsePriceAdjustmentType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The type of price adjustment being applied by the broker to the net price of the security"""

    PRICE_ADJUSTMENT_TYPE_UNSPECIFIED = "PRICE_ADJUSTMENT_TYPE_UNSPECIFIED"
    MARKUP = "MARKUP"
    MARKDOWN = "MARKDOWN"
    SALES_LOAD = "SALES_LOAD"


class RebookTradeResponsePriceAdjustmentRecordTypedDict(TypedDict):
    r"""Information about any price adjustments applied to the security"""

    price_adjustment_amount: NotRequired[
        Nullable[RebookTradeResponsePriceAdjustmentAmountTypedDict]
    ]
    r"""Total monetary value of the price_adjustment"""
    price_adjustment_percent: NotRequired[
        Nullable[RebookTradeResponsePriceAdjustmentPercentTypedDict]
    ]
    r"""The percent at which the price was adjusted. Expressed as a number from 0.00-100 (rounded to 2 decimals)"""
    price_adjustment_type: NotRequired[RebookTradeResponsePriceAdjustmentType]
    r"""The type of price adjustment being applied by the broker to the net price of the security"""


class RebookTradeResponsePriceAdjustmentRecord(BaseModel):
    r"""Information about any price adjustments applied to the security"""

    price_adjustment_amount: OptionalNullable[
        RebookTradeResponsePriceAdjustmentAmount
    ] = UNSET
    r"""Total monetary value of the price_adjustment"""

    price_adjustment_percent: OptionalNullable[
        RebookTradeResponsePriceAdjustmentPercent
    ] = UNSET
    r"""The percent at which the price was adjusted. Expressed as a number from 0.00-100 (rounded to 2 decimals)"""

    price_adjustment_type: Annotated[
        Optional[RebookTradeResponsePriceAdjustmentType],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""The type of price adjustment being applied by the broker to the net price of the security"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "price_adjustment_amount",
            "price_adjustment_percent",
            "price_adjustment_type",
        ]
        nullable_fields = ["price_adjustment_amount", "price_adjustment_percent"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class NewTradeTypedDict(TypedDict):
    r"""The new trade that is booked."""

    additional_instructions: NotRequired[List[str]]
    r"""Free form text field containing additional information for a trade"""
    alternate_order_id: NotRequired[str]
    r"""Max Length 100 characters. Alternate order id from the street used for FRAC trades"""
    booking_api_trade_allocation_id: NotRequired[str]
    r"""uuid assigned by the Booking API if a trade belongs to an allocation"""
    booking_api_trade_id: NotRequired[str]
    r"""uuid assigned by the Booking API to all trades"""
    broker: NotRequired[str]
    r"""Executing broker of the trade"""
    broker_capacity: NotRequired[RebookTradeResponseBrokerCapacity]
    r"""Used to calculate broadridge blotter code"""
    client_memos: NotRequired[List[str]]
    r"""Free form text submitted by the client for internal purposes"""
    client_order_id: NotRequired[str]
    r"""32 characters. The client order ID from the order submitted"""
    exchange: NotRequired[str]
    r"""MIC code for the exchange"""
    execution_id: NotRequired[str]
    r"""Execution id from the street"""
    execution_only: NotRequired[bool]
    r"""Indicates whether Apex is the clearing broker for this trade. When false, indicates Apex is the clearing broker"""
    external_id: NotRequired[str]
    r"""Max Length 100 characters. External system id provided by a client"""
    fund_confirmation_number: NotRequired[str]
    r"""The confirmation number associated with a mutual fund trade"""
    gateway_client_order_id: NotRequired[str]
    r"""Max length 100 characters. Order id generated by trading-gateway (Trade-Ex) to uniquely identify all orders in their system. Used as the client_order_id on new order singles sent downstream of the trading-gateway"""
    internal_error: NotRequired[bool]
    r"""If set to true, indicates the trade should be omitted from client billing"""
    is_writeoff: NotRequired[bool]
    r"""Set on penny-for-the-lot trades"""
    lots: NotRequired[List[LotTypedDict]]
    r"""Repeated record containing information about the tax lots, if specified"""
    order_id: NotRequired[str]
    r"""Max Length 100 characters. Internally generated order id that is returned to client on exec reports"""
    prevailing_market_price: NotRequired[
        Nullable[RebookTradeResponsePrevailingMarketPriceTypedDict]
    ]
    r"""The price for the instrument that is prevailing in the market."""
    price_adjustment_record: NotRequired[
        Nullable[RebookTradeResponsePriceAdjustmentRecordTypedDict]
    ]
    r"""Information about any price adjustments applied to the security"""
    route: NotRequired[str]
    r"""Used to calculate broadridge blotter code"""
    special_instructions: NotRequired[List[str]]
    r"""The special instructions for a trade"""
    symbol_description: NotRequired[str]
    r"""Name of the issuer of a security and additional descriptive information about the particular issue"""
    when_issued: NotRequired[bool]
    r"""Indicates the trade was executed in a security that is not currently listed. When-issued securities are bought and sold before they are officially issued, allowing investors to speculate on their future value"""
    yield_records: NotRequired[List[YieldRecordTypedDict]]
    r"""The yields associated with a fixed income trade. only valid if the SecurityType is FIXED_INCOME."""


class NewTrade(BaseModel):
    r"""The new trade that is booked."""

    additional_instructions: Optional[List[str]] = None
    r"""Free form text field containing additional information for a trade"""

    alternate_order_id: Optional[str] = None
    r"""Max Length 100 characters. Alternate order id from the street used for FRAC trades"""

    booking_api_trade_allocation_id: Optional[str] = None
    r"""uuid assigned by the Booking API if a trade belongs to an allocation"""

    booking_api_trade_id: Optional[str] = None
    r"""uuid assigned by the Booking API to all trades"""

    broker: Optional[str] = None
    r"""Executing broker of the trade"""

    broker_capacity: Annotated[
        Optional[RebookTradeResponseBrokerCapacity],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""Used to calculate broadridge blotter code"""

    client_memos: Optional[List[str]] = None
    r"""Free form text submitted by the client for internal purposes"""

    client_order_id: Optional[str] = None
    r"""32 characters. The client order ID from the order submitted"""

    exchange: Optional[str] = None
    r"""MIC code for the exchange"""

    execution_id: Optional[str] = None
    r"""Execution id from the street"""

    execution_only: Optional[bool] = None
    r"""Indicates whether Apex is the clearing broker for this trade. When false, indicates Apex is the clearing broker"""

    external_id: Optional[str] = None
    r"""Max Length 100 characters. External system id provided by a client"""

    fund_confirmation_number: Optional[str] = None
    r"""The confirmation number associated with a mutual fund trade"""

    gateway_client_order_id: Optional[str] = None
    r"""Max length 100 characters. Order id generated by trading-gateway (Trade-Ex) to uniquely identify all orders in their system. Used as the client_order_id on new order singles sent downstream of the trading-gateway"""

    internal_error: Optional[bool] = None
    r"""If set to true, indicates the trade should be omitted from client billing"""

    is_writeoff: Optional[bool] = None
    r"""Set on penny-for-the-lot trades"""

    lots: Optional[List[Lot]] = None
    r"""Repeated record containing information about the tax lots, if specified"""

    order_id: Optional[str] = None
    r"""Max Length 100 characters. Internally generated order id that is returned to client on exec reports"""

    prevailing_market_price: OptionalNullable[
        RebookTradeResponsePrevailingMarketPrice
    ] = UNSET
    r"""The price for the instrument that is prevailing in the market."""

    price_adjustment_record: OptionalNullable[
        RebookTradeResponsePriceAdjustmentRecord
    ] = UNSET
    r"""Information about any price adjustments applied to the security"""

    route: Optional[str] = None
    r"""Used to calculate broadridge blotter code"""

    special_instructions: Optional[List[str]] = None
    r"""The special instructions for a trade"""

    symbol_description: Optional[str] = None
    r"""Name of the issuer of a security and additional descriptive information about the particular issue"""

    when_issued: Optional[bool] = None
    r"""Indicates the trade was executed in a security that is not currently listed. When-issued securities are bought and sold before they are officially issued, allowing investors to speculate on their future value"""

    yield_records: Optional[List[YieldRecord]] = None
    r"""The yields associated with a fixed income trade. only valid if the SecurityType is FIXED_INCOME."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "additional_instructions",
            "alternate_order_id",
            "booking_api_trade_allocation_id",
            "booking_api_trade_id",
            "broker",
            "broker_capacity",
            "client_memos",
            "client_order_id",
            "exchange",
            "execution_id",
            "execution_only",
            "external_id",
            "fund_confirmation_number",
            "gateway_client_order_id",
            "internal_error",
            "is_writeoff",
            "lots",
            "order_id",
            "prevailing_market_price",
            "price_adjustment_record",
            "route",
            "special_instructions",
            "symbol_description",
            "when_issued",
            "yield_records",
        ]
        nullable_fields = ["prevailing_market_price", "price_adjustment_record"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class RebookTradeResponseOriginalTradeBrokerCapacity(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Used to calculate broadridge blotter code"""

    CAPACITY_UNSPECIFIED = "CAPACITY_UNSPECIFIED"
    AGENCY = "AGENCY"
    PRINCIPAL = "PRINCIPAL"
    MIXED = "MIXED"


class RebookTradeResponseOriginalTradePrevailingMarketPriceTypedDict(TypedDict):
    r"""The price for the instrument that is prevailing in the market."""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class RebookTradeResponseOriginalTradePrevailingMarketPrice(BaseModel):
    r"""The price for the instrument that is prevailing in the market."""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class RebookTradeResponseOriginalTradePriceAdjustmentAmountTypedDict(TypedDict):
    r"""Total monetary value of the price_adjustment"""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class RebookTradeResponseOriginalTradePriceAdjustmentAmount(BaseModel):
    r"""Total monetary value of the price_adjustment"""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class RebookTradeResponseOriginalTradePriceAdjustmentPercentTypedDict(TypedDict):
    r"""The percent at which the price was adjusted. Expressed as a number from 0.00-100 (rounded to 2 decimals)"""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class RebookTradeResponseOriginalTradePriceAdjustmentPercent(BaseModel):
    r"""The percent at which the price was adjusted. Expressed as a number from 0.00-100 (rounded to 2 decimals)"""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class RebookTradeResponseOriginalTradePriceAdjustmentType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""The type of price adjustment being applied by the broker to the net price of the security"""

    PRICE_ADJUSTMENT_TYPE_UNSPECIFIED = "PRICE_ADJUSTMENT_TYPE_UNSPECIFIED"
    MARKUP = "MARKUP"
    MARKDOWN = "MARKDOWN"
    SALES_LOAD = "SALES_LOAD"


class RebookTradeResponseOriginalTradePriceAdjustmentRecordTypedDict(TypedDict):
    r"""Information about any price adjustments applied to the security"""

    price_adjustment_amount: NotRequired[
        Nullable[RebookTradeResponseOriginalTradePriceAdjustmentAmountTypedDict]
    ]
    r"""Total monetary value of the price_adjustment"""
    price_adjustment_percent: NotRequired[
        Nullable[RebookTradeResponseOriginalTradePriceAdjustmentPercentTypedDict]
    ]
    r"""The percent at which the price was adjusted. Expressed as a number from 0.00-100 (rounded to 2 decimals)"""
    price_adjustment_type: NotRequired[
        RebookTradeResponseOriginalTradePriceAdjustmentType
    ]
    r"""The type of price adjustment being applied by the broker to the net price of the security"""


class RebookTradeResponseOriginalTradePriceAdjustmentRecord(BaseModel):
    r"""Information about any price adjustments applied to the security"""

    price_adjustment_amount: OptionalNullable[
        RebookTradeResponseOriginalTradePriceAdjustmentAmount
    ] = UNSET
    r"""Total monetary value of the price_adjustment"""

    price_adjustment_percent: OptionalNullable[
        RebookTradeResponseOriginalTradePriceAdjustmentPercent
    ] = UNSET
    r"""The percent at which the price was adjusted. Expressed as a number from 0.00-100 (rounded to 2 decimals)"""

    price_adjustment_type: Annotated[
        Optional[RebookTradeResponseOriginalTradePriceAdjustmentType],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""The type of price adjustment being applied by the broker to the net price of the security"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "price_adjustment_amount",
            "price_adjustment_percent",
            "price_adjustment_type",
        ]
        nullable_fields = ["price_adjustment_amount", "price_adjustment_percent"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class OriginalTradeTypedDict(TypedDict):
    r"""The original trade that was rebooked."""

    additional_instructions: NotRequired[List[str]]
    r"""Free form text field containing additional information for a trade"""
    alternate_order_id: NotRequired[str]
    r"""Max Length 100 characters. Alternate order id from the street used for FRAC trades"""
    booking_api_trade_allocation_id: NotRequired[str]
    r"""uuid assigned by the Booking API if a trade belongs to an allocation"""
    booking_api_trade_id: NotRequired[str]
    r"""uuid assigned by the Booking API to all trades"""
    broker: NotRequired[str]
    r"""Executing broker of the trade"""
    broker_capacity: NotRequired[RebookTradeResponseOriginalTradeBrokerCapacity]
    r"""Used to calculate broadridge blotter code"""
    client_memos: NotRequired[List[str]]
    r"""Free form text submitted by the client for internal purposes"""
    client_order_id: NotRequired[str]
    r"""32 characters. The client order ID from the order submitted"""
    exchange: NotRequired[str]
    r"""MIC code for the exchange"""
    execution_id: NotRequired[str]
    r"""Execution id from the street"""
    execution_only: NotRequired[bool]
    r"""Indicates whether Apex is the clearing broker for this trade. When false, indicates Apex is the clearing broker"""
    external_id: NotRequired[str]
    r"""Max Length 100 characters. External system id provided by a client"""
    fund_confirmation_number: NotRequired[str]
    r"""The confirmation number associated with a mutual fund trade"""
    gateway_client_order_id: NotRequired[str]
    r"""Max length 100 characters. Order id generated by trading-gateway (Trade-Ex) to uniquely identify all orders in their system. Used as the client_order_id on new order singles sent downstream of the trading-gateway"""
    internal_error: NotRequired[bool]
    r"""If set to true, indicates the trade should be omitted from client billing"""
    is_writeoff: NotRequired[bool]
    r"""Set on penny-for-the-lot trades"""
    lots: NotRequired[List[LotTypedDict]]
    r"""Repeated record containing information about the tax lots, if specified"""
    order_id: NotRequired[str]
    r"""Max Length 100 characters. Internally generated order id that is returned to client on exec reports"""
    prevailing_market_price: NotRequired[
        Nullable[RebookTradeResponseOriginalTradePrevailingMarketPriceTypedDict]
    ]
    r"""The price for the instrument that is prevailing in the market."""
    price_adjustment_record: NotRequired[
        Nullable[RebookTradeResponseOriginalTradePriceAdjustmentRecordTypedDict]
    ]
    r"""Information about any price adjustments applied to the security"""
    route: NotRequired[str]
    r"""Used to calculate broadridge blotter code"""
    special_instructions: NotRequired[List[str]]
    r"""The special instructions for a trade"""
    symbol_description: NotRequired[str]
    r"""Name of the issuer of a security and additional descriptive information about the particular issue"""
    when_issued: NotRequired[bool]
    r"""Indicates the trade was executed in a security that is not currently listed. When-issued securities are bought and sold before they are officially issued, allowing investors to speculate on their future value"""
    yield_records: NotRequired[List[YieldRecordTypedDict]]
    r"""The yields associated with a fixed income trade. only valid if the SecurityType is FIXED_INCOME."""


class OriginalTrade(BaseModel):
    r"""The original trade that was rebooked."""

    additional_instructions: Optional[List[str]] = None
    r"""Free form text field containing additional information for a trade"""

    alternate_order_id: Optional[str] = None
    r"""Max Length 100 characters. Alternate order id from the street used for FRAC trades"""

    booking_api_trade_allocation_id: Optional[str] = None
    r"""uuid assigned by the Booking API if a trade belongs to an allocation"""

    booking_api_trade_id: Optional[str] = None
    r"""uuid assigned by the Booking API to all trades"""

    broker: Optional[str] = None
    r"""Executing broker of the trade"""

    broker_capacity: Annotated[
        Optional[RebookTradeResponseOriginalTradeBrokerCapacity],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""Used to calculate broadridge blotter code"""

    client_memos: Optional[List[str]] = None
    r"""Free form text submitted by the client for internal purposes"""

    client_order_id: Optional[str] = None
    r"""32 characters. The client order ID from the order submitted"""

    exchange: Optional[str] = None
    r"""MIC code for the exchange"""

    execution_id: Optional[str] = None
    r"""Execution id from the street"""

    execution_only: Optional[bool] = None
    r"""Indicates whether Apex is the clearing broker for this trade. When false, indicates Apex is the clearing broker"""

    external_id: Optional[str] = None
    r"""Max Length 100 characters. External system id provided by a client"""

    fund_confirmation_number: Optional[str] = None
    r"""The confirmation number associated with a mutual fund trade"""

    gateway_client_order_id: Optional[str] = None
    r"""Max length 100 characters. Order id generated by trading-gateway (Trade-Ex) to uniquely identify all orders in their system. Used as the client_order_id on new order singles sent downstream of the trading-gateway"""

    internal_error: Optional[bool] = None
    r"""If set to true, indicates the trade should be omitted from client billing"""

    is_writeoff: Optional[bool] = None
    r"""Set on penny-for-the-lot trades"""

    lots: Optional[List[Lot]] = None
    r"""Repeated record containing information about the tax lots, if specified"""

    order_id: Optional[str] = None
    r"""Max Length 100 characters. Internally generated order id that is returned to client on exec reports"""

    prevailing_market_price: OptionalNullable[
        RebookTradeResponseOriginalTradePrevailingMarketPrice
    ] = UNSET
    r"""The price for the instrument that is prevailing in the market."""

    price_adjustment_record: OptionalNullable[
        RebookTradeResponseOriginalTradePriceAdjustmentRecord
    ] = UNSET
    r"""Information about any price adjustments applied to the security"""

    route: Optional[str] = None
    r"""Used to calculate broadridge blotter code"""

    special_instructions: Optional[List[str]] = None
    r"""The special instructions for a trade"""

    symbol_description: Optional[str] = None
    r"""Name of the issuer of a security and additional descriptive information about the particular issue"""

    when_issued: Optional[bool] = None
    r"""Indicates the trade was executed in a security that is not currently listed. When-issued securities are bought and sold before they are officially issued, allowing investors to speculate on their future value"""

    yield_records: Optional[List[YieldRecord]] = None
    r"""The yields associated with a fixed income trade. only valid if the SecurityType is FIXED_INCOME."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "additional_instructions",
            "alternate_order_id",
            "booking_api_trade_allocation_id",
            "booking_api_trade_id",
            "broker",
            "broker_capacity",
            "client_memos",
            "client_order_id",
            "exchange",
            "execution_id",
            "execution_only",
            "external_id",
            "fund_confirmation_number",
            "gateway_client_order_id",
            "internal_error",
            "is_writeoff",
            "lots",
            "order_id",
            "prevailing_market_price",
            "price_adjustment_record",
            "route",
            "special_instructions",
            "symbol_description",
            "when_issued",
            "yield_records",
        ]
        nullable_fields = ["prevailing_market_price", "price_adjustment_record"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class RebookTradeResponseTypedDict(TypedDict):
    r"""A response for the rebook trade method."""

    new_trade: NotRequired[Nullable[NewTradeTypedDict]]
    r"""The new trade that is booked."""
    original_trade: NotRequired[Nullable[OriginalTradeTypedDict]]
    r"""The original trade that was rebooked."""


class RebookTradeResponse(BaseModel):
    r"""A response for the rebook trade method."""

    new_trade: OptionalNullable[NewTrade] = UNSET
    r"""The new trade that is booked."""

    original_trade: OptionalNullable[OriginalTrade] = UNSET
    r"""The original trade that was rebooked."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["new_trade", "original_trade"]
        nullable_fields = ["new_trade", "original_trade"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
