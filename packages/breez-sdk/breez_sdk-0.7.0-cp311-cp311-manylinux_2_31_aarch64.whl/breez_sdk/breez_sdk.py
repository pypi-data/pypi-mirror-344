# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Tell mypy (a type checker) to ignore all errors from this file.
# See https://mypy.readthedocs.io/en/stable/config_file.html?highlight=ignore-errors#confval-ignore_errors
# mypy: ignore-errors

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime

# Used for default argument values
DEFAULT = object()


class RustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return rust_call(_UniFFILib.ffi_breez_sdk_a865_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return rust_call(_UniFFILib.ffi_breez_sdk_a865_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return rust_call(_UniFFILib.ffi_breez_sdk_a865_rustbuffer_free, self)

    def __str__(self):
        return "RustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def allocWithBuilder():
        """Context-manger to allocate a buffer using a RustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = RustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consumeWithStream(self):
        """Context-manager to consume a buffer using a RustBufferStream.

        The RustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = RustBufferStream(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer after consuming")
        finally:
            self.free()


class ForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "ForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class RustBufferStream(object):
    """
    Helper for structured reading of bytes from a RustBuffer
    """

    def __init__(self, rbuf):
        self.rbuf = rbuf
        self.offset = 0

    def remaining(self):
        return self.rbuf.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.rbuf.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.rbuf.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.rbuf.len:
            raise InternalError("read past end of rust buffer")
        data = self.rbuf.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def readI8(self):
        return self._unpack_from(1, ">b")

    def readU8(self):
        return self._unpack_from(1, ">B")

    def readI16(self):
        return self._unpack_from(2, ">h")

    def readU16(self):
        return self._unpack_from(2, ">H")

    def readI32(self):
        return self._unpack_from(4, ">i")

    def readU32(self):
        return self._unpack_from(4, ">I")

    def readI64(self):
        return self._unpack_from(8, ">q")

    def readU64(self):
        return self._unpack_from(8, ">Q")

    def readFloat(self):
        v = self._unpack_from(4, ">f")
        return v

    def readDouble(self):
        return self._unpack_from(8, ">d")


class RustBufferBuilder(object):
    """
    Helper for structured writing of bytes into a RustBuffer.
    """

    def __init__(self):
        self.rbuf = RustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, numBytes):
        if self.rbuf.len + numBytes > self.rbuf.capacity:
            self.rbuf = RustBuffer.reserve(self.rbuf, numBytes)
        yield None
        self.rbuf.len += numBytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def writeI8(self, v):
        self._pack_into(1, ">b", v)

    def writeU8(self, v):
        self._pack_into(1, ">B", v)

    def writeI16(self, v):
        self._pack_into(2, ">h", v)

    def writeU16(self, v):
        self._pack_into(2, ">H", v)

    def writeI32(self, v):
        self._pack_into(4, ">i", v)

    def writeU32(self, v):
        self._pack_into(4, ">I", v)

    def writeI64(self, v):
        self._pack_into(8, ">q", v)

    def writeU64(self, v):
        self._pack_into(8, ">Q", v)

    def writeFloat(self, v):
        self._pack_into(4, ">f", v)

    def writeDouble(self, v):
        self._pack_into(8, ">d", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class RustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", RustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == RustCallStatus.CALL_SUCCESS:
            return "RustCallStatus(CALL_SUCCESS)"
        elif self.code == RustCallStatus.CALL_ERROR:
            return "RustCallStatus(CALL_ERROR)"
        elif self.code == RustCallStatus.CALL_PANIC:
            return "RustCallStatus(CALL_PANIC)"
        else:
            return "RustCallStatus(<invalid code>)"

def rust_call(fn, *args):
    # Call a rust function
    return rust_call_with_error(None, fn, *args)

def rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the FfiConverter for the error class that corresponds to the result.
    call_status = RustCallStatus(code=RustCallStatus.CALL_SUCCESS, error_buf=RustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    if call_status.code == RustCallStatus.CALL_SUCCESS:
        return result
    elif call_status.code == RustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == RustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a RustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = FfiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid RustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: RustBuffer, buf_ptr: *mut RustBuffer) -> int`
FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, RustBuffer, ctypes.POINTER(RustBuffer))
# Types conforming to `FfiConverterPrimitive` pass themselves directly over the FFI.
class FfiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

# Helper class for wrapper types that will always go through a RustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class FfiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consumeWithStream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with RustBuffer.allocWithBuilder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code,
# and the FFI Function declarations in a com.sun.jna.Library.
# This is how we find and load the dynamic library provided by the component.
# For now we just look it up by name.
#
# XXX TODO: This will probably grow some magic for resolving megazording in future.
# E.g. we might start by looking for the named component in `libuniffi.so` and if
# that fails, fall back to loading it separately from `lib${componentName}.so`.

from pathlib import Path

def loadIndirect():
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    lib = libname.format("breez_sdk_bindings")
    path = str(Path(__file__).parent / lib)
    return ctypes.cdll.LoadLibrary(path)

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniFFILib = loadIndirect()
_UniFFILib.ffi_breez_sdk_a865_BlockingBreezServices_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_breez_sdk_a865_BlockingBreezServices_object_free.restype = None
_UniFFILib.breez_sdk_a865_BlockingBreezServices_disconnect.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_disconnect.restype = None
_UniFFILib.breez_sdk_a865_BlockingBreezServices_configure_node.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_configure_node.restype = None
_UniFFILib.breez_sdk_a865_BlockingBreezServices_send_payment.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_send_payment.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_send_spontaneous_payment.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_send_spontaneous_payment.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_receive_payment.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_receive_payment.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_pay_lnurl.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_pay_lnurl.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_withdraw_lnurl.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_withdraw_lnurl.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_lnurl_auth.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_lnurl_auth.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_report_issue.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_report_issue.restype = None
_UniFFILib.breez_sdk_a865_BlockingBreezServices_node_credentials.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_node_credentials.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_node_info.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_node_info.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_sign_message.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_sign_message.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_check_message.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_check_message.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_backup_status.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_backup_status.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_backup.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_backup.restype = None
_UniFFILib.breez_sdk_a865_BlockingBreezServices_list_payments.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_list_payments.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_payment_by_hash.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_payment_by_hash.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_set_payment_metadata.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_set_payment_metadata.restype = None
_UniFFILib.breez_sdk_a865_BlockingBreezServices_redeem_onchain_funds.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_redeem_onchain_funds.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_fetch_fiat_rates.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_fetch_fiat_rates.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_list_fiat_currencies.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_list_fiat_currencies.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_list_lsps.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_list_lsps.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_connect_lsp.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_connect_lsp.restype = None
_UniFFILib.breez_sdk_a865_BlockingBreezServices_fetch_lsp_info.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_fetch_lsp_info.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_open_channel_fee.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_open_channel_fee.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_lsp_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_lsp_id.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_lsp_info.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_lsp_info.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_close_lsp_channels.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_close_lsp_channels.restype = None
_UniFFILib.breez_sdk_a865_BlockingBreezServices_register_webhook.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_register_webhook.restype = None
_UniFFILib.breez_sdk_a865_BlockingBreezServices_unregister_webhook.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_unregister_webhook.restype = None
_UniFFILib.breez_sdk_a865_BlockingBreezServices_receive_onchain.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_receive_onchain.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_in_progress_swap.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_in_progress_swap.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_rescan_swaps.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_rescan_swaps.restype = None
_UniFFILib.breez_sdk_a865_BlockingBreezServices_redeem_swap.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_redeem_swap.restype = None
_UniFFILib.breez_sdk_a865_BlockingBreezServices_list_refundables.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_list_refundables.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_prepare_refund.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_prepare_refund.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_refund.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_refund.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_list_swaps.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_list_swaps.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_fetch_reverse_swap_fees.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_fetch_reverse_swap_fees.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_onchain_payment_limits.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_onchain_payment_limits.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_prepare_onchain_payment.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_prepare_onchain_payment.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_in_progress_onchain_payments.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_in_progress_onchain_payments.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_claim_reverse_swap.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_claim_reverse_swap.restype = None
_UniFFILib.breez_sdk_a865_BlockingBreezServices_pay_onchain.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_pay_onchain.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_execute_dev_command.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_execute_dev_command.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_generate_diagnostic_data.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_generate_diagnostic_data.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_sync.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_sync.restype = None
_UniFFILib.breez_sdk_a865_BlockingBreezServices_recommended_fees.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_recommended_fees.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_buy_bitcoin.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_buy_bitcoin.restype = RustBuffer
_UniFFILib.breez_sdk_a865_BlockingBreezServices_prepare_redeem_onchain_funds.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_BlockingBreezServices_prepare_redeem_onchain_funds.restype = RustBuffer
_UniFFILib.ffi_breez_sdk_a865_LogStream_init_callback.argtypes = (
    FOREIGN_CALLBACK_T,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_breez_sdk_a865_LogStream_init_callback.restype = None
_UniFFILib.ffi_breez_sdk_a865_EventListener_init_callback.argtypes = (
    FOREIGN_CALLBACK_T,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_breez_sdk_a865_EventListener_init_callback.restype = None
_UniFFILib.breez_sdk_a865_connect.argtypes = (
    RustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_connect.restype = ctypes.c_void_p
_UniFFILib.breez_sdk_a865_set_log_stream.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_set_log_stream.restype = None
_UniFFILib.breez_sdk_a865_parse_invoice.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_parse_invoice.restype = RustBuffer
_UniFFILib.breez_sdk_a865_parse_input.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_parse_input.restype = RustBuffer
_UniFFILib.breez_sdk_a865_mnemonic_to_seed.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_mnemonic_to_seed.restype = RustBuffer
_UniFFILib.breez_sdk_a865_default_config.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_default_config.restype = RustBuffer
_UniFFILib.breez_sdk_a865_static_backup.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_static_backup.restype = RustBuffer
_UniFFILib.breez_sdk_a865_service_health_check.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_a865_service_health_check.restype = RustBuffer
_UniFFILib.ffi_breez_sdk_a865_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_breez_sdk_a865_rustbuffer_alloc.restype = RustBuffer
_UniFFILib.ffi_breez_sdk_a865_rustbuffer_from_bytes.argtypes = (
    ForeignBytes,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_breez_sdk_a865_rustbuffer_from_bytes.restype = RustBuffer
_UniFFILib.ffi_breez_sdk_a865_rustbuffer_free.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_breez_sdk_a865_rustbuffer_free.restype = None
_UniFFILib.ffi_breez_sdk_a865_rustbuffer_reserve.argtypes = (
    RustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_breez_sdk_a865_rustbuffer_reserve.restype = RustBuffer

# Public interface members begin here.


class FfiConverterUInt8(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU8()

    @staticmethod
    def write(value, buf):
        buf.writeU8(value)

class FfiConverterUInt16(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU16()

    @staticmethod
    def write(value, buf):
        buf.writeU16(value)

class FfiConverterUInt32(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU32()

    @staticmethod
    def write(value, buf):
        buf.writeU32(value)

class FfiConverterUInt64(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU64()

    @staticmethod
    def write(value, buf):
        buf.writeU64(value)

class FfiConverterInt64(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readI64()

    @staticmethod
    def write(value, buf):
        buf.writeI64(value)

class FfiConverterDouble(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readDouble()

    @staticmethod
    def write(value, buf):
        buf.writeDouble(value)

class FfiConverterBool:
    @classmethod
    def read(cls, buf):
        return cls.lift(buf.readU8())

    @classmethod
    def write(cls, value, buf):
        buf.writeU8(cls.lower(value))

    @staticmethod
    def lift(value):
        return int(value) != 0

    @staticmethod
    def lower(value):
        return 1 if value else 0

class FfiConverterString:
    @staticmethod
    def read(buf):
        size = buf.readI32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8Bytes = buf.read(size)
        return utf8Bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8Bytes = value.encode("utf-8")
        buf.writeI32(len(utf8Bytes))
        buf.write(utf8Bytes)

    @staticmethod
    def lift(buf):
        with buf.consumeWithStream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with RustBuffer.allocWithBuilder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()



class BlockingBreezServices(object):

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_breez_sdk_a865_BlockingBreezServices_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def disconnect(self, ):
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_disconnect,self._pointer,)
    
    def configure_node(self, req):
        req = req
        
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_configure_node,self._pointer,
        FfiConverterTypeConfigureNodeRequest.lower(req))
    
    def send_payment(self, req):
        req = req
        
        return FfiConverterTypeSendPaymentResponse.lift(
            rust_call_with_error(
    FfiConverterTypeSendPaymentError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_send_payment,self._pointer,
        FfiConverterTypeSendPaymentRequest.lower(req))
        )
    def send_spontaneous_payment(self, req):
        req = req
        
        return FfiConverterTypeSendPaymentResponse.lift(
            rust_call_with_error(
    FfiConverterTypeSendPaymentError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_send_spontaneous_payment,self._pointer,
        FfiConverterTypeSendSpontaneousPaymentRequest.lower(req))
        )
    def receive_payment(self, req):
        req = req
        
        return FfiConverterTypeReceivePaymentResponse.lift(
            rust_call_with_error(
    FfiConverterTypeReceivePaymentError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_receive_payment,self._pointer,
        FfiConverterTypeReceivePaymentRequest.lower(req))
        )
    def pay_lnurl(self, req):
        req = req
        
        return FfiConverterTypeLnUrlPayResult.lift(
            rust_call_with_error(
    FfiConverterTypeLnUrlPayError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_pay_lnurl,self._pointer,
        FfiConverterTypeLnUrlPayRequest.lower(req))
        )
    def withdraw_lnurl(self, request):
        request = request
        
        return FfiConverterTypeLnUrlWithdrawResult.lift(
            rust_call_with_error(
    FfiConverterTypeLnUrlWithdrawError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_withdraw_lnurl,self._pointer,
        FfiConverterTypeLnUrlWithdrawRequest.lower(request))
        )
    def lnurl_auth(self, req_data):
        req_data = req_data
        
        return FfiConverterTypeLnUrlCallbackStatus.lift(
            rust_call_with_error(
    FfiConverterTypeLnUrlAuthError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_lnurl_auth,self._pointer,
        FfiConverterTypeLnUrlAuthRequestData.lower(req_data))
        )
    def report_issue(self, req):
        req = req
        
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_report_issue,self._pointer,
        FfiConverterTypeReportIssueRequest.lower(req))
    
    def node_credentials(self, ):
        return FfiConverterOptionalTypeNodeCredentials.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_node_credentials,self._pointer,)
        )
    def node_info(self, ):
        return FfiConverterTypeNodeState.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_node_info,self._pointer,)
        )
    def sign_message(self, req):
        req = req
        
        return FfiConverterTypeSignMessageResponse.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_sign_message,self._pointer,
        FfiConverterTypeSignMessageRequest.lower(req))
        )
    def check_message(self, req):
        req = req
        
        return FfiConverterTypeCheckMessageResponse.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_check_message,self._pointer,
        FfiConverterTypeCheckMessageRequest.lower(req))
        )
    def backup_status(self, ):
        return FfiConverterTypeBackupStatus.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_backup_status,self._pointer,)
        )
    def backup(self, ):
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_backup,self._pointer,)
    
    def list_payments(self, req):
        req = req
        
        return FfiConverterSequenceTypePayment.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_list_payments,self._pointer,
        FfiConverterTypeListPaymentsRequest.lower(req))
        )
    def payment_by_hash(self, hash):
        hash = hash
        
        return FfiConverterOptionalTypePayment.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_payment_by_hash,self._pointer,
        FfiConverterString.lower(hash))
        )
    def set_payment_metadata(self, hash,metadata):
        hash = hash
        
        metadata = metadata
        
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_set_payment_metadata,self._pointer,
        FfiConverterString.lower(hash),
        FfiConverterString.lower(metadata))
    
    def redeem_onchain_funds(self, req):
        req = req
        
        return FfiConverterTypeRedeemOnchainFundsResponse.lift(
            rust_call_with_error(
    FfiConverterTypeRedeemOnchainError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_redeem_onchain_funds,self._pointer,
        FfiConverterTypeRedeemOnchainFundsRequest.lower(req))
        )
    def fetch_fiat_rates(self, ):
        return FfiConverterSequenceTypeRate.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_fetch_fiat_rates,self._pointer,)
        )
    def list_fiat_currencies(self, ):
        return FfiConverterSequenceTypeFiatCurrency.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_list_fiat_currencies,self._pointer,)
        )
    def list_lsps(self, ):
        return FfiConverterSequenceTypeLspInformation.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_list_lsps,self._pointer,)
        )
    def connect_lsp(self, lsp_id):
        lsp_id = lsp_id
        
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_connect_lsp,self._pointer,
        FfiConverterString.lower(lsp_id))
    
    def fetch_lsp_info(self, lsp_id):
        lsp_id = lsp_id
        
        return FfiConverterOptionalTypeLspInformation.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_fetch_lsp_info,self._pointer,
        FfiConverterString.lower(lsp_id))
        )
    def open_channel_fee(self, req):
        req = req
        
        return FfiConverterTypeOpenChannelFeeResponse.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_open_channel_fee,self._pointer,
        FfiConverterTypeOpenChannelFeeRequest.lower(req))
        )
    def lsp_id(self, ):
        return FfiConverterOptionalString.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_lsp_id,self._pointer,)
        )
    def lsp_info(self, ):
        return FfiConverterTypeLspInformation.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_lsp_info,self._pointer,)
        )
    def close_lsp_channels(self, ):
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_close_lsp_channels,self._pointer,)
    
    def register_webhook(self, webhook_url):
        webhook_url = webhook_url
        
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_register_webhook,self._pointer,
        FfiConverterString.lower(webhook_url))
    
    def unregister_webhook(self, webhook_url):
        webhook_url = webhook_url
        
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_unregister_webhook,self._pointer,
        FfiConverterString.lower(webhook_url))
    
    def receive_onchain(self, req):
        req = req
        
        return FfiConverterTypeSwapInfo.lift(
            rust_call_with_error(
    FfiConverterTypeReceiveOnchainError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_receive_onchain,self._pointer,
        FfiConverterTypeReceiveOnchainRequest.lower(req))
        )
    def in_progress_swap(self, ):
        return FfiConverterOptionalTypeSwapInfo.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_in_progress_swap,self._pointer,)
        )
    def rescan_swaps(self, ):
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_rescan_swaps,self._pointer,)
    
    def redeem_swap(self, swap_address):
        swap_address = swap_address
        
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_redeem_swap,self._pointer,
        FfiConverterString.lower(swap_address))
    
    def list_refundables(self, ):
        return FfiConverterSequenceTypeSwapInfo.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_list_refundables,self._pointer,)
        )
    def prepare_refund(self, req):
        req = req
        
        return FfiConverterTypePrepareRefundResponse.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_prepare_refund,self._pointer,
        FfiConverterTypePrepareRefundRequest.lower(req))
        )
    def refund(self, req):
        req = req
        
        return FfiConverterTypeRefundResponse.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_refund,self._pointer,
        FfiConverterTypeRefundRequest.lower(req))
        )
    def list_swaps(self, req):
        req = req
        
        return FfiConverterSequenceTypeSwapInfo.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_list_swaps,self._pointer,
        FfiConverterTypeListSwapsRequest.lower(req))
        )
    def fetch_reverse_swap_fees(self, req):
        req = req
        
        return FfiConverterTypeReverseSwapPairInfo.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_fetch_reverse_swap_fees,self._pointer,
        FfiConverterTypeReverseSwapFeesRequest.lower(req))
        )
    def onchain_payment_limits(self, ):
        return FfiConverterTypeOnchainPaymentLimitsResponse.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_onchain_payment_limits,self._pointer,)
        )
    def prepare_onchain_payment(self, req):
        req = req
        
        return FfiConverterTypePrepareOnchainPaymentResponse.lift(
            rust_call_with_error(
    FfiConverterTypeSendOnchainError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_prepare_onchain_payment,self._pointer,
        FfiConverterTypePrepareOnchainPaymentRequest.lower(req))
        )
    def in_progress_onchain_payments(self, ):
        return FfiConverterSequenceTypeReverseSwapInfo.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_in_progress_onchain_payments,self._pointer,)
        )
    def claim_reverse_swap(self, lockup_address):
        lockup_address = lockup_address
        
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_claim_reverse_swap,self._pointer,
        FfiConverterString.lower(lockup_address))
    
    def pay_onchain(self, req):
        req = req
        
        return FfiConverterTypePayOnchainResponse.lift(
            rust_call_with_error(
    FfiConverterTypeSendOnchainError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_pay_onchain,self._pointer,
        FfiConverterTypePayOnchainRequest.lower(req))
        )
    def execute_dev_command(self, command):
        command = command
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_execute_dev_command,self._pointer,
        FfiConverterString.lower(command))
        )
    def generate_diagnostic_data(self, ):
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_generate_diagnostic_data,self._pointer,)
        )
    def sync(self, ):
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_sync,self._pointer,)
    
    def recommended_fees(self, ):
        return FfiConverterTypeRecommendedFees.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_recommended_fees,self._pointer,)
        )
    def buy_bitcoin(self, req):
        req = req
        
        return FfiConverterTypeBuyBitcoinResponse.lift(
            rust_call_with_error(
    FfiConverterTypeReceiveOnchainError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_buy_bitcoin,self._pointer,
        FfiConverterTypeBuyBitcoinRequest.lower(req))
        )
    def prepare_redeem_onchain_funds(self, req):
        req = req
        
        return FfiConverterTypePrepareRedeemOnchainFundsResponse.lift(
            rust_call_with_error(
    FfiConverterTypeRedeemOnchainError,_UniFFILib.breez_sdk_a865_BlockingBreezServices_prepare_redeem_onchain_funds,self._pointer,
        FfiConverterTypePrepareRedeemOnchainFundsRequest.lower(req))
        )
    


class FfiConverterTypeBlockingBreezServices:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, BlockingBreezServices):
            raise TypeError("Expected BlockingBreezServices instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return BlockingBreezServices._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class AesSuccessActionDataDecrypted:

    def __init__(self, description, plaintext):
        self.description = description
        self.plaintext = plaintext

    def __str__(self):
        return "AesSuccessActionDataDecrypted(description={}, plaintext={})".format(self.description, self.plaintext)

    def __eq__(self, other):
        if self.description != other.description:
            return False
        if self.plaintext != other.plaintext:
            return False
        return True

class FfiConverterTypeAesSuccessActionDataDecrypted(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AesSuccessActionDataDecrypted(
            description=FfiConverterString.read(buf),
            plaintext=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.description, buf)
        FfiConverterString.write(value.plaintext, buf)


class BackupFailedData:

    def __init__(self, error):
        self.error = error

    def __str__(self):
        return "BackupFailedData(error={})".format(self.error)

    def __eq__(self, other):
        if self.error != other.error:
            return False
        return True

class FfiConverterTypeBackupFailedData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BackupFailedData(
            error=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.error, buf)


class BackupStatus:

    def __init__(self, backed_up, last_backup_time):
        self.backed_up = backed_up
        self.last_backup_time = last_backup_time

    def __str__(self):
        return "BackupStatus(backed_up={}, last_backup_time={})".format(self.backed_up, self.last_backup_time)

    def __eq__(self, other):
        if self.backed_up != other.backed_up:
            return False
        if self.last_backup_time != other.last_backup_time:
            return False
        return True

class FfiConverterTypeBackupStatus(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BackupStatus(
            backed_up=FfiConverterBool.read(buf),
            last_backup_time=FfiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterBool.write(value.backed_up, buf)
        FfiConverterOptionalUInt64.write(value.last_backup_time, buf)


class BitcoinAddressData:

    def __init__(self, address, network, amount_sat, label, message):
        self.address = address
        self.network = network
        self.amount_sat = amount_sat
        self.label = label
        self.message = message

    def __str__(self):
        return "BitcoinAddressData(address={}, network={}, amount_sat={}, label={}, message={})".format(self.address, self.network, self.amount_sat, self.label, self.message)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.network != other.network:
            return False
        if self.amount_sat != other.amount_sat:
            return False
        if self.label != other.label:
            return False
        if self.message != other.message:
            return False
        return True

class FfiConverterTypeBitcoinAddressData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BitcoinAddressData(
            address=FfiConverterString.read(buf),
            network=FfiConverterTypeNetwork.read(buf),
            amount_sat=FfiConverterOptionalUInt64.read(buf),
            label=FfiConverterOptionalString.read(buf),
            message=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.address, buf)
        FfiConverterTypeNetwork.write(value.network, buf)
        FfiConverterOptionalUInt64.write(value.amount_sat, buf)
        FfiConverterOptionalString.write(value.label, buf)
        FfiConverterOptionalString.write(value.message, buf)


class BuyBitcoinRequest:

    def __init__(self, provider, opening_fee_params = DEFAULT, redirect_url = DEFAULT):
        self.provider = provider
        if opening_fee_params is DEFAULT:
            self.opening_fee_params = None
        else:
            self.opening_fee_params = opening_fee_params
        if redirect_url is DEFAULT:
            self.redirect_url = None
        else:
            self.redirect_url = redirect_url

    def __str__(self):
        return "BuyBitcoinRequest(provider={}, opening_fee_params={}, redirect_url={})".format(self.provider, self.opening_fee_params, self.redirect_url)

    def __eq__(self, other):
        if self.provider != other.provider:
            return False
        if self.opening_fee_params != other.opening_fee_params:
            return False
        if self.redirect_url != other.redirect_url:
            return False
        return True

class FfiConverterTypeBuyBitcoinRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BuyBitcoinRequest(
            provider=FfiConverterTypeBuyBitcoinProvider.read(buf),
            opening_fee_params=FfiConverterOptionalTypeOpeningFeeParams.read(buf),
            redirect_url=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeBuyBitcoinProvider.write(value.provider, buf)
        FfiConverterOptionalTypeOpeningFeeParams.write(value.opening_fee_params, buf)
        FfiConverterOptionalString.write(value.redirect_url, buf)


class BuyBitcoinResponse:

    def __init__(self, url, opening_fee_params):
        self.url = url
        self.opening_fee_params = opening_fee_params

    def __str__(self):
        return "BuyBitcoinResponse(url={}, opening_fee_params={})".format(self.url, self.opening_fee_params)

    def __eq__(self, other):
        if self.url != other.url:
            return False
        if self.opening_fee_params != other.opening_fee_params:
            return False
        return True

class FfiConverterTypeBuyBitcoinResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BuyBitcoinResponse(
            url=FfiConverterString.read(buf),
            opening_fee_params=FfiConverterOptionalTypeOpeningFeeParams.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.url, buf)
        FfiConverterOptionalTypeOpeningFeeParams.write(value.opening_fee_params, buf)


class CheckMessageRequest:

    def __init__(self, message, pubkey, signature):
        self.message = message
        self.pubkey = pubkey
        self.signature = signature

    def __str__(self):
        return "CheckMessageRequest(message={}, pubkey={}, signature={})".format(self.message, self.pubkey, self.signature)

    def __eq__(self, other):
        if self.message != other.message:
            return False
        if self.pubkey != other.pubkey:
            return False
        if self.signature != other.signature:
            return False
        return True

class FfiConverterTypeCheckMessageRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CheckMessageRequest(
            message=FfiConverterString.read(buf),
            pubkey=FfiConverterString.read(buf),
            signature=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.message, buf)
        FfiConverterString.write(value.pubkey, buf)
        FfiConverterString.write(value.signature, buf)


class CheckMessageResponse:

    def __init__(self, is_valid):
        self.is_valid = is_valid

    def __str__(self):
        return "CheckMessageResponse(is_valid={})".format(self.is_valid)

    def __eq__(self, other):
        if self.is_valid != other.is_valid:
            return False
        return True

class FfiConverterTypeCheckMessageResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CheckMessageResponse(
            is_valid=FfiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterBool.write(value.is_valid, buf)


class ClosedChannelPaymentDetails:

    def __init__(self, state, funding_txid, short_channel_id, closing_txid):
        self.state = state
        self.funding_txid = funding_txid
        self.short_channel_id = short_channel_id
        self.closing_txid = closing_txid

    def __str__(self):
        return "ClosedChannelPaymentDetails(state={}, funding_txid={}, short_channel_id={}, closing_txid={})".format(self.state, self.funding_txid, self.short_channel_id, self.closing_txid)

    def __eq__(self, other):
        if self.state != other.state:
            return False
        if self.funding_txid != other.funding_txid:
            return False
        if self.short_channel_id != other.short_channel_id:
            return False
        if self.closing_txid != other.closing_txid:
            return False
        return True

class FfiConverterTypeClosedChannelPaymentDetails(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ClosedChannelPaymentDetails(
            state=FfiConverterTypeChannelState.read(buf),
            funding_txid=FfiConverterString.read(buf),
            short_channel_id=FfiConverterOptionalString.read(buf),
            closing_txid=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeChannelState.write(value.state, buf)
        FfiConverterString.write(value.funding_txid, buf)
        FfiConverterOptionalString.write(value.short_channel_id, buf)
        FfiConverterOptionalString.write(value.closing_txid, buf)


class Config:

    def __init__(self, breezserver, chainnotifier_url, mempoolspace_url, working_dir, network, payment_timeout_sec, default_lsp_id, api_key, maxfee_percent, exemptfee_msat, node_config):
        self.breezserver = breezserver
        self.chainnotifier_url = chainnotifier_url
        self.mempoolspace_url = mempoolspace_url
        self.working_dir = working_dir
        self.network = network
        self.payment_timeout_sec = payment_timeout_sec
        self.default_lsp_id = default_lsp_id
        self.api_key = api_key
        self.maxfee_percent = maxfee_percent
        self.exemptfee_msat = exemptfee_msat
        self.node_config = node_config

    def __str__(self):
        return "Config(breezserver={}, chainnotifier_url={}, mempoolspace_url={}, working_dir={}, network={}, payment_timeout_sec={}, default_lsp_id={}, api_key={}, maxfee_percent={}, exemptfee_msat={}, node_config={})".format(self.breezserver, self.chainnotifier_url, self.mempoolspace_url, self.working_dir, self.network, self.payment_timeout_sec, self.default_lsp_id, self.api_key, self.maxfee_percent, self.exemptfee_msat, self.node_config)

    def __eq__(self, other):
        if self.breezserver != other.breezserver:
            return False
        if self.chainnotifier_url != other.chainnotifier_url:
            return False
        if self.mempoolspace_url != other.mempoolspace_url:
            return False
        if self.working_dir != other.working_dir:
            return False
        if self.network != other.network:
            return False
        if self.payment_timeout_sec != other.payment_timeout_sec:
            return False
        if self.default_lsp_id != other.default_lsp_id:
            return False
        if self.api_key != other.api_key:
            return False
        if self.maxfee_percent != other.maxfee_percent:
            return False
        if self.exemptfee_msat != other.exemptfee_msat:
            return False
        if self.node_config != other.node_config:
            return False
        return True

class FfiConverterTypeConfig(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Config(
            breezserver=FfiConverterString.read(buf),
            chainnotifier_url=FfiConverterString.read(buf),
            mempoolspace_url=FfiConverterOptionalString.read(buf),
            working_dir=FfiConverterString.read(buf),
            network=FfiConverterTypeNetwork.read(buf),
            payment_timeout_sec=FfiConverterUInt32.read(buf),
            default_lsp_id=FfiConverterOptionalString.read(buf),
            api_key=FfiConverterOptionalString.read(buf),
            maxfee_percent=FfiConverterDouble.read(buf),
            exemptfee_msat=FfiConverterUInt64.read(buf),
            node_config=FfiConverterTypeNodeConfig.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.breezserver, buf)
        FfiConverterString.write(value.chainnotifier_url, buf)
        FfiConverterOptionalString.write(value.mempoolspace_url, buf)
        FfiConverterString.write(value.working_dir, buf)
        FfiConverterTypeNetwork.write(value.network, buf)
        FfiConverterUInt32.write(value.payment_timeout_sec, buf)
        FfiConverterOptionalString.write(value.default_lsp_id, buf)
        FfiConverterOptionalString.write(value.api_key, buf)
        FfiConverterDouble.write(value.maxfee_percent, buf)
        FfiConverterUInt64.write(value.exemptfee_msat, buf)
        FfiConverterTypeNodeConfig.write(value.node_config, buf)


class ConfigureNodeRequest:

    def __init__(self, close_to_address):
        self.close_to_address = close_to_address

    def __str__(self):
        return "ConfigureNodeRequest(close_to_address={})".format(self.close_to_address)

    def __eq__(self, other):
        if self.close_to_address != other.close_to_address:
            return False
        return True

class FfiConverterTypeConfigureNodeRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ConfigureNodeRequest(
            close_to_address=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalString.write(value.close_to_address, buf)


class ConnectRequest:

    def __init__(self, config, seed, restore_only = DEFAULT):
        self.config = config
        self.seed = seed
        if restore_only is DEFAULT:
            self.restore_only = None
        else:
            self.restore_only = restore_only

    def __str__(self):
        return "ConnectRequest(config={}, seed={}, restore_only={})".format(self.config, self.seed, self.restore_only)

    def __eq__(self, other):
        if self.config != other.config:
            return False
        if self.seed != other.seed:
            return False
        if self.restore_only != other.restore_only:
            return False
        return True

class FfiConverterTypeConnectRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ConnectRequest(
            config=FfiConverterTypeConfig.read(buf),
            seed=FfiConverterSequenceUInt8.read(buf),
            restore_only=FfiConverterOptionalBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeConfig.write(value.config, buf)
        FfiConverterSequenceUInt8.write(value.seed, buf)
        FfiConverterOptionalBool.write(value.restore_only, buf)


class CurrencyInfo:

    def __init__(self, name, fraction_size, spacing, symbol, uniq_symbol, localized_name, locale_overrides):
        self.name = name
        self.fraction_size = fraction_size
        self.spacing = spacing
        self.symbol = symbol
        self.uniq_symbol = uniq_symbol
        self.localized_name = localized_name
        self.locale_overrides = locale_overrides

    def __str__(self):
        return "CurrencyInfo(name={}, fraction_size={}, spacing={}, symbol={}, uniq_symbol={}, localized_name={}, locale_overrides={})".format(self.name, self.fraction_size, self.spacing, self.symbol, self.uniq_symbol, self.localized_name, self.locale_overrides)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.fraction_size != other.fraction_size:
            return False
        if self.spacing != other.spacing:
            return False
        if self.symbol != other.symbol:
            return False
        if self.uniq_symbol != other.uniq_symbol:
            return False
        if self.localized_name != other.localized_name:
            return False
        if self.locale_overrides != other.locale_overrides:
            return False
        return True

class FfiConverterTypeCurrencyInfo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CurrencyInfo(
            name=FfiConverterString.read(buf),
            fraction_size=FfiConverterUInt32.read(buf),
            spacing=FfiConverterOptionalUInt32.read(buf),
            symbol=FfiConverterOptionalTypeSymbol.read(buf),
            uniq_symbol=FfiConverterOptionalTypeSymbol.read(buf),
            localized_name=FfiConverterSequenceTypeLocalizedName.read(buf),
            locale_overrides=FfiConverterSequenceTypeLocaleOverrides.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.name, buf)
        FfiConverterUInt32.write(value.fraction_size, buf)
        FfiConverterOptionalUInt32.write(value.spacing, buf)
        FfiConverterOptionalTypeSymbol.write(value.symbol, buf)
        FfiConverterOptionalTypeSymbol.write(value.uniq_symbol, buf)
        FfiConverterSequenceTypeLocalizedName.write(value.localized_name, buf)
        FfiConverterSequenceTypeLocaleOverrides.write(value.locale_overrides, buf)


class FiatCurrency:

    def __init__(self, id, info):
        self.id = id
        self.info = info

    def __str__(self):
        return "FiatCurrency(id={}, info={})".format(self.id, self.info)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.info != other.info:
            return False
        return True

class FfiConverterTypeFiatCurrency(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FiatCurrency(
            id=FfiConverterString.read(buf),
            info=FfiConverterTypeCurrencyInfo.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.id, buf)
        FfiConverterTypeCurrencyInfo.write(value.info, buf)


class GreenlightCredentials:

    def __init__(self, developer_key, developer_cert):
        self.developer_key = developer_key
        self.developer_cert = developer_cert

    def __str__(self):
        return "GreenlightCredentials(developer_key={}, developer_cert={})".format(self.developer_key, self.developer_cert)

    def __eq__(self, other):
        if self.developer_key != other.developer_key:
            return False
        if self.developer_cert != other.developer_cert:
            return False
        return True

class FfiConverterTypeGreenlightCredentials(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GreenlightCredentials(
            developer_key=FfiConverterSequenceUInt8.read(buf),
            developer_cert=FfiConverterSequenceUInt8.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterSequenceUInt8.write(value.developer_key, buf)
        FfiConverterSequenceUInt8.write(value.developer_cert, buf)


class GreenlightDeviceCredentials:

    def __init__(self, device):
        self.device = device

    def __str__(self):
        return "GreenlightDeviceCredentials(device={})".format(self.device)

    def __eq__(self, other):
        if self.device != other.device:
            return False
        return True

class FfiConverterTypeGreenlightDeviceCredentials(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GreenlightDeviceCredentials(
            device=FfiConverterSequenceUInt8.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterSequenceUInt8.write(value.device, buf)


class GreenlightNodeConfig:

    def __init__(self, partner_credentials, invite_code):
        self.partner_credentials = partner_credentials
        self.invite_code = invite_code

    def __str__(self):
        return "GreenlightNodeConfig(partner_credentials={}, invite_code={})".format(self.partner_credentials, self.invite_code)

    def __eq__(self, other):
        if self.partner_credentials != other.partner_credentials:
            return False
        if self.invite_code != other.invite_code:
            return False
        return True

class FfiConverterTypeGreenlightNodeConfig(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GreenlightNodeConfig(
            partner_credentials=FfiConverterOptionalTypeGreenlightCredentials.read(buf),
            invite_code=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalTypeGreenlightCredentials.write(value.partner_credentials, buf)
        FfiConverterOptionalString.write(value.invite_code, buf)


class InvoicePaidDetails:

    def __init__(self, payment_hash, bolt11, payment):
        self.payment_hash = payment_hash
        self.bolt11 = bolt11
        self.payment = payment

    def __str__(self):
        return "InvoicePaidDetails(payment_hash={}, bolt11={}, payment={})".format(self.payment_hash, self.bolt11, self.payment)

    def __eq__(self, other):
        if self.payment_hash != other.payment_hash:
            return False
        if self.bolt11 != other.bolt11:
            return False
        if self.payment != other.payment:
            return False
        return True

class FfiConverterTypeInvoicePaidDetails(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return InvoicePaidDetails(
            payment_hash=FfiConverterString.read(buf),
            bolt11=FfiConverterString.read(buf),
            payment=FfiConverterOptionalTypePayment.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.payment_hash, buf)
        FfiConverterString.write(value.bolt11, buf)
        FfiConverterOptionalTypePayment.write(value.payment, buf)


class LnInvoice:

    def __init__(self, bolt11, network, payee_pubkey, payment_hash, description, description_hash, amount_msat, timestamp, expiry, routing_hints, payment_secret, min_final_cltv_expiry_delta):
        self.bolt11 = bolt11
        self.network = network
        self.payee_pubkey = payee_pubkey
        self.payment_hash = payment_hash
        self.description = description
        self.description_hash = description_hash
        self.amount_msat = amount_msat
        self.timestamp = timestamp
        self.expiry = expiry
        self.routing_hints = routing_hints
        self.payment_secret = payment_secret
        self.min_final_cltv_expiry_delta = min_final_cltv_expiry_delta

    def __str__(self):
        return "LnInvoice(bolt11={}, network={}, payee_pubkey={}, payment_hash={}, description={}, description_hash={}, amount_msat={}, timestamp={}, expiry={}, routing_hints={}, payment_secret={}, min_final_cltv_expiry_delta={})".format(self.bolt11, self.network, self.payee_pubkey, self.payment_hash, self.description, self.description_hash, self.amount_msat, self.timestamp, self.expiry, self.routing_hints, self.payment_secret, self.min_final_cltv_expiry_delta)

    def __eq__(self, other):
        if self.bolt11 != other.bolt11:
            return False
        if self.network != other.network:
            return False
        if self.payee_pubkey != other.payee_pubkey:
            return False
        if self.payment_hash != other.payment_hash:
            return False
        if self.description != other.description:
            return False
        if self.description_hash != other.description_hash:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.timestamp != other.timestamp:
            return False
        if self.expiry != other.expiry:
            return False
        if self.routing_hints != other.routing_hints:
            return False
        if self.payment_secret != other.payment_secret:
            return False
        if self.min_final_cltv_expiry_delta != other.min_final_cltv_expiry_delta:
            return False
        return True

class FfiConverterTypeLnInvoice(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnInvoice(
            bolt11=FfiConverterString.read(buf),
            network=FfiConverterTypeNetwork.read(buf),
            payee_pubkey=FfiConverterString.read(buf),
            payment_hash=FfiConverterString.read(buf),
            description=FfiConverterOptionalString.read(buf),
            description_hash=FfiConverterOptionalString.read(buf),
            amount_msat=FfiConverterOptionalUInt64.read(buf),
            timestamp=FfiConverterUInt64.read(buf),
            expiry=FfiConverterUInt64.read(buf),
            routing_hints=FfiConverterSequenceTypeRouteHint.read(buf),
            payment_secret=FfiConverterSequenceUInt8.read(buf),
            min_final_cltv_expiry_delta=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.bolt11, buf)
        FfiConverterTypeNetwork.write(value.network, buf)
        FfiConverterString.write(value.payee_pubkey, buf)
        FfiConverterString.write(value.payment_hash, buf)
        FfiConverterOptionalString.write(value.description, buf)
        FfiConverterOptionalString.write(value.description_hash, buf)
        FfiConverterOptionalUInt64.write(value.amount_msat, buf)
        FfiConverterUInt64.write(value.timestamp, buf)
        FfiConverterUInt64.write(value.expiry, buf)
        FfiConverterSequenceTypeRouteHint.write(value.routing_hints, buf)
        FfiConverterSequenceUInt8.write(value.payment_secret, buf)
        FfiConverterUInt64.write(value.min_final_cltv_expiry_delta, buf)


class ListPaymentsRequest:

    def __init__(self, filters = DEFAULT, metadata_filters = DEFAULT, from_timestamp = DEFAULT, to_timestamp = DEFAULT, include_failures = DEFAULT, offset = DEFAULT, limit = DEFAULT):
        if filters is DEFAULT:
            self.filters = None
        else:
            self.filters = filters
        if metadata_filters is DEFAULT:
            self.metadata_filters = None
        else:
            self.metadata_filters = metadata_filters
        if from_timestamp is DEFAULT:
            self.from_timestamp = None
        else:
            self.from_timestamp = from_timestamp
        if to_timestamp is DEFAULT:
            self.to_timestamp = None
        else:
            self.to_timestamp = to_timestamp
        if include_failures is DEFAULT:
            self.include_failures = None
        else:
            self.include_failures = include_failures
        if offset is DEFAULT:
            self.offset = None
        else:
            self.offset = offset
        if limit is DEFAULT:
            self.limit = None
        else:
            self.limit = limit

    def __str__(self):
        return "ListPaymentsRequest(filters={}, metadata_filters={}, from_timestamp={}, to_timestamp={}, include_failures={}, offset={}, limit={})".format(self.filters, self.metadata_filters, self.from_timestamp, self.to_timestamp, self.include_failures, self.offset, self.limit)

    def __eq__(self, other):
        if self.filters != other.filters:
            return False
        if self.metadata_filters != other.metadata_filters:
            return False
        if self.from_timestamp != other.from_timestamp:
            return False
        if self.to_timestamp != other.to_timestamp:
            return False
        if self.include_failures != other.include_failures:
            return False
        if self.offset != other.offset:
            return False
        if self.limit != other.limit:
            return False
        return True

class FfiConverterTypeListPaymentsRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListPaymentsRequest(
            filters=FfiConverterOptionalSequenceTypePaymentTypeFilter.read(buf),
            metadata_filters=FfiConverterOptionalSequenceTypeMetadataFilter.read(buf),
            from_timestamp=FfiConverterOptionalInt64.read(buf),
            to_timestamp=FfiConverterOptionalInt64.read(buf),
            include_failures=FfiConverterOptionalBool.read(buf),
            offset=FfiConverterOptionalUInt32.read(buf),
            limit=FfiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalSequenceTypePaymentTypeFilter.write(value.filters, buf)
        FfiConverterOptionalSequenceTypeMetadataFilter.write(value.metadata_filters, buf)
        FfiConverterOptionalInt64.write(value.from_timestamp, buf)
        FfiConverterOptionalInt64.write(value.to_timestamp, buf)
        FfiConverterOptionalBool.write(value.include_failures, buf)
        FfiConverterOptionalUInt32.write(value.offset, buf)
        FfiConverterOptionalUInt32.write(value.limit, buf)


class ListSwapsRequest:

    def __init__(self, status = DEFAULT, from_timestamp = DEFAULT, to_timestamp = DEFAULT, offset = DEFAULT, limit = DEFAULT):
        if status is DEFAULT:
            self.status = None
        else:
            self.status = status
        if from_timestamp is DEFAULT:
            self.from_timestamp = None
        else:
            self.from_timestamp = from_timestamp
        if to_timestamp is DEFAULT:
            self.to_timestamp = None
        else:
            self.to_timestamp = to_timestamp
        if offset is DEFAULT:
            self.offset = None
        else:
            self.offset = offset
        if limit is DEFAULT:
            self.limit = None
        else:
            self.limit = limit

    def __str__(self):
        return "ListSwapsRequest(status={}, from_timestamp={}, to_timestamp={}, offset={}, limit={})".format(self.status, self.from_timestamp, self.to_timestamp, self.offset, self.limit)

    def __eq__(self, other):
        if self.status != other.status:
            return False
        if self.from_timestamp != other.from_timestamp:
            return False
        if self.to_timestamp != other.to_timestamp:
            return False
        if self.offset != other.offset:
            return False
        if self.limit != other.limit:
            return False
        return True

class FfiConverterTypeListSwapsRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListSwapsRequest(
            status=FfiConverterOptionalSequenceTypeSwapStatus.read(buf),
            from_timestamp=FfiConverterOptionalInt64.read(buf),
            to_timestamp=FfiConverterOptionalInt64.read(buf),
            offset=FfiConverterOptionalUInt32.read(buf),
            limit=FfiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalSequenceTypeSwapStatus.write(value.status, buf)
        FfiConverterOptionalInt64.write(value.from_timestamp, buf)
        FfiConverterOptionalInt64.write(value.to_timestamp, buf)
        FfiConverterOptionalUInt32.write(value.offset, buf)
        FfiConverterOptionalUInt32.write(value.limit, buf)


class LnPaymentDetails:

    def __init__(self, payment_hash, label, destination_pubkey, payment_preimage, keysend, bolt11, open_channel_bolt11, lnurl_success_action, lnurl_pay_domain, lnurl_pay_comment, lnurl_metadata, ln_address, lnurl_withdraw_endpoint, swap_info, reverse_swap_info, pending_expiration_block):
        self.payment_hash = payment_hash
        self.label = label
        self.destination_pubkey = destination_pubkey
        self.payment_preimage = payment_preimage
        self.keysend = keysend
        self.bolt11 = bolt11
        self.open_channel_bolt11 = open_channel_bolt11
        self.lnurl_success_action = lnurl_success_action
        self.lnurl_pay_domain = lnurl_pay_domain
        self.lnurl_pay_comment = lnurl_pay_comment
        self.lnurl_metadata = lnurl_metadata
        self.ln_address = ln_address
        self.lnurl_withdraw_endpoint = lnurl_withdraw_endpoint
        self.swap_info = swap_info
        self.reverse_swap_info = reverse_swap_info
        self.pending_expiration_block = pending_expiration_block

    def __str__(self):
        return "LnPaymentDetails(payment_hash={}, label={}, destination_pubkey={}, payment_preimage={}, keysend={}, bolt11={}, open_channel_bolt11={}, lnurl_success_action={}, lnurl_pay_domain={}, lnurl_pay_comment={}, lnurl_metadata={}, ln_address={}, lnurl_withdraw_endpoint={}, swap_info={}, reverse_swap_info={}, pending_expiration_block={})".format(self.payment_hash, self.label, self.destination_pubkey, self.payment_preimage, self.keysend, self.bolt11, self.open_channel_bolt11, self.lnurl_success_action, self.lnurl_pay_domain, self.lnurl_pay_comment, self.lnurl_metadata, self.ln_address, self.lnurl_withdraw_endpoint, self.swap_info, self.reverse_swap_info, self.pending_expiration_block)

    def __eq__(self, other):
        if self.payment_hash != other.payment_hash:
            return False
        if self.label != other.label:
            return False
        if self.destination_pubkey != other.destination_pubkey:
            return False
        if self.payment_preimage != other.payment_preimage:
            return False
        if self.keysend != other.keysend:
            return False
        if self.bolt11 != other.bolt11:
            return False
        if self.open_channel_bolt11 != other.open_channel_bolt11:
            return False
        if self.lnurl_success_action != other.lnurl_success_action:
            return False
        if self.lnurl_pay_domain != other.lnurl_pay_domain:
            return False
        if self.lnurl_pay_comment != other.lnurl_pay_comment:
            return False
        if self.lnurl_metadata != other.lnurl_metadata:
            return False
        if self.ln_address != other.ln_address:
            return False
        if self.lnurl_withdraw_endpoint != other.lnurl_withdraw_endpoint:
            return False
        if self.swap_info != other.swap_info:
            return False
        if self.reverse_swap_info != other.reverse_swap_info:
            return False
        if self.pending_expiration_block != other.pending_expiration_block:
            return False
        return True

class FfiConverterTypeLnPaymentDetails(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnPaymentDetails(
            payment_hash=FfiConverterString.read(buf),
            label=FfiConverterString.read(buf),
            destination_pubkey=FfiConverterString.read(buf),
            payment_preimage=FfiConverterString.read(buf),
            keysend=FfiConverterBool.read(buf),
            bolt11=FfiConverterString.read(buf),
            open_channel_bolt11=FfiConverterOptionalString.read(buf),
            lnurl_success_action=FfiConverterOptionalTypeSuccessActionProcessed.read(buf),
            lnurl_pay_domain=FfiConverterOptionalString.read(buf),
            lnurl_pay_comment=FfiConverterOptionalString.read(buf),
            lnurl_metadata=FfiConverterOptionalString.read(buf),
            ln_address=FfiConverterOptionalString.read(buf),
            lnurl_withdraw_endpoint=FfiConverterOptionalString.read(buf),
            swap_info=FfiConverterOptionalTypeSwapInfo.read(buf),
            reverse_swap_info=FfiConverterOptionalTypeReverseSwapInfo.read(buf),
            pending_expiration_block=FfiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.payment_hash, buf)
        FfiConverterString.write(value.label, buf)
        FfiConverterString.write(value.destination_pubkey, buf)
        FfiConverterString.write(value.payment_preimage, buf)
        FfiConverterBool.write(value.keysend, buf)
        FfiConverterString.write(value.bolt11, buf)
        FfiConverterOptionalString.write(value.open_channel_bolt11, buf)
        FfiConverterOptionalTypeSuccessActionProcessed.write(value.lnurl_success_action, buf)
        FfiConverterOptionalString.write(value.lnurl_pay_domain, buf)
        FfiConverterOptionalString.write(value.lnurl_pay_comment, buf)
        FfiConverterOptionalString.write(value.lnurl_metadata, buf)
        FfiConverterOptionalString.write(value.ln_address, buf)
        FfiConverterOptionalString.write(value.lnurl_withdraw_endpoint, buf)
        FfiConverterOptionalTypeSwapInfo.write(value.swap_info, buf)
        FfiConverterOptionalTypeReverseSwapInfo.write(value.reverse_swap_info, buf)
        FfiConverterOptionalUInt32.write(value.pending_expiration_block, buf)


class LnUrlAuthRequestData:

    def __init__(self, k1, domain, url, action = DEFAULT):
        self.k1 = k1
        self.domain = domain
        self.url = url
        if action is DEFAULT:
            self.action = None
        else:
            self.action = action

    def __str__(self):
        return "LnUrlAuthRequestData(k1={}, domain={}, url={}, action={})".format(self.k1, self.domain, self.url, self.action)

    def __eq__(self, other):
        if self.k1 != other.k1:
            return False
        if self.domain != other.domain:
            return False
        if self.url != other.url:
            return False
        if self.action != other.action:
            return False
        return True

class FfiConverterTypeLnUrlAuthRequestData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlAuthRequestData(
            k1=FfiConverterString.read(buf),
            domain=FfiConverterString.read(buf),
            url=FfiConverterString.read(buf),
            action=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.k1, buf)
        FfiConverterString.write(value.domain, buf)
        FfiConverterString.write(value.url, buf)
        FfiConverterOptionalString.write(value.action, buf)


class LnUrlErrorData:

    def __init__(self, reason):
        self.reason = reason

    def __str__(self):
        return "LnUrlErrorData(reason={})".format(self.reason)

    def __eq__(self, other):
        if self.reason != other.reason:
            return False
        return True

class FfiConverterTypeLnUrlErrorData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlErrorData(
            reason=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.reason, buf)


class LnUrlPayErrorData:

    def __init__(self, payment_hash, reason):
        self.payment_hash = payment_hash
        self.reason = reason

    def __str__(self):
        return "LnUrlPayErrorData(payment_hash={}, reason={})".format(self.payment_hash, self.reason)

    def __eq__(self, other):
        if self.payment_hash != other.payment_hash:
            return False
        if self.reason != other.reason:
            return False
        return True

class FfiConverterTypeLnUrlPayErrorData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlPayErrorData(
            payment_hash=FfiConverterString.read(buf),
            reason=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.payment_hash, buf)
        FfiConverterString.write(value.reason, buf)


class LnUrlPayRequest:

    def __init__(self, data, amount_msat, use_trampoline, comment = DEFAULT, payment_label = DEFAULT, validate_success_action_url = DEFAULT):
        self.data = data
        self.amount_msat = amount_msat
        self.use_trampoline = use_trampoline
        if comment is DEFAULT:
            self.comment = None
        else:
            self.comment = comment
        if payment_label is DEFAULT:
            self.payment_label = None
        else:
            self.payment_label = payment_label
        if validate_success_action_url is DEFAULT:
            self.validate_success_action_url = None
        else:
            self.validate_success_action_url = validate_success_action_url

    def __str__(self):
        return "LnUrlPayRequest(data={}, amount_msat={}, use_trampoline={}, comment={}, payment_label={}, validate_success_action_url={})".format(self.data, self.amount_msat, self.use_trampoline, self.comment, self.payment_label, self.validate_success_action_url)

    def __eq__(self, other):
        if self.data != other.data:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.use_trampoline != other.use_trampoline:
            return False
        if self.comment != other.comment:
            return False
        if self.payment_label != other.payment_label:
            return False
        if self.validate_success_action_url != other.validate_success_action_url:
            return False
        return True

class FfiConverterTypeLnUrlPayRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlPayRequest(
            data=FfiConverterTypeLnUrlPayRequestData.read(buf),
            amount_msat=FfiConverterUInt64.read(buf),
            use_trampoline=FfiConverterBool.read(buf),
            comment=FfiConverterOptionalString.read(buf),
            payment_label=FfiConverterOptionalString.read(buf),
            validate_success_action_url=FfiConverterOptionalBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeLnUrlPayRequestData.write(value.data, buf)
        FfiConverterUInt64.write(value.amount_msat, buf)
        FfiConverterBool.write(value.use_trampoline, buf)
        FfiConverterOptionalString.write(value.comment, buf)
        FfiConverterOptionalString.write(value.payment_label, buf)
        FfiConverterOptionalBool.write(value.validate_success_action_url, buf)


class LnUrlPayRequestData:

    def __init__(self, callback, min_sendable, max_sendable, metadata_str, comment_allowed, domain, allows_nostr, nostr_pubkey, ln_address):
        self.callback = callback
        self.min_sendable = min_sendable
        self.max_sendable = max_sendable
        self.metadata_str = metadata_str
        self.comment_allowed = comment_allowed
        self.domain = domain
        self.allows_nostr = allows_nostr
        self.nostr_pubkey = nostr_pubkey
        self.ln_address = ln_address

    def __str__(self):
        return "LnUrlPayRequestData(callback={}, min_sendable={}, max_sendable={}, metadata_str={}, comment_allowed={}, domain={}, allows_nostr={}, nostr_pubkey={}, ln_address={})".format(self.callback, self.min_sendable, self.max_sendable, self.metadata_str, self.comment_allowed, self.domain, self.allows_nostr, self.nostr_pubkey, self.ln_address)

    def __eq__(self, other):
        if self.callback != other.callback:
            return False
        if self.min_sendable != other.min_sendable:
            return False
        if self.max_sendable != other.max_sendable:
            return False
        if self.metadata_str != other.metadata_str:
            return False
        if self.comment_allowed != other.comment_allowed:
            return False
        if self.domain != other.domain:
            return False
        if self.allows_nostr != other.allows_nostr:
            return False
        if self.nostr_pubkey != other.nostr_pubkey:
            return False
        if self.ln_address != other.ln_address:
            return False
        return True

class FfiConverterTypeLnUrlPayRequestData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlPayRequestData(
            callback=FfiConverterString.read(buf),
            min_sendable=FfiConverterUInt64.read(buf),
            max_sendable=FfiConverterUInt64.read(buf),
            metadata_str=FfiConverterString.read(buf),
            comment_allowed=FfiConverterUInt16.read(buf),
            domain=FfiConverterString.read(buf),
            allows_nostr=FfiConverterBool.read(buf),
            nostr_pubkey=FfiConverterOptionalString.read(buf),
            ln_address=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.callback, buf)
        FfiConverterUInt64.write(value.min_sendable, buf)
        FfiConverterUInt64.write(value.max_sendable, buf)
        FfiConverterString.write(value.metadata_str, buf)
        FfiConverterUInt16.write(value.comment_allowed, buf)
        FfiConverterString.write(value.domain, buf)
        FfiConverterBool.write(value.allows_nostr, buf)
        FfiConverterOptionalString.write(value.nostr_pubkey, buf)
        FfiConverterOptionalString.write(value.ln_address, buf)


class LnUrlPaySuccessData:

    def __init__(self, success_action, payment):
        self.success_action = success_action
        self.payment = payment

    def __str__(self):
        return "LnUrlPaySuccessData(success_action={}, payment={})".format(self.success_action, self.payment)

    def __eq__(self, other):
        if self.success_action != other.success_action:
            return False
        if self.payment != other.payment:
            return False
        return True

class FfiConverterTypeLnUrlPaySuccessData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlPaySuccessData(
            success_action=FfiConverterOptionalTypeSuccessActionProcessed.read(buf),
            payment=FfiConverterTypePayment.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalTypeSuccessActionProcessed.write(value.success_action, buf)
        FfiConverterTypePayment.write(value.payment, buf)


class LnUrlWithdrawRequest:

    def __init__(self, data, amount_msat, description = DEFAULT):
        self.data = data
        self.amount_msat = amount_msat
        if description is DEFAULT:
            self.description = None
        else:
            self.description = description

    def __str__(self):
        return "LnUrlWithdrawRequest(data={}, amount_msat={}, description={})".format(self.data, self.amount_msat, self.description)

    def __eq__(self, other):
        if self.data != other.data:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.description != other.description:
            return False
        return True

class FfiConverterTypeLnUrlWithdrawRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlWithdrawRequest(
            data=FfiConverterTypeLnUrlWithdrawRequestData.read(buf),
            amount_msat=FfiConverterUInt64.read(buf),
            description=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeLnUrlWithdrawRequestData.write(value.data, buf)
        FfiConverterUInt64.write(value.amount_msat, buf)
        FfiConverterOptionalString.write(value.description, buf)


class LnUrlWithdrawRequestData:

    def __init__(self, callback, k1, default_description, min_withdrawable, max_withdrawable):
        self.callback = callback
        self.k1 = k1
        self.default_description = default_description
        self.min_withdrawable = min_withdrawable
        self.max_withdrawable = max_withdrawable

    def __str__(self):
        return "LnUrlWithdrawRequestData(callback={}, k1={}, default_description={}, min_withdrawable={}, max_withdrawable={})".format(self.callback, self.k1, self.default_description, self.min_withdrawable, self.max_withdrawable)

    def __eq__(self, other):
        if self.callback != other.callback:
            return False
        if self.k1 != other.k1:
            return False
        if self.default_description != other.default_description:
            return False
        if self.min_withdrawable != other.min_withdrawable:
            return False
        if self.max_withdrawable != other.max_withdrawable:
            return False
        return True

class FfiConverterTypeLnUrlWithdrawRequestData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlWithdrawRequestData(
            callback=FfiConverterString.read(buf),
            k1=FfiConverterString.read(buf),
            default_description=FfiConverterString.read(buf),
            min_withdrawable=FfiConverterUInt64.read(buf),
            max_withdrawable=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.callback, buf)
        FfiConverterString.write(value.k1, buf)
        FfiConverterString.write(value.default_description, buf)
        FfiConverterUInt64.write(value.min_withdrawable, buf)
        FfiConverterUInt64.write(value.max_withdrawable, buf)


class LnUrlWithdrawSuccessData:

    def __init__(self, invoice):
        self.invoice = invoice

    def __str__(self):
        return "LnUrlWithdrawSuccessData(invoice={})".format(self.invoice)

    def __eq__(self, other):
        if self.invoice != other.invoice:
            return False
        return True

class FfiConverterTypeLnUrlWithdrawSuccessData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlWithdrawSuccessData(
            invoice=FfiConverterTypeLnInvoice.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeLnInvoice.write(value.invoice, buf)


class LocaleOverrides:

    def __init__(self, locale, spacing, symbol):
        self.locale = locale
        self.spacing = spacing
        self.symbol = symbol

    def __str__(self):
        return "LocaleOverrides(locale={}, spacing={}, symbol={})".format(self.locale, self.spacing, self.symbol)

    def __eq__(self, other):
        if self.locale != other.locale:
            return False
        if self.spacing != other.spacing:
            return False
        if self.symbol != other.symbol:
            return False
        return True

class FfiConverterTypeLocaleOverrides(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LocaleOverrides(
            locale=FfiConverterString.read(buf),
            spacing=FfiConverterOptionalUInt32.read(buf),
            symbol=FfiConverterTypeSymbol.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.locale, buf)
        FfiConverterOptionalUInt32.write(value.spacing, buf)
        FfiConverterTypeSymbol.write(value.symbol, buf)


class LocalizedName:

    def __init__(self, locale, name):
        self.locale = locale
        self.name = name

    def __str__(self):
        return "LocalizedName(locale={}, name={})".format(self.locale, self.name)

    def __eq__(self, other):
        if self.locale != other.locale:
            return False
        if self.name != other.name:
            return False
        return True

class FfiConverterTypeLocalizedName(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LocalizedName(
            locale=FfiConverterString.read(buf),
            name=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.locale, buf)
        FfiConverterString.write(value.name, buf)


class LogEntry:

    def __init__(self, line, level):
        self.line = line
        self.level = level

    def __str__(self):
        return "LogEntry(line={}, level={})".format(self.line, self.level)

    def __eq__(self, other):
        if self.line != other.line:
            return False
        if self.level != other.level:
            return False
        return True

class FfiConverterTypeLogEntry(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LogEntry(
            line=FfiConverterString.read(buf),
            level=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.line, buf)
        FfiConverterString.write(value.level, buf)


class LspInformation:

    def __init__(self, id, name, widget_url, pubkey, host, base_fee_msat, fee_rate, time_lock_delta, min_htlc_msat, lsp_pubkey, opening_fee_params_list):
        self.id = id
        self.name = name
        self.widget_url = widget_url
        self.pubkey = pubkey
        self.host = host
        self.base_fee_msat = base_fee_msat
        self.fee_rate = fee_rate
        self.time_lock_delta = time_lock_delta
        self.min_htlc_msat = min_htlc_msat
        self.lsp_pubkey = lsp_pubkey
        self.opening_fee_params_list = opening_fee_params_list

    def __str__(self):
        return "LspInformation(id={}, name={}, widget_url={}, pubkey={}, host={}, base_fee_msat={}, fee_rate={}, time_lock_delta={}, min_htlc_msat={}, lsp_pubkey={}, opening_fee_params_list={})".format(self.id, self.name, self.widget_url, self.pubkey, self.host, self.base_fee_msat, self.fee_rate, self.time_lock_delta, self.min_htlc_msat, self.lsp_pubkey, self.opening_fee_params_list)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.name != other.name:
            return False
        if self.widget_url != other.widget_url:
            return False
        if self.pubkey != other.pubkey:
            return False
        if self.host != other.host:
            return False
        if self.base_fee_msat != other.base_fee_msat:
            return False
        if self.fee_rate != other.fee_rate:
            return False
        if self.time_lock_delta != other.time_lock_delta:
            return False
        if self.min_htlc_msat != other.min_htlc_msat:
            return False
        if self.lsp_pubkey != other.lsp_pubkey:
            return False
        if self.opening_fee_params_list != other.opening_fee_params_list:
            return False
        return True

class FfiConverterTypeLspInformation(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LspInformation(
            id=FfiConverterString.read(buf),
            name=FfiConverterString.read(buf),
            widget_url=FfiConverterString.read(buf),
            pubkey=FfiConverterString.read(buf),
            host=FfiConverterString.read(buf),
            base_fee_msat=FfiConverterInt64.read(buf),
            fee_rate=FfiConverterDouble.read(buf),
            time_lock_delta=FfiConverterUInt32.read(buf),
            min_htlc_msat=FfiConverterInt64.read(buf),
            lsp_pubkey=FfiConverterSequenceUInt8.read(buf),
            opening_fee_params_list=FfiConverterTypeOpeningFeeParamsMenu.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.id, buf)
        FfiConverterString.write(value.name, buf)
        FfiConverterString.write(value.widget_url, buf)
        FfiConverterString.write(value.pubkey, buf)
        FfiConverterString.write(value.host, buf)
        FfiConverterInt64.write(value.base_fee_msat, buf)
        FfiConverterDouble.write(value.fee_rate, buf)
        FfiConverterUInt32.write(value.time_lock_delta, buf)
        FfiConverterInt64.write(value.min_htlc_msat, buf)
        FfiConverterSequenceUInt8.write(value.lsp_pubkey, buf)
        FfiConverterTypeOpeningFeeParamsMenu.write(value.opening_fee_params_list, buf)


class MessageSuccessActionData:

    def __init__(self, message):
        self.message = message

    def __str__(self):
        return "MessageSuccessActionData(message={})".format(self.message)

    def __eq__(self, other):
        if self.message != other.message:
            return False
        return True

class FfiConverterTypeMessageSuccessActionData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MessageSuccessActionData(
            message=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.message, buf)


class MetadataFilter:

    def __init__(self, json_path, json_value):
        self.json_path = json_path
        self.json_value = json_value

    def __str__(self):
        return "MetadataFilter(json_path={}, json_value={})".format(self.json_path, self.json_value)

    def __eq__(self, other):
        if self.json_path != other.json_path:
            return False
        if self.json_value != other.json_value:
            return False
        return True

class FfiConverterTypeMetadataFilter(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MetadataFilter(
            json_path=FfiConverterString.read(buf),
            json_value=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.json_path, buf)
        FfiConverterString.write(value.json_value, buf)


class MetadataItem:

    def __init__(self, key, value):
        self.key = key
        self.value = value

    def __str__(self):
        return "MetadataItem(key={}, value={})".format(self.key, self.value)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.value != other.value:
            return False
        return True

class FfiConverterTypeMetadataItem(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MetadataItem(
            key=FfiConverterString.read(buf),
            value=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.key, buf)
        FfiConverterString.write(value.value, buf)


class NodeState:

    def __init__(self, id, block_height, channels_balance_msat, onchain_balance_msat, pending_onchain_balance_msat, utxos, max_payable_msat, max_receivable_msat, max_single_payment_amount_msat, max_chan_reserve_msats, connected_peers, max_receivable_single_payment_amount_msat, total_inbound_liquidity_msats):
        self.id = id
        self.block_height = block_height
        self.channels_balance_msat = channels_balance_msat
        self.onchain_balance_msat = onchain_balance_msat
        self.pending_onchain_balance_msat = pending_onchain_balance_msat
        self.utxos = utxos
        self.max_payable_msat = max_payable_msat
        self.max_receivable_msat = max_receivable_msat
        self.max_single_payment_amount_msat = max_single_payment_amount_msat
        self.max_chan_reserve_msats = max_chan_reserve_msats
        self.connected_peers = connected_peers
        self.max_receivable_single_payment_amount_msat = max_receivable_single_payment_amount_msat
        self.total_inbound_liquidity_msats = total_inbound_liquidity_msats

    def __str__(self):
        return "NodeState(id={}, block_height={}, channels_balance_msat={}, onchain_balance_msat={}, pending_onchain_balance_msat={}, utxos={}, max_payable_msat={}, max_receivable_msat={}, max_single_payment_amount_msat={}, max_chan_reserve_msats={}, connected_peers={}, max_receivable_single_payment_amount_msat={}, total_inbound_liquidity_msats={})".format(self.id, self.block_height, self.channels_balance_msat, self.onchain_balance_msat, self.pending_onchain_balance_msat, self.utxos, self.max_payable_msat, self.max_receivable_msat, self.max_single_payment_amount_msat, self.max_chan_reserve_msats, self.connected_peers, self.max_receivable_single_payment_amount_msat, self.total_inbound_liquidity_msats)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.block_height != other.block_height:
            return False
        if self.channels_balance_msat != other.channels_balance_msat:
            return False
        if self.onchain_balance_msat != other.onchain_balance_msat:
            return False
        if self.pending_onchain_balance_msat != other.pending_onchain_balance_msat:
            return False
        if self.utxos != other.utxos:
            return False
        if self.max_payable_msat != other.max_payable_msat:
            return False
        if self.max_receivable_msat != other.max_receivable_msat:
            return False
        if self.max_single_payment_amount_msat != other.max_single_payment_amount_msat:
            return False
        if self.max_chan_reserve_msats != other.max_chan_reserve_msats:
            return False
        if self.connected_peers != other.connected_peers:
            return False
        if self.max_receivable_single_payment_amount_msat != other.max_receivable_single_payment_amount_msat:
            return False
        if self.total_inbound_liquidity_msats != other.total_inbound_liquidity_msats:
            return False
        return True

class FfiConverterTypeNodeState(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NodeState(
            id=FfiConverterString.read(buf),
            block_height=FfiConverterUInt32.read(buf),
            channels_balance_msat=FfiConverterUInt64.read(buf),
            onchain_balance_msat=FfiConverterUInt64.read(buf),
            pending_onchain_balance_msat=FfiConverterUInt64.read(buf),
            utxos=FfiConverterSequenceTypeUnspentTransactionOutput.read(buf),
            max_payable_msat=FfiConverterUInt64.read(buf),
            max_receivable_msat=FfiConverterUInt64.read(buf),
            max_single_payment_amount_msat=FfiConverterUInt64.read(buf),
            max_chan_reserve_msats=FfiConverterUInt64.read(buf),
            connected_peers=FfiConverterSequenceString.read(buf),
            max_receivable_single_payment_amount_msat=FfiConverterUInt64.read(buf),
            total_inbound_liquidity_msats=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.id, buf)
        FfiConverterUInt32.write(value.block_height, buf)
        FfiConverterUInt64.write(value.channels_balance_msat, buf)
        FfiConverterUInt64.write(value.onchain_balance_msat, buf)
        FfiConverterUInt64.write(value.pending_onchain_balance_msat, buf)
        FfiConverterSequenceTypeUnspentTransactionOutput.write(value.utxos, buf)
        FfiConverterUInt64.write(value.max_payable_msat, buf)
        FfiConverterUInt64.write(value.max_receivable_msat, buf)
        FfiConverterUInt64.write(value.max_single_payment_amount_msat, buf)
        FfiConverterUInt64.write(value.max_chan_reserve_msats, buf)
        FfiConverterSequenceString.write(value.connected_peers, buf)
        FfiConverterUInt64.write(value.max_receivable_single_payment_amount_msat, buf)
        FfiConverterUInt64.write(value.total_inbound_liquidity_msats, buf)


class OnchainPaymentLimitsResponse:

    def __init__(self, min_sat, max_sat, max_payable_sat):
        self.min_sat = min_sat
        self.max_sat = max_sat
        self.max_payable_sat = max_payable_sat

    def __str__(self):
        return "OnchainPaymentLimitsResponse(min_sat={}, max_sat={}, max_payable_sat={})".format(self.min_sat, self.max_sat, self.max_payable_sat)

    def __eq__(self, other):
        if self.min_sat != other.min_sat:
            return False
        if self.max_sat != other.max_sat:
            return False
        if self.max_payable_sat != other.max_payable_sat:
            return False
        return True

class FfiConverterTypeOnchainPaymentLimitsResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OnchainPaymentLimitsResponse(
            min_sat=FfiConverterUInt64.read(buf),
            max_sat=FfiConverterUInt64.read(buf),
            max_payable_sat=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.min_sat, buf)
        FfiConverterUInt64.write(value.max_sat, buf)
        FfiConverterUInt64.write(value.max_payable_sat, buf)


class OpenChannelFeeRequest:

    def __init__(self, amount_msat, expiry = DEFAULT):
        self.amount_msat = amount_msat
        if expiry is DEFAULT:
            self.expiry = None
        else:
            self.expiry = expiry

    def __str__(self):
        return "OpenChannelFeeRequest(amount_msat={}, expiry={})".format(self.amount_msat, self.expiry)

    def __eq__(self, other):
        if self.amount_msat != other.amount_msat:
            return False
        if self.expiry != other.expiry:
            return False
        return True

class FfiConverterTypeOpenChannelFeeRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OpenChannelFeeRequest(
            amount_msat=FfiConverterOptionalUInt64.read(buf),
            expiry=FfiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalUInt64.write(value.amount_msat, buf)
        FfiConverterOptionalUInt32.write(value.expiry, buf)


class OpenChannelFeeResponse:

    def __init__(self, fee_msat, fee_params):
        self.fee_msat = fee_msat
        self.fee_params = fee_params

    def __str__(self):
        return "OpenChannelFeeResponse(fee_msat={}, fee_params={})".format(self.fee_msat, self.fee_params)

    def __eq__(self, other):
        if self.fee_msat != other.fee_msat:
            return False
        if self.fee_params != other.fee_params:
            return False
        return True

class FfiConverterTypeOpenChannelFeeResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OpenChannelFeeResponse(
            fee_msat=FfiConverterOptionalUInt64.read(buf),
            fee_params=FfiConverterTypeOpeningFeeParams.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalUInt64.write(value.fee_msat, buf)
        FfiConverterTypeOpeningFeeParams.write(value.fee_params, buf)


class OpeningFeeParams:

    def __init__(self, min_msat, proportional, valid_until, max_idle_time, max_client_to_self_delay, promise):
        self.min_msat = min_msat
        self.proportional = proportional
        self.valid_until = valid_until
        self.max_idle_time = max_idle_time
        self.max_client_to_self_delay = max_client_to_self_delay
        self.promise = promise

    def __str__(self):
        return "OpeningFeeParams(min_msat={}, proportional={}, valid_until={}, max_idle_time={}, max_client_to_self_delay={}, promise={})".format(self.min_msat, self.proportional, self.valid_until, self.max_idle_time, self.max_client_to_self_delay, self.promise)

    def __eq__(self, other):
        if self.min_msat != other.min_msat:
            return False
        if self.proportional != other.proportional:
            return False
        if self.valid_until != other.valid_until:
            return False
        if self.max_idle_time != other.max_idle_time:
            return False
        if self.max_client_to_self_delay != other.max_client_to_self_delay:
            return False
        if self.promise != other.promise:
            return False
        return True

class FfiConverterTypeOpeningFeeParams(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OpeningFeeParams(
            min_msat=FfiConverterUInt64.read(buf),
            proportional=FfiConverterUInt32.read(buf),
            valid_until=FfiConverterString.read(buf),
            max_idle_time=FfiConverterUInt32.read(buf),
            max_client_to_self_delay=FfiConverterUInt32.read(buf),
            promise=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.min_msat, buf)
        FfiConverterUInt32.write(value.proportional, buf)
        FfiConverterString.write(value.valid_until, buf)
        FfiConverterUInt32.write(value.max_idle_time, buf)
        FfiConverterUInt32.write(value.max_client_to_self_delay, buf)
        FfiConverterString.write(value.promise, buf)


class OpeningFeeParamsMenu:

    def __init__(self, values):
        self.values = values

    def __str__(self):
        return "OpeningFeeParamsMenu(values={})".format(self.values)

    def __eq__(self, other):
        if self.values != other.values:
            return False
        return True

class FfiConverterTypeOpeningFeeParamsMenu(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OpeningFeeParamsMenu(
            values=FfiConverterSequenceTypeOpeningFeeParams.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterSequenceTypeOpeningFeeParams.write(value.values, buf)


class PayOnchainRequest:

    def __init__(self, recipient_address, prepare_res):
        self.recipient_address = recipient_address
        self.prepare_res = prepare_res

    def __str__(self):
        return "PayOnchainRequest(recipient_address={}, prepare_res={})".format(self.recipient_address, self.prepare_res)

    def __eq__(self, other):
        if self.recipient_address != other.recipient_address:
            return False
        if self.prepare_res != other.prepare_res:
            return False
        return True

class FfiConverterTypePayOnchainRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PayOnchainRequest(
            recipient_address=FfiConverterString.read(buf),
            prepare_res=FfiConverterTypePrepareOnchainPaymentResponse.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.recipient_address, buf)
        FfiConverterTypePrepareOnchainPaymentResponse.write(value.prepare_res, buf)


class PayOnchainResponse:

    def __init__(self, reverse_swap_info):
        self.reverse_swap_info = reverse_swap_info

    def __str__(self):
        return "PayOnchainResponse(reverse_swap_info={})".format(self.reverse_swap_info)

    def __eq__(self, other):
        if self.reverse_swap_info != other.reverse_swap_info:
            return False
        return True

class FfiConverterTypePayOnchainResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PayOnchainResponse(
            reverse_swap_info=FfiConverterTypeReverseSwapInfo.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeReverseSwapInfo.write(value.reverse_swap_info, buf)


class Payment:

    def __init__(self, id, payment_type, payment_time, amount_msat, fee_msat, status, error, description, details, metadata):
        self.id = id
        self.payment_type = payment_type
        self.payment_time = payment_time
        self.amount_msat = amount_msat
        self.fee_msat = fee_msat
        self.status = status
        self.error = error
        self.description = description
        self.details = details
        self.metadata = metadata

    def __str__(self):
        return "Payment(id={}, payment_type={}, payment_time={}, amount_msat={}, fee_msat={}, status={}, error={}, description={}, details={}, metadata={})".format(self.id, self.payment_type, self.payment_time, self.amount_msat, self.fee_msat, self.status, self.error, self.description, self.details, self.metadata)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.payment_type != other.payment_type:
            return False
        if self.payment_time != other.payment_time:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.fee_msat != other.fee_msat:
            return False
        if self.status != other.status:
            return False
        if self.error != other.error:
            return False
        if self.description != other.description:
            return False
        if self.details != other.details:
            return False
        if self.metadata != other.metadata:
            return False
        return True

class FfiConverterTypePayment(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Payment(
            id=FfiConverterString.read(buf),
            payment_type=FfiConverterTypePaymentType.read(buf),
            payment_time=FfiConverterInt64.read(buf),
            amount_msat=FfiConverterUInt64.read(buf),
            fee_msat=FfiConverterUInt64.read(buf),
            status=FfiConverterTypePaymentStatus.read(buf),
            error=FfiConverterOptionalString.read(buf),
            description=FfiConverterOptionalString.read(buf),
            details=FfiConverterTypePaymentDetails.read(buf),
            metadata=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.id, buf)
        FfiConverterTypePaymentType.write(value.payment_type, buf)
        FfiConverterInt64.write(value.payment_time, buf)
        FfiConverterUInt64.write(value.amount_msat, buf)
        FfiConverterUInt64.write(value.fee_msat, buf)
        FfiConverterTypePaymentStatus.write(value.status, buf)
        FfiConverterOptionalString.write(value.error, buf)
        FfiConverterOptionalString.write(value.description, buf)
        FfiConverterTypePaymentDetails.write(value.details, buf)
        FfiConverterOptionalString.write(value.metadata, buf)


class PaymentFailedData:

    def __init__(self, error, node_id, invoice, label):
        self.error = error
        self.node_id = node_id
        self.invoice = invoice
        self.label = label

    def __str__(self):
        return "PaymentFailedData(error={}, node_id={}, invoice={}, label={})".format(self.error, self.node_id, self.invoice, self.label)

    def __eq__(self, other):
        if self.error != other.error:
            return False
        if self.node_id != other.node_id:
            return False
        if self.invoice != other.invoice:
            return False
        if self.label != other.label:
            return False
        return True

class FfiConverterTypePaymentFailedData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PaymentFailedData(
            error=FfiConverterString.read(buf),
            node_id=FfiConverterString.read(buf),
            invoice=FfiConverterOptionalTypeLnInvoice.read(buf),
            label=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.error, buf)
        FfiConverterString.write(value.node_id, buf)
        FfiConverterOptionalTypeLnInvoice.write(value.invoice, buf)
        FfiConverterOptionalString.write(value.label, buf)


class PrepareOnchainPaymentRequest:

    def __init__(self, amount_sat, amount_type, claim_tx_feerate):
        self.amount_sat = amount_sat
        self.amount_type = amount_type
        self.claim_tx_feerate = claim_tx_feerate

    def __str__(self):
        return "PrepareOnchainPaymentRequest(amount_sat={}, amount_type={}, claim_tx_feerate={})".format(self.amount_sat, self.amount_type, self.claim_tx_feerate)

    def __eq__(self, other):
        if self.amount_sat != other.amount_sat:
            return False
        if self.amount_type != other.amount_type:
            return False
        if self.claim_tx_feerate != other.claim_tx_feerate:
            return False
        return True

class FfiConverterTypePrepareOnchainPaymentRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PrepareOnchainPaymentRequest(
            amount_sat=FfiConverterUInt64.read(buf),
            amount_type=FfiConverterTypeSwapAmountType.read(buf),
            claim_tx_feerate=FfiConverterUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.amount_sat, buf)
        FfiConverterTypeSwapAmountType.write(value.amount_type, buf)
        FfiConverterUInt32.write(value.claim_tx_feerate, buf)


class PrepareOnchainPaymentResponse:

    def __init__(self, fees_hash, fees_percentage, fees_lockup, fees_claim, sender_amount_sat, recipient_amount_sat, total_fees):
        self.fees_hash = fees_hash
        self.fees_percentage = fees_percentage
        self.fees_lockup = fees_lockup
        self.fees_claim = fees_claim
        self.sender_amount_sat = sender_amount_sat
        self.recipient_amount_sat = recipient_amount_sat
        self.total_fees = total_fees

    def __str__(self):
        return "PrepareOnchainPaymentResponse(fees_hash={}, fees_percentage={}, fees_lockup={}, fees_claim={}, sender_amount_sat={}, recipient_amount_sat={}, total_fees={})".format(self.fees_hash, self.fees_percentage, self.fees_lockup, self.fees_claim, self.sender_amount_sat, self.recipient_amount_sat, self.total_fees)

    def __eq__(self, other):
        if self.fees_hash != other.fees_hash:
            return False
        if self.fees_percentage != other.fees_percentage:
            return False
        if self.fees_lockup != other.fees_lockup:
            return False
        if self.fees_claim != other.fees_claim:
            return False
        if self.sender_amount_sat != other.sender_amount_sat:
            return False
        if self.recipient_amount_sat != other.recipient_amount_sat:
            return False
        if self.total_fees != other.total_fees:
            return False
        return True

class FfiConverterTypePrepareOnchainPaymentResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PrepareOnchainPaymentResponse(
            fees_hash=FfiConverterString.read(buf),
            fees_percentage=FfiConverterDouble.read(buf),
            fees_lockup=FfiConverterUInt64.read(buf),
            fees_claim=FfiConverterUInt64.read(buf),
            sender_amount_sat=FfiConverterUInt64.read(buf),
            recipient_amount_sat=FfiConverterUInt64.read(buf),
            total_fees=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.fees_hash, buf)
        FfiConverterDouble.write(value.fees_percentage, buf)
        FfiConverterUInt64.write(value.fees_lockup, buf)
        FfiConverterUInt64.write(value.fees_claim, buf)
        FfiConverterUInt64.write(value.sender_amount_sat, buf)
        FfiConverterUInt64.write(value.recipient_amount_sat, buf)
        FfiConverterUInt64.write(value.total_fees, buf)


class PrepareRedeemOnchainFundsRequest:

    def __init__(self, to_address, sat_per_vbyte):
        self.to_address = to_address
        self.sat_per_vbyte = sat_per_vbyte

    def __str__(self):
        return "PrepareRedeemOnchainFundsRequest(to_address={}, sat_per_vbyte={})".format(self.to_address, self.sat_per_vbyte)

    def __eq__(self, other):
        if self.to_address != other.to_address:
            return False
        if self.sat_per_vbyte != other.sat_per_vbyte:
            return False
        return True

class FfiConverterTypePrepareRedeemOnchainFundsRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PrepareRedeemOnchainFundsRequest(
            to_address=FfiConverterString.read(buf),
            sat_per_vbyte=FfiConverterUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.to_address, buf)
        FfiConverterUInt32.write(value.sat_per_vbyte, buf)


class PrepareRedeemOnchainFundsResponse:

    def __init__(self, tx_weight, tx_fee_sat):
        self.tx_weight = tx_weight
        self.tx_fee_sat = tx_fee_sat

    def __str__(self):
        return "PrepareRedeemOnchainFundsResponse(tx_weight={}, tx_fee_sat={})".format(self.tx_weight, self.tx_fee_sat)

    def __eq__(self, other):
        if self.tx_weight != other.tx_weight:
            return False
        if self.tx_fee_sat != other.tx_fee_sat:
            return False
        return True

class FfiConverterTypePrepareRedeemOnchainFundsResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PrepareRedeemOnchainFundsResponse(
            tx_weight=FfiConverterUInt64.read(buf),
            tx_fee_sat=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.tx_weight, buf)
        FfiConverterUInt64.write(value.tx_fee_sat, buf)


class PrepareRefundRequest:

    def __init__(self, swap_address, to_address, sat_per_vbyte, unilateral = DEFAULT):
        self.swap_address = swap_address
        self.to_address = to_address
        self.sat_per_vbyte = sat_per_vbyte
        if unilateral is DEFAULT:
            self.unilateral = None
        else:
            self.unilateral = unilateral

    def __str__(self):
        return "PrepareRefundRequest(swap_address={}, to_address={}, sat_per_vbyte={}, unilateral={})".format(self.swap_address, self.to_address, self.sat_per_vbyte, self.unilateral)

    def __eq__(self, other):
        if self.swap_address != other.swap_address:
            return False
        if self.to_address != other.to_address:
            return False
        if self.sat_per_vbyte != other.sat_per_vbyte:
            return False
        if self.unilateral != other.unilateral:
            return False
        return True

class FfiConverterTypePrepareRefundRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PrepareRefundRequest(
            swap_address=FfiConverterString.read(buf),
            to_address=FfiConverterString.read(buf),
            sat_per_vbyte=FfiConverterUInt32.read(buf),
            unilateral=FfiConverterOptionalBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.swap_address, buf)
        FfiConverterString.write(value.to_address, buf)
        FfiConverterUInt32.write(value.sat_per_vbyte, buf)
        FfiConverterOptionalBool.write(value.unilateral, buf)


class PrepareRefundResponse:

    def __init__(self, refund_tx_weight, refund_tx_fee_sat):
        self.refund_tx_weight = refund_tx_weight
        self.refund_tx_fee_sat = refund_tx_fee_sat

    def __str__(self):
        return "PrepareRefundResponse(refund_tx_weight={}, refund_tx_fee_sat={})".format(self.refund_tx_weight, self.refund_tx_fee_sat)

    def __eq__(self, other):
        if self.refund_tx_weight != other.refund_tx_weight:
            return False
        if self.refund_tx_fee_sat != other.refund_tx_fee_sat:
            return False
        return True

class FfiConverterTypePrepareRefundResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PrepareRefundResponse(
            refund_tx_weight=FfiConverterUInt32.read(buf),
            refund_tx_fee_sat=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt32.write(value.refund_tx_weight, buf)
        FfiConverterUInt64.write(value.refund_tx_fee_sat, buf)


class Rate:

    def __init__(self, coin, value):
        self.coin = coin
        self.value = value

    def __str__(self):
        return "Rate(coin={}, value={})".format(self.coin, self.value)

    def __eq__(self, other):
        if self.coin != other.coin:
            return False
        if self.value != other.value:
            return False
        return True

class FfiConverterTypeRate(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Rate(
            coin=FfiConverterString.read(buf),
            value=FfiConverterDouble.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.coin, buf)
        FfiConverterDouble.write(value.value, buf)


class ReceiveOnchainRequest:

    def __init__(self, opening_fee_params = DEFAULT):
        if opening_fee_params is DEFAULT:
            self.opening_fee_params = None
        else:
            self.opening_fee_params = opening_fee_params

    def __str__(self):
        return "ReceiveOnchainRequest(opening_fee_params={})".format(self.opening_fee_params)

    def __eq__(self, other):
        if self.opening_fee_params != other.opening_fee_params:
            return False
        return True

class FfiConverterTypeReceiveOnchainRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReceiveOnchainRequest(
            opening_fee_params=FfiConverterOptionalTypeOpeningFeeParams.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalTypeOpeningFeeParams.write(value.opening_fee_params, buf)


class ReceivePaymentRequest:

    def __init__(self, amount_msat, description, preimage = DEFAULT, opening_fee_params = DEFAULT, use_description_hash = DEFAULT, expiry = DEFAULT, cltv = DEFAULT):
        self.amount_msat = amount_msat
        self.description = description
        if preimage is DEFAULT:
            self.preimage = None
        else:
            self.preimage = preimage
        if opening_fee_params is DEFAULT:
            self.opening_fee_params = None
        else:
            self.opening_fee_params = opening_fee_params
        if use_description_hash is DEFAULT:
            self.use_description_hash = None
        else:
            self.use_description_hash = use_description_hash
        if expiry is DEFAULT:
            self.expiry = None
        else:
            self.expiry = expiry
        if cltv is DEFAULT:
            self.cltv = None
        else:
            self.cltv = cltv

    def __str__(self):
        return "ReceivePaymentRequest(amount_msat={}, description={}, preimage={}, opening_fee_params={}, use_description_hash={}, expiry={}, cltv={})".format(self.amount_msat, self.description, self.preimage, self.opening_fee_params, self.use_description_hash, self.expiry, self.cltv)

    def __eq__(self, other):
        if self.amount_msat != other.amount_msat:
            return False
        if self.description != other.description:
            return False
        if self.preimage != other.preimage:
            return False
        if self.opening_fee_params != other.opening_fee_params:
            return False
        if self.use_description_hash != other.use_description_hash:
            return False
        if self.expiry != other.expiry:
            return False
        if self.cltv != other.cltv:
            return False
        return True

class FfiConverterTypeReceivePaymentRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReceivePaymentRequest(
            amount_msat=FfiConverterUInt64.read(buf),
            description=FfiConverterString.read(buf),
            preimage=FfiConverterOptionalSequenceUInt8.read(buf),
            opening_fee_params=FfiConverterOptionalTypeOpeningFeeParams.read(buf),
            use_description_hash=FfiConverterOptionalBool.read(buf),
            expiry=FfiConverterOptionalUInt32.read(buf),
            cltv=FfiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.amount_msat, buf)
        FfiConverterString.write(value.description, buf)
        FfiConverterOptionalSequenceUInt8.write(value.preimage, buf)
        FfiConverterOptionalTypeOpeningFeeParams.write(value.opening_fee_params, buf)
        FfiConverterOptionalBool.write(value.use_description_hash, buf)
        FfiConverterOptionalUInt32.write(value.expiry, buf)
        FfiConverterOptionalUInt32.write(value.cltv, buf)


class ReceivePaymentResponse:

    def __init__(self, ln_invoice, opening_fee_params, opening_fee_msat):
        self.ln_invoice = ln_invoice
        self.opening_fee_params = opening_fee_params
        self.opening_fee_msat = opening_fee_msat

    def __str__(self):
        return "ReceivePaymentResponse(ln_invoice={}, opening_fee_params={}, opening_fee_msat={})".format(self.ln_invoice, self.opening_fee_params, self.opening_fee_msat)

    def __eq__(self, other):
        if self.ln_invoice != other.ln_invoice:
            return False
        if self.opening_fee_params != other.opening_fee_params:
            return False
        if self.opening_fee_msat != other.opening_fee_msat:
            return False
        return True

class FfiConverterTypeReceivePaymentResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReceivePaymentResponse(
            ln_invoice=FfiConverterTypeLnInvoice.read(buf),
            opening_fee_params=FfiConverterOptionalTypeOpeningFeeParams.read(buf),
            opening_fee_msat=FfiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeLnInvoice.write(value.ln_invoice, buf)
        FfiConverterOptionalTypeOpeningFeeParams.write(value.opening_fee_params, buf)
        FfiConverterOptionalUInt64.write(value.opening_fee_msat, buf)


class RecommendedFees:

    def __init__(self, fastest_fee, half_hour_fee, hour_fee, economy_fee, minimum_fee):
        self.fastest_fee = fastest_fee
        self.half_hour_fee = half_hour_fee
        self.hour_fee = hour_fee
        self.economy_fee = economy_fee
        self.minimum_fee = minimum_fee

    def __str__(self):
        return "RecommendedFees(fastest_fee={}, half_hour_fee={}, hour_fee={}, economy_fee={}, minimum_fee={})".format(self.fastest_fee, self.half_hour_fee, self.hour_fee, self.economy_fee, self.minimum_fee)

    def __eq__(self, other):
        if self.fastest_fee != other.fastest_fee:
            return False
        if self.half_hour_fee != other.half_hour_fee:
            return False
        if self.hour_fee != other.hour_fee:
            return False
        if self.economy_fee != other.economy_fee:
            return False
        if self.minimum_fee != other.minimum_fee:
            return False
        return True

class FfiConverterTypeRecommendedFees(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RecommendedFees(
            fastest_fee=FfiConverterUInt64.read(buf),
            half_hour_fee=FfiConverterUInt64.read(buf),
            hour_fee=FfiConverterUInt64.read(buf),
            economy_fee=FfiConverterUInt64.read(buf),
            minimum_fee=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.fastest_fee, buf)
        FfiConverterUInt64.write(value.half_hour_fee, buf)
        FfiConverterUInt64.write(value.hour_fee, buf)
        FfiConverterUInt64.write(value.economy_fee, buf)
        FfiConverterUInt64.write(value.minimum_fee, buf)


class RedeemOnchainFundsRequest:

    def __init__(self, to_address, sat_per_vbyte):
        self.to_address = to_address
        self.sat_per_vbyte = sat_per_vbyte

    def __str__(self):
        return "RedeemOnchainFundsRequest(to_address={}, sat_per_vbyte={})".format(self.to_address, self.sat_per_vbyte)

    def __eq__(self, other):
        if self.to_address != other.to_address:
            return False
        if self.sat_per_vbyte != other.sat_per_vbyte:
            return False
        return True

class FfiConverterTypeRedeemOnchainFundsRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RedeemOnchainFundsRequest(
            to_address=FfiConverterString.read(buf),
            sat_per_vbyte=FfiConverterUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.to_address, buf)
        FfiConverterUInt32.write(value.sat_per_vbyte, buf)


class RedeemOnchainFundsResponse:

    def __init__(self, txid):
        self.txid = txid

    def __str__(self):
        return "RedeemOnchainFundsResponse(txid={})".format(self.txid)

    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        return True

class FfiConverterTypeRedeemOnchainFundsResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RedeemOnchainFundsResponse(
            txid=FfiConverterSequenceUInt8.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterSequenceUInt8.write(value.txid, buf)


class RefundRequest:

    def __init__(self, swap_address, to_address, sat_per_vbyte, unilateral = DEFAULT):
        self.swap_address = swap_address
        self.to_address = to_address
        self.sat_per_vbyte = sat_per_vbyte
        if unilateral is DEFAULT:
            self.unilateral = None
        else:
            self.unilateral = unilateral

    def __str__(self):
        return "RefundRequest(swap_address={}, to_address={}, sat_per_vbyte={}, unilateral={})".format(self.swap_address, self.to_address, self.sat_per_vbyte, self.unilateral)

    def __eq__(self, other):
        if self.swap_address != other.swap_address:
            return False
        if self.to_address != other.to_address:
            return False
        if self.sat_per_vbyte != other.sat_per_vbyte:
            return False
        if self.unilateral != other.unilateral:
            return False
        return True

class FfiConverterTypeRefundRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RefundRequest(
            swap_address=FfiConverterString.read(buf),
            to_address=FfiConverterString.read(buf),
            sat_per_vbyte=FfiConverterUInt32.read(buf),
            unilateral=FfiConverterOptionalBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.swap_address, buf)
        FfiConverterString.write(value.to_address, buf)
        FfiConverterUInt32.write(value.sat_per_vbyte, buf)
        FfiConverterOptionalBool.write(value.unilateral, buf)


class RefundResponse:

    def __init__(self, refund_tx_id):
        self.refund_tx_id = refund_tx_id

    def __str__(self):
        return "RefundResponse(refund_tx_id={})".format(self.refund_tx_id)

    def __eq__(self, other):
        if self.refund_tx_id != other.refund_tx_id:
            return False
        return True

class FfiConverterTypeRefundResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RefundResponse(
            refund_tx_id=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.refund_tx_id, buf)


class ReportPaymentFailureDetails:

    def __init__(self, payment_hash, comment = DEFAULT):
        self.payment_hash = payment_hash
        if comment is DEFAULT:
            self.comment = None
        else:
            self.comment = comment

    def __str__(self):
        return "ReportPaymentFailureDetails(payment_hash={}, comment={})".format(self.payment_hash, self.comment)

    def __eq__(self, other):
        if self.payment_hash != other.payment_hash:
            return False
        if self.comment != other.comment:
            return False
        return True

class FfiConverterTypeReportPaymentFailureDetails(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReportPaymentFailureDetails(
            payment_hash=FfiConverterString.read(buf),
            comment=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.payment_hash, buf)
        FfiConverterOptionalString.write(value.comment, buf)


class ReverseSwapFeesRequest:

    def __init__(self, send_amount_sat = DEFAULT, claim_tx_feerate = DEFAULT):
        if send_amount_sat is DEFAULT:
            self.send_amount_sat = None
        else:
            self.send_amount_sat = send_amount_sat
        if claim_tx_feerate is DEFAULT:
            self.claim_tx_feerate = None
        else:
            self.claim_tx_feerate = claim_tx_feerate

    def __str__(self):
        return "ReverseSwapFeesRequest(send_amount_sat={}, claim_tx_feerate={})".format(self.send_amount_sat, self.claim_tx_feerate)

    def __eq__(self, other):
        if self.send_amount_sat != other.send_amount_sat:
            return False
        if self.claim_tx_feerate != other.claim_tx_feerate:
            return False
        return True

class FfiConverterTypeReverseSwapFeesRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReverseSwapFeesRequest(
            send_amount_sat=FfiConverterOptionalUInt64.read(buf),
            claim_tx_feerate=FfiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalUInt64.write(value.send_amount_sat, buf)
        FfiConverterOptionalUInt32.write(value.claim_tx_feerate, buf)


class ReverseSwapInfo:

    def __init__(self, id, claim_pubkey, lockup_txid, claim_txid, onchain_amount_sat, status):
        self.id = id
        self.claim_pubkey = claim_pubkey
        self.lockup_txid = lockup_txid
        self.claim_txid = claim_txid
        self.onchain_amount_sat = onchain_amount_sat
        self.status = status

    def __str__(self):
        return "ReverseSwapInfo(id={}, claim_pubkey={}, lockup_txid={}, claim_txid={}, onchain_amount_sat={}, status={})".format(self.id, self.claim_pubkey, self.lockup_txid, self.claim_txid, self.onchain_amount_sat, self.status)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.claim_pubkey != other.claim_pubkey:
            return False
        if self.lockup_txid != other.lockup_txid:
            return False
        if self.claim_txid != other.claim_txid:
            return False
        if self.onchain_amount_sat != other.onchain_amount_sat:
            return False
        if self.status != other.status:
            return False
        return True

class FfiConverterTypeReverseSwapInfo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReverseSwapInfo(
            id=FfiConverterString.read(buf),
            claim_pubkey=FfiConverterString.read(buf),
            lockup_txid=FfiConverterOptionalString.read(buf),
            claim_txid=FfiConverterOptionalString.read(buf),
            onchain_amount_sat=FfiConverterUInt64.read(buf),
            status=FfiConverterTypeReverseSwapStatus.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.id, buf)
        FfiConverterString.write(value.claim_pubkey, buf)
        FfiConverterOptionalString.write(value.lockup_txid, buf)
        FfiConverterOptionalString.write(value.claim_txid, buf)
        FfiConverterUInt64.write(value.onchain_amount_sat, buf)
        FfiConverterTypeReverseSwapStatus.write(value.status, buf)


class ReverseSwapPairInfo:

    def __init__(self, min, max, fees_hash, fees_percentage, fees_lockup, fees_claim, total_fees):
        self.min = min
        self.max = max
        self.fees_hash = fees_hash
        self.fees_percentage = fees_percentage
        self.fees_lockup = fees_lockup
        self.fees_claim = fees_claim
        self.total_fees = total_fees

    def __str__(self):
        return "ReverseSwapPairInfo(min={}, max={}, fees_hash={}, fees_percentage={}, fees_lockup={}, fees_claim={}, total_fees={})".format(self.min, self.max, self.fees_hash, self.fees_percentage, self.fees_lockup, self.fees_claim, self.total_fees)

    def __eq__(self, other):
        if self.min != other.min:
            return False
        if self.max != other.max:
            return False
        if self.fees_hash != other.fees_hash:
            return False
        if self.fees_percentage != other.fees_percentage:
            return False
        if self.fees_lockup != other.fees_lockup:
            return False
        if self.fees_claim != other.fees_claim:
            return False
        if self.total_fees != other.total_fees:
            return False
        return True

class FfiConverterTypeReverseSwapPairInfo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReverseSwapPairInfo(
            min=FfiConverterUInt64.read(buf),
            max=FfiConverterUInt64.read(buf),
            fees_hash=FfiConverterString.read(buf),
            fees_percentage=FfiConverterDouble.read(buf),
            fees_lockup=FfiConverterUInt64.read(buf),
            fees_claim=FfiConverterUInt64.read(buf),
            total_fees=FfiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.min, buf)
        FfiConverterUInt64.write(value.max, buf)
        FfiConverterString.write(value.fees_hash, buf)
        FfiConverterDouble.write(value.fees_percentage, buf)
        FfiConverterUInt64.write(value.fees_lockup, buf)
        FfiConverterUInt64.write(value.fees_claim, buf)
        FfiConverterOptionalUInt64.write(value.total_fees, buf)


class RouteHint:

    def __init__(self, hops):
        self.hops = hops

    def __str__(self):
        return "RouteHint(hops={})".format(self.hops)

    def __eq__(self, other):
        if self.hops != other.hops:
            return False
        return True

class FfiConverterTypeRouteHint(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RouteHint(
            hops=FfiConverterSequenceTypeRouteHintHop.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterSequenceTypeRouteHintHop.write(value.hops, buf)


class RouteHintHop:

    def __init__(self, src_node_id, short_channel_id, fees_base_msat, fees_proportional_millionths, cltv_expiry_delta, htlc_minimum_msat, htlc_maximum_msat):
        self.src_node_id = src_node_id
        self.short_channel_id = short_channel_id
        self.fees_base_msat = fees_base_msat
        self.fees_proportional_millionths = fees_proportional_millionths
        self.cltv_expiry_delta = cltv_expiry_delta
        self.htlc_minimum_msat = htlc_minimum_msat
        self.htlc_maximum_msat = htlc_maximum_msat

    def __str__(self):
        return "RouteHintHop(src_node_id={}, short_channel_id={}, fees_base_msat={}, fees_proportional_millionths={}, cltv_expiry_delta={}, htlc_minimum_msat={}, htlc_maximum_msat={})".format(self.src_node_id, self.short_channel_id, self.fees_base_msat, self.fees_proportional_millionths, self.cltv_expiry_delta, self.htlc_minimum_msat, self.htlc_maximum_msat)

    def __eq__(self, other):
        if self.src_node_id != other.src_node_id:
            return False
        if self.short_channel_id != other.short_channel_id:
            return False
        if self.fees_base_msat != other.fees_base_msat:
            return False
        if self.fees_proportional_millionths != other.fees_proportional_millionths:
            return False
        if self.cltv_expiry_delta != other.cltv_expiry_delta:
            return False
        if self.htlc_minimum_msat != other.htlc_minimum_msat:
            return False
        if self.htlc_maximum_msat != other.htlc_maximum_msat:
            return False
        return True

class FfiConverterTypeRouteHintHop(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RouteHintHop(
            src_node_id=FfiConverterString.read(buf),
            short_channel_id=FfiConverterString.read(buf),
            fees_base_msat=FfiConverterUInt32.read(buf),
            fees_proportional_millionths=FfiConverterUInt32.read(buf),
            cltv_expiry_delta=FfiConverterUInt64.read(buf),
            htlc_minimum_msat=FfiConverterOptionalUInt64.read(buf),
            htlc_maximum_msat=FfiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.src_node_id, buf)
        FfiConverterString.write(value.short_channel_id, buf)
        FfiConverterUInt32.write(value.fees_base_msat, buf)
        FfiConverterUInt32.write(value.fees_proportional_millionths, buf)
        FfiConverterUInt64.write(value.cltv_expiry_delta, buf)
        FfiConverterOptionalUInt64.write(value.htlc_minimum_msat, buf)
        FfiConverterOptionalUInt64.write(value.htlc_maximum_msat, buf)


class SendPaymentRequest:

    def __init__(self, bolt11, use_trampoline, amount_msat = DEFAULT, label = DEFAULT):
        self.bolt11 = bolt11
        self.use_trampoline = use_trampoline
        if amount_msat is DEFAULT:
            self.amount_msat = None
        else:
            self.amount_msat = amount_msat
        if label is DEFAULT:
            self.label = None
        else:
            self.label = label

    def __str__(self):
        return "SendPaymentRequest(bolt11={}, use_trampoline={}, amount_msat={}, label={})".format(self.bolt11, self.use_trampoline, self.amount_msat, self.label)

    def __eq__(self, other):
        if self.bolt11 != other.bolt11:
            return False
        if self.use_trampoline != other.use_trampoline:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.label != other.label:
            return False
        return True

class FfiConverterTypeSendPaymentRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SendPaymentRequest(
            bolt11=FfiConverterString.read(buf),
            use_trampoline=FfiConverterBool.read(buf),
            amount_msat=FfiConverterOptionalUInt64.read(buf),
            label=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.bolt11, buf)
        FfiConverterBool.write(value.use_trampoline, buf)
        FfiConverterOptionalUInt64.write(value.amount_msat, buf)
        FfiConverterOptionalString.write(value.label, buf)


class SendPaymentResponse:

    def __init__(self, payment):
        self.payment = payment

    def __str__(self):
        return "SendPaymentResponse(payment={})".format(self.payment)

    def __eq__(self, other):
        if self.payment != other.payment:
            return False
        return True

class FfiConverterTypeSendPaymentResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SendPaymentResponse(
            payment=FfiConverterTypePayment.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypePayment.write(value.payment, buf)


class SendSpontaneousPaymentRequest:

    def __init__(self, node_id, amount_msat, extra_tlvs = DEFAULT, label = DEFAULT):
        self.node_id = node_id
        self.amount_msat = amount_msat
        if extra_tlvs is DEFAULT:
            self.extra_tlvs = None
        else:
            self.extra_tlvs = extra_tlvs
        if label is DEFAULT:
            self.label = None
        else:
            self.label = label

    def __str__(self):
        return "SendSpontaneousPaymentRequest(node_id={}, amount_msat={}, extra_tlvs={}, label={})".format(self.node_id, self.amount_msat, self.extra_tlvs, self.label)

    def __eq__(self, other):
        if self.node_id != other.node_id:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.extra_tlvs != other.extra_tlvs:
            return False
        if self.label != other.label:
            return False
        return True

class FfiConverterTypeSendSpontaneousPaymentRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SendSpontaneousPaymentRequest(
            node_id=FfiConverterString.read(buf),
            amount_msat=FfiConverterUInt64.read(buf),
            extra_tlvs=FfiConverterOptionalSequenceTypeTlvEntry.read(buf),
            label=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.node_id, buf)
        FfiConverterUInt64.write(value.amount_msat, buf)
        FfiConverterOptionalSequenceTypeTlvEntry.write(value.extra_tlvs, buf)
        FfiConverterOptionalString.write(value.label, buf)


class ServiceHealthCheckResponse:

    def __init__(self, status):
        self.status = status

    def __str__(self):
        return "ServiceHealthCheckResponse(status={})".format(self.status)

    def __eq__(self, other):
        if self.status != other.status:
            return False
        return True

class FfiConverterTypeServiceHealthCheckResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ServiceHealthCheckResponse(
            status=FfiConverterTypeHealthCheckStatus.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeHealthCheckStatus.write(value.status, buf)


class SignMessageRequest:

    def __init__(self, message):
        self.message = message

    def __str__(self):
        return "SignMessageRequest(message={})".format(self.message)

    def __eq__(self, other):
        if self.message != other.message:
            return False
        return True

class FfiConverterTypeSignMessageRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SignMessageRequest(
            message=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.message, buf)


class SignMessageResponse:

    def __init__(self, signature):
        self.signature = signature

    def __str__(self):
        return "SignMessageResponse(signature={})".format(self.signature)

    def __eq__(self, other):
        if self.signature != other.signature:
            return False
        return True

class FfiConverterTypeSignMessageResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SignMessageResponse(
            signature=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.signature, buf)


class StaticBackupRequest:

    def __init__(self, working_dir):
        self.working_dir = working_dir

    def __str__(self):
        return "StaticBackupRequest(working_dir={})".format(self.working_dir)

    def __eq__(self, other):
        if self.working_dir != other.working_dir:
            return False
        return True

class FfiConverterTypeStaticBackupRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StaticBackupRequest(
            working_dir=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.working_dir, buf)


class StaticBackupResponse:

    def __init__(self, backup):
        self.backup = backup

    def __str__(self):
        return "StaticBackupResponse(backup={})".format(self.backup)

    def __eq__(self, other):
        if self.backup != other.backup:
            return False
        return True

class FfiConverterTypeStaticBackupResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StaticBackupResponse(
            backup=FfiConverterOptionalSequenceString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalSequenceString.write(value.backup, buf)


class SwapInfo:

    def __init__(self, bitcoin_address, created_at, lock_height, payment_hash, preimage, private_key, public_key, swapper_public_key, script, bolt11, paid_msat, unconfirmed_sats, confirmed_sats, total_incoming_txs, status, refund_tx_ids, unconfirmed_tx_ids, confirmed_tx_ids, min_allowed_deposit, max_allowed_deposit, max_swapper_payable, last_redeem_error, channel_opening_fees, confirmed_at):
        self.bitcoin_address = bitcoin_address
        self.created_at = created_at
        self.lock_height = lock_height
        self.payment_hash = payment_hash
        self.preimage = preimage
        self.private_key = private_key
        self.public_key = public_key
        self.swapper_public_key = swapper_public_key
        self.script = script
        self.bolt11 = bolt11
        self.paid_msat = paid_msat
        self.unconfirmed_sats = unconfirmed_sats
        self.confirmed_sats = confirmed_sats
        self.total_incoming_txs = total_incoming_txs
        self.status = status
        self.refund_tx_ids = refund_tx_ids
        self.unconfirmed_tx_ids = unconfirmed_tx_ids
        self.confirmed_tx_ids = confirmed_tx_ids
        self.min_allowed_deposit = min_allowed_deposit
        self.max_allowed_deposit = max_allowed_deposit
        self.max_swapper_payable = max_swapper_payable
        self.last_redeem_error = last_redeem_error
        self.channel_opening_fees = channel_opening_fees
        self.confirmed_at = confirmed_at

    def __str__(self):
        return "SwapInfo(bitcoin_address={}, created_at={}, lock_height={}, payment_hash={}, preimage={}, private_key={}, public_key={}, swapper_public_key={}, script={}, bolt11={}, paid_msat={}, unconfirmed_sats={}, confirmed_sats={}, total_incoming_txs={}, status={}, refund_tx_ids={}, unconfirmed_tx_ids={}, confirmed_tx_ids={}, min_allowed_deposit={}, max_allowed_deposit={}, max_swapper_payable={}, last_redeem_error={}, channel_opening_fees={}, confirmed_at={})".format(self.bitcoin_address, self.created_at, self.lock_height, self.payment_hash, self.preimage, self.private_key, self.public_key, self.swapper_public_key, self.script, self.bolt11, self.paid_msat, self.unconfirmed_sats, self.confirmed_sats, self.total_incoming_txs, self.status, self.refund_tx_ids, self.unconfirmed_tx_ids, self.confirmed_tx_ids, self.min_allowed_deposit, self.max_allowed_deposit, self.max_swapper_payable, self.last_redeem_error, self.channel_opening_fees, self.confirmed_at)

    def __eq__(self, other):
        if self.bitcoin_address != other.bitcoin_address:
            return False
        if self.created_at != other.created_at:
            return False
        if self.lock_height != other.lock_height:
            return False
        if self.payment_hash != other.payment_hash:
            return False
        if self.preimage != other.preimage:
            return False
        if self.private_key != other.private_key:
            return False
        if self.public_key != other.public_key:
            return False
        if self.swapper_public_key != other.swapper_public_key:
            return False
        if self.script != other.script:
            return False
        if self.bolt11 != other.bolt11:
            return False
        if self.paid_msat != other.paid_msat:
            return False
        if self.unconfirmed_sats != other.unconfirmed_sats:
            return False
        if self.confirmed_sats != other.confirmed_sats:
            return False
        if self.total_incoming_txs != other.total_incoming_txs:
            return False
        if self.status != other.status:
            return False
        if self.refund_tx_ids != other.refund_tx_ids:
            return False
        if self.unconfirmed_tx_ids != other.unconfirmed_tx_ids:
            return False
        if self.confirmed_tx_ids != other.confirmed_tx_ids:
            return False
        if self.min_allowed_deposit != other.min_allowed_deposit:
            return False
        if self.max_allowed_deposit != other.max_allowed_deposit:
            return False
        if self.max_swapper_payable != other.max_swapper_payable:
            return False
        if self.last_redeem_error != other.last_redeem_error:
            return False
        if self.channel_opening_fees != other.channel_opening_fees:
            return False
        if self.confirmed_at != other.confirmed_at:
            return False
        return True

class FfiConverterTypeSwapInfo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SwapInfo(
            bitcoin_address=FfiConverterString.read(buf),
            created_at=FfiConverterInt64.read(buf),
            lock_height=FfiConverterInt64.read(buf),
            payment_hash=FfiConverterSequenceUInt8.read(buf),
            preimage=FfiConverterSequenceUInt8.read(buf),
            private_key=FfiConverterSequenceUInt8.read(buf),
            public_key=FfiConverterSequenceUInt8.read(buf),
            swapper_public_key=FfiConverterSequenceUInt8.read(buf),
            script=FfiConverterSequenceUInt8.read(buf),
            bolt11=FfiConverterOptionalString.read(buf),
            paid_msat=FfiConverterUInt64.read(buf),
            unconfirmed_sats=FfiConverterUInt64.read(buf),
            confirmed_sats=FfiConverterUInt64.read(buf),
            total_incoming_txs=FfiConverterUInt64.read(buf),
            status=FfiConverterTypeSwapStatus.read(buf),
            refund_tx_ids=FfiConverterSequenceString.read(buf),
            unconfirmed_tx_ids=FfiConverterSequenceString.read(buf),
            confirmed_tx_ids=FfiConverterSequenceString.read(buf),
            min_allowed_deposit=FfiConverterInt64.read(buf),
            max_allowed_deposit=FfiConverterInt64.read(buf),
            max_swapper_payable=FfiConverterInt64.read(buf),
            last_redeem_error=FfiConverterOptionalString.read(buf),
            channel_opening_fees=FfiConverterOptionalTypeOpeningFeeParams.read(buf),
            confirmed_at=FfiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.bitcoin_address, buf)
        FfiConverterInt64.write(value.created_at, buf)
        FfiConverterInt64.write(value.lock_height, buf)
        FfiConverterSequenceUInt8.write(value.payment_hash, buf)
        FfiConverterSequenceUInt8.write(value.preimage, buf)
        FfiConverterSequenceUInt8.write(value.private_key, buf)
        FfiConverterSequenceUInt8.write(value.public_key, buf)
        FfiConverterSequenceUInt8.write(value.swapper_public_key, buf)
        FfiConverterSequenceUInt8.write(value.script, buf)
        FfiConverterOptionalString.write(value.bolt11, buf)
        FfiConverterUInt64.write(value.paid_msat, buf)
        FfiConverterUInt64.write(value.unconfirmed_sats, buf)
        FfiConverterUInt64.write(value.confirmed_sats, buf)
        FfiConverterUInt64.write(value.total_incoming_txs, buf)
        FfiConverterTypeSwapStatus.write(value.status, buf)
        FfiConverterSequenceString.write(value.refund_tx_ids, buf)
        FfiConverterSequenceString.write(value.unconfirmed_tx_ids, buf)
        FfiConverterSequenceString.write(value.confirmed_tx_ids, buf)
        FfiConverterInt64.write(value.min_allowed_deposit, buf)
        FfiConverterInt64.write(value.max_allowed_deposit, buf)
        FfiConverterInt64.write(value.max_swapper_payable, buf)
        FfiConverterOptionalString.write(value.last_redeem_error, buf)
        FfiConverterOptionalTypeOpeningFeeParams.write(value.channel_opening_fees, buf)
        FfiConverterOptionalUInt32.write(value.confirmed_at, buf)


class Symbol:

    def __init__(self, grapheme, template, rtl, position):
        self.grapheme = grapheme
        self.template = template
        self.rtl = rtl
        self.position = position

    def __str__(self):
        return "Symbol(grapheme={}, template={}, rtl={}, position={})".format(self.grapheme, self.template, self.rtl, self.position)

    def __eq__(self, other):
        if self.grapheme != other.grapheme:
            return False
        if self.template != other.template:
            return False
        if self.rtl != other.rtl:
            return False
        if self.position != other.position:
            return False
        return True

class FfiConverterTypeSymbol(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Symbol(
            grapheme=FfiConverterOptionalString.read(buf),
            template=FfiConverterOptionalString.read(buf),
            rtl=FfiConverterOptionalBool.read(buf),
            position=FfiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalString.write(value.grapheme, buf)
        FfiConverterOptionalString.write(value.template, buf)
        FfiConverterOptionalBool.write(value.rtl, buf)
        FfiConverterOptionalUInt32.write(value.position, buf)


class TlvEntry:

    def __init__(self, field_number, value):
        self.field_number = field_number
        self.value = value

    def __str__(self):
        return "TlvEntry(field_number={}, value={})".format(self.field_number, self.value)

    def __eq__(self, other):
        if self.field_number != other.field_number:
            return False
        if self.value != other.value:
            return False
        return True

class FfiConverterTypeTlvEntry(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TlvEntry(
            field_number=FfiConverterUInt64.read(buf),
            value=FfiConverterSequenceUInt8.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.field_number, buf)
        FfiConverterSequenceUInt8.write(value.value, buf)


class UnspentTransactionOutput:

    def __init__(self, txid, outnum, amount_millisatoshi, address, reserved):
        self.txid = txid
        self.outnum = outnum
        self.amount_millisatoshi = amount_millisatoshi
        self.address = address
        self.reserved = reserved

    def __str__(self):
        return "UnspentTransactionOutput(txid={}, outnum={}, amount_millisatoshi={}, address={}, reserved={})".format(self.txid, self.outnum, self.amount_millisatoshi, self.address, self.reserved)

    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        if self.outnum != other.outnum:
            return False
        if self.amount_millisatoshi != other.amount_millisatoshi:
            return False
        if self.address != other.address:
            return False
        if self.reserved != other.reserved:
            return False
        return True

class FfiConverterTypeUnspentTransactionOutput(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UnspentTransactionOutput(
            txid=FfiConverterSequenceUInt8.read(buf),
            outnum=FfiConverterUInt32.read(buf),
            amount_millisatoshi=FfiConverterUInt64.read(buf),
            address=FfiConverterString.read(buf),
            reserved=FfiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterSequenceUInt8.write(value.txid, buf)
        FfiConverterUInt32.write(value.outnum, buf)
        FfiConverterUInt64.write(value.amount_millisatoshi, buf)
        FfiConverterString.write(value.address, buf)
        FfiConverterBool.write(value.reserved, buf)


class UrlSuccessActionData:

    def __init__(self, description, url, matches_callback_domain):
        self.description = description
        self.url = url
        self.matches_callback_domain = matches_callback_domain

    def __str__(self):
        return "UrlSuccessActionData(description={}, url={}, matches_callback_domain={})".format(self.description, self.url, self.matches_callback_domain)

    def __eq__(self, other):
        if self.description != other.description:
            return False
        if self.url != other.url:
            return False
        if self.matches_callback_domain != other.matches_callback_domain:
            return False
        return True

class FfiConverterTypeUrlSuccessActionData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UrlSuccessActionData(
            description=FfiConverterString.read(buf),
            url=FfiConverterString.read(buf),
            matches_callback_domain=FfiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.description, buf)
        FfiConverterString.write(value.url, buf)
        FfiConverterBool.write(value.matches_callback_domain, buf)




class AesSuccessActionDataResult:
    def __init__(self):
        raise RuntimeError("AesSuccessActionDataResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class DECRYPTED(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "AesSuccessActionDataResult.DECRYPTED(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_decrypted():
                return False
            if self.data != other.data:
                return False
            return True
    class ERROR_STATUS(object):
        def __init__(self,reason):
            
            self.reason = reason
            

        def __str__(self):
            return "AesSuccessActionDataResult.ERROR_STATUS(reason={})".format(self.reason)

        def __eq__(self, other):
            if not other.is_error_status():
                return False
            if self.reason != other.reason:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_decrypted(self):
        return isinstance(self, AesSuccessActionDataResult.DECRYPTED)
    def is_error_status(self):
        return isinstance(self, AesSuccessActionDataResult.ERROR_STATUS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
AesSuccessActionDataResult.DECRYPTED = type("AesSuccessActionDataResult.DECRYPTED", (AesSuccessActionDataResult.DECRYPTED, AesSuccessActionDataResult,), {})
AesSuccessActionDataResult.ERROR_STATUS = type("AesSuccessActionDataResult.ERROR_STATUS", (AesSuccessActionDataResult.ERROR_STATUS, AesSuccessActionDataResult,), {})




class FfiConverterTypeAesSuccessActionDataResult(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return AesSuccessActionDataResult.DECRYPTED(
                FfiConverterTypeAesSuccessActionDataDecrypted.read(buf),
            )
        if variant == 2:
            return AesSuccessActionDataResult.ERROR_STATUS(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_decrypted():
            buf.writeI32(1)
            FfiConverterTypeAesSuccessActionDataDecrypted.write(value.data, buf)
        if value.is_error_status():
            buf.writeI32(2)
            FfiConverterString.write(value.reason, buf)




class BreezEvent:
    def __init__(self):
        raise RuntimeError("BreezEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NEW_BLOCK(object):
        def __init__(self,block):
            
            self.block = block
            

        def __str__(self):
            return "BreezEvent.NEW_BLOCK(block={})".format(self.block)

        def __eq__(self, other):
            if not other.is_new_block():
                return False
            if self.block != other.block:
                return False
            return True
    class INVOICE_PAID(object):
        def __init__(self,details):
            
            self.details = details
            

        def __str__(self):
            return "BreezEvent.INVOICE_PAID(details={})".format(self.details)

        def __eq__(self, other):
            if not other.is_invoice_paid():
                return False
            if self.details != other.details:
                return False
            return True
    class SYNCED(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "BreezEvent.SYNCED()".format()

        def __eq__(self, other):
            if not other.is_synced():
                return False
            return True
    class PAYMENT_SUCCEED(object):
        def __init__(self,details):
            
            self.details = details
            

        def __str__(self):
            return "BreezEvent.PAYMENT_SUCCEED(details={})".format(self.details)

        def __eq__(self, other):
            if not other.is_payment_succeed():
                return False
            if self.details != other.details:
                return False
            return True
    class PAYMENT_FAILED(object):
        def __init__(self,details):
            
            self.details = details
            

        def __str__(self):
            return "BreezEvent.PAYMENT_FAILED(details={})".format(self.details)

        def __eq__(self, other):
            if not other.is_payment_failed():
                return False
            if self.details != other.details:
                return False
            return True
    class BACKUP_STARTED(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "BreezEvent.BACKUP_STARTED()".format()

        def __eq__(self, other):
            if not other.is_backup_started():
                return False
            return True
    class BACKUP_SUCCEEDED(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "BreezEvent.BACKUP_SUCCEEDED()".format()

        def __eq__(self, other):
            if not other.is_backup_succeeded():
                return False
            return True
    class BACKUP_FAILED(object):
        def __init__(self,details):
            
            self.details = details
            

        def __str__(self):
            return "BreezEvent.BACKUP_FAILED(details={})".format(self.details)

        def __eq__(self, other):
            if not other.is_backup_failed():
                return False
            if self.details != other.details:
                return False
            return True
    class REVERSE_SWAP_UPDATED(object):
        def __init__(self,details):
            
            self.details = details
            

        def __str__(self):
            return "BreezEvent.REVERSE_SWAP_UPDATED(details={})".format(self.details)

        def __eq__(self, other):
            if not other.is_reverse_swap_updated():
                return False
            if self.details != other.details:
                return False
            return True
    class SWAP_UPDATED(object):
        def __init__(self,details):
            
            self.details = details
            

        def __str__(self):
            return "BreezEvent.SWAP_UPDATED(details={})".format(self.details)

        def __eq__(self, other):
            if not other.is_swap_updated():
                return False
            if self.details != other.details:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_new_block(self):
        return isinstance(self, BreezEvent.NEW_BLOCK)
    def is_invoice_paid(self):
        return isinstance(self, BreezEvent.INVOICE_PAID)
    def is_synced(self):
        return isinstance(self, BreezEvent.SYNCED)
    def is_payment_succeed(self):
        return isinstance(self, BreezEvent.PAYMENT_SUCCEED)
    def is_payment_failed(self):
        return isinstance(self, BreezEvent.PAYMENT_FAILED)
    def is_backup_started(self):
        return isinstance(self, BreezEvent.BACKUP_STARTED)
    def is_backup_succeeded(self):
        return isinstance(self, BreezEvent.BACKUP_SUCCEEDED)
    def is_backup_failed(self):
        return isinstance(self, BreezEvent.BACKUP_FAILED)
    def is_reverse_swap_updated(self):
        return isinstance(self, BreezEvent.REVERSE_SWAP_UPDATED)
    def is_swap_updated(self):
        return isinstance(self, BreezEvent.SWAP_UPDATED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
BreezEvent.NEW_BLOCK = type("BreezEvent.NEW_BLOCK", (BreezEvent.NEW_BLOCK, BreezEvent,), {})
BreezEvent.INVOICE_PAID = type("BreezEvent.INVOICE_PAID", (BreezEvent.INVOICE_PAID, BreezEvent,), {})
BreezEvent.SYNCED = type("BreezEvent.SYNCED", (BreezEvent.SYNCED, BreezEvent,), {})
BreezEvent.PAYMENT_SUCCEED = type("BreezEvent.PAYMENT_SUCCEED", (BreezEvent.PAYMENT_SUCCEED, BreezEvent,), {})
BreezEvent.PAYMENT_FAILED = type("BreezEvent.PAYMENT_FAILED", (BreezEvent.PAYMENT_FAILED, BreezEvent,), {})
BreezEvent.BACKUP_STARTED = type("BreezEvent.BACKUP_STARTED", (BreezEvent.BACKUP_STARTED, BreezEvent,), {})
BreezEvent.BACKUP_SUCCEEDED = type("BreezEvent.BACKUP_SUCCEEDED", (BreezEvent.BACKUP_SUCCEEDED, BreezEvent,), {})
BreezEvent.BACKUP_FAILED = type("BreezEvent.BACKUP_FAILED", (BreezEvent.BACKUP_FAILED, BreezEvent,), {})
BreezEvent.REVERSE_SWAP_UPDATED = type("BreezEvent.REVERSE_SWAP_UPDATED", (BreezEvent.REVERSE_SWAP_UPDATED, BreezEvent,), {})
BreezEvent.SWAP_UPDATED = type("BreezEvent.SWAP_UPDATED", (BreezEvent.SWAP_UPDATED, BreezEvent,), {})




class FfiConverterTypeBreezEvent(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return BreezEvent.NEW_BLOCK(
                FfiConverterUInt32.read(buf),
            )
        if variant == 2:
            return BreezEvent.INVOICE_PAID(
                FfiConverterTypeInvoicePaidDetails.read(buf),
            )
        if variant == 3:
            return BreezEvent.SYNCED(
            )
        if variant == 4:
            return BreezEvent.PAYMENT_SUCCEED(
                FfiConverterTypePayment.read(buf),
            )
        if variant == 5:
            return BreezEvent.PAYMENT_FAILED(
                FfiConverterTypePaymentFailedData.read(buf),
            )
        if variant == 6:
            return BreezEvent.BACKUP_STARTED(
            )
        if variant == 7:
            return BreezEvent.BACKUP_SUCCEEDED(
            )
        if variant == 8:
            return BreezEvent.BACKUP_FAILED(
                FfiConverterTypeBackupFailedData.read(buf),
            )
        if variant == 9:
            return BreezEvent.REVERSE_SWAP_UPDATED(
                FfiConverterTypeReverseSwapInfo.read(buf),
            )
        if variant == 10:
            return BreezEvent.SWAP_UPDATED(
                FfiConverterTypeSwapInfo.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_new_block():
            buf.writeI32(1)
            FfiConverterUInt32.write(value.block, buf)
        if value.is_invoice_paid():
            buf.writeI32(2)
            FfiConverterTypeInvoicePaidDetails.write(value.details, buf)
        if value.is_synced():
            buf.writeI32(3)
        if value.is_payment_succeed():
            buf.writeI32(4)
            FfiConverterTypePayment.write(value.details, buf)
        if value.is_payment_failed():
            buf.writeI32(5)
            FfiConverterTypePaymentFailedData.write(value.details, buf)
        if value.is_backup_started():
            buf.writeI32(6)
        if value.is_backup_succeeded():
            buf.writeI32(7)
        if value.is_backup_failed():
            buf.writeI32(8)
            FfiConverterTypeBackupFailedData.write(value.details, buf)
        if value.is_reverse_swap_updated():
            buf.writeI32(9)
            FfiConverterTypeReverseSwapInfo.write(value.details, buf)
        if value.is_swap_updated():
            buf.writeI32(10)
            FfiConverterTypeSwapInfo.write(value.details, buf)




class BuyBitcoinProvider(enum.Enum):
    MOONPAY = 1
    


class FfiConverterTypeBuyBitcoinProvider(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return BuyBitcoinProvider.MOONPAY
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == BuyBitcoinProvider.MOONPAY:
            buf.writeI32(1)




class ChannelState(enum.Enum):
    PENDING_OPEN = 1
    OPENED = 2
    PENDING_CLOSE = 3
    CLOSED = 4
    


class FfiConverterTypeChannelState(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ChannelState.PENDING_OPEN
        if variant == 2:
            return ChannelState.OPENED
        if variant == 3:
            return ChannelState.PENDING_CLOSE
        if variant == 4:
            return ChannelState.CLOSED
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ChannelState.PENDING_OPEN:
            buf.writeI32(1)
        if value == ChannelState.OPENED:
            buf.writeI32(2)
        if value == ChannelState.PENDING_CLOSE:
            buf.writeI32(3)
        if value == ChannelState.CLOSED:
            buf.writeI32(4)




class EnvironmentType(enum.Enum):
    PRODUCTION = 1
    STAGING = 2
    


class FfiConverterTypeEnvironmentType(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return EnvironmentType.PRODUCTION
        if variant == 2:
            return EnvironmentType.STAGING
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == EnvironmentType.PRODUCTION:
            buf.writeI32(1)
        if value == EnvironmentType.STAGING:
            buf.writeI32(2)




class FeeratePreset(enum.Enum):
    REGULAR = 1
    ECONOMY = 2
    PRIORITY = 3
    


class FfiConverterTypeFeeratePreset(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return FeeratePreset.REGULAR
        if variant == 2:
            return FeeratePreset.ECONOMY
        if variant == 3:
            return FeeratePreset.PRIORITY
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == FeeratePreset.REGULAR:
            buf.writeI32(1)
        if value == FeeratePreset.ECONOMY:
            buf.writeI32(2)
        if value == FeeratePreset.PRIORITY:
            buf.writeI32(3)




class HealthCheckStatus(enum.Enum):
    OPERATIONAL = 1
    MAINTENANCE = 2
    SERVICE_DISRUPTION = 3
    


class FfiConverterTypeHealthCheckStatus(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return HealthCheckStatus.OPERATIONAL
        if variant == 2:
            return HealthCheckStatus.MAINTENANCE
        if variant == 3:
            return HealthCheckStatus.SERVICE_DISRUPTION
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == HealthCheckStatus.OPERATIONAL:
            buf.writeI32(1)
        if value == HealthCheckStatus.MAINTENANCE:
            buf.writeI32(2)
        if value == HealthCheckStatus.SERVICE_DISRUPTION:
            buf.writeI32(3)




class InputType:
    def __init__(self):
        raise RuntimeError("InputType cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BITCOIN_ADDRESS(object):
        def __init__(self,address):
            
            self.address = address
            

        def __str__(self):
            return "InputType.BITCOIN_ADDRESS(address={})".format(self.address)

        def __eq__(self, other):
            if not other.is_bitcoin_address():
                return False
            if self.address != other.address:
                return False
            return True
    class BOLT11(object):
        def __init__(self,invoice):
            
            self.invoice = invoice
            

        def __str__(self):
            return "InputType.BOLT11(invoice={})".format(self.invoice)

        def __eq__(self, other):
            if not other.is_bolt11():
                return False
            if self.invoice != other.invoice:
                return False
            return True
    class NODE_ID(object):
        def __init__(self,node_id):
            
            self.node_id = node_id
            

        def __str__(self):
            return "InputType.NODE_ID(node_id={})".format(self.node_id)

        def __eq__(self, other):
            if not other.is_node_id():
                return False
            if self.node_id != other.node_id:
                return False
            return True
    class URL(object):
        def __init__(self,url):
            
            self.url = url
            

        def __str__(self):
            return "InputType.URL(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_url():
                return False
            if self.url != other.url:
                return False
            return True
    class LN_URL_PAY(object):
        def __init__(self,data, bip353_address):
            
            self.data = data
            self.bip353_address = bip353_address
            

        def __str__(self):
            return "InputType.LN_URL_PAY(data={}, bip353_address={})".format(self.data, self.bip353_address)

        def __eq__(self, other):
            if not other.is_ln_url_pay():
                return False
            if self.data != other.data:
                return False
            if self.bip353_address != other.bip353_address:
                return False
            return True
    class LN_URL_WITHDRAW(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "InputType.LN_URL_WITHDRAW(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_ln_url_withdraw():
                return False
            if self.data != other.data:
                return False
            return True
    class LN_URL_AUTH(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "InputType.LN_URL_AUTH(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_ln_url_auth():
                return False
            if self.data != other.data:
                return False
            return True
    class LN_URL_ERROR(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "InputType.LN_URL_ERROR(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_ln_url_error():
                return False
            if self.data != other.data:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_bitcoin_address(self):
        return isinstance(self, InputType.BITCOIN_ADDRESS)
    def is_bolt11(self):
        return isinstance(self, InputType.BOLT11)
    def is_node_id(self):
        return isinstance(self, InputType.NODE_ID)
    def is_url(self):
        return isinstance(self, InputType.URL)
    def is_ln_url_pay(self):
        return isinstance(self, InputType.LN_URL_PAY)
    def is_ln_url_withdraw(self):
        return isinstance(self, InputType.LN_URL_WITHDRAW)
    def is_ln_url_auth(self):
        return isinstance(self, InputType.LN_URL_AUTH)
    def is_ln_url_error(self):
        return isinstance(self, InputType.LN_URL_ERROR)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
InputType.BITCOIN_ADDRESS = type("InputType.BITCOIN_ADDRESS", (InputType.BITCOIN_ADDRESS, InputType,), {})
InputType.BOLT11 = type("InputType.BOLT11", (InputType.BOLT11, InputType,), {})
InputType.NODE_ID = type("InputType.NODE_ID", (InputType.NODE_ID, InputType,), {})
InputType.URL = type("InputType.URL", (InputType.URL, InputType,), {})
InputType.LN_URL_PAY = type("InputType.LN_URL_PAY", (InputType.LN_URL_PAY, InputType,), {})
InputType.LN_URL_WITHDRAW = type("InputType.LN_URL_WITHDRAW", (InputType.LN_URL_WITHDRAW, InputType,), {})
InputType.LN_URL_AUTH = type("InputType.LN_URL_AUTH", (InputType.LN_URL_AUTH, InputType,), {})
InputType.LN_URL_ERROR = type("InputType.LN_URL_ERROR", (InputType.LN_URL_ERROR, InputType,), {})




class FfiConverterTypeInputType(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return InputType.BITCOIN_ADDRESS(
                FfiConverterTypeBitcoinAddressData.read(buf),
            )
        if variant == 2:
            return InputType.BOLT11(
                FfiConverterTypeLnInvoice.read(buf),
            )
        if variant == 3:
            return InputType.NODE_ID(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return InputType.URL(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return InputType.LN_URL_PAY(
                FfiConverterTypeLnUrlPayRequestData.read(buf),
                FfiConverterOptionalString.read(buf),
            )
        if variant == 6:
            return InputType.LN_URL_WITHDRAW(
                FfiConverterTypeLnUrlWithdrawRequestData.read(buf),
            )
        if variant == 7:
            return InputType.LN_URL_AUTH(
                FfiConverterTypeLnUrlAuthRequestData.read(buf),
            )
        if variant == 8:
            return InputType.LN_URL_ERROR(
                FfiConverterTypeLnUrlErrorData.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_bitcoin_address():
            buf.writeI32(1)
            FfiConverterTypeBitcoinAddressData.write(value.address, buf)
        if value.is_bolt11():
            buf.writeI32(2)
            FfiConverterTypeLnInvoice.write(value.invoice, buf)
        if value.is_node_id():
            buf.writeI32(3)
            FfiConverterString.write(value.node_id, buf)
        if value.is_url():
            buf.writeI32(4)
            FfiConverterString.write(value.url, buf)
        if value.is_ln_url_pay():
            buf.writeI32(5)
            FfiConverterTypeLnUrlPayRequestData.write(value.data, buf)
            FfiConverterOptionalString.write(value.bip353_address, buf)
        if value.is_ln_url_withdraw():
            buf.writeI32(6)
            FfiConverterTypeLnUrlWithdrawRequestData.write(value.data, buf)
        if value.is_ln_url_auth():
            buf.writeI32(7)
            FfiConverterTypeLnUrlAuthRequestData.write(value.data, buf)
        if value.is_ln_url_error():
            buf.writeI32(8)
            FfiConverterTypeLnUrlErrorData.write(value.data, buf)




class LnUrlCallbackStatus:
    def __init__(self):
        raise RuntimeError("LnUrlCallbackStatus cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class OK(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "LnUrlCallbackStatus.OK()".format()

        def __eq__(self, other):
            if not other.is_ok():
                return False
            return True
    class ERROR_STATUS(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "LnUrlCallbackStatus.ERROR_STATUS(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_error_status():
                return False
            if self.data != other.data:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_ok(self):
        return isinstance(self, LnUrlCallbackStatus.OK)
    def is_error_status(self):
        return isinstance(self, LnUrlCallbackStatus.ERROR_STATUS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
LnUrlCallbackStatus.OK = type("LnUrlCallbackStatus.OK", (LnUrlCallbackStatus.OK, LnUrlCallbackStatus,), {})
LnUrlCallbackStatus.ERROR_STATUS = type("LnUrlCallbackStatus.ERROR_STATUS", (LnUrlCallbackStatus.ERROR_STATUS, LnUrlCallbackStatus,), {})




class FfiConverterTypeLnUrlCallbackStatus(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return LnUrlCallbackStatus.OK(
            )
        if variant == 2:
            return LnUrlCallbackStatus.ERROR_STATUS(
                FfiConverterTypeLnUrlErrorData.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_ok():
            buf.writeI32(1)
        if value.is_error_status():
            buf.writeI32(2)
            FfiConverterTypeLnUrlErrorData.write(value.data, buf)




class LnUrlPayResult:
    def __init__(self):
        raise RuntimeError("LnUrlPayResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ENDPOINT_SUCCESS(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "LnUrlPayResult.ENDPOINT_SUCCESS(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_endpoint_success():
                return False
            if self.data != other.data:
                return False
            return True
    class ENDPOINT_ERROR(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "LnUrlPayResult.ENDPOINT_ERROR(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_endpoint_error():
                return False
            if self.data != other.data:
                return False
            return True
    class PAY_ERROR(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "LnUrlPayResult.PAY_ERROR(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_pay_error():
                return False
            if self.data != other.data:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_endpoint_success(self):
        return isinstance(self, LnUrlPayResult.ENDPOINT_SUCCESS)
    def is_endpoint_error(self):
        return isinstance(self, LnUrlPayResult.ENDPOINT_ERROR)
    def is_pay_error(self):
        return isinstance(self, LnUrlPayResult.PAY_ERROR)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
LnUrlPayResult.ENDPOINT_SUCCESS = type("LnUrlPayResult.ENDPOINT_SUCCESS", (LnUrlPayResult.ENDPOINT_SUCCESS, LnUrlPayResult,), {})
LnUrlPayResult.ENDPOINT_ERROR = type("LnUrlPayResult.ENDPOINT_ERROR", (LnUrlPayResult.ENDPOINT_ERROR, LnUrlPayResult,), {})
LnUrlPayResult.PAY_ERROR = type("LnUrlPayResult.PAY_ERROR", (LnUrlPayResult.PAY_ERROR, LnUrlPayResult,), {})




class FfiConverterTypeLnUrlPayResult(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return LnUrlPayResult.ENDPOINT_SUCCESS(
                FfiConverterTypeLnUrlPaySuccessData.read(buf),
            )
        if variant == 2:
            return LnUrlPayResult.ENDPOINT_ERROR(
                FfiConverterTypeLnUrlErrorData.read(buf),
            )
        if variant == 3:
            return LnUrlPayResult.PAY_ERROR(
                FfiConverterTypeLnUrlPayErrorData.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_endpoint_success():
            buf.writeI32(1)
            FfiConverterTypeLnUrlPaySuccessData.write(value.data, buf)
        if value.is_endpoint_error():
            buf.writeI32(2)
            FfiConverterTypeLnUrlErrorData.write(value.data, buf)
        if value.is_pay_error():
            buf.writeI32(3)
            FfiConverterTypeLnUrlPayErrorData.write(value.data, buf)




class LnUrlWithdrawResult:
    def __init__(self):
        raise RuntimeError("LnUrlWithdrawResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class OK(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "LnUrlWithdrawResult.OK(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_ok():
                return False
            if self.data != other.data:
                return False
            return True
    class TIMEOUT(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "LnUrlWithdrawResult.TIMEOUT(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_timeout():
                return False
            if self.data != other.data:
                return False
            return True
    class ERROR_STATUS(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "LnUrlWithdrawResult.ERROR_STATUS(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_error_status():
                return False
            if self.data != other.data:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_ok(self):
        return isinstance(self, LnUrlWithdrawResult.OK)
    def is_timeout(self):
        return isinstance(self, LnUrlWithdrawResult.TIMEOUT)
    def is_error_status(self):
        return isinstance(self, LnUrlWithdrawResult.ERROR_STATUS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
LnUrlWithdrawResult.OK = type("LnUrlWithdrawResult.OK", (LnUrlWithdrawResult.OK, LnUrlWithdrawResult,), {})
LnUrlWithdrawResult.TIMEOUT = type("LnUrlWithdrawResult.TIMEOUT", (LnUrlWithdrawResult.TIMEOUT, LnUrlWithdrawResult,), {})
LnUrlWithdrawResult.ERROR_STATUS = type("LnUrlWithdrawResult.ERROR_STATUS", (LnUrlWithdrawResult.ERROR_STATUS, LnUrlWithdrawResult,), {})




class FfiConverterTypeLnUrlWithdrawResult(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return LnUrlWithdrawResult.OK(
                FfiConverterTypeLnUrlWithdrawSuccessData.read(buf),
            )
        if variant == 2:
            return LnUrlWithdrawResult.TIMEOUT(
                FfiConverterTypeLnUrlWithdrawSuccessData.read(buf),
            )
        if variant == 3:
            return LnUrlWithdrawResult.ERROR_STATUS(
                FfiConverterTypeLnUrlErrorData.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_ok():
            buf.writeI32(1)
            FfiConverterTypeLnUrlWithdrawSuccessData.write(value.data, buf)
        if value.is_timeout():
            buf.writeI32(2)
            FfiConverterTypeLnUrlWithdrawSuccessData.write(value.data, buf)
        if value.is_error_status():
            buf.writeI32(3)
            FfiConverterTypeLnUrlErrorData.write(value.data, buf)




class Network(enum.Enum):
    BITCOIN = 1
    TESTNET = 2
    SIGNET = 3
    REGTEST = 4
    


class FfiConverterTypeNetwork(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return Network.BITCOIN
        if variant == 2:
            return Network.TESTNET
        if variant == 3:
            return Network.SIGNET
        if variant == 4:
            return Network.REGTEST
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == Network.BITCOIN:
            buf.writeI32(1)
        if value == Network.TESTNET:
            buf.writeI32(2)
        if value == Network.SIGNET:
            buf.writeI32(3)
        if value == Network.REGTEST:
            buf.writeI32(4)




class NodeConfig:
    def __init__(self):
        raise RuntimeError("NodeConfig cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class GREENLIGHT(object):
        def __init__(self,config):
            
            self.config = config
            

        def __str__(self):
            return "NodeConfig.GREENLIGHT(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_greenlight():
                return False
            if self.config != other.config:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_greenlight(self):
        return isinstance(self, NodeConfig.GREENLIGHT)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
NodeConfig.GREENLIGHT = type("NodeConfig.GREENLIGHT", (NodeConfig.GREENLIGHT, NodeConfig,), {})




class FfiConverterTypeNodeConfig(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return NodeConfig.GREENLIGHT(
                FfiConverterTypeGreenlightNodeConfig.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_greenlight():
            buf.writeI32(1)
            FfiConverterTypeGreenlightNodeConfig.write(value.config, buf)




class NodeCredentials:
    def __init__(self):
        raise RuntimeError("NodeCredentials cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class GREENLIGHT(object):
        def __init__(self,credentials):
            
            self.credentials = credentials
            

        def __str__(self):
            return "NodeCredentials.GREENLIGHT(credentials={})".format(self.credentials)

        def __eq__(self, other):
            if not other.is_greenlight():
                return False
            if self.credentials != other.credentials:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_greenlight(self):
        return isinstance(self, NodeCredentials.GREENLIGHT)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
NodeCredentials.GREENLIGHT = type("NodeCredentials.GREENLIGHT", (NodeCredentials.GREENLIGHT, NodeCredentials,), {})




class FfiConverterTypeNodeCredentials(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return NodeCredentials.GREENLIGHT(
                FfiConverterTypeGreenlightDeviceCredentials.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_greenlight():
            buf.writeI32(1)
            FfiConverterTypeGreenlightDeviceCredentials.write(value.credentials, buf)




class PaymentDetails:
    def __init__(self):
        raise RuntimeError("PaymentDetails cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class LN(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "PaymentDetails.LN(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_ln():
                return False
            if self.data != other.data:
                return False
            return True
    class CLOSED_CHANNEL(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "PaymentDetails.CLOSED_CHANNEL(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_closed_channel():
                return False
            if self.data != other.data:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_ln(self):
        return isinstance(self, PaymentDetails.LN)
    def is_closed_channel(self):
        return isinstance(self, PaymentDetails.CLOSED_CHANNEL)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
PaymentDetails.LN = type("PaymentDetails.LN", (PaymentDetails.LN, PaymentDetails,), {})
PaymentDetails.CLOSED_CHANNEL = type("PaymentDetails.CLOSED_CHANNEL", (PaymentDetails.CLOSED_CHANNEL, PaymentDetails,), {})




class FfiConverterTypePaymentDetails(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return PaymentDetails.LN(
                FfiConverterTypeLnPaymentDetails.read(buf),
            )
        if variant == 2:
            return PaymentDetails.CLOSED_CHANNEL(
                FfiConverterTypeClosedChannelPaymentDetails.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_ln():
            buf.writeI32(1)
            FfiConverterTypeLnPaymentDetails.write(value.data, buf)
        if value.is_closed_channel():
            buf.writeI32(2)
            FfiConverterTypeClosedChannelPaymentDetails.write(value.data, buf)




class PaymentStatus(enum.Enum):
    PENDING = 1
    COMPLETE = 2
    FAILED = 3
    


class FfiConverterTypePaymentStatus(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return PaymentStatus.PENDING
        if variant == 2:
            return PaymentStatus.COMPLETE
        if variant == 3:
            return PaymentStatus.FAILED
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == PaymentStatus.PENDING:
            buf.writeI32(1)
        if value == PaymentStatus.COMPLETE:
            buf.writeI32(2)
        if value == PaymentStatus.FAILED:
            buf.writeI32(3)




class PaymentType(enum.Enum):
    SENT = 1
    RECEIVED = 2
    CLOSED_CHANNEL = 3
    


class FfiConverterTypePaymentType(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return PaymentType.SENT
        if variant == 2:
            return PaymentType.RECEIVED
        if variant == 3:
            return PaymentType.CLOSED_CHANNEL
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == PaymentType.SENT:
            buf.writeI32(1)
        if value == PaymentType.RECEIVED:
            buf.writeI32(2)
        if value == PaymentType.CLOSED_CHANNEL:
            buf.writeI32(3)




class PaymentTypeFilter(enum.Enum):
    SENT = 1
    RECEIVED = 2
    CLOSED_CHANNEL = 3
    


class FfiConverterTypePaymentTypeFilter(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return PaymentTypeFilter.SENT
        if variant == 2:
            return PaymentTypeFilter.RECEIVED
        if variant == 3:
            return PaymentTypeFilter.CLOSED_CHANNEL
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == PaymentTypeFilter.SENT:
            buf.writeI32(1)
        if value == PaymentTypeFilter.RECEIVED:
            buf.writeI32(2)
        if value == PaymentTypeFilter.CLOSED_CHANNEL:
            buf.writeI32(3)




class ReportIssueRequest:
    def __init__(self):
        raise RuntimeError("ReportIssueRequest cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PAYMENT_FAILURE(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "ReportIssueRequest.PAYMENT_FAILURE(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_payment_failure():
                return False
            if self.data != other.data:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_payment_failure(self):
        return isinstance(self, ReportIssueRequest.PAYMENT_FAILURE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ReportIssueRequest.PAYMENT_FAILURE = type("ReportIssueRequest.PAYMENT_FAILURE", (ReportIssueRequest.PAYMENT_FAILURE, ReportIssueRequest,), {})




class FfiConverterTypeReportIssueRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ReportIssueRequest.PAYMENT_FAILURE(
                FfiConverterTypeReportPaymentFailureDetails.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_payment_failure():
            buf.writeI32(1)
            FfiConverterTypeReportPaymentFailureDetails.write(value.data, buf)




class ReverseSwapStatus(enum.Enum):
    INITIAL = 1
    IN_PROGRESS = 2
    CANCELLED = 3
    COMPLETED_SEEN = 4
    COMPLETED_CONFIRMED = 5
    


class FfiConverterTypeReverseSwapStatus(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ReverseSwapStatus.INITIAL
        if variant == 2:
            return ReverseSwapStatus.IN_PROGRESS
        if variant == 3:
            return ReverseSwapStatus.CANCELLED
        if variant == 4:
            return ReverseSwapStatus.COMPLETED_SEEN
        if variant == 5:
            return ReverseSwapStatus.COMPLETED_CONFIRMED
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ReverseSwapStatus.INITIAL:
            buf.writeI32(1)
        if value == ReverseSwapStatus.IN_PROGRESS:
            buf.writeI32(2)
        if value == ReverseSwapStatus.CANCELLED:
            buf.writeI32(3)
        if value == ReverseSwapStatus.COMPLETED_SEEN:
            buf.writeI32(4)
        if value == ReverseSwapStatus.COMPLETED_CONFIRMED:
            buf.writeI32(5)




class SuccessActionProcessed:
    def __init__(self):
        raise RuntimeError("SuccessActionProcessed cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class AES(object):
        def __init__(self,result):
            
            self.result = result
            

        def __str__(self):
            return "SuccessActionProcessed.AES(result={})".format(self.result)

        def __eq__(self, other):
            if not other.is_aes():
                return False
            if self.result != other.result:
                return False
            return True
    class MESSAGE(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "SuccessActionProcessed.MESSAGE(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_message():
                return False
            if self.data != other.data:
                return False
            return True
    class URL(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "SuccessActionProcessed.URL(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_url():
                return False
            if self.data != other.data:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_aes(self):
        return isinstance(self, SuccessActionProcessed.AES)
    def is_message(self):
        return isinstance(self, SuccessActionProcessed.MESSAGE)
    def is_url(self):
        return isinstance(self, SuccessActionProcessed.URL)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
SuccessActionProcessed.AES = type("SuccessActionProcessed.AES", (SuccessActionProcessed.AES, SuccessActionProcessed,), {})
SuccessActionProcessed.MESSAGE = type("SuccessActionProcessed.MESSAGE", (SuccessActionProcessed.MESSAGE, SuccessActionProcessed,), {})
SuccessActionProcessed.URL = type("SuccessActionProcessed.URL", (SuccessActionProcessed.URL, SuccessActionProcessed,), {})




class FfiConverterTypeSuccessActionProcessed(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return SuccessActionProcessed.AES(
                FfiConverterTypeAesSuccessActionDataResult.read(buf),
            )
        if variant == 2:
            return SuccessActionProcessed.MESSAGE(
                FfiConverterTypeMessageSuccessActionData.read(buf),
            )
        if variant == 3:
            return SuccessActionProcessed.URL(
                FfiConverterTypeUrlSuccessActionData.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_aes():
            buf.writeI32(1)
            FfiConverterTypeAesSuccessActionDataResult.write(value.result, buf)
        if value.is_message():
            buf.writeI32(2)
            FfiConverterTypeMessageSuccessActionData.write(value.data, buf)
        if value.is_url():
            buf.writeI32(3)
            FfiConverterTypeUrlSuccessActionData.write(value.data, buf)




class SwapAmountType(enum.Enum):
    SEND = 1
    RECEIVE = 2
    


class FfiConverterTypeSwapAmountType(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return SwapAmountType.SEND
        if variant == 2:
            return SwapAmountType.RECEIVE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == SwapAmountType.SEND:
            buf.writeI32(1)
        if value == SwapAmountType.RECEIVE:
            buf.writeI32(2)




class SwapStatus(enum.Enum):
    INITIAL = 1
    WAITING_CONFIRMATION = 2
    REDEEMABLE = 3
    REDEEMED = 4
    REFUNDABLE = 5
    COMPLETED = 6
    


class FfiConverterTypeSwapStatus(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return SwapStatus.INITIAL
        if variant == 2:
            return SwapStatus.WAITING_CONFIRMATION
        if variant == 3:
            return SwapStatus.REDEEMABLE
        if variant == 4:
            return SwapStatus.REDEEMED
        if variant == 5:
            return SwapStatus.REFUNDABLE
        if variant == 6:
            return SwapStatus.COMPLETED
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == SwapStatus.INITIAL:
            buf.writeI32(1)
        if value == SwapStatus.WAITING_CONFIRMATION:
            buf.writeI32(2)
        if value == SwapStatus.REDEEMABLE:
            buf.writeI32(3)
        if value == SwapStatus.REDEEMED:
            buf.writeI32(4)
        if value == SwapStatus.REFUNDABLE:
            buf.writeI32(5)
        if value == SwapStatus.COMPLETED:
            buf.writeI32(6)



# ConnectError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class ConnectError(Exception):
        pass
    
    class Generic(ConnectError):
        def __str__(self):
            return "ConnectError.Generic({})".format(repr(super().__str__()))

    ConnectError.Generic = Generic
    class RestoreOnly(ConnectError):
        def __str__(self):
            return "ConnectError.RestoreOnly({})".format(repr(super().__str__()))

    ConnectError.RestoreOnly = RestoreOnly
    class ServiceConnectivity(ConnectError):
        def __str__(self):
            return "ConnectError.ServiceConnectivity({})".format(repr(super().__str__()))

    ConnectError.ServiceConnectivity = ServiceConnectivity
ConnectError = UniFFIExceptionTmpNamespace.ConnectError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeConnectError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ConnectError.Generic(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return ConnectError.RestoreOnly(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return ConnectError.ServiceConnectivity(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, ConnectError.Generic):
            buf.writeI32(1)
        if isinstance(value, ConnectError.RestoreOnly):
            buf.writeI32(2)
        if isinstance(value, ConnectError.ServiceConnectivity):
            buf.writeI32(3)



# LnUrlAuthError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class LnUrlAuthError(Exception):
        pass
    
    class Generic(LnUrlAuthError):
        def __str__(self):
            return "LnUrlAuthError.Generic({})".format(repr(super().__str__()))

    LnUrlAuthError.Generic = Generic
    class InvalidUri(LnUrlAuthError):
        def __str__(self):
            return "LnUrlAuthError.InvalidUri({})".format(repr(super().__str__()))

    LnUrlAuthError.InvalidUri = InvalidUri
    class ServiceConnectivity(LnUrlAuthError):
        def __str__(self):
            return "LnUrlAuthError.ServiceConnectivity({})".format(repr(super().__str__()))

    LnUrlAuthError.ServiceConnectivity = ServiceConnectivity
LnUrlAuthError = UniFFIExceptionTmpNamespace.LnUrlAuthError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeLnUrlAuthError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return LnUrlAuthError.Generic(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return LnUrlAuthError.InvalidUri(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return LnUrlAuthError.ServiceConnectivity(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, LnUrlAuthError.Generic):
            buf.writeI32(1)
        if isinstance(value, LnUrlAuthError.InvalidUri):
            buf.writeI32(2)
        if isinstance(value, LnUrlAuthError.ServiceConnectivity):
            buf.writeI32(3)



# LnUrlPayError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class LnUrlPayError(Exception):
        pass
    
    class AlreadyPaid(LnUrlPayError):
        def __str__(self):
            return "LnUrlPayError.AlreadyPaid({})".format(repr(super().__str__()))

    LnUrlPayError.AlreadyPaid = AlreadyPaid
    class Generic(LnUrlPayError):
        def __str__(self):
            return "LnUrlPayError.Generic({})".format(repr(super().__str__()))

    LnUrlPayError.Generic = Generic
    class InvalidAmount(LnUrlPayError):
        def __str__(self):
            return "LnUrlPayError.InvalidAmount({})".format(repr(super().__str__()))

    LnUrlPayError.InvalidAmount = InvalidAmount
    class InvalidInvoice(LnUrlPayError):
        def __str__(self):
            return "LnUrlPayError.InvalidInvoice({})".format(repr(super().__str__()))

    LnUrlPayError.InvalidInvoice = InvalidInvoice
    class InvalidNetwork(LnUrlPayError):
        def __str__(self):
            return "LnUrlPayError.InvalidNetwork({})".format(repr(super().__str__()))

    LnUrlPayError.InvalidNetwork = InvalidNetwork
    class InvalidUri(LnUrlPayError):
        def __str__(self):
            return "LnUrlPayError.InvalidUri({})".format(repr(super().__str__()))

    LnUrlPayError.InvalidUri = InvalidUri
    class InvoiceExpired(LnUrlPayError):
        def __str__(self):
            return "LnUrlPayError.InvoiceExpired({})".format(repr(super().__str__()))

    LnUrlPayError.InvoiceExpired = InvoiceExpired
    class PaymentFailed(LnUrlPayError):
        def __str__(self):
            return "LnUrlPayError.PaymentFailed({})".format(repr(super().__str__()))

    LnUrlPayError.PaymentFailed = PaymentFailed
    class PaymentTimeout(LnUrlPayError):
        def __str__(self):
            return "LnUrlPayError.PaymentTimeout({})".format(repr(super().__str__()))

    LnUrlPayError.PaymentTimeout = PaymentTimeout
    class RouteNotFound(LnUrlPayError):
        def __str__(self):
            return "LnUrlPayError.RouteNotFound({})".format(repr(super().__str__()))

    LnUrlPayError.RouteNotFound = RouteNotFound
    class RouteTooExpensive(LnUrlPayError):
        def __str__(self):
            return "LnUrlPayError.RouteTooExpensive({})".format(repr(super().__str__()))

    LnUrlPayError.RouteTooExpensive = RouteTooExpensive
    class ServiceConnectivity(LnUrlPayError):
        def __str__(self):
            return "LnUrlPayError.ServiceConnectivity({})".format(repr(super().__str__()))

    LnUrlPayError.ServiceConnectivity = ServiceConnectivity
    class InsufficientBalance(LnUrlPayError):
        def __str__(self):
            return "LnUrlPayError.InsufficientBalance({})".format(repr(super().__str__()))

    LnUrlPayError.InsufficientBalance = InsufficientBalance
LnUrlPayError = UniFFIExceptionTmpNamespace.LnUrlPayError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeLnUrlPayError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return LnUrlPayError.AlreadyPaid(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return LnUrlPayError.Generic(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return LnUrlPayError.InvalidAmount(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return LnUrlPayError.InvalidInvoice(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return LnUrlPayError.InvalidNetwork(
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return LnUrlPayError.InvalidUri(
                FfiConverterString.read(buf),
            )
        if variant == 7:
            return LnUrlPayError.InvoiceExpired(
                FfiConverterString.read(buf),
            )
        if variant == 8:
            return LnUrlPayError.PaymentFailed(
                FfiConverterString.read(buf),
            )
        if variant == 9:
            return LnUrlPayError.PaymentTimeout(
                FfiConverterString.read(buf),
            )
        if variant == 10:
            return LnUrlPayError.RouteNotFound(
                FfiConverterString.read(buf),
            )
        if variant == 11:
            return LnUrlPayError.RouteTooExpensive(
                FfiConverterString.read(buf),
            )
        if variant == 12:
            return LnUrlPayError.ServiceConnectivity(
                FfiConverterString.read(buf),
            )
        if variant == 13:
            return LnUrlPayError.InsufficientBalance(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, LnUrlPayError.AlreadyPaid):
            buf.writeI32(1)
        if isinstance(value, LnUrlPayError.Generic):
            buf.writeI32(2)
        if isinstance(value, LnUrlPayError.InvalidAmount):
            buf.writeI32(3)
        if isinstance(value, LnUrlPayError.InvalidInvoice):
            buf.writeI32(4)
        if isinstance(value, LnUrlPayError.InvalidNetwork):
            buf.writeI32(5)
        if isinstance(value, LnUrlPayError.InvalidUri):
            buf.writeI32(6)
        if isinstance(value, LnUrlPayError.InvoiceExpired):
            buf.writeI32(7)
        if isinstance(value, LnUrlPayError.PaymentFailed):
            buf.writeI32(8)
        if isinstance(value, LnUrlPayError.PaymentTimeout):
            buf.writeI32(9)
        if isinstance(value, LnUrlPayError.RouteNotFound):
            buf.writeI32(10)
        if isinstance(value, LnUrlPayError.RouteTooExpensive):
            buf.writeI32(11)
        if isinstance(value, LnUrlPayError.ServiceConnectivity):
            buf.writeI32(12)
        if isinstance(value, LnUrlPayError.InsufficientBalance):
            buf.writeI32(13)



# LnUrlWithdrawError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class LnUrlWithdrawError(Exception):
        pass
    
    class Generic(LnUrlWithdrawError):
        def __str__(self):
            return "LnUrlWithdrawError.Generic({})".format(repr(super().__str__()))

    LnUrlWithdrawError.Generic = Generic
    class InvalidAmount(LnUrlWithdrawError):
        def __str__(self):
            return "LnUrlWithdrawError.InvalidAmount({})".format(repr(super().__str__()))

    LnUrlWithdrawError.InvalidAmount = InvalidAmount
    class InvalidInvoice(LnUrlWithdrawError):
        def __str__(self):
            return "LnUrlWithdrawError.InvalidInvoice({})".format(repr(super().__str__()))

    LnUrlWithdrawError.InvalidInvoice = InvalidInvoice
    class InvalidUri(LnUrlWithdrawError):
        def __str__(self):
            return "LnUrlWithdrawError.InvalidUri({})".format(repr(super().__str__()))

    LnUrlWithdrawError.InvalidUri = InvalidUri
    class ServiceConnectivity(LnUrlWithdrawError):
        def __str__(self):
            return "LnUrlWithdrawError.ServiceConnectivity({})".format(repr(super().__str__()))

    LnUrlWithdrawError.ServiceConnectivity = ServiceConnectivity
    class InvoiceNoRoutingHints(LnUrlWithdrawError):
        def __str__(self):
            return "LnUrlWithdrawError.InvoiceNoRoutingHints({})".format(repr(super().__str__()))

    LnUrlWithdrawError.InvoiceNoRoutingHints = InvoiceNoRoutingHints
LnUrlWithdrawError = UniFFIExceptionTmpNamespace.LnUrlWithdrawError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeLnUrlWithdrawError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return LnUrlWithdrawError.Generic(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return LnUrlWithdrawError.InvalidAmount(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return LnUrlWithdrawError.InvalidInvoice(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return LnUrlWithdrawError.InvalidUri(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return LnUrlWithdrawError.ServiceConnectivity(
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return LnUrlWithdrawError.InvoiceNoRoutingHints(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, LnUrlWithdrawError.Generic):
            buf.writeI32(1)
        if isinstance(value, LnUrlWithdrawError.InvalidAmount):
            buf.writeI32(2)
        if isinstance(value, LnUrlWithdrawError.InvalidInvoice):
            buf.writeI32(3)
        if isinstance(value, LnUrlWithdrawError.InvalidUri):
            buf.writeI32(4)
        if isinstance(value, LnUrlWithdrawError.ServiceConnectivity):
            buf.writeI32(5)
        if isinstance(value, LnUrlWithdrawError.InvoiceNoRoutingHints):
            buf.writeI32(6)



# ReceiveOnchainError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class ReceiveOnchainError(Exception):
        pass
    
    class Generic(ReceiveOnchainError):
        def __str__(self):
            return "ReceiveOnchainError.Generic({})".format(repr(super().__str__()))

    ReceiveOnchainError.Generic = Generic
    class ServiceConnectivity(ReceiveOnchainError):
        def __str__(self):
            return "ReceiveOnchainError.ServiceConnectivity({})".format(repr(super().__str__()))

    ReceiveOnchainError.ServiceConnectivity = ServiceConnectivity
    class SwapInProgress(ReceiveOnchainError):
        def __str__(self):
            return "ReceiveOnchainError.SwapInProgress({})".format(repr(super().__str__()))

    ReceiveOnchainError.SwapInProgress = SwapInProgress
ReceiveOnchainError = UniFFIExceptionTmpNamespace.ReceiveOnchainError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeReceiveOnchainError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ReceiveOnchainError.Generic(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return ReceiveOnchainError.ServiceConnectivity(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return ReceiveOnchainError.SwapInProgress(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, ReceiveOnchainError.Generic):
            buf.writeI32(1)
        if isinstance(value, ReceiveOnchainError.ServiceConnectivity):
            buf.writeI32(2)
        if isinstance(value, ReceiveOnchainError.SwapInProgress):
            buf.writeI32(3)



# ReceivePaymentError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class ReceivePaymentError(Exception):
        pass
    
    class Generic(ReceivePaymentError):
        def __str__(self):
            return "ReceivePaymentError.Generic({})".format(repr(super().__str__()))

    ReceivePaymentError.Generic = Generic
    class InvalidAmount(ReceivePaymentError):
        def __str__(self):
            return "ReceivePaymentError.InvalidAmount({})".format(repr(super().__str__()))

    ReceivePaymentError.InvalidAmount = InvalidAmount
    class InvalidInvoice(ReceivePaymentError):
        def __str__(self):
            return "ReceivePaymentError.InvalidInvoice({})".format(repr(super().__str__()))

    ReceivePaymentError.InvalidInvoice = InvalidInvoice
    class InvoiceExpired(ReceivePaymentError):
        def __str__(self):
            return "ReceivePaymentError.InvoiceExpired({})".format(repr(super().__str__()))

    ReceivePaymentError.InvoiceExpired = InvoiceExpired
    class InvoiceNoDescription(ReceivePaymentError):
        def __str__(self):
            return "ReceivePaymentError.InvoiceNoDescription({})".format(repr(super().__str__()))

    ReceivePaymentError.InvoiceNoDescription = InvoiceNoDescription
    class InvoicePreimageAlreadyExists(ReceivePaymentError):
        def __str__(self):
            return "ReceivePaymentError.InvoicePreimageAlreadyExists({})".format(repr(super().__str__()))

    ReceivePaymentError.InvoicePreimageAlreadyExists = InvoicePreimageAlreadyExists
    class ServiceConnectivity(ReceivePaymentError):
        def __str__(self):
            return "ReceivePaymentError.ServiceConnectivity({})".format(repr(super().__str__()))

    ReceivePaymentError.ServiceConnectivity = ServiceConnectivity
    class InvoiceNoRoutingHints(ReceivePaymentError):
        def __str__(self):
            return "ReceivePaymentError.InvoiceNoRoutingHints({})".format(repr(super().__str__()))

    ReceivePaymentError.InvoiceNoRoutingHints = InvoiceNoRoutingHints
ReceivePaymentError = UniFFIExceptionTmpNamespace.ReceivePaymentError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeReceivePaymentError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ReceivePaymentError.Generic(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return ReceivePaymentError.InvalidAmount(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return ReceivePaymentError.InvalidInvoice(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return ReceivePaymentError.InvoiceExpired(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return ReceivePaymentError.InvoiceNoDescription(
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return ReceivePaymentError.InvoicePreimageAlreadyExists(
                FfiConverterString.read(buf),
            )
        if variant == 7:
            return ReceivePaymentError.ServiceConnectivity(
                FfiConverterString.read(buf),
            )
        if variant == 8:
            return ReceivePaymentError.InvoiceNoRoutingHints(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, ReceivePaymentError.Generic):
            buf.writeI32(1)
        if isinstance(value, ReceivePaymentError.InvalidAmount):
            buf.writeI32(2)
        if isinstance(value, ReceivePaymentError.InvalidInvoice):
            buf.writeI32(3)
        if isinstance(value, ReceivePaymentError.InvoiceExpired):
            buf.writeI32(4)
        if isinstance(value, ReceivePaymentError.InvoiceNoDescription):
            buf.writeI32(5)
        if isinstance(value, ReceivePaymentError.InvoicePreimageAlreadyExists):
            buf.writeI32(6)
        if isinstance(value, ReceivePaymentError.ServiceConnectivity):
            buf.writeI32(7)
        if isinstance(value, ReceivePaymentError.InvoiceNoRoutingHints):
            buf.writeI32(8)



# RedeemOnchainError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class RedeemOnchainError(Exception):
        pass
    
    class Generic(RedeemOnchainError):
        def __str__(self):
            return "RedeemOnchainError.Generic({})".format(repr(super().__str__()))

    RedeemOnchainError.Generic = Generic
    class ServiceConnectivity(RedeemOnchainError):
        def __str__(self):
            return "RedeemOnchainError.ServiceConnectivity({})".format(repr(super().__str__()))

    RedeemOnchainError.ServiceConnectivity = ServiceConnectivity
    class InsufficientFunds(RedeemOnchainError):
        def __str__(self):
            return "RedeemOnchainError.InsufficientFunds({})".format(repr(super().__str__()))

    RedeemOnchainError.InsufficientFunds = InsufficientFunds
RedeemOnchainError = UniFFIExceptionTmpNamespace.RedeemOnchainError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeRedeemOnchainError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return RedeemOnchainError.Generic(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return RedeemOnchainError.ServiceConnectivity(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return RedeemOnchainError.InsufficientFunds(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, RedeemOnchainError.Generic):
            buf.writeI32(1)
        if isinstance(value, RedeemOnchainError.ServiceConnectivity):
            buf.writeI32(2)
        if isinstance(value, RedeemOnchainError.InsufficientFunds):
            buf.writeI32(3)



# SdkError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class SdkError(Exception):
        pass
    
    class Generic(SdkError):
        def __str__(self):
            return "SdkError.Generic({})".format(repr(super().__str__()))

    SdkError.Generic = Generic
    class ServiceConnectivity(SdkError):
        def __str__(self):
            return "SdkError.ServiceConnectivity({})".format(repr(super().__str__()))

    SdkError.ServiceConnectivity = ServiceConnectivity
SdkError = UniFFIExceptionTmpNamespace.SdkError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeSdkError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return SdkError.Generic(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return SdkError.ServiceConnectivity(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, SdkError.Generic):
            buf.writeI32(1)
        if isinstance(value, SdkError.ServiceConnectivity):
            buf.writeI32(2)



# SendOnchainError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class SendOnchainError(Exception):
        pass
    
    class Generic(SendOnchainError):
        def __str__(self):
            return "SendOnchainError.Generic({})".format(repr(super().__str__()))

    SendOnchainError.Generic = Generic
    class InvalidDestinationAddress(SendOnchainError):
        def __str__(self):
            return "SendOnchainError.InvalidDestinationAddress({})".format(repr(super().__str__()))

    SendOnchainError.InvalidDestinationAddress = InvalidDestinationAddress
    class OutOfRange(SendOnchainError):
        def __str__(self):
            return "SendOnchainError.OutOfRange({})".format(repr(super().__str__()))

    SendOnchainError.OutOfRange = OutOfRange
    class PaymentFailed(SendOnchainError):
        def __str__(self):
            return "SendOnchainError.PaymentFailed({})".format(repr(super().__str__()))

    SendOnchainError.PaymentFailed = PaymentFailed
    class PaymentTimeout(SendOnchainError):
        def __str__(self):
            return "SendOnchainError.PaymentTimeout({})".format(repr(super().__str__()))

    SendOnchainError.PaymentTimeout = PaymentTimeout
    class ServiceConnectivity(SendOnchainError):
        def __str__(self):
            return "SendOnchainError.ServiceConnectivity({})".format(repr(super().__str__()))

    SendOnchainError.ServiceConnectivity = ServiceConnectivity
SendOnchainError = UniFFIExceptionTmpNamespace.SendOnchainError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeSendOnchainError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return SendOnchainError.Generic(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return SendOnchainError.InvalidDestinationAddress(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return SendOnchainError.OutOfRange(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return SendOnchainError.PaymentFailed(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return SendOnchainError.PaymentTimeout(
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return SendOnchainError.ServiceConnectivity(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, SendOnchainError.Generic):
            buf.writeI32(1)
        if isinstance(value, SendOnchainError.InvalidDestinationAddress):
            buf.writeI32(2)
        if isinstance(value, SendOnchainError.OutOfRange):
            buf.writeI32(3)
        if isinstance(value, SendOnchainError.PaymentFailed):
            buf.writeI32(4)
        if isinstance(value, SendOnchainError.PaymentTimeout):
            buf.writeI32(5)
        if isinstance(value, SendOnchainError.ServiceConnectivity):
            buf.writeI32(6)



# SendPaymentError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class SendPaymentError(Exception):
        pass
    
    class AlreadyPaid(SendPaymentError):
        def __str__(self):
            return "SendPaymentError.AlreadyPaid({})".format(repr(super().__str__()))

    SendPaymentError.AlreadyPaid = AlreadyPaid
    class Generic(SendPaymentError):
        def __str__(self):
            return "SendPaymentError.Generic({})".format(repr(super().__str__()))

    SendPaymentError.Generic = Generic
    class InvalidAmount(SendPaymentError):
        def __str__(self):
            return "SendPaymentError.InvalidAmount({})".format(repr(super().__str__()))

    SendPaymentError.InvalidAmount = InvalidAmount
    class InvalidInvoice(SendPaymentError):
        def __str__(self):
            return "SendPaymentError.InvalidInvoice({})".format(repr(super().__str__()))

    SendPaymentError.InvalidInvoice = InvalidInvoice
    class InvoiceExpired(SendPaymentError):
        def __str__(self):
            return "SendPaymentError.InvoiceExpired({})".format(repr(super().__str__()))

    SendPaymentError.InvoiceExpired = InvoiceExpired
    class InvalidNetwork(SendPaymentError):
        def __str__(self):
            return "SendPaymentError.InvalidNetwork({})".format(repr(super().__str__()))

    SendPaymentError.InvalidNetwork = InvalidNetwork
    class PaymentFailed(SendPaymentError):
        def __str__(self):
            return "SendPaymentError.PaymentFailed({})".format(repr(super().__str__()))

    SendPaymentError.PaymentFailed = PaymentFailed
    class PaymentTimeout(SendPaymentError):
        def __str__(self):
            return "SendPaymentError.PaymentTimeout({})".format(repr(super().__str__()))

    SendPaymentError.PaymentTimeout = PaymentTimeout
    class RouteNotFound(SendPaymentError):
        def __str__(self):
            return "SendPaymentError.RouteNotFound({})".format(repr(super().__str__()))

    SendPaymentError.RouteNotFound = RouteNotFound
    class RouteTooExpensive(SendPaymentError):
        def __str__(self):
            return "SendPaymentError.RouteTooExpensive({})".format(repr(super().__str__()))

    SendPaymentError.RouteTooExpensive = RouteTooExpensive
    class ServiceConnectivity(SendPaymentError):
        def __str__(self):
            return "SendPaymentError.ServiceConnectivity({})".format(repr(super().__str__()))

    SendPaymentError.ServiceConnectivity = ServiceConnectivity
    class InsufficientBalance(SendPaymentError):
        def __str__(self):
            return "SendPaymentError.InsufficientBalance({})".format(repr(super().__str__()))

    SendPaymentError.InsufficientBalance = InsufficientBalance
SendPaymentError = UniFFIExceptionTmpNamespace.SendPaymentError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeSendPaymentError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return SendPaymentError.AlreadyPaid(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return SendPaymentError.Generic(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return SendPaymentError.InvalidAmount(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return SendPaymentError.InvalidInvoice(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return SendPaymentError.InvoiceExpired(
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return SendPaymentError.InvalidNetwork(
                FfiConverterString.read(buf),
            )
        if variant == 7:
            return SendPaymentError.PaymentFailed(
                FfiConverterString.read(buf),
            )
        if variant == 8:
            return SendPaymentError.PaymentTimeout(
                FfiConverterString.read(buf),
            )
        if variant == 9:
            return SendPaymentError.RouteNotFound(
                FfiConverterString.read(buf),
            )
        if variant == 10:
            return SendPaymentError.RouteTooExpensive(
                FfiConverterString.read(buf),
            )
        if variant == 11:
            return SendPaymentError.ServiceConnectivity(
                FfiConverterString.read(buf),
            )
        if variant == 12:
            return SendPaymentError.InsufficientBalance(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, SendPaymentError.AlreadyPaid):
            buf.writeI32(1)
        if isinstance(value, SendPaymentError.Generic):
            buf.writeI32(2)
        if isinstance(value, SendPaymentError.InvalidAmount):
            buf.writeI32(3)
        if isinstance(value, SendPaymentError.InvalidInvoice):
            buf.writeI32(4)
        if isinstance(value, SendPaymentError.InvoiceExpired):
            buf.writeI32(5)
        if isinstance(value, SendPaymentError.InvalidNetwork):
            buf.writeI32(6)
        if isinstance(value, SendPaymentError.PaymentFailed):
            buf.writeI32(7)
        if isinstance(value, SendPaymentError.PaymentTimeout):
            buf.writeI32(8)
        if isinstance(value, SendPaymentError.RouteNotFound):
            buf.writeI32(9)
        if isinstance(value, SendPaymentError.RouteTooExpensive):
            buf.writeI32(10)
        if isinstance(value, SendPaymentError.ServiceConnectivity):
            buf.writeI32(11)
        if isinstance(value, SendPaymentError.InsufficientBalance):
            buf.writeI32(12)



import threading

class ConcurrentHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._left_map = {}  # type: Dict[Handle, Any]
        self._right_map = {}  # type: Dict[Any, Handle]

        self._lock = threading.Lock()
        self._current_handle = 0
        self._stride = 1


    def insert(self, obj):
        with self._lock:
            if obj in self._right_map:
                return self._right_map[obj]
            else:
                handle = self._current_handle
                self._current_handle += self._stride
                self._left_map[handle] = obj
                self._right_map[obj] = handle
                return handle

    def get(self, handle):
        with self._lock:
            return self._left_map.get(handle)

    def remove(self, handle):
        with self._lock:
            if handle in self._left_map:
                obj = self._left_map.pop(handle)
                del self._right_map[obj]
                return obj

# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
IDX_CALLBACK_FREE = 0

class FfiConverterCallbackInterface:
    _handle_map = ConcurrentHandleMap()

    def __init__(self, cb):
        self._foreign_callback = cb

    def drop(self, handle):
        self.__class__._handle_map.remove(handle)

    @classmethod
    def lift(cls, handle):
        obj = cls._handle_map.get(handle)
        if not obj:
            raise InternalError("The object in the handle map has been dropped already")

        return obj

    @classmethod
    def read(cls, buf):
        handle = buf.readU64()
        cls.lift(handle)

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.writeU64(cls.lower(cb))

# Declaration and FfiConverters for EventListener Callback Interface

class EventListener:
    def on_event(e):
        raise NotImplementedError

    

def py_foreignCallbackCallbackInterfaceEventListener(handle, method, args, buf_ptr):
    
    def invoke_on_event(python_callback, args):
        with args.consumeWithStream() as buf:
            rval = python_callback.on_event(
                FfiConverterTypeBreezEvent.read(buf)
                )
        return RustBuffer.alloc(0)
        

    cb = FfiConverterCallbackInterfaceEventListener.lift(handle)
    if not cb:
        raise InternalError("No callback in handlemap; this is a Uniffi bug")

    if method == IDX_CALLBACK_FREE:
        FfiConverterCallbackInterfaceEventListener.drop(handle)
        # No return value.
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
        return 0

    if method == 1:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs` for details
        try:
            # Successful return
            buf_ptr[0] = invoke_on_event(cb, args)
            return 1
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = FfiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return -1
    

    # This should never happen, because an out of bounds method index won't
    # ever be used. Once we can catch errors, we should return an InternalException.
    # https://github.com/mozilla/uniffi-rs/issues/351

    # An unexpected error happened.
    # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
    return -1

# We need to keep this function reference alive:
# if they get GC'd while in use then UniFFI internals could attempt to call a function
# that is in freed memory.
# That would be...uh...bad. Yeah, that's the word. Bad.
foreignCallbackCallbackInterfaceEventListener = FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceEventListener)

# The FfiConverter which transforms the Callbacks in to Handles to pass to Rust.
rust_call(lambda err: _UniFFILib.ffi_breez_sdk_a865_EventListener_init_callback(foreignCallbackCallbackInterfaceEventListener, err))
FfiConverterCallbackInterfaceEventListener = FfiConverterCallbackInterface(foreignCallbackCallbackInterfaceEventListener)





# Declaration and FfiConverters for LogStream Callback Interface

class LogStream:
    def log(l):
        raise NotImplementedError

    

def py_foreignCallbackCallbackInterfaceLogStream(handle, method, args, buf_ptr):
    
    def invoke_log(python_callback, args):
        with args.consumeWithStream() as buf:
            rval = python_callback.log(
                FfiConverterTypeLogEntry.read(buf)
                )
        return RustBuffer.alloc(0)
        

    cb = FfiConverterCallbackInterfaceLogStream.lift(handle)
    if not cb:
        raise InternalError("No callback in handlemap; this is a Uniffi bug")

    if method == IDX_CALLBACK_FREE:
        FfiConverterCallbackInterfaceLogStream.drop(handle)
        # No return value.
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
        return 0

    if method == 1:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs` for details
        try:
            # Successful return
            buf_ptr[0] = invoke_log(cb, args)
            return 1
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = FfiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return -1
    

    # This should never happen, because an out of bounds method index won't
    # ever be used. Once we can catch errors, we should return an InternalException.
    # https://github.com/mozilla/uniffi-rs/issues/351

    # An unexpected error happened.
    # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
    return -1

# We need to keep this function reference alive:
# if they get GC'd while in use then UniFFI internals could attempt to call a function
# that is in freed memory.
# That would be...uh...bad. Yeah, that's the word. Bad.
foreignCallbackCallbackInterfaceLogStream = FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceLogStream)

# The FfiConverter which transforms the Callbacks in to Handles to pass to Rust.
rust_call(lambda err: _UniFFILib.ffi_breez_sdk_a865_LogStream_init_callback(foreignCallbackCallbackInterfaceLogStream, err))
FfiConverterCallbackInterfaceLogStream = FfiConverterCallbackInterface(foreignCallbackCallbackInterfaceLogStream)



class FfiConverterOptionalUInt32(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalUInt64(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalInt64(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalBool(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterBool.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterBool.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeGreenlightCredentials(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeGreenlightCredentials.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeGreenlightCredentials.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeLnInvoice(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeLnInvoice.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeLnInvoice.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeLspInformation(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeLspInformation.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeLspInformation.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeOpeningFeeParams(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeOpeningFeeParams.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeOpeningFeeParams.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypePayment(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypePayment.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypePayment.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeReverseSwapInfo(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeReverseSwapInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeReverseSwapInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeSwapInfo(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeSwapInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeSwapInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeSymbol(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeSymbol.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeSymbol.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeNodeCredentials(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeNodeCredentials.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeNodeCredentials.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeSuccessActionProcessed(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeSuccessActionProcessed.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeSuccessActionProcessed.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceUInt8(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceUInt8.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceUInt8.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceTypeMetadataFilter(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceTypeMetadataFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceTypeMetadataFilter.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceTypeTlvEntry(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceTypeTlvEntry.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceTypeTlvEntry.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceTypePaymentTypeFilter(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceTypePaymentTypeFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceTypePaymentTypeFilter.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceTypeSwapStatus(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceTypeSwapStatus.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceTypeSwapStatus.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterSequenceUInt8(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterUInt8.read(buf) for i in range(count)
        ]



class FfiConverterSequenceString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterString.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeFiatCurrency(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeFiatCurrency.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeFiatCurrency.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeLocaleOverrides(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeLocaleOverrides.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeLocaleOverrides.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeLocalizedName(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeLocalizedName.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeLocalizedName.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeLspInformation(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeLspInformation.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeLspInformation.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeMetadataFilter(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeMetadataFilter.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeMetadataFilter.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeOpeningFeeParams(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeOpeningFeeParams.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeOpeningFeeParams.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypePayment(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypePayment.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypePayment.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeRate(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeRate.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeRate.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeReverseSwapInfo(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeReverseSwapInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeReverseSwapInfo.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeRouteHint(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeRouteHint.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeRouteHint.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeRouteHintHop(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeRouteHintHop.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeRouteHintHop.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeSwapInfo(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeSwapInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeSwapInfo.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeTlvEntry(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeTlvEntry.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeTlvEntry.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeUnspentTransactionOutput(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeUnspentTransactionOutput.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeUnspentTransactionOutput.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypePaymentTypeFilter(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypePaymentTypeFilter.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypePaymentTypeFilter.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeSwapStatus(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeSwapStatus.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeSwapStatus.read(buf) for i in range(count)
        ]

def connect(req,listener):
    req = req
    
    listener = listener
    
    return FfiConverterTypeBlockingBreezServices.lift(rust_call_with_error(FfiConverterTypeConnectError,_UniFFILib.breez_sdk_a865_connect,
        FfiConverterTypeConnectRequest.lower(req),
        FfiConverterCallbackInterfaceEventListener.lower(listener)))



def set_log_stream(log_stream):
    log_stream = log_stream
    
    rust_call_with_error(FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_set_log_stream,
        FfiConverterCallbackInterfaceLogStream.lower(log_stream))


def parse_invoice(invoice):
    invoice = invoice
    
    return FfiConverterTypeLnInvoice.lift(rust_call_with_error(FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_parse_invoice,
        FfiConverterString.lower(invoice)))



def parse_input(s):
    s = s
    
    return FfiConverterTypeInputType.lift(rust_call_with_error(FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_parse_input,
        FfiConverterString.lower(s)))



def mnemonic_to_seed(phrase):
    phrase = phrase
    
    return FfiConverterSequenceUInt8.lift(rust_call_with_error(FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_mnemonic_to_seed,
        FfiConverterString.lower(phrase)))



def default_config(env_type,api_key,node_config):
    env_type = env_type
    
    api_key = api_key
    
    node_config = node_config
    
    return FfiConverterTypeConfig.lift(rust_call(_UniFFILib.breez_sdk_a865_default_config,
        FfiConverterTypeEnvironmentType.lower(env_type),
        FfiConverterString.lower(api_key),
        FfiConverterTypeNodeConfig.lower(node_config)))



def static_backup(req):
    req = req
    
    return FfiConverterTypeStaticBackupResponse.lift(rust_call_with_error(FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_static_backup,
        FfiConverterTypeStaticBackupRequest.lower(req)))



def service_health_check(api_key):
    api_key = api_key
    
    return FfiConverterTypeServiceHealthCheckResponse.lift(rust_call_with_error(FfiConverterTypeSdkError,_UniFFILib.breez_sdk_a865_service_health_check,
        FfiConverterString.lower(api_key)))



__all__ = [
    "InternalError",
    "AesSuccessActionDataResult",
    "BreezEvent",
    "BuyBitcoinProvider",
    "ChannelState",
    "EnvironmentType",
    "FeeratePreset",
    "HealthCheckStatus",
    "InputType",
    "LnUrlCallbackStatus",
    "LnUrlPayResult",
    "LnUrlWithdrawResult",
    "Network",
    "NodeConfig",
    "NodeCredentials",
    "PaymentDetails",
    "PaymentStatus",
    "PaymentType",
    "PaymentTypeFilter",
    "ReportIssueRequest",
    "ReverseSwapStatus",
    "SuccessActionProcessed",
    "SwapAmountType",
    "SwapStatus",
    "AesSuccessActionDataDecrypted",
    "BackupFailedData",
    "BackupStatus",
    "BitcoinAddressData",
    "BuyBitcoinRequest",
    "BuyBitcoinResponse",
    "CheckMessageRequest",
    "CheckMessageResponse",
    "ClosedChannelPaymentDetails",
    "Config",
    "ConfigureNodeRequest",
    "ConnectRequest",
    "CurrencyInfo",
    "FiatCurrency",
    "GreenlightCredentials",
    "GreenlightDeviceCredentials",
    "GreenlightNodeConfig",
    "InvoicePaidDetails",
    "LnInvoice",
    "ListPaymentsRequest",
    "ListSwapsRequest",
    "LnPaymentDetails",
    "LnUrlAuthRequestData",
    "LnUrlErrorData",
    "LnUrlPayErrorData",
    "LnUrlPayRequest",
    "LnUrlPayRequestData",
    "LnUrlPaySuccessData",
    "LnUrlWithdrawRequest",
    "LnUrlWithdrawRequestData",
    "LnUrlWithdrawSuccessData",
    "LocaleOverrides",
    "LocalizedName",
    "LogEntry",
    "LspInformation",
    "MessageSuccessActionData",
    "MetadataFilter",
    "MetadataItem",
    "NodeState",
    "OnchainPaymentLimitsResponse",
    "OpenChannelFeeRequest",
    "OpenChannelFeeResponse",
    "OpeningFeeParams",
    "OpeningFeeParamsMenu",
    "PayOnchainRequest",
    "PayOnchainResponse",
    "Payment",
    "PaymentFailedData",
    "PrepareOnchainPaymentRequest",
    "PrepareOnchainPaymentResponse",
    "PrepareRedeemOnchainFundsRequest",
    "PrepareRedeemOnchainFundsResponse",
    "PrepareRefundRequest",
    "PrepareRefundResponse",
    "Rate",
    "ReceiveOnchainRequest",
    "ReceivePaymentRequest",
    "ReceivePaymentResponse",
    "RecommendedFees",
    "RedeemOnchainFundsRequest",
    "RedeemOnchainFundsResponse",
    "RefundRequest",
    "RefundResponse",
    "ReportPaymentFailureDetails",
    "ReverseSwapFeesRequest",
    "ReverseSwapInfo",
    "ReverseSwapPairInfo",
    "RouteHint",
    "RouteHintHop",
    "SendPaymentRequest",
    "SendPaymentResponse",
    "SendSpontaneousPaymentRequest",
    "ServiceHealthCheckResponse",
    "SignMessageRequest",
    "SignMessageResponse",
    "StaticBackupRequest",
    "StaticBackupResponse",
    "SwapInfo",
    "Symbol",
    "TlvEntry",
    "UnspentTransactionOutput",
    "UrlSuccessActionData",
    "connect",
    "set_log_stream",
    "parse_invoice",
    "parse_input",
    "mnemonic_to_seed",
    "default_config",
    "static_backup",
    "service_health_check",
    "BlockingBreezServices",
    "ConnectError",
    "LnUrlAuthError",
    "LnUrlPayError",
    "LnUrlWithdrawError",
    "ReceiveOnchainError",
    "ReceivePaymentError",
    "RedeemOnchainError",
    "SdkError",
    "SendOnchainError",
    "SendPaymentError",
    "LogStream",
    "EventListener",
]

