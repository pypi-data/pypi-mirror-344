{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":"<p>attrsx \u2013 An Extension to attrs for Declarative Handler Injection &amp; Integrated Logging</p>"},{"location":"#1-purpose","title":"1. Purpose","text":"<p><code>attrsx</code> builds on top of the <code>attrs</code> data\u2011class library and contributes two orthogonal capabilities that are frequently needed in service\u2011layer and infrastructure code:</p> <ol> <li>Integrated Logging\u00a0\u2013 transparent, boilerplate\u2011free creation of a configured <code>logging.Logger</code> for every instance.</li> <li>Declarative Handler Injection\u00a0\u2013 generation of lazy\u2011initialised strategy objects (\u201chandlers\u201d) declared via <code>handler_specs</code>.</li> </ol> <p>Both features are opt\u2011in; if a class does not request them, <code>attrsx.define</code> behaves exactly like <code>attrs.define</code>.</p>"},{"location":"#2-key-features","title":"2. Key Features","text":"<ul> <li> <p>Drop-in replacement for <code>attrs.define</code> \u2013 forwards every keyword parameter that <code>attrs.define</code> understands (<code>slots</code>, <code>frozen</code>, <code>kw_only</code>, validators, converters, \u2026).</p> </li> <li> <p>Integrated logging \u2013 injects four fields (<code>logger</code>, <code>loggerLvl</code>, <code>logger_name</code>, <code>logger_format</code>) and wraps <code>__attrs_post_init__</code> to attaches a <code>logging.logger</code>      to the instance if none is present.  The logger\u2019s name defaults to the class name; level and format are configurable per instance.</p> </li> <li> <p>Declarative handler injection \u2013 for each entry in <code>handler_specs={\"key\": HandlerClass, ...}</code> the decorator adds three fields   (<code>&lt;key&gt;_class</code>, <code>&lt;key&gt;_params</code>, <code>&lt;key&gt;_h</code>) plus a lazy factory method <code>_initialize_&lt;key&gt;_h()</code>, which calls <code>&lt;key&gt;_class(**&lt;key&gt;_params)</code> the first time it is invoked.</p> </li> <li> <p>Type-hint compliance \u2013 all generated attributes are inserted into <code>__annotations__</code>, so static type-checkers recognise them.</p> </li> <li> <p>Zero runtime overhead \u2013 field and method generation is performed once, at import time; normal instance construction stays on the <code>attrs</code> fast path.</p> </li> </ul>"},{"location":"#3-underlying-pattern","title":"3. Underlying Pattern","text":"<p>The handler mechanism realises Declarative Handler Injection (a variant of the Strategy pattern implemented through composition and a lazy factory method).  Configuration is expressed as data, leaving the host class agnostic of concrete strategy classes.</p>"},{"location":"#4-when-to-use","title":"4. When to Use","text":"<ul> <li>You need consistent, ready\u2011to\u2011use logging across many small classes.</li> <li>You want to supply interchangeable helper or strategy objects without manual glue code.</li> <li>You prefer composition over inheritance but dislike factory boilerplate.</li> </ul> <p>If none of the above apply, simply continue to use <code>attrs.define</code>; the migration path is one import statement.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install attrsx\n</code></pre>"},{"location":"description/","title":"Description","text":"<pre><code>import attrsx\nimport attrs\n</code></pre>"},{"location":"description/#usage","title":"Usage","text":""},{"location":"description/#1-built-in-logger","title":"1. Built-in logger","text":"<p>One of the primary extensions in <code>attrsx</code> is automatic logging. It can be accessed via <code>self.logger</code> in any <code>attrsx</code>-decorated class.</p>"},{"location":"description/#basic-logger-usage","title":"Basic Logger Usage","text":"<pre><code>@attrsx.define\nclass ProcessData:\n    data: str = attrs.field(default=None)\n\n    def run(self):\n        self.logger.info(\"Running data processing...\")\n        self.logger.debug(f\"Processing data: {self.data}\")\n        return f\"Processed: {self.data}\"\n\n</code></pre> <pre><code>ProcessData(data = \"data\").run()\n</code></pre> <pre><code>INFO:ProcessData:Running data processing...\n\n\n\n\n\n'Processed: data'\n</code></pre>"},{"location":"description/#logger-configuration","title":"Logger Configuration","text":"<p>The logging behavior can be customized using the following optional attributes:</p> <ul> <li><code>loggerLvl</code> : Sets the log level (from <code>logging</code>), defaults to <code>logging.INFO</code>.</li> <li><code>logger_name</code> : Specifies the logger name; defaults to the class name.</li> <li><code>logger_format</code> : Sets the logging message format, defaults to <code>%(levelname)s:%(name)s:%(message)s</code>.</li> </ul> <p><code>self.logger</code> becomes available starting from <code>__attrs_post_init__</code>.</p> <pre><code>import logging\n\n@attrsx.define\nclass VerboseProcess:\n    data: str = attrs.field(default=None)\n    loggerLvl: int = attrs.field(default=logging.DEBUG)\n    logger_format: str = attrs.field(\n        default=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n    )\n\n    def __attrs_post_init__(self):\n        self.logger.info(\"Custom post-init logic\")\n        self.data = \"DATA\"\n\n    def run(self):\n        self.logger.debug(\"Processing %s\", self.data)\n        return f\"Processed: {self.data}\"\n\n</code></pre> <pre><code>VerboseProcess(data = \"data\").run()\n</code></pre> <pre><code>2025-05-01 16:04:38,304 - VerboseProcess - INFO - Custom post-init logic\n2025-05-01 16:04:38,305 - VerboseProcess - DEBUG - Processing DATA\n\n\n\n\n\n'Processed: DATA'\n</code></pre>"},{"location":"description/#using-external-loggers","title":"Using External Loggers","text":"<p>An external, pre-initialized logger can also be provided to the class using the <code>logger</code> attribute.</p> <pre><code>shared_logger = ProcessData().logger\n\nVerboseProcess(\n    data = \"data\",\n    logger = shared_logger\n).run()\n</code></pre> <pre><code>INFO:ProcessData:Custom post-init logic\n\n\n\n\n\n'Processed: DATA'\n</code></pre>"},{"location":"description/#2-built-in-handlers","title":"2. Built-in handlers","text":"<p>Another extension in <code>attrsx</code> is <code>built-in handlers</code>. This feature is meant to help plug interchangeable helper objects (\u201chandlers\u201d) into a host class declaratively, without manual wiring, in a way that allows for both providing initialized handlers as well as initializing handlers within a class. </p> <p>The main class has access to methods of handler classes, can reinitialize them or reset them in a well defined way, where most additional code is added automatically by the library to the class.</p>"},{"location":"description/#adding-handlers-to-a-class","title":"Adding handlers to a class","text":"<p>To add handlers to an <code>attrsx</code> class, one can take advantage of <code>handler_specs</code> parameter within <code>@attrsx.define</code>, which takes a dictionary, where key is alias for the handler and value is the handler class.</p> <pre><code>@attrsx.define(handler_specs={\"procd\": ProcessData})\nclass Service:\n    def run(self, data: str):\n        self.logger.info(\"Calling procd handler\")\n        self._initialize_procd_h(uparams={\"data\": data})\n        return self.procd_h.run()\n\n</code></pre> <pre><code>Service().run(\"some data\")\n</code></pre> <pre><code>INFO:Service:Calling procd handler\nINFO:ProcessData:Running data processing...\n\n\n\n\n\n'Processed: some data'\n</code></pre> <p>For each handler in provided via <code>handler_specs</code> in definition of <code>NewClass</code> as :</p> <pre><code>@attrsx.define(handler_specs = {\n    'handler_alias' : HandlerClass, ..., \n    'another_handler_alias_n' : AnotherHandlerClass})\nclass NewClass:\n    ...\n</code></pre> <p>the class gets the following attributes:</p> <ul> <li><code>{handler_alias}_h</code> : an instance of the handler, by default set to <code>None</code></li> <li><code>{handler_alias}_class</code> : a class of the handler, will be used if corresponding instance is None, when initialized</li> <li><code>{handler_alias}_params</code> : parameters that should be used for creating new instance of the handler, using handler class</li> </ul> <p>and a function:</p> <pre><code>def _initialize_{handler_alias}_h(self, params : dict = None, uparams : dict = None):\n\n    if params is None:\n        params = self.{handler_alias}_params\n\n    if uparams is not None:\n        params.update(uparams)\n\n    if self.{handler_alias}_h is None:\n        self.{handler_alias}_h = self.{handler_alias}_class(**params)\n</code></pre> <p>which checks is initialized instance was already provided and if not, initializes handler with provided parameters.</p> <p>To achieve the same with regular <code>attrs</code>, the <code>NewClass</code> could be defined in the following way, which would work exactly the same:</p> <pre><code>@attrs.define\nclass NewClass:\n    ...\n\n    handler_alias_h = attrs.field(default=None)\n    handler_alias_class = attrs.field(default=HandlerClass)\n    handler_alias_params = attrs.field(default={})\n\n    another_handler_alias_n_h = attrs.field(default=None)\n    another_handler_alias_n_class = attrs.field(default=AnotherHandlerClass)\n    another_handler_alias_n_params = attrs.field(default={})\n\n    logger_chaining = attrs.field(default={\n        'loggerLvl' : True, \n        'logger' : False, \n        'logger_format' : True})\n\n    def _apply_logger_chaining(self, handler_class, params):\n\n        if self.logger_chaining.get(\"logger\"):\n            if ('logger' in handler_class.__dict__) \\\n                    and \"logger\" not in params.keys():\n                params[\"logger\"] = self.logger\n\n        if self.logger_chaining.get(\"loggerLvl\"):\n\n            if ('loggerLvl' in handler_class.__dict__) \\\n                    and \"loggerLvl\" not in params.keys():\n                params[\"loggerLvl\"] = self.loggerLvl\n\n        if self.logger_chaining.get(\"logger_format\"):\n\n            if ('logger_format' in handler_class.__dict__) \\\n                    and \"logger_format\" not in params.keys():\n                params[\"logger_format\"] = self.logger_format\n\n        return params\n\n    def _initialize_handler_alias_h(self, params : dict = None, uparams : dict = None):\n\n        if params is None:\n            params = self.handler_alias_params\n\n        if uparams is not None:\n            params.update(uparams)\n\n        params = self._apply_logger_chaining(\n            handler_class = self.handler_alias_class, \n            params = params)\n\n        if self.handler_alias_h is None:\n            self.handler_alias_n_h = self.handler_alias_class(**params)\n\n    def _initialize_another_handler_alias_n_h(self, params : dict = None, uparams : dict = None):\n\n        if params is None:\n            params = self.another_handler_alias_n_params\n\n        if uparams is not None:\n            params.update(uparams)\n\n        params = self._apply_logger_chaining(\n            handler_class = self.another_handler_alias_n_class, \n            params = params)\n\n        if self.another_handler_alias_n_h is None:\n            self.another_handler_alias_n_h = self.another_handler_alias_n_class(**params)\n\n</code></pre>"},{"location":"description/#setting-default-parameters","title":"Setting default parameters","text":"<p>For each handler there is <code>{handler_alias}_params</code> within new class, which can be used to provide parameters for handler initialization. </p> <p>Sometimes there is a need to extend or update default parameters and initialize/reinitialize the handler. Each handler has <code>_initialize_{handler_alias}_h</code> method within new class to which new default params (parameters that one would use when initializing handler class) could be passed via <code>params</code> and update to these or <code>{handler_alias}_params</code> via <code>uparams</code>.</p> <pre><code>@attrsx.define(handler_specs = {'procd' : ProcessData})\nclass Service:\n    data: str = attrs.field(default=None)\n\n    procd_params = attrs.field(default={\"loggerLvl\" : logging.DEBUG})\n\n    def run(self, data : str):\n\n        self.logger.info(\"Running method from procd handler!\")\n\n        self._initialize_procd_h(uparams={\"data\" : data})\n\n        return self.procd_h.run()\n\n</code></pre> <pre><code>Service().run(data = \"some data\")\n\n</code></pre> <pre><code>INFO:Service:Running method from procd handler!\nINFO:ProcessData:Running data processing...\nDEBUG:ProcessData:Processing data: some data\n\n\n\n\n\n'Processed: some data'\n</code></pre>"},{"location":"description/#adding-handler-initialization-to-class-post-init","title":"Adding handler initialization to class post init","text":"<p>One of the benefits of using <code>attrs</code> is the ability to define what happens when class in initialized without making the whole <code>__init__</code>, by using <code>__attrs_post_init__</code>. Some handlers could be added there to be initialized with a new class and rdy to be used within its methods. </p> <pre><code>@attrsx.define(handler_specs = {'procd' : ProcessData})\nclass Service:\n    data: str = attrs.field(default=None)\n\n    procd_params = attrs.field(default={\"data\" : \"default data\"})\n\n    def __attrs_post_init__(self):\n        self._initialize_procd_h()\n\n    def run(self, data : str = None):\n\n        self.logger.info(\"Running method from procd handler!\")\n\n        return self.procd_h.run()\n</code></pre> <pre><code>Service().run()\n</code></pre> <pre><code>INFO:Service:Running method from procd handler!\nINFO:ProcessData:Running data processing...\n\n\n\n\n\n'Processed: default data'\n</code></pre>"},{"location":"description/#using-instances-of-handlers-initialized-outside-of-new-class","title":"Using instances of handlers initialized outside of new class","text":"<p>Each new class defined with <code>handler_specs</code> can use initialized instances of handlers and skip initialization within new class, which allows the code to remain flexible. </p> <pre><code>@attrsx.define(handler_specs = {'procd' : ProcessData})\nclass Service:\n    data: str = attrs.field(default=None)\n\n    procd_params = attrs.field(default={\"data\" : \"default data\"})\n\n    def __attrs_post_init__(self):\n        self._initialize_procd_h()\n\n    def run(self, data : str = None):\n\n        self.logger.info(\"Running method from procd handler!\")\n\n        return self.procd_h.run()\n</code></pre> <pre><code>outside_procd = ProcessData(data = 'some other data')\n\nService(procd_h=outside_procd).run()\n</code></pre> <pre><code>INFO:Service:Running method from procd handler!\nINFO:ProcessData:Running data processing...\n\n\n\n\n\n'Processed: some other data'\n</code></pre>"},{"location":"description/#chaining-loggers","title":"Chaining loggers","text":"<p>Each <code>attrsx</code> class has its own independent built-in logger, it might be useful to control behaviour of handler loggers from main class (for handlers that themselves are <code>attrsx</code> classes). This package allows to chain loggers of <code>attrsx</code> classes on 3 different levels via <code>logger_chaining</code> boolean parameters in <code>@attrsx.define</code>:</p> <ol> <li><code>logger_format</code> : synchronizes logger format for all <code>attrsx</code> handlers (by default set to <code>True</code>)</li> <li><code>loggerLvl</code> : synchronizes logger level for all <code>attrsx</code> handlers (by default set to <code>True</code>)</li> <li><code>logger</code> : uses logger defined for main class within handlers (by default set to <code>False</code>)</li> </ol> <pre><code>@attrsx.define(handler_specs = {'procd' : ProcessData})\nclass ChainedService:\n    data: str = attrs.field(default=None)\n\n    procd_params = attrs.field(default={\"data\" : \"default data\"})\n\n    loggerLvl = attrs.field(default=logging.DEBUG)\n    logger_format = attrs.field(default=\"%(levelname)s - %(name)s - %(message)s\")\n\n    def __attrs_post_init__(self):\n        self._initialize_procd_h()\n\n    def run(self, data : str = None):\n\n        self.logger.info(\"Running method from procd handler!\")\n\n        return self.procd_h.run()\n</code></pre> <pre><code>ChainedService().run()\n</code></pre> <pre><code>INFO - ChainedService - Running method from procd handler!\nINFO - ProcessData - Running data processing...\nDEBUG - ProcessData - Processing data: default data\n\n\n\n\n\n'Processed: default data'\n</code></pre> <pre><code>@attrsx.define(handler_specs = {'procd' : ProcessData}, logger_chaining={'logger' : True})\nclass ChainedService:\n    data: str = attrs.field(default=None)\n\n    procd_params = attrs.field(default={\"data\" : \"default data\"})\n\n    loggerLvl = attrs.field(default=logging.DEBUG)\n    logger_format = attrs.field(default=\"%(levelname)s - %(name)s - %(message)s\")\n\n    def __attrs_post_init__(self):\n        self._initialize_procd_h()\n\n    def run(self, data : str = None):\n\n        self.logger.info(\"Running method from procd handler!\")\n\n        return self.procd_h.run()\n</code></pre> <pre><code>ChainedService().run()\n</code></pre> <pre><code>INFO - ChainedService - Running method from procd handler!\nINFO - ChainedService - Running data processing...\nDEBUG - ChainedService - Processing data: default data\n\n\n\n\n\n'Processed: default data'\n</code></pre>"},{"location":"release-notes/","title":"Release notes","text":""},{"location":"release-notes/#010","title":"0.1.0","text":"<pre><code>- support for built-in handlers\n</code></pre>"},{"location":"release-notes/#001","title":"0.0.1","text":"<pre><code>- initial version that includes simple logging extension\n</code></pre>"}]}