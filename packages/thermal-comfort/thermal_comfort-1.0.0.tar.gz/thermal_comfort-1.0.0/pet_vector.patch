diff --git a/src/_thermal_comfort.f90 b/src/_thermal_comfort.f90
index 015bdc8..2806161 100644
--- a/src/_thermal_comfort.f90
+++ b/src/_thermal_comfort.f90
@@ -155,15 +155,15 @@ CONTAINS
       !
       !  Input arguments:
       ! ----------------
-      REAL(kind=8), INTENT(IN) :: ta     !< Air temperature           (°C)
-      REAL(kind=8), INTENT(IN) :: tmrt   !< Mean radiant temperature  (°C)
-      REAL(kind=8), INTENT(IN) :: v      !< Wind speed                (m/s)
-      REAL(kind=8), INTENT(IN) :: rh     !< relative humidity         (%)
-      REAL(kind=8), INTENT(IN) :: p      !< Air pressure              (hPa)
+      REAL(kind=8), INTENT(IN) :: ta(:)     !< Air temperature           (°C)
+      REAL(kind=8), INTENT(IN) :: tmrt(:)   !< Mean radiant temperature  (°C)
+      REAL(kind=8), INTENT(IN) :: v(:)      !< Wind speed                (m/s)
+      REAL(kind=8), INTENT(IN) :: rh(:)     !< relative humidity         (%)
+      REAL(kind=8), INTENT(IN) :: p(:)      !< Air pressure              (hPa)
       !
       !  Output arguments:
       ! ----------------
-      REAL(kind=8), INTENT(OUT) :: tx   !< PET  (°C)
+      REAL(kind=8), INTENT(OUT) :: tx(size(ta))   !< PET  (°C)
       !  former intent (out), disabled:
       !  - tsk        : Skin temperature              (°C)    real
       !  - tcl        : Clothing temperature          (°C)    real
@@ -173,9 +173,13 @@ CONTAINS
       !
       !  Internal variables:
       ! ----------------
-      REAL(kind=8) :: acl, adu, aeff, ere, erel, esw, facl, feff, rdcl, &
-                      rdsk, rtv, vpts, tsk, tcl, wetsk, vpa
-      !
+      INTEGER :: i
+      REAL(kind=8) :: vpa(size(ta)), ere(size(ta)), erel(size(ta)), rtv(size(ta)), acl(size(ta)), &
+                      adu(size(ta)), wetsk(size(ta)), vpts(size(ta)), tsk(size(ta)), tcl(size(ta)), &
+                      rdsk(size(ta)), rdcl(size(ta)), feff(size(ta)), facl(size(ta)), esw(size(ta)), aeff(size(ta))
+      ! REAL(kind=8) :: acl(size(ta)), adu(size(ta)), aeff(size(ta)), ere(size(ta)), erel(size(ta)), esw(size(ta)), facl(size(ta)), feff(size(ta)), rdcl(size(ta)), &
+      !                 rdsk(size(ta)), rtv(size(ta)), vpts(size(ta)), tsk(size(ta)), tcl(size(ta)), wetsk(size(ta)), vpa(size(ta))
+      ! REAL(kind=8) :: vpa(size(ta))
       !  Optional arguments not supported, removed
       !  REAL(kind=8), INTENT ( in ), optional :: age, mbody, ht, work, eta, icl, fcl
       !  INTEGER, INTENT ( in ), optional :: pos, sex
@@ -192,11 +196,11 @@ CONTAINS
       !   IF ( .NOT. present( sex ) )   sex   =  1
 
       ! this never converges if a value is nan so  we need to check if any of the values are nan
-      IF (ieee_is_nan(ta) .OR. ieee_is_nan(rh) .OR. ieee_is_nan(tmrt) .OR. ieee_is_nan(v) .OR. &
-          ieee_is_nan(p)) THEN
-         tx = ieee_value(tx, ieee_quiet_nan)
-         RETURN
-      END IF
+      ! IF (ieee_is_nan(ta) .OR. ieee_is_nan(rh) .OR. ieee_is_nan(tmrt) .OR. ieee_is_nan(v) .OR. &
+      !     ieee_is_nan(p)) THEN
+      !    tx = ieee_value(tx, ieee_quiet_nan)
+      !    RETURN
+      ! END IF
 
       !   MEMI configuration
       age = 35.
@@ -209,17 +213,24 @@ CONTAINS
       pos = 1
       sex = 1
       ! calculate vapor pressure from rh
-      vpa = (rh*es(Ta))/100.0
+      vpa = (rh*es_vectorized_wexler(Ta))/100.0
 
-      ! !-- call subfunctions
-      CALL in_body(ere, erel, p, rtv, ta, vpa)
+      do i = 1, size(ta)
+         IF (ieee_is_nan(ta(i)) .OR. ieee_is_nan(rh(i)) .OR. ieee_is_nan(tmrt(i)) .OR. ieee_is_nan(v(i)) .OR. &
+             ieee_is_nan(p(i))) THEN
+            tx(i) = ieee_value(tx(i), ieee_quiet_nan)
+            CYCLE
+         END IF
 
-      CALL heat_exch(acl, adu, aeff, ere, erel, esw, facl, feff, &
-                     p, rdcl, rdsk, ta, tcl, tmrt, tsk, v, vpa, vpts, wetsk)
+         !-- call subfunctions
+         CALL in_body(ere(i), erel(i), p(i), rtv(i), ta(i), vpa(i))
 
-      CALL pet_iteration(acl, adu, aeff, esw, facl, feff, p, rdcl, &
-                         rdsk, rtv, ta, tcl, tsk, tx, vpts, wetsk)
+         CALL heat_exch(acl(i), adu(i), aeff(i), ere(i), erel(i), esw(i), facl(i), feff(i), &
+                        p(i), rdcl(i), rdsk(i), ta(i), tcl(i), tmrt(i), tsk(i), v(i), vpa(i), vpts(i), wetsk(i))
 
+         CALL pet_iteration(acl(i), adu(i), aeff(i), esw(i), facl(i), feff(i), p(i), rdcl(i), &
+                            rdsk(i), rtv(i), ta(i), tcl(i), tsk(i), tx(i), vpts(i), wetsk(i))
+      end do
    END SUBROUTINE pet_static
 
 !------------------------------------------------------------------------------!
diff --git a/src/thermal_comfort/_thermal_comfort/thermal_comfort_mod.pyi b/src/thermal_comfort/_thermal_comfort/thermal_comfort_mod.pyi
index 4714c13..01dcf98 100644
--- a/src/thermal_comfort/_thermal_comfort/thermal_comfort_mod.pyi
+++ b/src/thermal_comfort/_thermal_comfort/thermal_comfort_mod.pyi
@@ -7,7 +7,13 @@ import numpy.typing as npt
 T = TypeVar('T', bound=np.floating | np.integer)
 
 
-def pet_static(ta: float, rh: float, v: float, tmrt: float, p: float) -> float:
+def pet_static(
+        ta: npt.NDArray[T] | float,
+        rh: npt.NDArray[T] | float,
+        v: npt.NDArray[T] | float,
+        tmrt: npt.NDArray[T] | float,
+        p: npt.NDArray[T] | float,
+) -> npt.NDArray[Any]:
     """Calculate the Physiological Equivalent Temperature (PET).
 
     The PET is implemented as described in VDI 3787 Part 2. The fortran code was
@@ -32,9 +38,6 @@ def pet_static(ta: float, rh: float, v: float, tmrt: float, p: float) -> float:
     - ``pos = 1``
     - ``sex = 1``
 
-    The procedure does not work on arrays. It has to be wrapped in ``np.vectorize`` to
-    properly work on arrays.
-
     :param ta: air temperature in °C
     :param rh: relative humidity in %
     :param v: wind speed in m/s
diff --git a/tests/thermal_comfort_test.py b/tests/thermal_comfort_test.py
index aa4c255..d2f8cc6 100644
--- a/tests/thermal_comfort_test.py
+++ b/tests/thermal_comfort_test.py
@@ -220,45 +220,6 @@ def test_pet_static(ta, rh, v, tmrt, expected):
         (float('nan'), float('nan'), float('nan'), 31, float('nan')),
         (float('nan'), float('nan'), float('nan'), float('nan'), 1013.25),
         (float('nan'), float('nan'), float('nan'), float('nan'), float('nan')),
-    ),
-)
-def test_pet_static_missing_value(ta, rh, v, tmrt, p):
-    assert math.isnan(pet_static(ta=ta, rh=rh, v=v, tmrt=tmrt, p=p))
-
-
-def test_pet_static_missing_value_mixed_array():
-    f = np.vectorize(pet_static, otypes=[float], cache=True)
-    result = f(
-        ta=np.array([20, float('nan')]),
-        rh=np.array([50, float('nan')]),
-        v=np.array([0.5, float('nan')]),
-        tmrt=np.array([20, float('nan')]),
-        p=np.array([1013.5, float('nan')]),
-    )
-    assert_array_almost_equal(result, [18, float('nan')], decimal=1)
-
-
-def test_pet_static_missing_value_mixed_series():
-    f = np.vectorize(pet_static, otypes=[float], cache=True)
-    df = pd.DataFrame({
-        'ta': pd.Series([20, float('nan')]),
-        'rh': pd.Series([50, float('nan')]),
-        'v': pd.Series([0.5, float('nan')]),
-        'tmrt': pd.Series([20, float('nan')]),
-        'p': pd.Series([1013.5, float('nan')]),
-    })
-    df['result'] = f(ta=df['ta'], rh=df['rh'], v=df['v'], tmrt=df['tmrt'], p=df['p'])
-    assert_series_equal(
-        left=df['result'],
-        right=pd.Series([18, float('nan')]),
-        atol=1,
-        check_names=False,
-    )
-
-
-@pytest.mark.parametrize(
-    ('ta', 'rh', 'v', 'tmrt', 'p'),
-    (
         (20, 50, 0.2, 31, None),
         (20, 50, 0.2, None, 1013.25),
         (20, 50, 0.2, None, None),
@@ -292,10 +253,39 @@ def test_pet_static_missing_value_mixed_series():
         (None, None, None, None, None),
     ),
 )
-def test_pet_static_values_is_none(ta, rh, v, tmrt, p):
-    with pytest.raises(TypeError) as exc_info:
-        pet_static(ta=ta, rh=rh, v=v, tmrt=tmrt, p=p)
-    assert "can't be converted to double" in exc_info.value.args[0]
+def test_pet_static_missing_value(ta, rh, v, tmrt, p):
+    assert math.isnan(pet_static(ta=ta, rh=rh, v=v, tmrt=tmrt, p=p)[0])
+
+
+def test_pet_static_missing_value_mixed_array():
+    result = pet_static(
+        ta=np.array([20, float('nan')]),
+        rh=np.array([50, float('nan')]),
+        v=np.array([0.5, float('nan')]),
+        tmrt=np.array([20, float('nan')]),
+        p=np.array([1013.5, float('nan')]),
+    )
+    assert_array_almost_equal(result, [18, float('nan')], decimal=1)
+
+
+def test_pet_static_missing_value_mixed_series():
+    df = pd.DataFrame({
+        'ta': pd.Series([20, float('nan')]),
+        'rh': pd.Series([50, float('nan')]),
+        'v': pd.Series([0.5, float('nan')]),
+        'tmrt': pd.Series([20, float('nan')]),
+        'p': pd.Series([1013.5, float('nan')]),
+    })
+    df['result'] = pet_static(
+        ta=df['ta'], rh=df['rh'],
+        v=df['v'], tmrt=df['tmrt'], p=df['p'],
+    )
+    assert_series_equal(
+        left=df['result'],
+        right=pd.Series([18, float('nan')]),
+        atol=1,
+        check_names=False,
+    )
 
 
 @pytest.mark.parametrize('f', [mrt, mrt_np])
