from typing import Optional

from ..redisimnest.settings import TTL_AUTO_RENEW


class Key:
    def __init__(
        self, 
        prefix_template: str, 
        default: Optional[Any] = None,
        ttl: Optional[int] = None,
        ttl_auto_renew: bool = TTL_AUTO_RENEW,
        is_secret: bool = False,
        is_password: bool = False
    ):
        """
        Represents a terminal key in the Redis cluster hierarchy.

        A `Key` defines a fully-resolved Redis entry with a parameterized prefix, optional default value, 
        and fine-grained TTL control. It supports runtime substitution of prefix parameters, hierarchical TTL 
        inheritance, and key-level metadata.

        Parameters:
            prefix_template (str): 
                A string pattern for the Redis key prefix (e.g., "user:{user_id}:session"). 
                Parameters in `{}` must be supplied when resolving the key.

            default (Any, optional): 
                A fallback value returned when the key is not present in Redis.
                This value is not persisted; it's returned only when Redis returns `None`.

            ttl (int, optional): 
                Time-to-live in seconds. Overrides TTL set on any parent cluster.

            ttl_auto_renew (bool): 
                If True, the TTL will be renewed automatically on access. 
                Defaults to the global `TTL_AUTO_RENEW`.

            is_secret (bool): 
                If True, marks the key as sensitive (e.g., API keys). May be excluded from logs or debug output.

            is_password (bool): 
                If True, indicates that the key stores a password. May trigger extra validation or restrictions.

        Features:
            - **Parameterized prefixes**: Dynamic key paths with named placeholders.
            - **TTL management**: Supports TTL inheritance and override ("TTL drilling").
            - **Default fallback**: Soft fallback value for missing keys.
            - **Metadata flags**: Supports marking keys as secrets or passwords.

        Example:
            >>> Key("user:{user_id}:session", ttl=3600)
            # A user session key with a 1-hour TTL

            >>> Key("config:app", default={})
            # A static config key returning `{}` if not present
        """
        ...
    


    @property
    def key(self) -> str:
        """Returns the final, resolved key for this key instance."""
        ...
    @property
    async def the_type(self) -> type:
        """
        Returns the Python `type` object of the value stored at this key, if available.
        """
        ...
    @property
    def the_ttl(self):
        """Returns the current resolved ttl that is about to be applied"""
        ...
    def describe(self):
        """Returns key description as dict (name, prefix, params, key, ttl)"""
        ...
    async def verify_password(self, plain_password: str) -> bool:
        """Verifies given password with original"""
        ...
    async def raw(self):
        """Returns the data as is as stored in redis"""
        ...
    
    from typing import Union, Awaitable, Any  # Local import for clarity
    def set(self, value, ex=None, px=None, nx=False, xx=False, keepttl=False, get=False, exat=None, pxat=None) -> Union[Awaitable[Any], Any]: ...
    def get(self) -> Union[Awaitable[Any], Any]: ...
    def delete(self) -> Union[Awaitable[Any], Any]: ...
    def __delitem__(self) -> Union[Awaitable[Any], Any]: ...
    def __getitem__(self) -> Union[Awaitable[Any], Any]: ...
    def __setitem__(self, value) -> Union[Awaitable[Any], Any]: ...
    def _eval(self, command, script, numkeys, keys_and_args) -> Union[Awaitable[Any], Any]: ...
    def _evalsha(self, command, sha, numkeys, keys_and_args) -> Union[Awaitable[Any], Any]: ...
    def _fcall(self, command, function, numkeys, keys_and_args) -> Union[Awaitable[Any], Any]: ...
    def _georadiusgeneric(self, command, *args, **kwargs) -> Union[Awaitable[Any], Any]: ...
    def _geosearchgeneric(self, command, *args, **kwargs) -> Union[Awaitable[Any], Any]: ...
    def _send_command_parse_response(self, conn, command_name, *args, options) -> Union[Awaitable[Any], Any]: ...
    def _tfcall(self, lib_name, func_name, keys=None, _async=False, *args) -> Union[Awaitable[Any], Any]: ...
    def _zrange(self, command, dest, start, end, desc=False, byscore=False, bylex=False, withscores=False, score_cast_func=float, offset=None, num=None) -> Union[Awaitable[Any], Any]: ...
    def acl_deluser(self, username, **kwargs) -> Union[Awaitable[Any], Any]: ...
    def acl_dryrun(self, username, *args, **kwargs) -> Union[Awaitable[Any], Any]: ...
    def bitop(self, operation, dest, keys) -> Union[Awaitable[Any], Any]: ...
    def blmpop(self, timeout, numkeys, *args, direction, count=1) -> Union[Awaitable[Any], Any]: ...
    def client_setname(self, **kwargs) -> Union[Awaitable[Any], Any]: ...
    def cluster(self, cluster_arg, *args, **kwargs) -> Union[Awaitable[Any], Any]: ...
    def command_docs(self, *args) -> Union[Awaitable[Any], Any]: ...
    def command_getkeys(self, *args) -> Union[Awaitable[Any], Any]: ...
    def command_getkeysandflags(self, *args) -> Union[Awaitable[Any], Any]: ...
    def config_get(self, pattern='*', *args, **kwargs) -> Union[Awaitable[Any], Any]: ...
    def config_set(self, value, *args, **kwargs) -> Union[Awaitable[Any], Any]: ...
    def decr(self, amount=1) -> Union[Awaitable[Any], Any]: ...
    def decrby(self, amount=1) -> Union[Awaitable[Any], Any]: ...
    def dump(self) -> Union[Awaitable[Any], Any]: ...
    def eval(self, script, numkeys, keys_and_args) -> Union[Awaitable[Any], Any]: ...
    def eval_ro(self, script, numkeys, keys_and_args) -> Union[Awaitable[Any], Any]: ...
    def evalsha(self, sha, numkeys, keys_and_args) -> Union[Awaitable[Any], Any]: ...
    def evalsha_ro(self, sha, numkeys, keys_and_args) -> Union[Awaitable[Any], Any]: ...
    def execute_command(self, *args, options) -> Union[Awaitable[Any], Any]: ...
    def expire(self, time, nx=False, xx=False, gt=False, lt=False) -> Union[Awaitable[Any], Any]: ...
    def expireat(self, when, nx=False, xx=False, gt=False, lt=False) -> Union[Awaitable[Any], Any]: ...
    def fcall(self, function, numkeys, keys_and_args) -> Union[Awaitable[Any], Any]: ...
    def fcall_ro(self, function, numkeys, keys_and_args) -> Union[Awaitable[Any], Any]: ...
    def geoadd(self, values, nx=False, xx=False, ch=False) -> Union[Awaitable[Any], Any]: ...
    def geodist(self, place1, place2, unit=None) -> Union[Awaitable[Any], Any]: ...
    def geohash(self, values) -> Union[Awaitable[Any], Any]: ...
    def geopos(self, values) -> Union[Awaitable[Any], Any]: ...
    def georadius(self, longitude, latitude, radius, unit=None, withdist=False, withcoord=False, withhash=False, count=None, sort=None, store=None, store_dist=None, any=False) -> Union[Awaitable[Any], Any]: ...
    def georadiusbymember(self, member, radius, unit=None, withdist=False, withcoord=False, withhash=False, count=None, sort=None, store=None, store_dist=None, any=False) -> Union[Awaitable[Any], Any]: ...
    def geosearch(self, member=None, longitude=None, latitude=None, unit='m', radius=None, width=None, height=None, sort=None, count=None, any=False, withcoord=False, withdist=False, withhash=False) -> Union[Awaitable[Any], Any]: ...
    def geosearchstore(self, dest, member=None, longitude=None, latitude=None, unit='m', radius=None, width=None, height=None, sort=None, count=None, any=False, storedist=False) -> Union[Awaitable[Any], Any]: ...
    def getbit(self, offset) -> Union[Awaitable[Any], Any]: ...
    def getdel(self) -> Union[Awaitable[Any], Any]: ...
    def getex(self, ex=None, px=None, exat=None, pxat=None, persist=False) -> Union[Awaitable[Any], Any]: ...
    def getset(self, value) -> Union[Awaitable[Any], Any]: ...
    def hdel(self, keys) -> Union[Awaitable[Any], Any]: ...
    def hexists(self, key) -> Union[Awaitable[Any], Any]: ...
    def hexpire(self, seconds, fields, nx=False, xx=False, gt=False, lt=False) -> Union[Awaitable[Any], Any]: ...
    def hexpireat(self, unix_time_seconds, fields, nx=False, xx=False, gt=False, lt=False) -> Union[Awaitable[Any], Any]: ...
    def hexpiretime(self, key, fields) -> Union[Awaitable[Any], Any]: ...
    def hget(self, key) -> Union[Awaitable[Any], Any]: ...
    def hgetall(self) -> Union[Awaitable[Any], Any]: ...
    def hincrby(self, key, amount=1) -> Union[Awaitable[Any], Any]: ...
    def hincrbyfloat(self, key, amount=1.0) -> Union[Awaitable[Any], Any]: ...
    def hkeys(self) -> Union[Awaitable[Any], Any]: ...
    def hlen(self) -> Union[Awaitable[Any], Any]: ...
    def hmget(self, keys, *args) -> Union[Awaitable[Any], Any]: ...
    def hmset(self, mapping) -> Union[Awaitable[Any], Any]: ...
    def hpersist(self, fields) -> Union[Awaitable[Any], Any]: ...
    def hpexpire(self, milliseconds, fields, nx=False, xx=False, gt=False, lt=False) -> Union[Awaitable[Any], Any]: ...
    def hpexpireat(self, unix_time_milliseconds, fields, nx=False, xx=False, gt=False, lt=False) -> Union[Awaitable[Any], Any]: ...
    def hpexpiretime(self, key, fields) -> Union[Awaitable[Any], Any]: ...
    def hpttl(self, key, fields) -> Union[Awaitable[Any], Any]: ...
    def hscan(self, cursor=0, match=None, count=None, no_values=None) -> Union[Awaitable[Any], Any]: ...
    def hscan_iter(self, match=None, count=None, no_values=None) -> Union[Awaitable[Any], Any]: ...
    def hset(self, key=None, value=None, mapping=None, items=None) -> Union[Awaitable[Any], Any]: ...
    def hsetnx(self, key, value) -> Union[Awaitable[Any], Any]: ...
    def hstrlen(self, key) -> Union[Awaitable[Any], Any]: ...
    def httl(self, key, fields) -> Union[Awaitable[Any], Any]: ...
    def hvals(self) -> Union[Awaitable[Any], Any]: ...
    def incr(self, amount=1) -> Union[Awaitable[Any], Any]: ...
    def incrby(self, amount=1) -> Union[Awaitable[Any], Any]: ...
    def incrbyfloat(self, amount=1.0) -> Union[Awaitable[Any], Any]: ...
    def info(self, section=None, *args, **kwargs) -> Union[Awaitable[Any], Any]: ...
    def latency_histogram(self, *args) -> Union[Awaitable[Any], Any]: ...
    def latency_reset(self, events) -> Union[Awaitable[Any], Any]: ...
    def lindex(self, index) -> Union[Awaitable[Any], Any]: ...
    def linsert(self, where, refvalue, value) -> Union[Awaitable[Any], Any]: ...
    def llen(self) -> Union[Awaitable[Any], Any]: ...
    def lmpop(self, num_keys, *args, direction, count=1) -> Union[Awaitable[Any], Any]: ...
    def lock(self, timeout=None, sleep=0.1, blocking=True, blocking_timeout=None, lock_class=None, thread_local=True) -> Union[Awaitable[Any], Any]: ...
    def lolwut(self, version_numbers, **kwargs) -> Union[Awaitable[Any], Any]: ...
    def lpop(self, count=None) -> Union[Awaitable[Any], Any]: ...
    def lpos(self, value, rank=None, count=None, maxlen=None) -> Union[Awaitable[Any], Any]: ...
    def lpush(self, values) -> Union[Awaitable[Any], Any]: ...
    def lpushx(self, values) -> Union[Awaitable[Any], Any]: ...
    def lrange(self, start, end) -> Union[Awaitable[Any], Any]: ...
    def lrem(self, count, value) -> Union[Awaitable[Any], Any]: ...
    def lset(self, index, value) -> Union[Awaitable[Any], Any]: ...
    def ltrim(self, start, end) -> Union[Awaitable[Any], Any]: ...
    def mget(self, keys, *args) -> Union[Awaitable[Any], Any]: ...
    def module_load(self, path, *args) -> Union[Awaitable[Any], Any]: ...
    def module_unload(self) -> Union[Awaitable[Any], Any]: ...
    def move(self, db) -> Union[Awaitable[Any], Any]: ...
    def persist(self) -> Union[Awaitable[Any], Any]: ...
    def pexpire(self, time, nx=False, xx=False, gt=False, lt=False) -> Union[Awaitable[Any], Any]: ...
    def pexpireat(self, when, nx=False, xx=False, gt=False, lt=False) -> Union[Awaitable[Any], Any]: ...
    def pfadd(self, values) -> Union[Awaitable[Any], Any]: ...
    def pfcount(self, sources) -> Union[Awaitable[Any], Any]: ...
    def pfmerge(self, dest, sources) -> Union[Awaitable[Any], Any]: ...
    def psetex(self, time_ms, value) -> Union[Awaitable[Any], Any]: ...
    def pttl(self) -> Union[Awaitable[Any], Any]: ...
    def pubsub_numsub(self, *args, **kwargs) -> Union[Awaitable[Any], Any]: ...
    def pubsub_shardnumsub(self, *args, **kwargs) -> Union[Awaitable[Any], Any]: ...
    def replicaof(self, *args, **kwargs) -> Union[Awaitable[Any], Any]: ...
    def restore(self, ttl, value, replace=False, absttl=False, idletime=None, frequency=None) -> Union[Awaitable[Any], Any]: ...
    def rpop(self, count=None) -> Union[Awaitable[Any], Any]: ...
    def rpush(self, values) -> Union[Awaitable[Any], Any]: ...
    def rpushx(self, values) -> Union[Awaitable[Any], Any]: ...
    def sadd(self, values) -> Union[Awaitable[Any], Any]: ...
    def scard(self) -> Union[Awaitable[Any], Any]: ...
    def script_debug(self, *args) -> Union[Awaitable[Any], Any]: ...
    def script_exists(self, *args) -> Union[Awaitable[Any], Any]: ...
    def sdiff(self, keys, *args) -> Union[Awaitable[Any], Any]: ...
    def sdiffstore(self, dest, keys, *args) -> Union[Awaitable[Any], Any]: ...
    def sentinel(self, *args) -> Union[Awaitable[Any], Any]: ...
    def sentinel_monitor(self, ip, port, quorum) -> Union[Awaitable[Any], Any]: ...
    def sentinel_remove(self) -> Union[Awaitable[Any], Any]: ...
    def sentinel_set(self, option, value) -> Union[Awaitable[Any], Any]: ...
    def setbit(self, offset, value) -> Union[Awaitable[Any], Any]: ...
    def setex(self, time, value) -> Union[Awaitable[Any], Any]: ...
    def setnx(self, value) -> Union[Awaitable[Any], Any]: ...
    def setrange(self, offset, value) -> Union[Awaitable[Any], Any]: ...
    def sinter(self, keys, *args) -> Union[Awaitable[Any], Any]: ...
    def sinterstore(self, dest, keys, *args) -> Union[Awaitable[Any], Any]: ...
    def sismember(self, value) -> Union[Awaitable[Any], Any]: ...
    def smembers(self) -> Union[Awaitable[Any], Any]: ...
    def smismember(self, values, *args) -> Union[Awaitable[Any], Any]: ...
    def sort(self, start=None, num=None, by=None, get=None, desc=False, alpha=False, store=None, groups=False) -> Union[Awaitable[Any], Any]: ...
    def spop(self, count=None) -> Union[Awaitable[Any], Any]: ...
    def srandmember(self, number=None) -> Union[Awaitable[Any], Any]: ...
    def srem(self, values) -> Union[Awaitable[Any], Any]: ...
    def sscan(self, cursor=0, match=None, count=None) -> Union[Awaitable[Any], Any]: ...
    def sscan_iter(self, match=None, count=None) -> Union[Awaitable[Any], Any]: ...
    def strlen(self) -> Union[Awaitable[Any], Any]: ...
    def substr(self, start, end=-1) -> Union[Awaitable[Any], Any]: ...
    def sunion(self, keys, *args) -> Union[Awaitable[Any], Any]: ...
    def sunionstore(self, dest, keys, *args) -> Union[Awaitable[Any], Any]: ...
    def tfcall(self, lib_name, func_name, keys=None, *args) -> Union[Awaitable[Any], Any]: ...
    def tfcall_async(self, lib_name, func_name, keys=None, *args) -> Union[Awaitable[Any], Any]: ...
    def touch(self, *args) -> Union[Awaitable[Any], Any]: ...
    def transaction(self, func, watches, shard_hint=None, value_from_callable=False, watch_delay=None) -> Union[Awaitable[Any], Any]: ...
    def ttl(self) -> Union[Awaitable[Any], Any]: ...
    def type(self) -> Union[Awaitable[Any], Any]: ...
    def xack(self, groupname, ids) -> Union[Awaitable[Any], Any]: ...
    def xadd(self, fields, id='*', maxlen=None, approximate=True, nomkstream=False, minid=None, limit=None) -> Union[Awaitable[Any], Any]: ...
    def xautoclaim(self, groupname, consumername, min_idle_time, start_id='0-0', count=None, justid=False) -> Union[Awaitable[Any], Any]: ...
    def xclaim(self, groupname, consumername, min_idle_time, message_ids, idle=None, time=None, retrycount=None, force=False, justid=False) -> Union[Awaitable[Any], Any]: ...
    def xdel(self, ids) -> Union[Awaitable[Any], Any]: ...
    def xgroup_create(self, groupname, id='$', mkstream=False, entries_read=None) -> Union[Awaitable[Any], Any]: ...
    def xgroup_createconsumer(self, groupname, consumername) -> Union[Awaitable[Any], Any]: ...
    def xgroup_delconsumer(self, groupname, consumername) -> Union[Awaitable[Any], Any]: ...
    def xgroup_destroy(self, groupname) -> Union[Awaitable[Any], Any]: ...
    def xgroup_setid(self, groupname, id, entries_read=None) -> Union[Awaitable[Any], Any]: ...
    def xinfo_consumers(self, groupname) -> Union[Awaitable[Any], Any]: ...
    def xinfo_groups(self) -> Union[Awaitable[Any], Any]: ...
    def xinfo_stream(self, full=False) -> Union[Awaitable[Any], Any]: ...
    def xlen(self) -> Union[Awaitable[Any], Any]: ...
    def xpending(self, groupname) -> Union[Awaitable[Any], Any]: ...
    def xpending_range(self, groupname, min, max, count, consumername=None, idle=None) -> Union[Awaitable[Any], Any]: ...
    def xrange(self, min='-', max='+', count=None) -> Union[Awaitable[Any], Any]: ...
    def xrevrange(self, max='+', min='-', count=None) -> Union[Awaitable[Any], Any]: ...
    def xtrim(self, maxlen=None, approximate=True, minid=None, limit=None) -> Union[Awaitable[Any], Any]: ...
    def zadd(self, mapping, nx=False, xx=False, ch=False, incr=False, gt=False, lt=False) -> Union[Awaitable[Any], Any]: ...
    def zcard(self) -> Union[Awaitable[Any], Any]: ...
    def zcount(self, min, max) -> Union[Awaitable[Any], Any]: ...
    def zincrby(self, amount, value) -> Union[Awaitable[Any], Any]: ...
    def zlexcount(self, min, max) -> Union[Awaitable[Any], Any]: ...
    def zpopmax(self, count=None) -> Union[Awaitable[Any], Any]: ...
    def zpopmin(self, count=None) -> Union[Awaitable[Any], Any]: ...
    def zrange(self, start, end, desc=False, withscores=False, score_cast_func=float, byscore=False, bylex=False, offset=None, num=None) -> Union[Awaitable[Any], Any]: ...
    def zrangebylex(self, min, max, start=None, num=None) -> Union[Awaitable[Any], Any]: ...
    def zrangebyscore(self, min, max, start=None, num=None, withscores=False, score_cast_func=float) -> Union[Awaitable[Any], Any]: ...
    def zrangestore(self, dest, start, end, byscore=False, bylex=False, desc=False, offset=None, num=None) -> Union[Awaitable[Any], Any]: ...
    def zrank(self, value, withscore=False) -> Union[Awaitable[Any], Any]: ...
    def zrem(self, values) -> Union[Awaitable[Any], Any]: ...
    def zremrangebylex(self, min, max) -> Union[Awaitable[Any], Any]: ...
    def zremrangebyrank(self, min, max) -> Union[Awaitable[Any], Any]: ...
    def zremrangebyscore(self, min, max) -> Union[Awaitable[Any], Any]: ...
    def zrevrange(self, start, end, withscores=False, score_cast_func=float) -> Union[Awaitable[Any], Any]: ...
    def zrevrangebylex(self, max, min, start=None, num=None) -> Union[Awaitable[Any], Any]: ...
    def zrevrangebyscore(self, max, min, start=None, num=None, withscores=False, score_cast_func=float) -> Union[Awaitable[Any], Any]: ...
    def zrevrank(self, value, withscore=False) -> Union[Awaitable[Any], Any]: ...
    def zscan(self, cursor=0, match=None, count=None, score_cast_func=float) -> Union[Awaitable[Any], Any]: ...
    def zscan_iter(self, match=None, count=None, score_cast_func=float) -> Union[Awaitable[Any], Any]: ...
    def zscore(self, value) -> Union[Awaitable[Any], Any]: ...


