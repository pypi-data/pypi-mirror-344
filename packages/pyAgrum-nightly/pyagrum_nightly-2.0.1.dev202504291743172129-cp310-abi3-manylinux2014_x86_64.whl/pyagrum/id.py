# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""influence diagram module"""

from sys import version_info as _swig_python_version_info
# ## added by passForType (pyAgrum)
from typing import List,Set,Dict,Tuple
# ## recursive import for typehints annotation
import pyagrum
# ## end of added by passForType (pyAgrum)

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _id
else:
    import _id

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _id.delete_SwigPyIterator

    def value(self) -> object:
        return _id.SwigPyIterator_value(self)

    def incr(self, n: int=1) -> "swig::SwigPyIterator *":
        return _id.SwigPyIterator_incr(self, n)

    def decr(self, n: int=1) -> "swig::SwigPyIterator *":
        return _id.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _id.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> bool:
        return _id.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _id.SwigPyIterator_copy(self)

    def next(self) -> object:
        return _id.SwigPyIterator_next(self)

    def __next__(self) -> object:
        return _id.SwigPyIterator___next__(self)

    def previous(self) -> object:
        return _id.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _id.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> bool:
        return _id.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> bool:
        return _id.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _id.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _id.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _id.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _id.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _id:
_id.SwigPyIterator_swigregister(SwigPyIterator)
import pyagrum.bn
import pyagrum.base
class IDGenerator(object):
    r"""

    IDGenerator is used to easily generate influence diagrams.

    IDGenerator() -> IDGenerator
        default constructor

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def generate(self, nbrNodes: int=10, arcDensity: float=0.2, chanceNodeDensity: float=0.8, utilityNodeDensity: float=0.1, max_modality: int=2) -> "pyagrum.InfluenceDiagram":
        r"""

        Generate a new influence diagram given the parameters.

        Parameters
        ----------
        nbrNodes : int
        	the number of node
        arcDensity : float
        	the density of arc (1 for a complete graph)
        chanceNodeDensity : float
        	the density of chance node
        utilityNodeDensity : float
        	the density of utility node
        max_modality : int
        	the maximum value for modalities

        Returns
        -------
        pyagrum.InfluenceDiagram
        	the generated influence diagram

        """
        return _id.IDGenerator_generate(self, nbrNodes, arcDensity, chanceNodeDensity, utilityNodeDensity, max_modality)

    def __init__(self):
        r"""

        IDGenerator is used to easily generate influence diagrams.

        IDGenerator() -> IDGenerator
            default constructor

        """
        _id.IDGenerator_swiginit(self, _id.new_IDGenerator())
    __swig_destroy__ = _id.delete_IDGenerator

# Register IDGenerator in _id:
_id.IDGenerator_swigregister(IDGenerator)
class InfluenceDiagram(pyagrum.base.DAGmodel):
    r"""

    InfluenceDiagram represents an Influence Diagram.

    InfluenceDiagram() -> InfluenceDiagram
        default constructor

    InfluenceDiagram(source) -> InfluenceDiagram
        Parameters:
            - **source** (*pyagrum.InfluenceDiagram*) -- the InfluenceDiagram to copy

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    @staticmethod
    def fastPrototype(*args) -> "pyagrum.InfluenceDiagram":
        r"""

        Create an Influence Diagram with a dot-like syntax which specifies:
            - the structure 'a->b<-c;b->d;c<-e;'.
            - a prefix for the type of node (chance/decision/utiliy nodes):

              - `a` : a chance node named 'a' (by default)
              - `$a` : a utility node named 'a'
              - `*a` : a decision node named 'a'

            - the type of the variables with different syntax as postfix:

              - by default, a variable is a pyagrum.RangeVariable using the default domain size (second argument)
              - with `'a[10]'`, the variable is a pyagrum.RangeVariable using 10 as domain size (from 0 to 9)
              - with `'a[3,7]'`, the variable is a pyagrum.RangeVariable using a domainSize from 3 to 7
              - with `'a[1,3.14,5,6.2]'`, the variable is a pyagrum.DiscretizedVariable using the given ticks (at least 3 values)
              - with `'a{top|middle|bottom}'`, the variable is a pyagrum.LabelizedVariable using the given labels.
              - with 'a{-1|5|0|3}', the variable is a pyagrum.IntegerVariable using the sorted given values.
              - with 'a{-0.5|5.01|0|3.1415}', the variable is a pyagrum.NumericalDiscreteVariable using the sorted given values.

        Note
        ----
          - If the dot-like string contains such a specification more than once for a variable, the first specification will be used.
          - the tensors (probabilities, utilities) are randomly generated.
          - see also pyagrum.fastID.

        Examples
        --------
        >>> import pyagrum as gum
        >>> bn=pyagrum.fastID('A->B[1,3]<-*C{yes|No}->$D<-E[1,2.5,3.9]',6)

        Parameters
        ----------
        dotlike : str
                the string containing the specification
        domainSize :int or str
                the default domain size or the default domain for variables

        Returns
        -------
        pyagrum.InfluenceDiagram
                the resulting Influence Diagram

        """
        return _id.InfluenceDiagram_fastPrototype(*args)
    __swig_destroy__ = _id.delete_InfluenceDiagram

    def __init__(self, *args):
        _id.InfluenceDiagram_swiginit(self, _id.new_InfluenceDiagram(*args))

    def __eq__(self, other: "InfluenceDiagram") -> bool:
        return _id.InfluenceDiagram___eq__(self, other)

    def __ne__(self, other: "InfluenceDiagram") -> bool:
        return _id.InfluenceDiagram___ne__(self, other)

    def toDot(self) -> str:
        r"""

        Returns
        -------
        str
            a friendly display of the graph in DOT format

        """
        return _id.InfluenceDiagram_toDot(self)

    def clear(self) -> None:
        return _id.InfluenceDiagram_clear(self)

    def cpt(self, *args) -> "pyagrum.Tensor":
        r"""

        Returns the CPT of a variable.

        Parameters
        ----------
        var : Union[int,str]
        	a variable's id (int) or name

        Returns
        -------
        pyagrum.Tensor
        	The variable's CPT.

        Raises
        ------
        pyagrum.NotFound
        	If no variable's id matches varId.

        """
        return _id.InfluenceDiagram_cpt(self, *args)

    def utility(self, *args) -> "pyagrum.Tensor":
        r"""

        Parameters
        ----------
        var : Union[int,str]
        	a variable's id (int) or name

        Returns
        -------
        pyagrum.Tensor
        	the utility table of the node

        Raises
        ------
        pyagrum.IndexError
        	If the InfluenceDiagram does not contain the variable

        """
        return _id.InfluenceDiagram_utility(self, *args)

    def isUtilityNode(self, *args) -> bool:
        r"""

        Parameters
        ----------
        varId : int
        	the tested node id.

        Returns
        -------
        bool
        	true if node is an utility node

        """
        return _id.InfluenceDiagram_isUtilityNode(self, *args)

    def isDecisionNode(self, *args) -> bool:
        r"""

        Parameters
        ----------
        varId : int
        	the tested node id.

        Returns
        -------
        bool
        	true if node is a decision node

        """
        return _id.InfluenceDiagram_isDecisionNode(self, *args)

    def isChanceNode(self, *args) -> bool:
        r"""

        Parameters
        ----------
        varId : int
        	the tested node id.

        Returns
        -------
        bool
        	true if node is a chance node

        """
        return _id.InfluenceDiagram_isChanceNode(self, *args)

    def utilityNodeSize(self) -> int:
        r"""

        Returns
        -------
        int
        	the number of utility nodes

        """
        return _id.InfluenceDiagram_utilityNodeSize(self)

    def chanceNodeSize(self) -> int:
        r"""

        Returns
        -------
        int
        	the number of chance nodes.

        """
        return _id.InfluenceDiagram_chanceNodeSize(self)

    def decisionNodeSize(self) -> int:
        r"""

        Returns
        -------
        int
        	the number of decision nodes

        """
        return _id.InfluenceDiagram_decisionNodeSize(self)

    def variable(self, *args) -> "pyagrum.DiscreteVariable":
        r"""

        Parameters
        ----------
        id : int
         	the node id

        Returns
        ------
        pyagrum.DiscreteVariable
        	a constant reference over a variabe given it's node id

        Raises
        ------
        pyagrum.NotFound
        	If no variable's id matches the parameter

        """
        return _id.InfluenceDiagram_variable(self, *args)

    def nodeId(self, var: "pyagrum.DiscreteVariable") -> int:
        r"""

        Parameters
        ----------
        var : pyagrum.DiscreteVariable
        	a variable

        Returns
        -------
        int
        	the id of the variable

        Raises
        ------
        pyagrum.IndexError
        	If the InfluenceDiagram does not contain the variable

        """
        return _id.InfluenceDiagram_nodeId(self, var)

    def idFromName(self, name: str) -> int:
        r"""

        Returns a variable's id given its name.

        Parameters
        ----------
        name : str
        	the variable's name from which the id is returned.

        Returns
        -------
        int
        	the variable's node id.

        Raises
        ------
        pyagrum.NotFound
        	If no such name exists in the graph.

        """
        return _id.InfluenceDiagram_idFromName(self, name)

    def variableFromName(self, name: str) -> "pyagrum.DiscreteVariable":
        r"""

        Parameters
        ----------
        name : str
        	a variable's name

        Returns
        -------
        pyagrum.DiscreteVariable
        	the variable

        Notes
        -----
          A convenient shortcut for `g.variableFromName(name)` is `g[name]`.

        Raises
        ------
        pyagrum.IndexError
        	If the InfluenceDiagram does not contain the variable

        """
        return _id.InfluenceDiagram_variableFromName(self, name)

    def add(self, *args) -> int:
        r"""

        Add a variable, it's associate node and it's CPT.

        The id of the new variable is automatically generated.

        Parameters
        ----------
        variable : pyagrum.DiscreteVariable
        	The variable added by copy that will be a chance node.
        descr: str
          the descr of the variable following :ref:`fast syntax<Quick specification of (randomly parameterized) graphical models>` extended for :func:`pyagrum.fastID`.
        nbr_mod_or_id : int
        	if the first argument is `variable`, this set an optional fixed id for the node. If the first argument is `descr`, this gives the default number of modalities
        	for the variable. Note that if a utility node is described in `descr`, this value is overriden by 1.

        Returns
        -------
        int
            the id of the added variable.

        Raises
        ------
          pyagrum.DuplicateElement
        	  If already used id or name.

        """
        return _id.InfluenceDiagram_add(self, *args)

    def addChanceNode(self, *args) -> int:
        r"""

        Add a chance variable, it's associate node and it's CPT.

        The id of the new variable is automatically generated.

        Parameters
        ----------
        variable : pyagrum.DiscreteVariable
        	the variable added by copy.
        id : int
        	the chosen id. If 0, the NodeGraphPart will choose.

        Warnings
        --------
        give an id (not 0) should be reserved for rare and specific situations !!!

        Returns
        -------
        int
            the id of the added variable.

        Raises
        ------
        pyagrum.DuplicateElement
        	If id(<>0) is already used

        """
        return _id.InfluenceDiagram_addChanceNode(self, *args)

    def addUtilityNode(self, *args) -> int:
        r"""

        Add a utility variable, it's associate node and it's UT.

        The id of the new variable is automatically generated.

        Parameters
        ----------
        variable : pyagrum.DiscreteVariable
        	the variable added by copy
        id : int
        	the chosen id. If 0, the NodeGraphPart will choose

        Warnings
        --------
        give an id (not 0) should be reserved for rare and specific situations !!!

        Returns
        -------
        int
            the id of the added variable.

        Raises
        ------
        pyagrum.InvalidArgument
        	If variable has more than one label
        pyagrum.DuplicateElement
        	If id(<>0) is already used

        """
        return _id.InfluenceDiagram_addUtilityNode(self, *args)

    def addDecisionNode(self, *args) -> int:
        r"""

        Add a decision variable.

        The id of the new variable is automatically generated.

        Parameters
        ----------
        variable : pyagrum.DiscreteVariable
        	the variable added by copy.
        id : int
        	the chosen id. If 0, the NodeGraphPart will choose.

        Warnings
        --------
        give an id (not 0) should be reserved for rare and specific situations !!!

        Returns
        -------
        int
            the id of the added variable.

        Raises
        ------
        pyagrum.DuplicateElement
        	If id(<>0) is already used

        """
        return _id.InfluenceDiagram_addDecisionNode(self, *args)

    def erase(self, *args) -> None:
        r"""

        Erase a Variable from the network and remove the variable from all his childs.

        If no variable matches the id, then nothing is done.

        Parameters
        ----------
        id : int
        	The id of the variable to erase.
        var :  Union[int,str,pyagrum.DiscreteVariable]
        	a variable's id (int) or name or th reference on the variable to remove.

        """
        return _id.InfluenceDiagram_erase(self, *args)

    def changeVariableName(self, *args) -> None:
        r"""

        Parameters
        ----------
        var : Union[int,str]
        	a variable's id (int) or name
        new_name : str
        	the name of the variable

        Raises
        ------
        pyagrum.DuplicateLabel
        	If this name already exists
        pyagrum.NotFound
        	If no nodes matches id.

        """
        return _id.InfluenceDiagram_changeVariableName(self, *args)

    def addArc(self, *args) -> None:
        r"""

        Add an arc in the ID, and update diagram's tensor nodes cpt if necessary.

        Parameters
        ----------
        tail : Union[int,str]
        	a variable's id (int) or name
        head : Union[int,str]
        	a variable's id (int) or name

        Raises
        ------
          pyagrum.InvalidEdge
        	If arc.tail and/or arc.head are not in the ID.
          pyagrum.InvalidEdge
        	If tail is a utility node

        """
        return _id.InfluenceDiagram_addArc(self, *args)

    def eraseArc(self, *args) -> None:
        r"""

        Removes an arc in the ID, and update diagram's tensor nodes cpt if necessary.

        If (tail, head) doesn't exist, the nothing happens.

        Parameters
        ----------
        arc : pyagrum.Arc
        	The arc to be removed whn calling eraseArc(arc)
        tail : Union[int,str]
        	a variable's id (int) or name when calling eraseArc(tail,head)
        head : Union[int,str]
        	a variable's id (int) or name when calling eraseArc(tail,head)

        """
        return _id.InfluenceDiagram_eraseArc(self, *args)

    def decisionOrderExists(self) -> bool:
        r"""

        Returns
        -------
        bool
        	True if a directed path exist with all decision node

        """
        return _id.InfluenceDiagram_decisionOrderExists(self)

    def getDecisionGraph(self) -> "pyagrum.DAG":
        r"""

        Returns
        -------
        pyagrum.DAG
        	the temporal Graph.

        """
        return _id.InfluenceDiagram_getDecisionGraph(self)

    def decisionOrder(self) -> List[int]:
        return _id.InfluenceDiagram_decisionOrder(self)

    def existsPathBetween(self, *args) -> bool:
        r"""

        Returns
        -------
        bool
        	true if a path exists between two nodes.

        """
        return _id.InfluenceDiagram_existsPathBetween(self, *args)

    def beginTopologyTransformation(self) -> None:
        return _id.InfluenceDiagram_beginTopologyTransformation(self)

    def endTopologyTransformation(self) -> None:
        return _id.InfluenceDiagram_endTopologyTransformation(self)

    def names(self) -> object:
        r"""

        Returns
        -------
        List[str]
        	The names of the InfluenceDiagram variables

        """
        return _id.InfluenceDiagram_names(self)

    def __iter__(self):
      """
      Iterate over the variables of the model

      Yield
      -----
      Tuple[int,str]
        The index of the variable and its name
      """
      for i in self.nodes():
        yield i,self.variable(i).name()

    def __getitem__(self, key):
      if isinstance(key, int):
        return self.variable(key)
      elif isinstance(key, str):
        return self.variableFromName(key)
      else:
        raise TypeError("key must be an int or a string")


    def nodes(self) -> object:
        r"""

        Returns
        -------
        set
            the set of ids

        """
        return _id.InfluenceDiagram_nodes(self)

    def connectedComponents(self):
      """ connected components from a graph/graphical models

      Compute the connected components of a pyAgrum's graph or graphical models
      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)

      The firstly visited node for each component is called a 'root' and is used as a key for the component.
      This root has been arbitrarily chosen during the algorithm.

      Returns
      -------
      dict(int,Set[int])
        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.

      """
      nodes=self.nodes()
      connected_components=dict()

      def parcours(node,orig):
          cc={node}
          nodes.discard(node)
          if hasattr(self,'children'):
              for chi in self.children(node):
                  if chi!=orig:
                      if chi in nodes:
                          cc|=parcours(chi,node)

          if hasattr(self,'parents'):
              for par in self.parents(node):
                  if par!=orig:
                      if par in nodes:
                          cc|=parcours(par,node)

          if hasattr(self,'neighbours'):
              for nei in self.neighbours(node):
                  if nei!=orig:
                      if nei in nodes:
                          cc|=parcours(nei,node)
          return cc

      while (len(nodes)>0):
          root=nodes.pop()
          connected_components[root]=parcours(root,None)
      return connected_components

    def adjacencyMatrix(self):
      """ adjacency matrix from a graph/graphical models

      Compute the adjacency matrix of a pyAgrum's graph or graphical models
      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)

      Returns
      -------
      numpy.ndarray
        adjacency matrix (as numpy.ndarray) with nodeId as key.

      """
      import numpy as np
      nodes=self.nodes()
      n=self.size()
      am=np.zeros((n,n)).astype(int)

      for node in nodes:
          if hasattr(self,'children'):
              for children in self.children(node):
                  am[node,children]=1
          if hasattr(self,'neighbours'):
              for neighbour in self.neighbours(node):
                  am[node,neighbour]=1
      return am


    def arcs(self) -> object:
        r"""

        Returns
        -------
        list:
        	the list of all the arcs in the Influence Diagram.

        """
        return _id.InfluenceDiagram_arcs(self)

    def parents(self, norid: object) -> object:
        r"""

        Parameters
        ----------
        var : Union[int,str]
        	a variable's id (int) or name

        Returns
        -------
        set
            the set of the parents ids.

        """
        return _id.InfluenceDiagram_parents(self, norid)

    def children(self, norid: object) -> object:
        r"""

        Parameters
        ----------
        var : Union[int,str]
        	a variable's id (int) or name

        Returns
        -------
        Set
        	the set of all the children

        """
        return _id.InfluenceDiagram_children(self, norid)

    def family(self, norid: object) -> object:
        r"""

        give the set of parents of a node and the node

        Parameters
        ---------
        norid : str|int
          the node

        Returns
        -------
        Set[int]
          the set of nodeId of the family of the node `norid`

        """
        return _id.InfluenceDiagram_family(self, norid)

    def descendants(self, norid: object) -> object:
        r"""

        give the set of nodeid of descendants of a node

        Parameters
        ----------
        norid : str|int
          the name or the id of the node

        Returns
        -------
        Set[int]
          the set of ids of the descendants of node `norid`.

        """
        return _id.InfluenceDiagram_descendants(self, norid)

    def ancestors(self, norid: object) -> object:
        r"""

        give the set of nodeid of ancestors of a node

        Parameters
        ----------
        norid : str|int
          the name or the id of the node

        Returns
        -------
        Set[int]
          the set of ids of the ancestors of node `norid`.

        """
        return _id.InfluenceDiagram_ancestors(self, norid)

    def moralizedAncestralGraph(self, nodes: object) -> "pyagrum.UndiGraph":
        r"""

        build a UndiGraph by moralizing the Ancestral Graph of a list of nodes

        Parameters
        ----------
        nodes : str|intList[str|int]
          the list of of nodeIds or names

        Warnings
        --------
          pyagrum.UndiGraph only knows NodeId. Hence the moralized ancestral graph does not include the names of the variables.graph

        Returns
        -------
        pyagrum.UndiGraph
          the moralized ancestral graph of the nodes

        """
        return _id.InfluenceDiagram_moralizedAncestralGraph(self, nodes)

    def loadBIFXML(self, *args) -> bool:
        r"""

        Load a BIFXML file.

        Parameters
        ----------
        name : str
        	the name's file

        Raises
        ------
        pyagrum.IOError
        	If file not found
        pyagrum.FatalError
        	If file is not valid

        """
        return _id.InfluenceDiagram_loadBIFXML(self, *args)

    def saveBIFXML(self, name: str) -> None:
        r"""

        Save the BayesNet in a BIFXML file.

        Parameters
        ----------
        name : str
        	the file's name

        """
        return _id.InfluenceDiagram_saveBIFXML(self, name)

    def addVariables(self,listFastVariables,default_nbr_mod=2):
       """
       Add a list of variable in the form of 'fast' syntax.

       Parameters
       ----------
       listFastVariables: List[str]
         the list of variables following :ref:`fast syntax<Quick specification of (randomly parameterized) graphical models>` extended for :func:`pyagrum.fastID`.
       default_nbr_mod: int
         the number of modalities for the variable if not specified in the fast description. Note that default_nbr_mod=1 is
         mandatory to create variables with only one modality (for utility for instance).

       Returns
       -------
       List[int]
         the list of created ids.
       """
       return [self.add(descr,default_nbr_mod) for descr in listFastVariables]

    def addArcs(self,listArcs):
      """
      add a list of arcs in te model.

      Parameters
      ----------
      listArcs : List[Tuple[int,int]]
        the list of arcs
      """
      for arc in listArcs:
        self.addArc(*arc)


    def addStructureListener(self,whenNodeAdded=None,whenNodeDeleted=None,whenArcAdded=None,whenArcDeleted=None):
      """
      Add the listeners in parameters to the list of existing ones.

      Parameters
      ----------
      whenNodeAdded : lambda expression
        a function for when a node is added
      whenNodeDeleted : lambda expression
        a function for when a node is removed
      whenArcAdded : lambda expression
        a function for when an arc is added
      whenArcDeleted : lambda expression
        a function for when an arc is removed
      """
      if [whenNodeAdded,whenNodeDeleted,whenArcAdded,whenArcDeleted]==[None,None,None,None]:
        return

      if not hasattr(self,"_listeners"):
        self._listeners=[]

      nl = PythonBNListener(self, self.variableNodeMap())
      if whenNodeAdded is not None:
        nl.setWhenNodeAdded(whenNodeAdded)
      if whenNodeDeleted is not None:
        nl.setWhenNodeDeleted(whenNodeDeleted)
      if whenArcAdded is not None:
        nl.setWhenArcAdded(whenArcAdded)
      if whenArcDeleted is not None:
        nl.setWhenArcDeleted(whenArcDeleted)

      self._listeners.append(nl)


    def __getstate__(self):
        pyagrum.base._gum_add_properties_while_getstate_(self)
        state={
              "chance":[self.variable(i).toFast() for i in self.nodes() if self.isChanceNode(i)],
              "utility":[self.variable(i).toFast() for i in self.nodes() if self.isUtilityNode(i)],
              "decision":[self.variable(i).toFast() for i in self.nodes() if self.isDecisionNode(i)],
              "parents":{**{self.variable(i).name():list(self.cpt(i).names)[1:] for i in self.nodes()  if self.isChanceNode(i)},
                     **{self.variable(i).name():list(self.utility(i).names)[1:] for i in self.nodes()  if self.isUtilityNode(i)},
                     **{self.variable(i).name():[self.variable(j).name() for j in self.parents(i)] for i in self.nodes() if self.isDecisionNode(i)}},
              "cpt":{self.variable(i).name():self.cpt(i)[:].flatten().tolist() for i in self.nodes() if self.isChanceNode(i)},
              "reward":{self.variable(i).name():self.utility(i)[:].flatten().tolist() for i in self.nodes() if self.isUtilityNode(i)},
              "properties":{k:self.property(k) for k in self.properties()}
        }
        return state

    def __setstate__(self,state):
        self.__init__()
        for fastvar in state['chance']:
            self.addChanceNode(fastvar)
        for fastvar in state['utility']:
            self.addUtilityNode(fastvar)
        for fastvar in state['decision']:
            self.addDecisionNode(fastvar)
        self.beginTopologyTransformation()
        for son in state['parents']:
            for father in state['parents'][son]:
                self.addArc(father,son)
        self.endTopologyTransformation()
        for node in state['cpt']:
            self.cpt(node).fillWith(state['cpt'][node])
        for node in state['reward']:
            self.utility(node).fillWith(state['reward'][node])
        for prop in state['properties']:
            self.setProperty(prop,state['properties'][prop])
        return self


    def toFast(self, filename: str = None) -> str:
      """
      Export the influence Diagram as *fast* syntax (in a string or in a python file)

      Parameters
      ----------
      filename : Optional[str]
        the name of the file (including the prefix), if None , use sys.stdout
      """
      def _toFastVar(model,i):
        res=""
        if model.isUtilityNode(i):
          res="$"
        elif model.isDecisionNode(i):
          res="*"
        return res+model.variable(i).toFast()

      def _toFastBN(model,pythoncode=False):
        res = []
        sovars = set()
        for x, y in model.arcs():
          if x in sovars:
            src = model.variable(x).name()
          else:
            src = _toFastVar(model,x)
            sovars.add(x)
          if y in sovars:
            dst = model.variable(y).name()
          else:
             dst = _toFastVar(model,y)
             sovars.add(y)
          res.append(f"{src}->{dst}")

        for x in model.nodes():
          if x not in sovars:
             res .append(_toFastVar(model,x))

        if pythoncode:
          return 'model=pyagrum.fastID("""'+';\n     '.join(res)+'""")'
        else:
          return ';'.join(res)

      if filename is None:
        return _toFastBN(self)
      else:
        with open(filename, "w") as pyfile:
          print(_toFastBN(self,pythoncode=True), file=pyfile)


    def __repr__(self) -> str:
        return _id.InfluenceDiagram___repr__(self)

    def __str__(self) -> str:
        return _id.InfluenceDiagram___str__(self)

# Register InfluenceDiagram in _id:
_id.InfluenceDiagram_swigregister(InfluenceDiagram)
class ShaferShenoyLIMIDInference(object):
    r"""

    This inference considers the provided model as a LIMID rather than an influence diagram. It is an optimized
    implementation of the LIMID resolution algorithm. However an inference on a classical influence diagram can be performed
    by adding a assumption of the existence of the sequence of decision nodes to be solved, which also implies that the
    decision choices can have an impact on the rest of the sequence (Non Forgetting Assumption,
    cf. pyagrum.ShaferShenoyLIMIDInference.addNoForgettingAssumption).

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, infDiag: "InfluenceDiagram"):
        _id.ShaferShenoyLIMIDInference_swiginit(self, _id.new_ShaferShenoyLIMIDInference(infDiag))

        self._model=infDiag



    __swig_destroy__ = _id.delete_ShaferShenoyLIMIDInference

    def junctionTree(self) -> "pyagrum.JunctionTree":
        r"""

        Returns
        -------
        pyagrum.CliqueGraph
          the current junction tree

        """
        val = _id.ShaferShenoyLIMIDInference_junctionTree(self)

        val._engine=self


        return val


    def clear(self) -> None:
        return _id.ShaferShenoyLIMIDInference_clear(self)

    def addNoForgettingAssumption(self, *args) -> None:
        return _id.ShaferShenoyLIMIDInference_addNoForgettingAssumption(self, *args)

    def hasNoForgettingAssumption(self) -> bool:
        return _id.ShaferShenoyLIMIDInference_hasNoForgettingAssumption(self)

    def reducedGraph(self) -> "pyagrum.DAG":
        r"""

        Returns the DAG build to solve the influence diagram.

        Returns
        -------
        pyagrum.DAG
          a copy of the reduced graph


        """
        return _id.ShaferShenoyLIMIDInference_reducedGraph(self)

    def reversePartialOrder(self) -> "pyagrum.YetUnWrapped":
        return _id.ShaferShenoyLIMIDInference_reversePartialOrder(self)

    def reducedLIMID(self) -> "pyagrum.InfluenceDiagram":
        r"""

        Returns the (reduced) LIMID build to solve the influence diagram.

        Returns
        -------
        pyagrum.InfluenceDiagram
          a copy of the reduced influence Diagram (LIMID)


        """
        return _id.ShaferShenoyLIMIDInference_reducedLIMID(self)

    def isSolvable(self) -> bool:
        r"""

        check wether the influence diagram is solvable or not

        Returns
        -------
        bool
          True if the influence diagram is solvable

        """
        return _id.ShaferShenoyLIMIDInference_isSolvable(self)

    def optimalDecision(self, *args) -> "pyagrum.Tensor":
        r"""

        Returns best choice for decision variable given in parameter ( based upon MEU criteria )

        Parameters
        ----------
        decisionId : int,str
        	the id or name of the decision variable

        Raises
        ------
          pyagrum.OperationNotAllowed
        	If no inference have yet been made
        pyagrum.InvalidNode
        	If node given in parmaeter is not a decision node

        """
        return _id.ShaferShenoyLIMIDInference_optimalDecision(self, *args)

    def posteriorUtility(self, *args) -> "pyagrum.Tensor":
        r"""

        Returns the posterior utiliyt of a utility node (after optimisation) depending on decision nodes, if any.

        Parameters
        ----------
        var : int
          the node Id of the node for which we need a posterior probability
        nodeName : str
          the node name of the node for which we need a posterior probability

        Returns
        -------
        pyagrum.Tensor
          a const ref to the posterior utility of the utility node


        """
        return _id.ShaferShenoyLIMIDInference_posteriorUtility(self, *args)

    def makeInference(self) -> None:
        r"""

        Perform the heavy computations needed to compute the optimal decisions.

        """
        return _id.ShaferShenoyLIMIDInference_makeInference(self)

    def posterior(self, *args) -> "pyagrum.Tensor":
        r"""

        Returns the posterior of a chance or a decision node (after optimisation).

        Parameters
        ----------
        var : int
          the node Id of the node for which we need a posterior probability
        nodeName : str
          the node name of the node for which we need a posterior probability

        Returns
        -------
        pyagrum.Tensor
          a const ref to the posterior probability of the node

        """
        return _id.ShaferShenoyLIMIDInference_posterior(self, *args)

    def addEvidence(self, *args) -> None:
        r"""

        Adds a new evidence on a node (might be soft or hard).

        Parameters
        ----------
        id : int
          a node Id
        nodeName : int
          a node name
        val :
          (int) a node value
        val :
          (str) the label of the node value
        vals : list
          a list of values

        Raises
        ------
          pyagrum.InvalidArgument
            If the node already has an evidence
          pyagrum.InvalidArgument
            If val is not a value for the node
          pyagrum.InvalidArgument
            If the size of vals is different from the domain side of the node
          pyagrum.FatalError
            If vals is a vector of 0s
          pyagrum.UndefinedElement
            If the node does not belong to the Bayesian network

        """
        return _id.ShaferShenoyLIMIDInference_addEvidence(self, *args)

    def chgEvidence(self, *args) -> None:
        r"""

        Change the value of an already existing evidence on a node (might be soft or hard).

        Parameters
        ----------
        id : int
          a node Id
        nodeName : int
          a node name
        val : intstr
          a node value or the label of the node value
        vals : List[float]
          a list of values

        Raises
        ------
        pyagrum.InvalidArgument
          If the node does not already have an evidence
        pyagrum.InvalidArgument
          If val is not a value for the node
        pyagrum.InvalidArgument
          If the size of vals is different from the domain side of the node
        pyagrum.FatalError
          If vals is a vector of 0s
        pyagrum.UndefinedElement
          If the node does not belong to the Bayesian network

        """
        return _id.ShaferShenoyLIMIDInference_chgEvidence(self, *args)

    def hasEvidence(self, *args) -> bool:
        r"""

        Parameters
        ----------
        id : int
          a node Id
        nodeName : str
          a node name

        Returns
        -------
        bool
          True if some node(s) (or the one in parameters) have received evidence

        Raises
        ------
        pyagrum.IndexError
          If the node does not belong to the Bayesian network

        """
        return _id.ShaferShenoyLIMIDInference_hasEvidence(self, *args)

    def eraseAllEvidence(self) -> None:
        r"""

        Remove all evidence.

        """
        return _id.ShaferShenoyLIMIDInference_eraseAllEvidence(self)

    def eraseEvidence(self, *args) -> None:
        r"""

        Remove the evidence, if any, corresponding to the node Id or name.

        Parameters
        ----------
        id : int
          a node Id
        nodeName : int
          a node name

        Raises
        ------
        pyagrum.IndexError
          If the node does not belong to the Bayesian network

        """
        return _id.ShaferShenoyLIMIDInference_eraseEvidence(self, *args)

    def hasHardEvidence(self, nodeName: str) -> bool:
        r"""

        Parameters
        ----------
        id : int
          a node Id
        nodeName : str
          a node name

        Returns
        -------
        bool
          True if node has received a hard evidence

        Raises
        ------
        pyagrum.IndexError
          If the node does not belong to the Bayesian network

        """
        return _id.ShaferShenoyLIMIDInference_hasHardEvidence(self, nodeName)

    def hasSoftEvidence(self, *args) -> bool:
        r"""

        Parameters
        ----------
        id : int
          a node Id
        nodeName : str
          a node name

        Returns
        -------
        bool
          True if node has received a soft evidence

        Raises
        ------
        pyagrum.IndexError
          If the node does not belong to the Bayesian network

        """
        return _id.ShaferShenoyLIMIDInference_hasSoftEvidence(self, *args)

    def nbrEvidence(self) -> int:
        r"""

        Returns
        -------
        int
          the number of evidence entered into the Bayesian network

        """
        return _id.ShaferShenoyLIMIDInference_nbrEvidence(self)

    def nbrHardEvidence(self) -> int:
        r"""

        Returns
        -------
        int
          the number of hard evidence entered into the Bayesian network

        """
        return _id.ShaferShenoyLIMIDInference_nbrHardEvidence(self)

    def nbrSoftEvidence(self) -> int:
        r"""

        Returns
        -------
        int
          the number of soft evidence entered into the Bayesian network

        """
        return _id.ShaferShenoyLIMIDInference_nbrSoftEvidence(self)

    def influenceDiagram(self) -> "pyagrum.InfluenceDiagram":
        r"""

        Returns a constant reference over the InfluenceDiagram on which this class work.

        Returns
        -------
        pyagrum.InfluenceDiagram
        	the InfluenceDiagram on which this class work

        """
        return _id.ShaferShenoyLIMIDInference_influenceDiagram(self)

    def setEvidence(self, evidces):
        """
        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.

        Parameters
        ----------
        evidces : dict
          a dict of evidences

        Raises
        ------
          pyagrum.InvalidArgument
            If one value is not a value for the node
          pyagrum.InvalidArgument
            If the size of a value is different from the domain side of the node
          pyagrum.FatalError
            If one value is a vector of 0s
          pyagrum.UndefinedElement
            If one node does not belong to the influence diagram
        """
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
        self.eraseAllEvidence()
        for k,v in evidces.items():
            self.addEvidence(k,v)



    def updateEvidence(self, evidces):
        """
        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).

        Parameters
        ----------
        evidces : dict
          a dict of evidences

        Raises
        ------
          pyagrum.InvalidArgument
            If one value is not a value for the node
          pyagrum.InvalidArgument
            If the size of a value is different from the domain side of the node
          pyagrum.FatalError
            If one value is a vector of 0s
          pyagrum.UndefinedElement
            If one node does not belong to the Bayesian network
        """
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))

        for k,v in evidces.items():
            if self.hasEvidence(k):
                self.chgEvidence(k,v)
            else:
                self.addEvidence(k,v)



    def hardEvidenceNodes(self) -> object:
        r"""

        Returns
        -------
        set
          the set of nodes with hard evidence

        """
        return _id.ShaferShenoyLIMIDInference_hardEvidenceNodes(self)

    def softEvidenceNodes(self) -> object:
        return _id.ShaferShenoyLIMIDInference_softEvidenceNodes(self)

    def MEU(self, *args) -> object:
        r"""

        Returns maximum expected utility obtained from inference.

        Raises
        ------
        pyagrum.OperationNotAllowed
        	If no inference have yet been made

        """
        return _id.ShaferShenoyLIMIDInference_MEU(self, *args)

    def meanVar(self, *args) -> object:
        r"""

        Parameters
        ----------
        id : int
          a node Id
        nodeName : str
          a node name

        Returns
        -------
        dict[str, float]
          a dictionary with the mean and variance of the node (after the inference)

        """
        return _id.ShaferShenoyLIMIDInference_meanVar(self, *args)

# Register ShaferShenoyLIMIDInference in _id:
_id.ShaferShenoyLIMIDInference_swigregister(ShaferShenoyLIMIDInference)

__version__ = '2.0.1'
__license__ = __doc__
__project_url__ = 'https://agrum.org'
__project_name__ = 'pyAgrum'
__project_description__ = __doc__
__project__ = __doc__


def about():
  """
  about() for pyAgrum

  """
  print(f"pyAgrum {__version__}")
  print("(c) 2015-2024 Pierre-Henri Wuillemin, Christophe Gonzales")
  print("""
    This is free software; see the source code for copying conditions.
    There is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  For details, see 'pyagrum.warranty'.
    """)


import os.path as ospath

def availableIDExts():
  """ Give the list of all formats known by pyAgrum to save a influence diagram.

  Returns
  ------
  str
    a string which lists all suffixes for supported ID file formats.
  """
  return "xmlbif|bifxml|xml|pkl"


def loadID(filename):
  """
  read a pyagrum.InfluenceDiagram from a ID file

  Parameters
  ----------
  filename: str
    the name of the input file

  Returns
  -------
  pyagrum.InfluenceDiagram
    the InfluenceDiagram
  """
  extension = filename.split('.')[-1].upper()

  if extension in {"BIFXML", "XMLBIF", "XML"}:
    diag = pyagrum.InfluenceDiagram()
# for now, just one format
    res = diag.loadBIFXML(filename)

    if not res:
      raise IOError(f"Error(s) in {filename}")
  elif extension == "PKL":
    import pickle
    with open(filename, "rb") as f:
      diag = pickle.load(f)
  else:
    raise InvalidArgument("extension " + filename.split('.')[-1] + " unknown. Please use among " + availableIDExts())

  diag.setProperty("name", diag.propertyWithDefault("name", ospath.splitext(ospath.basename(filename))[0]))
  return diag


def saveID(infdiag, filename):
  """
  save an ID into a file using the format corresponding to one of the availableWriteIDExts() suffixes.

  Parameters
  ----------
  infdiag : pyagrum.InfluenceDiagram
    the Influence Diagram to save
  filename : str
    the name of the output file
  """
  extension = filename.split('.')[-1].upper()

  if extension in {"BIFXML", "BIFXML", "XML"}:
    infdiag.saveBIFXML(filename)
  elif extension == "PKL":
    import pickle
    with open(filename, "wb") as f:
      pickle.dump(infdiag, f, pickle.HIGHEST_PROTOCOL)
  else:
    raise InvalidArgument("extension " + filename.split('.')[-1] + " unknown. Please use among " + availableBNExts())


def fastID(structure, domain="[2]"):
  """
  Create an Influence Diagram with a modified dot-like syntax which specifies:
      - the structure and the type of the variables following :ref:`fast syntax<Quick specification of (randomly parameterized) graphical models>`,
      - a prefix for the type of node (chance/decision/utiliy nodes):

        - ``a`` : a chance node named 'a' (by default)
        - ``$a`` : a utility node named 'a'
        - ``*a`` : a decision node named 'a'

  Examples
  --------
  >>> import pyagrum as gum
  >>> bn=pyagrum.fastID('A->B[1,3]<-*C{yes|No}->$D<-E[1,2.5,3.9]',6)

  Parameters
  ----------
  structure : str
          the string containing the specification
  domain: int or str
          the default domain size (int) or domain specification (str) for variables (default is "[2]"

  Returns
  -------
  pyagrum.InfluenceDiagram
          the resulting Influence Diagram
  """
  return InfluenceDiagram.fastPrototype(structure, domain)


