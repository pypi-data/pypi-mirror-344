# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.4.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""Markov random field module"""

from sys import version_info as _swig_python_version_info
# ## added by passForType (pyAgrum)
from typing import List,Set,Dict,Tuple
# ## recursive import for typehints annotation
import pyagrum
# ## end of added by passForType (pyAgrum)

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _mrf
else:
    import _mrf

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _mrf.delete_SwigPyIterator

    def value(self) -> object:
        return _mrf.SwigPyIterator_value(self)

    def incr(self, n: int=1) -> "swig::SwigPyIterator *":
        return _mrf.SwigPyIterator_incr(self, n)

    def decr(self, n: int=1) -> "swig::SwigPyIterator *":
        return _mrf.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _mrf.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> bool:
        return _mrf.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _mrf.SwigPyIterator_copy(self)

    def next(self) -> object:
        return _mrf.SwigPyIterator_next(self)

    def __next__(self) -> object:
        return _mrf.SwigPyIterator___next__(self)

    def previous(self) -> object:
        return _mrf.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _mrf.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> bool:
        return _mrf.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> bool:
        return _mrf.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _mrf.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _mrf.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _mrf.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _mrf.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _mrf:
_mrf.SwigPyIterator_swigregister(SwigPyIterator)
class PythonBNListener(object):
    r"""

    Listener for Bayesian Network's modifications. This listener is notified when the structure of the BN is changed.

    PythonBNListener(bn:pyagrum.BayesNet,vnm:pyagrum.VariableNodeMap) -> PythonBNListener
        default constructor

    Note
    ----
        This class est mainly automatically instantiated using the method pyagrum.BayesNet.addStructureListener.

    Parameters
    ----------
    bn : BaysNet
        The bayes net to listen to
    vnm : VarNodeMap
        A translation unit between id of node and name of variable (usually : bn.variableNodeMap()).

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, bn: "pyagrum.BayesNet", vnm: "pyagrum.VariableNodeMap"):
        r"""

        Listener for Bayesian Network's modifications. This listener is notified when the structure of the BN is changed.

        PythonBNListener(bn:pyagrum.BayesNet,vnm:pyagrum.VariableNodeMap) -> PythonBNListener
            default constructor

        Note
        ----
            This class est mainly automatically instantiated using the method pyagrum.BayesNet.addStructureListener.

        Parameters
        ----------
        bn : BaysNet
            The bayes net to listen to
        vnm : VarNodeMap
            A translation unit between id of node and name of variable (usually : bn.variableNodeMap()).

        """
        _mrf.PythonBNListener_swiginit(self, _mrf.new_PythonBNListener(bn, vnm))
    __swig_destroy__ = _mrf.delete_PythonBNListener

    def whenNodeAdded(self, source: object, id: int) -> None:
        return _mrf.PythonBNListener_whenNodeAdded(self, source, id)

    def whenNodeDeleted(self, arg2: object, id: int) -> None:
        return _mrf.PythonBNListener_whenNodeDeleted(self, arg2, id)

    def whenArcAdded(self, arg2: object, src: int, dst: int) -> None:
        return _mrf.PythonBNListener_whenArcAdded(self, arg2, src, dst)

    def whenArcDeleted(self, arg2: object, src: int, dst: int) -> None:
        return _mrf.PythonBNListener_whenArcDeleted(self, arg2, src, dst)

    def setWhenArcAdded(self, pyfunc: object) -> None:
        r"""

        Add the listener in parameter to the list of existing ones for adding an arc.

        Parameters
        ----------
        pyfunc : lambda expression
            a function (i:int,j:int) called when when an arc (i,j) is added

        """
        return _mrf.PythonBNListener_setWhenArcAdded(self, pyfunc)

    def setWhenArcDeleted(self, pyfunc: object) -> None:
        r"""

        Add the listener in parameter to the list of existing ones for deleting an arc.

        Parameters
        ----------
        pyfunc : lambda expression
            a function (i:int,j:int) called when when an arc (i,j) is removed

        """
        return _mrf.PythonBNListener_setWhenArcDeleted(self, pyfunc)

    def setWhenNodeAdded(self, pyfunc: object) -> None:
        r"""

        Add the listener in parameter to the list of existing ones for adding a node.

        Parameters
        ----------
        pyfunc : lambda expression
            a function (i:int,s:str) called when a node of id i and name s is added.

        """
        return _mrf.PythonBNListener_setWhenNodeAdded(self, pyfunc)

    def setWhenNodeDeleted(self, pyfunc: object) -> None:
        r"""

        Add the listener in parameter to the list of existing ones for deleting an arc.

        Parameters
        ----------
        pyfunc : lambda expression
            a function (i:int) called when a node of id i and name s is removed.

        """
        return _mrf.PythonBNListener_setWhenNodeDeleted(self, pyfunc)

# Register PythonBNListener in _mrf:
_mrf.PythonBNListener_swigregister(PythonBNListener)
class PythonLoadListener(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def whenLoading(self, buffer: object, percent: int) -> None:
        return _mrf.PythonLoadListener_whenLoading(self, buffer, percent)

    def setPythonListener(self, l: object) -> bool:
        r"""



        """
        return _mrf.PythonLoadListener_setPythonListener(self, l)

    def __init__(self):
        _mrf.PythonLoadListener_swiginit(self, _mrf.new_PythonLoadListener())
    __swig_destroy__ = _mrf.delete_PythonLoadListener

# Register PythonLoadListener in _mrf:
_mrf.PythonLoadListener_swigregister(PythonLoadListener)

def _fillLoadListeners_(py_listener: List["pyagrum.PythonLoadListener"], l: object) -> int:
    return _mrf._fillLoadListeners_(py_listener, l)
class PythonApproximationListener(object):
    r"""

    Parameters
    ----------
    algo : IApproximationSchemeConfiguration
    	an approxmation scheme

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, algo: "IApproximationSchemeConfiguration"):
        r"""

        Parameters
        ----------
        algo : IApproximationSchemeConfiguration
        	an approxmation scheme

        """
        _mrf.PythonApproximationListener_swiginit(self, _mrf.new_PythonApproximationListener(algo))
    __swig_destroy__ = _mrf.delete_PythonApproximationListener

    def whenProgress(self, src: object, step: int, error: float, duration: float) -> None:
        return _mrf.PythonApproximationListener_whenProgress(self, src, step, error, duration)

    def whenStop(self, src: object, message: str) -> None:
        return _mrf.PythonApproximationListener_whenStop(self, src, message)

    def setWhenProgress(self, pyfunc: object) -> None:
        r"""

        Parameters
        ----------
        pyfunc
        	the function to execute

        """
        return _mrf.PythonApproximationListener_setWhenProgress(self, pyfunc)

    def setWhenStop(self, pyfunc: object) -> None:
        r"""

        Parameters
        ----------
        pyfunc
        	the function to execute

        """
        return _mrf.PythonApproximationListener_setWhenStop(self, pyfunc)

# Register PythonApproximationListener in _mrf:
_mrf.PythonApproximationListener_swigregister(PythonApproximationListener)
class PythonDatabaseGeneratorListener(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, notif: "BNDatabaseGenerator"):
        _mrf.PythonDatabaseGeneratorListener_swiginit(self, _mrf.new_PythonDatabaseGeneratorListener(notif))
    __swig_destroy__ = _mrf.delete_PythonDatabaseGeneratorListener

    def whenProgress(self, src: object, step: int, duration: float) -> None:
        return _mrf.PythonDatabaseGeneratorListener_whenProgress(self, src, step, duration)

    def whenStop(self, src: object, message: str) -> None:
        return _mrf.PythonDatabaseGeneratorListener_whenStop(self, src, message)

    def setWhenProgress(self, pyfunc: object) -> None:
        return _mrf.PythonDatabaseGeneratorListener_setWhenProgress(self, pyfunc)

    def setWhenStop(self, pyfunc: object) -> None:
        return _mrf.PythonDatabaseGeneratorListener_setWhenStop(self, pyfunc)

# Register PythonDatabaseGeneratorListener in _mrf:
_mrf.PythonDatabaseGeneratorListener_swigregister(PythonDatabaseGeneratorListener)
import pyagrum.bn
import pyagrum.base
class IMarkovRandomField(pyagrum.base.UGmodel):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _mrf.delete_IMarkovRandomField

    def smallestFactorFromNode(self, *args) -> List[int]:
        return _mrf.IMarkovRandomField_smallestFactorFromNode(self, *args)

    def factors(self) -> List[Set[int]]:
        return _mrf.IMarkovRandomField_factors(self)

    def variableNodeMap(self) -> "pyagrum.VariableNodeMap":
        return _mrf.IMarkovRandomField_variableNodeMap(self)

    def variable(self, id: int) -> "pyagrum.DiscreteVariable":
        return _mrf.IMarkovRandomField_variable(self, id)

    def nodeId(self, var: "pyagrum.DiscreteVariable") -> int:
        return _mrf.IMarkovRandomField_nodeId(self, var)

    def idFromName(self, name: str) -> int:
        return _mrf.IMarkovRandomField_idFromName(self, name)

    def variableFromName(self, name: str) -> "pyagrum.DiscreteVariable":
        return _mrf.IMarkovRandomField_variableFromName(self, name)

    def __eq__(self, _from: "IMarkovRandomField") -> bool:
        return _mrf.IMarkovRandomField___eq__(self, _from)

    def __ne__(self, _from: "IMarkovRandomField") -> bool:
        return _mrf.IMarkovRandomField___ne__(self, _from)

    def dim(self) -> int:
        return _mrf.IMarkovRandomField_dim(self)

    def maxVarDomainSize(self) -> int:
        return _mrf.IMarkovRandomField_maxVarDomainSize(self)

    def minParam(self) -> float:
        return _mrf.IMarkovRandomField_minParam(self)

    def maxParam(self) -> float:
        return _mrf.IMarkovRandomField_maxParam(self)

    def minNonZeroParam(self) -> float:
        return _mrf.IMarkovRandomField_minNonZeroParam(self)

    def maxNonOneParam(self) -> float:
        return _mrf.IMarkovRandomField_maxNonOneParam(self)

    def toDot(self) -> str:
        return _mrf.IMarkovRandomField_toDot(self)

    def toDotAsFactorGraph(self) -> str:
        return _mrf.IMarkovRandomField_toDotAsFactorGraph(self)

    def names(self) -> object:
        r"""

        Set of names of variables in the model

        Returns
        -------
        Set[str]
        	The names of the graph variables

        """
        return _mrf.IMarkovRandomField_names(self)

    def __iter__(self):
      """
      Iterate over the variables of the model

      Yield
      -----
      Tuple[int,str]
        The index of the variable and its name
      """
      for i in self.nodes():
        yield i,self.variable(i).name()

    def __getitem__(self, key):
      if isinstance(key, int):
        return self.variable(key)
      elif isinstance(key, str):
        return self.variableFromName(key)
      else:
        raise TypeError("key must be an int or a string")


    def nodes(self) -> object:
        return _mrf.IMarkovRandomField_nodes(self)

    def connectedComponents(self):
      """ connected components from a graph/graphical models

      Compute the connected components of a pyAgrum's graph or graphical models
      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)

      The firstly visited node for each component is called a 'root' and is used as a key for the component.
      This root has been arbitrarily chosen during the algorithm.

      Returns
      -------
      dict(int,Set[int])
        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.

      """
      nodes=self.nodes()
      connected_components=dict()

      def parcours(node,orig):
          cc={node}
          nodes.discard(node)
          if hasattr(self,'children'):
              for chi in self.children(node):
                  if chi!=orig:
                      if chi in nodes:
                          cc|=parcours(chi,node)

          if hasattr(self,'parents'):
              for par in self.parents(node):
                  if par!=orig:
                      if par in nodes:
                          cc|=parcours(par,node)

          if hasattr(self,'neighbours'):
              for nei in self.neighbours(node):
                  if nei!=orig:
                      if nei in nodes:
                          cc|=parcours(nei,node)
          return cc

      while (len(nodes)>0):
          root=nodes.pop()
          connected_components[root]=parcours(root,None)
      return connected_components

    def adjacencyMatrix(self):
      """ adjacency matrix from a graph/graphical models

      Compute the adjacency matrix of a pyAgrum's graph or graphical models
      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)

      Returns
      -------
      numpy.ndarray
        adjacency matrix (as numpy.ndarray) with nodeId as key.

      """
      import numpy as np
      nodes=self.nodes()
      n=self.size()
      am=np.zeros((n,n)).astype(int)

      for node in nodes:
          if hasattr(self,'children'):
              for children in self.children(node):
                  am[node,children]=1
          if hasattr(self,'neighbours'):
              for neighbour in self.neighbours(node):
                  am[node,neighbour]=1
      return am


    def neighbours(self, norid: object) -> object:
        return _mrf.IMarkovRandomField_neighbours(self, norid)

    def edges(self) -> object:
        return _mrf.IMarkovRandomField_edges(self)

    def minimalCondSet(self, *args) -> object:
        return _mrf.IMarkovRandomField_minimalCondSet(self, *args)

    def factor(self, *args) -> "pyagrum.Tensor":
        return _mrf.IMarkovRandomField_factor(self, *args)

    def isIndependent(self, *args) -> bool:
        r"""

        check if nodes X and nodes Y are independent given nodes Z

        Parameters
        ----------
        X : str|intList[str|int]
              a list of of nodeIds or names
        Y : str|intList[str|int]
              a list of of nodeIds or names
        Z : str|intList[str|int]
              a list of of nodeIds or names

        Raises
        ------
        InvalidArgument
          if X and Y share variables

        Returns
        -------
        bool
          True if X and Y are independent given Z in the model

        """
        return _mrf.IMarkovRandomField_isIndependent(self, *args)

    def __repr__(self) -> str:
        return _mrf.IMarkovRandomField___repr__(self)

    def __str__(self) -> str:
        return _mrf.IMarkovRandomField___str__(self)

# Register IMarkovRandomField in _mrf:
_mrf.IMarkovRandomField_swigregister(IMarkovRandomField)
class MarkovRandomField(IMarkovRandomField):
    r"""

    MarkovRandomField represents a Markov random field.

    MarkovRandomField(name='') -> MarkovRandomField
        Parameters:
          - **name** (*str*) -- the name of the Bayes Net

    MarkovRandomField(source) -> MarkovRandomField
        Parameters:
          - **source** (*pyagrum.MarkovRandomField*) -- the Markov random field to copy

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    @staticmethod
    def fastPrototype(*args) -> "pyagrum.MarkovRandomField":
        r"""

        Create a Markov random field with a modified dot-like syntax which specifies:
            - the structure ``a-b-c;b-d-e;``. The substring ``a-b-c`` indicates a factor with the scope (a,b,c).
            - the type of the variables with different syntax (cf documentation).

        Examples
        --------
        >>> import pyagrum as gum
        >>> bn=pyagrum.MarkovRandomField.fastPrototype('A--B[1,3]-C{yes|No}--D[2,4]--E[1,2.5,3.9]',6)

        Parameters
        ----------
        dotlike : str
                the string containing the specification
        domainSize : int or str
                the default domain size or the default domain for variables

        Returns
        -------
        pyagrum.MarkovRandomField
                the resulting Markov random field

        """
        return _mrf.MarkovRandomField_fastPrototype(*args)

    @staticmethod
    def fromBN(bn: "pyagrum.BayesNet") -> "pyagrum.MarkovRandomField":
        return _mrf.MarkovRandomField_fromBN(bn)
    __swig_destroy__ = _mrf.delete_MarkovRandomField

    def __init__(self, *args):
        _mrf.MarkovRandomField_swiginit(self, _mrf.new_MarkovRandomField(*args))

    def smallestFactorFromNode(self, node: int) -> List[int]:
        return _mrf.MarkovRandomField_smallestFactorFromNode(self, node)

    def factors(self) -> List[Set[int]]:
        return _mrf.MarkovRandomField_factors(self)

    def variableNodeMap(self) -> "pyagrum.VariableNodeMap":
        return _mrf.MarkovRandomField_variableNodeMap(self)

    def add(self, *args) -> int:
        r"""

        Add a variable to the pyagrum.MarkovRandomField.

        Parameters
        ----------
        variable : pyagrum.DiscreteVariable
        	the variable added
        name : str
        	the variable name
        nbrmod : int
        	the number of modalities for the new variable
        id : int
        	the variable forced id in the pyagrum.MarkovRandomField

        Returns
        -------
        int
        	the id of the new node

        Raises
        ------
        pyagrum.DuplicateLabel
            If variable.name() is already used in this pyagrum.MarkovRandomField.
        pyagrum.OperationNotAllowed
            If nbrmod is less than 2
        pyagrum.DuplicateElement
            If id is already used.

        """
        return _mrf.MarkovRandomField_add(self, *args)

    def clear(self) -> None:
        r"""

        Clear the whole MarkovRandomField

        """
        return _mrf.MarkovRandomField_clear(self)

    def erase(self, *args) -> None:
        r"""

        Remove a variable from the pyagrum.MarkovRandomField.

        Removes the corresponding variable from the pyagrum.MarkovRandomField and from all of it's children pyagrum.Tensor.

        If no variable matches the given id, then nothing is done.

        Parameters
        ----------
        var :Union[int,str,pyagrum.DiscreteVariable]
        	a variable's id (int) or name of variable or a reference of this variable to remove.

        """
        return _mrf.MarkovRandomField_erase(self, *args)

    def variable(self, *args) -> "pyagrum.DiscreteVariable":
        return _mrf.MarkovRandomField_variable(self, *args)

    def changeVariableName(self, *args) -> None:
        r"""

        Changes a variable's name in the pyagrum.MarkovRandomField.

        This will change the "pyagrum.DiscreteVariable" names in the pyagrum.MarkovRandomField.

        Parameters
        ----------
        car :Union[int,str]
        	a variable's id (int) or name
        new_name : str
        	the new name of the variable

        Raises
        ------
        pyagrum.DuplicateLabel
            If new_name is already used in this MarkovRandomField.
        pyagrum.NotFound
            If no variable matches id.

        """
        return _mrf.MarkovRandomField_changeVariableName(self, *args)

    def changeVariableLabel(self, *args) -> None:
        r"""

        change the label of the variable associated to nodeId to the new value.

        Parameters
        ----------
        var :Union[int,str]
        	a variable's id (int) or name
        old_label : str
        	the old label
        new_label : str
        	the new label

        Raises
        ------
        pyagrum.NotFound
            if id/name is not a variable or if old_label does not exist.

        """
        return _mrf.MarkovRandomField_changeVariableLabel(self, *args)

    def nodeId(self, var: "pyagrum.DiscreteVariable") -> int:
        return _mrf.MarkovRandomField_nodeId(self, var)

    def idFromName(self, name: str) -> int:
        return _mrf.MarkovRandomField_idFromName(self, name)

    def variableFromName(self, name: str) -> "pyagrum.DiscreteVariable":
        return _mrf.MarkovRandomField_variableFromName(self, name)

    def generateFactors(self) -> None:
        r"""

        Randomly generates factors parameters for a given structure.

        """
        return _mrf.MarkovRandomField_generateFactors(self)

    def generateFactor(self, vars: List[int]) -> None:
        r"""

        Randomly generate factor parameters for a given factor in a given structure.

        Parameters
        ----------
        node : Union[int,str]
        	a variable's id (int) or name

        """
        return _mrf.MarkovRandomField_generateFactor(self, vars)

    def beginTopologyTransformation(self) -> None:
        return _mrf.MarkovRandomField_beginTopologyTransformation(self)

    def endTopologyTransformation(self) -> None:
        r"""

        Terminates a sequence of insertions/deletions of arcs by adjusting all CPTs dimensions.
        End Multiple Change for all CPTs.

        Returns
        -------
        pyagrum.MarkovRandomField

        """
        return _mrf.MarkovRandomField_endTopologyTransformation(self)

    def graph(self) -> "pyagrum.UndiGraph":
        return _mrf.MarkovRandomField_graph(self)

    def size(self) -> int:
        return _mrf.MarkovRandomField_size(self)

    def log10DomainSize(self) -> float:
        r"""

        returns the log10 of the domain size of the model defined as the product of the domain sizes of the variables in the model.

        Returns
        -------
        float
        	the log10 domain size.

        """
        return _mrf.MarkovRandomField_log10DomainSize(self)

    def names(self) -> object:
        r"""

        Set of names of variables in the model

        Returns
        -------
        Set[str]
        	The names of the graph variables

        """
        return _mrf.MarkovRandomField_names(self)

    def __iter__(self):
      """
      Iterate over the variables of the model

      Yield
      -----
      Tuple[int,str]
        The index of the variable and its name
      """
      for i in self.nodes():
        yield i,self.variable(i).name()

    def __getitem__(self, key):
      if isinstance(key, int):
        return self.variable(key)
      elif isinstance(key, str):
        return self.variableFromName(key)
      else:
        raise TypeError("key must be an int or a string")


    def nodes(self) -> object:
        return _mrf.MarkovRandomField_nodes(self)

    def connectedComponents(self):
      """ connected components from a graph/graphical models

      Compute the connected components of a pyAgrum's graph or graphical models
      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)

      The firstly visited node for each component is called a 'root' and is used as a key for the component.
      This root has been arbitrarily chosen during the algorithm.

      Returns
      -------
      dict(int,Set[int])
        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.

      """
      nodes=self.nodes()
      connected_components=dict()

      def parcours(node,orig):
          cc={node}
          nodes.discard(node)
          if hasattr(self,'children'):
              for chi in self.children(node):
                  if chi!=orig:
                      if chi in nodes:
                          cc|=parcours(chi,node)

          if hasattr(self,'parents'):
              for par in self.parents(node):
                  if par!=orig:
                      if par in nodes:
                          cc|=parcours(par,node)

          if hasattr(self,'neighbours'):
              for nei in self.neighbours(node):
                  if nei!=orig:
                      if nei in nodes:
                          cc|=parcours(nei,node)
          return cc

      while (len(nodes)>0):
          root=nodes.pop()
          connected_components[root]=parcours(root,None)
      return connected_components

    def adjacencyMatrix(self):
      """ adjacency matrix from a graph/graphical models

      Compute the adjacency matrix of a pyAgrum's graph or graphical models
      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)

      Returns
      -------
      numpy.ndarray
        adjacency matrix (as numpy.ndarray) with nodeId as key.

      """
      import numpy as np
      nodes=self.nodes()
      n=self.size()
      am=np.zeros((n,n)).astype(int)

      for node in nodes:
          if hasattr(self,'children'):
              for children in self.children(node):
                  am[node,children]=1
          if hasattr(self,'neighbours'):
              for neighbour in self.neighbours(node):
                  am[node,neighbour]=1
      return am


    def neighbours(self, norid: object) -> object:
        return _mrf.MarkovRandomField_neighbours(self, norid)

    def edges(self) -> object:
        return _mrf.MarkovRandomField_edges(self)

    def minimalCondSet(self, *args) -> object:
        return _mrf.MarkovRandomField_minimalCondSet(self, *args)

    def factor(self, *args) -> "pyagrum.Tensor":
        r"""

        Returns the factor of a set of variables (if existing).

        Parameters
        ----------
        vars : Union[Set[int],Set[str]]
        	A set of ids or names of variable the pyagrum.MarkovRandomField.

        Returns
        -------
        pyagrum.Tensor
        	The factor of the set of nodes.

        Raises
        ------
        pyagrum.NotFound
            If no variable's id matches varId.

        """
        return _mrf.MarkovRandomField_factor(self, *args)

    def isIndependent(self, *args) -> bool:
        r"""

        check if nodes X and nodes Y are independent given nodes Z

        Parameters
        ----------
        X : str|intList[str|int]
              a list of of nodeIds or names
        Y : str|intList[str|int]
              a list of of nodeIds or names
        Z : str|intList[str|int]
              a list of of nodeIds or names

        Raises
        ------
        InvalidArgument
          if X and Y share variables

        Returns
        -------
        bool
          True if X and Y are independent given Z in the model

        """
        return _mrf.MarkovRandomField_isIndependent(self, *args)

    def loadUAI(self, *args) -> str:
        r"""

        Load an UAI file.

        Parameters
        ----------
        name : str
        	the name's file
        l : list
        	list of functions to execute

        Raises
        ------
        pyagrum.IOError
            If file not found
        pyagrum.FatalError
            If file is not valid

        """
        return _mrf.MarkovRandomField_loadUAI(self, *args)

    def saveUAI(self, name: str) -> None:
        r"""

        Save the MarkovRandomField in an UAI file.

        Parameters
        ----------
        name : str
        	the file's name

        """
        return _mrf.MarkovRandomField_saveUAI(self, name)

    def __getstate__(self):
        pyagrum.base._gum_add_properties_while_getstate_(self)
        state={"nodes":[self.variable(i).toFast() for i in self.nodes()],
               "factors":[[n for n in self.factor(factor).names] for factor in self.factors()],
               "potential":{"-".join(self.factor(factor).names):self.factor(factor)[:].flatten().tolist() for factor in self.factors()},
               "properties":{k:self.property(k) for k in self.properties()}
              }
        return state

    def __setstate__(self,state):
        self.__init__()
        for fastvar in state['nodes']:
            self.add(fastvar)
        self.beginTopologyTransformation()
        for factor in state['factors']:
             self.addFactor(factor)
        self.endTopologyTransformation()
        for cliq in state['potential']:
            self.factor(cliq.split("-")).fillWith(state['potential'][cliq])
        for prop in state['properties']:
            self.setProperty(prop,state['properties'][prop])
        return self

    def toFast(self, filename: str = None) -> str:
      """
      Export the MRF as *fast* syntax (in a string or in a python file)

      Parameters
      ----------
      filename : Optional[str]
        the name of the file (including the prefix), if None , use sys.stdout
      """

      def _toFastMRF(model,pythoncode=False):
        res = []
        sovars = set()
        first = True
        for f in model.factors():
          l = []
          for x in f:
              if x in sovars:
                src = model.variable(x).name()
              else:
                src = model.variable(x).toFast()
                sovars.add(x)
              l.append(src)
          res.append("--".join(l))

        for x in model.nodes():
          if x not in sovars:
            res.append(model.variable(x).toFast())

        if pythoncode:
          return 'model=pyagrum.fastMRF("""'+';\n     '.join(res)+'""")'
        else:
          return ';'.join(res)

      if filename is None:
        return _toFastMRF(self)
      else:
        with open(filename, "w") as pyfile:
          print(_toFastBN(self,pythoncode=True), file=pyfile)


    def __repr__(self) -> str:
        return _mrf.MarkovRandomField___repr__(self)

    def __str__(self) -> str:
        return _mrf.MarkovRandomField___str__(self)

    def addFactor(self, *args) -> "pyagrum.Tensor":
        r"""

        Add a factor from a list or a set of id or str. If the argument is a set, the order is the order of the IDs of the variables

        Parameters
        ----------
        seq : sequence (list or set) of int or string
        	The sequence (ordered or not) of node id or names

        """
        return _mrf.MarkovRandomField_addFactor(self, *args)

    def eraseFactor(self, *args) -> None:
        return _mrf.MarkovRandomField_eraseFactor(self, *args)

    def addVariables(self,listFastVariables,default_nbr_mod=2):
       """
       Add a list of variable in the form of 'fast' syntax.

       Parameters
       ----------
       listFastVariables: List[str]
         the list of variables in 'fast' syntax.
       default_nbr_mod: int
         the number of modalities for the variable if not specified following :ref:`fast syntax<Quick specification of (randomly parameterized) graphical models>`. Note that default_nbr_mod=1 is
         mandatory to create variables with only one modality (for utility for instance).

       Returns
       -------
       List[int]
         the list of created ids.
       """
       return [self.add(descr,default_nbr_mod) for descr in listFastVariables]

    def addStructureListener(self,whenNodeAdded=None,whenNodeDeleted=None,whenEdgeAdded=None,whenedgeDeleted=None):
        """
        Add the listeners in parameters to the list of existing ones.

        Parameters
        ----------
        whenNodeAdded : lambda expression
          a function for when a node is added
        whenNodeDeleted : lambda expression
          a function for when a node is removed
        whenEdgeAdded : lambda expression
          a function for when an edge is added
        whenEdgeDeleted : lambda expression
          a function for when an edge is removed
        """
        if [whenNodeAdded,whenNodeDeleted,whenEdgeAdded,whenEdgeDeleted]==[None,None,None,None]:
          return

        if not hasattr(self,"_listeners"):
          self._listeners=[]

        nl = PythonBNListener(self, self.variableNodeMap())
        if whenNodeAdded is not None:
          nl.setWhenNodeAdded(whenNodeAdded)
        if whenNodeDeleted is not None:
          nl.setWhenNodeDeleted(whenNodeDeleted)
        if whenEdgeAdded is not None:
          nl.setWhenEdgeAdded(whenEdgeAdded)
        if whenEdgeDeleted is not None:
          nl.setWhenArcDeleted(whenEdgeDeleted)

        self._listeners.append(nl)


# Register MarkovRandomField in _mrf:
_mrf.MarkovRandomField_swigregister(MarkovRandomField)
class ShaferShenoyMRFInference(object):
    r"""

    Class used for Shafer-Shenoy inferences for Markov random field.

    ShaferShenoyMRFInference(bn) -> ShaferShenoyMRFInference
        Parameters:
            - **mrf** (*pyagrum.MarkovRandomField*) -- a Markov random field

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, MN: "IMarkovRandomField", use_binary_join_tree: bool=True):
        _mrf.ShaferShenoyMRFInference_swiginit(self, _mrf.new_ShaferShenoyMRFInference(MN, use_binary_join_tree))

        self._model=MN#first arg of the constructor



    __swig_destroy__ = _mrf.delete_ShaferShenoyMRFInference

    def setTriangulation(self, new_triangulation: "pyagrum.Triangulation") -> None:
        return _mrf.ShaferShenoyMRFInference_setTriangulation(self, new_triangulation)

    def joinTree(self) -> "pyagrum.CliqueGraph":
        r"""

        Returns
        -------
        pyagrum.CliqueGraph
          the current join tree used

        """
        return _mrf.ShaferShenoyMRFInference_joinTree(self)

    def junctionTree(self) -> "pyagrum.JunctionTree":
        r"""

        Returns
        -------
        pyagrum.CliqueGraph
          the current junction tree

        """
        val = _mrf.ShaferShenoyMRFInference_junctionTree(self)

        val._engine=self


        return val


    def evidenceProbability(self) -> float:
        r"""

        Returns
        -------
        float
          the probability of evidence

        """
        return _mrf.ShaferShenoyMRFInference_evidenceProbability(self)

    def setNumberOfThreads(self, nb: int) -> None:
        r"""

        If the argument nb is different from 0, this number of threads will be used during inferences, hence overriding aGrUM's default number of threads.
        If, on the contrary, nb is equal to 0, the parallelized inference engine will comply with aGrUM's default number of threads.

        Parameters
        ----------
        nb : int
        	the number of threads to be used by ShaferShenoyMRFInference

        """
        return _mrf.ShaferShenoyMRFInference_setNumberOfThreads(self, nb)

    def getNumberOfThreads(self) -> int:
        r"""

        returns the number of threads used by LazyPropagation during inferences.

        Returns
        -------
        int
        	the number of threads used by LazyPropagation during inferences

        """
        return _mrf.ShaferShenoyMRFInference_getNumberOfThreads(self)

    def isGumNumberOfThreadsOverriden(self) -> bool:
        r"""

        Indicates whether LazyPropagation currently overrides aGrUM's default number of threads (see method setNumberOfThreads).

        Returns
        -------
        bool
        	A Boolean indicating whether LazyPropagation currently overrides aGrUM's default number of threads

        """
        return _mrf.ShaferShenoyMRFInference_isGumNumberOfThreadsOverriden(self)

    def setMaxMemory(self, gigabytes: int) -> None:
        r"""

        sets an upper bound on the memory consumption admissible

        Parameters
        ----------
        gigabytes: float
          this upper bound in gigabytes.

        """
        return _mrf.ShaferShenoyMRFInference_setMaxMemory(self, gigabytes)

    def makeInference(self) -> None:
        r"""

        Perform the heavy computations needed to compute the targets' posteriors

        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.

        """
        return _mrf.ShaferShenoyMRFInference_makeInference(self)

    def addEvidence(self, *args) -> None:
        r"""

        Adds a new evidence on a node (might be soft or hard).

        Parameters
        ----------
        id : int
          a node Id
        nodeName : int
          a node name
        val :
          (int) a node value
        val :
          (str) the label of the node value
        vals : list
          a list of values

        Raises
        ------
          pyagrum.InvalidArgument
            If the node already has an evidence
          pyagrum.InvalidArgument
            If val is not a value for the node
          pyagrum.InvalidArgument
            If the size of vals is different from the domain side of the node
          pyagrum.FatalError
            If vals is a vector of 0s
          pyagrum.UndefinedElement
            If the node does not belong to the Bayesian network

        """
        return _mrf.ShaferShenoyMRFInference_addEvidence(self, *args)

    def chgEvidence(self, *args) -> None:
        r"""

        Change the value of an already existing evidence on a node (might be soft or hard).

        Parameters
        ----------
        id : int
          a node Id
        nodeName : int
          a node name
        val : intstr
          a node value or the label of the node value
        vals : List[float]
          a list of values

        Raises
        ------
        pyagrum.InvalidArgument
          If the node does not already have an evidence
        pyagrum.InvalidArgument
          If val is not a value for the node
        pyagrum.InvalidArgument
          If the size of vals is different from the domain side of the node
        pyagrum.FatalError
          If vals is a vector of 0s
        pyagrum.UndefinedElement
          If the node does not belong to the Bayesian network

        """
        return _mrf.ShaferShenoyMRFInference_chgEvidence(self, *args)

    def hasEvidence(self, *args) -> bool:
        r"""

        Parameters
        ----------
        id : int
          a node Id
        nodeName : str
          a node name

        Returns
        -------
        bool
          True if some node(s) (or the one in parameters) have received evidence

        Raises
        ------
        pyagrum.IndexError
          If the node does not belong to the Bayesian network

        """
        return _mrf.ShaferShenoyMRFInference_hasEvidence(self, *args)

    def eraseAllEvidence(self) -> None:
        r"""

        Removes all the evidence entered into the network.

        """
        return _mrf.ShaferShenoyMRFInference_eraseAllEvidence(self)

    def eraseEvidence(self, *args) -> None:
        r"""

        Remove the evidence, if any, corresponding to the node Id or name.

        Parameters
        ----------
        id : int
          a node Id
        nodeName : int
          a node name

        Raises
        ------
        pyagrum.IndexError
          If the node does not belong to the Bayesian network

        """
        return _mrf.ShaferShenoyMRFInference_eraseEvidence(self, *args)

    def hasHardEvidence(self, nodeName: str) -> bool:
        r"""

        Parameters
        ----------
        id : int
          a node Id
        nodeName : str
          a node name

        Returns
        -------
        bool
          True if node has received a hard evidence

        Raises
        ------
        pyagrum.IndexError
          If the node does not belong to the Bayesian network

        """
        return _mrf.ShaferShenoyMRFInference_hasHardEvidence(self, nodeName)

    def hasSoftEvidence(self, *args) -> bool:
        r"""

        Parameters
        ----------
        id : int
          a node Id
        nodeName : str
          a node name

        Returns
        -------
        bool
          True if node has received a soft evidence

        Raises
        ------
        pyagrum.IndexError
          If the node does not belong to the Bayesian network

        """
        return _mrf.ShaferShenoyMRFInference_hasSoftEvidence(self, *args)

    def nbrEvidence(self) -> int:
        r"""

        Returns
        -------
        int
          the number of evidence entered into the Bayesian network

        """
        return _mrf.ShaferShenoyMRFInference_nbrEvidence(self)

    def nbrHardEvidence(self) -> int:
        r"""

        Returns
        -------
        int
          the number of hard evidence entered into the Bayesian network

        """
        return _mrf.ShaferShenoyMRFInference_nbrHardEvidence(self)

    def nbrSoftEvidence(self) -> int:
        r"""

        Returns
        -------
        int
          the number of soft evidence entered into the Bayesian network

        """
        return _mrf.ShaferShenoyMRFInference_nbrSoftEvidence(self)

    def eraseAllTargets(self) -> None:
        r"""

        Clear all previously defined targets (marginal and joint targets).

        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).

        """
        return _mrf.ShaferShenoyMRFInference_eraseAllTargets(self)

    def addAllTargets(self) -> None:
        r"""

        Add all the nodes as targets.

        """
        return _mrf.ShaferShenoyMRFInference_addAllTargets(self)

    def addTarget(self, *args) -> None:
        r"""

        Add a marginal target to the list of targets.

        Parameters
        ----------
        target : int
          a node Id
        nodeName : str
          a node name

        Raises
        ------
        pyagrum.UndefinedElement
          If target is not a NodeId in the Bayes net

        """
        return _mrf.ShaferShenoyMRFInference_addTarget(self, *args)

    def eraseTarget(self, *args) -> None:
        r"""

        Remove, if existing, the marginal target.

        Parameters
        ----------
        target : int
          a node Id
        nodeName : int
          a node name

        Raises
        ------
        pyagrum.IndexError
          If one of the node does not belong to the Bayesian network
        pyagrum.UndefinedElement
          If node Id is not in the Bayesian network

        """
        return _mrf.ShaferShenoyMRFInference_eraseTarget(self, *args)

    def isTarget(self, *args) -> bool:
        r"""

        Parameters
        ----------
        variable : int
         a node Id
        nodeName : str
          a node name

        Returns
        -------
        bool
          True if variable is a (marginal) target

        Raises
        ------
        pyagrum.IndexError
          If the node does not belong to the Bayesian network
        pyagrum.UndefinedElement
          If node Id is not in the Bayesian network

        """
        return _mrf.ShaferShenoyMRFInference_isTarget(self, *args)

    def nbrTargets(self) -> int:
        r"""

        Returns
        -------
        int
          the number of marginal targets

        """
        return _mrf.ShaferShenoyMRFInference_nbrTargets(self)

    def H(self, *args) -> float:
        r"""

        Parameters
        ----------
        X : int
          a node Id
        nodeName : str
          a node name

        Returns
        -------
        float
          the computed Shanon's entropy of a node given the observation

        """
        return _mrf.ShaferShenoyMRFInference_H(self, *args)

    def MRF(self) -> "pyagrum.IMarkovRandomField":
        return _mrf.ShaferShenoyMRFInference_MRF(self)

    def posterior(self, *args) -> "pyagrum.Tensor":
        r"""

        Computes and returns the posterior of a node.

        Parameters
        ----------
        var : int
          the node Id of the node for which we need a posterior probability
        nodeName : str
          the node name of the node for which we need a posterior probability

        Returns
        -------
        pyagrum.Tensor
          a const ref to the posterior probability of the node

        Raises
        ------
        pyagrum.UndefinedElement
          If an element of nodes is not in targets

        """
        return _mrf.ShaferShenoyMRFInference_posterior(self, *args)

    def eraseAllJointTargets(self) -> None:
        r"""

        Clear all previously defined joint targets.

        """
        return _mrf.ShaferShenoyMRFInference_eraseAllJointTargets(self)

    def eraseAllMarginalTargets(self) -> None:
        r"""

        Clear all the previously defined marginal targets.

        """
        return _mrf.ShaferShenoyMRFInference_eraseAllMarginalTargets(self)

    def nbrJointTargets(self) -> int:
        r"""

        Returns
        -------
        int
          the number of joint targets

        """
        return _mrf.ShaferShenoyMRFInference_nbrJointTargets(self)

    def setEvidence(self, evidces):
        """
        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.

        Parameters
        ----------
        evidces : dict
          a dict of evidences

        Raises
        ------
        pyagrum.InvalidArgument
            If one value is not a value for the node
        pyagrum.InvalidArgument
            If the size of a value is different from the domain side of the node
        pyagrum.FatalError
            If one value is a vector of 0s
        pyagrum.UndefinedElement
            If one node does not belong to the Bayesian network
        """
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
        self.eraseAllEvidence()
        for k,v in evidces.items():
            self.addEvidence(k,v)



    def updateEvidence(self, evidces):
        """
        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).

        Parameters
        ----------
        evidces : dict
          a dict of evidences

        Raises
        ------
        pyagrum.InvalidArgument
            If one value is not a value for the node
        pyagrum.InvalidArgument
            If the size of a value is different from the domain side of the node
        pyagrum.FatalError
            If one value is a vector of 0s
        pyagrum.UndefinedElement
            If one node does not belong to the Bayesian network
        """
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))

        for k,v in evidces.items():
            if self.hasEvidence(k):
                self.chgEvidence(k,v)
            else:
                self.addEvidence(k,v)



    def setTargets(self, targets):
        """
        Remove all the targets and add the ones in parameter.

        Parameters
        ----------
        targets : set
          a set of targets

        Raises
        ------
        pyagrum.UndefinedElement
            If one target is not in the Bayes net
        """
        if not isinstance(targets, set):
            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))

        self.eraseAllTargets()
        for k in targets:
            self.addTarget(k)



    def hardEvidenceNodes(self) -> object:
        r"""

        Returns
        -------
        set
          the set of nodes with hard evidence

        """
        return _mrf.ShaferShenoyMRFInference_hardEvidenceNodes(self)

    def softEvidenceNodes(self) -> object:
        r"""

        Returns
        -------
        set
          the set of nodes with soft evidence

        """
        return _mrf.ShaferShenoyMRFInference_softEvidenceNodes(self)

    def targets(self) -> object:
        r"""

        Returns
        -------
        list
          the list of marginal targets

        """
        return _mrf.ShaferShenoyMRFInference_targets(self)

    def evidenceImpact(self, *args) -> "pyagrum.Tensor":
        r"""

        Create a pyagrum.Tensor for P(target|evs) (for all instanciation of target and evs)

        Parameters
        ----------
        target : set
          a set of targets ids or names.
        evs : set
          a set of nodes ids or names.

        Warnings
        --------
        if some evs are d-separated, they are not included in the Tensor.

        Returns
        -------
        pyagrum.Tensor
          a Tensor for P(targets|evs)

        """
        return _mrf.ShaferShenoyMRFInference_evidenceImpact(self, *args)

    def jointMutualInformation(self, targets: object) -> float:
        return _mrf.ShaferShenoyMRFInference_jointMutualInformation(self, targets)

    def evidenceJointImpact(self, *args) -> "pyagrum.Tensor":
        r"""

        Create a pyagrum.Tensor for P(joint targets|evs) (for all instanciation of targets and evs)

        Parameters
        ----------
        targets : List[intstr]
          a list of node Ids or node names
        evs : Set[intstr]
          a set of nodes ids or names.

        Returns
        -------
        pyagrum.Tensor
          a Tensor for P(target|evs)

        Raises
        ------
        pyagrum.Exception
          If some evidene entered into the Bayes net are incompatible (their joint proba = 0)

        """
        return _mrf.ShaferShenoyMRFInference_evidenceJointImpact(self, *args)

    def jointPosterior(self, targets: object) -> "pyagrum.Tensor":
        r"""

        Compute the joint posterior of a set of nodes.

        Parameters
        ----------
        list :
          the list of nodes whose posterior joint probability is wanted


        Warnings
        --------
        The order of the variables given by the list here or when the jointTarget is declared can not be assumed to be used by the Tensor.

        Returns
        -------
        pyagrum.Tensor
          a const ref to the posterior joint probability of the set of nodes.

        Raises
        ------
        pyagrum.UndefinedElement
          If an element of nodes is not in targets

        """
        return _mrf.ShaferShenoyMRFInference_jointPosterior(self, targets)

    def addJointTarget(self, targets: object) -> None:
        r"""

        Add a list of nodes as a new joint target. As a collateral effect, every node is added as a marginal target.

        Parameters
        ----------
        list
          a list of names of nodes

        Raises
        ------
        pyagrum.UndefinedElement
          If some node(s) do not belong to the Bayesian network

        """
        return _mrf.ShaferShenoyMRFInference_addJointTarget(self, targets)

    def eraseJointTarget(self, targets: object) -> None:
        r"""

        Remove, if existing, the joint target.

        Parameters
        ----------
        list
          a list of names or Ids of nodes

        Raises
        ------
        pyagrum.IndexError
          If one of the node does not belong to the Bayesian network
        pyagrum.UndefinedElement
          If node Id is not in the Bayesian network

        """
        return _mrf.ShaferShenoyMRFInference_eraseJointTarget(self, targets)

    def isJointTarget(self, targets: object) -> bool:
        r"""

        Parameters
        ----------
        list
          a list of nodes ids or names.

        Returns
        -------
        bool
          True if target is a joint target.

        Raises
        ------
        pyagrum.IndexError
          If the node does not belong to the Bayesian network
        pyagrum.UndefinedElement
          If node Id is not in the Bayesian network

        """
        return _mrf.ShaferShenoyMRFInference_isJointTarget(self, targets)

    def jointTargets(self) -> object:
        r"""

        Returns
        -------
        list
          the list of target sets

        """
        return _mrf.ShaferShenoyMRFInference_jointTargets(self)

# Register ShaferShenoyMRFInference in _mrf:
_mrf.ShaferShenoyMRFInference_swigregister(ShaferShenoyMRFInference)

__version__ = '2.0.1'
__license__ = __doc__
__project_url__ = 'https://agrum.org'
__project_name__ = 'pyAgrum'
__project_description__ = __doc__
__project__ = __doc__


def about():
  """
  about() for pyAgrum

  """
  print(f"pyAgrum {__version__}")
  print("(c) 2015-2024 Pierre-Henri Wuillemin, Christophe Gonzales")
  print("""
    This is free software; see the source code for copying conditions.
    There is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  For details, see 'pyagrum.warranty'.
    """)


import warnings

def availableMRFExts():
  """ Give the list of all formats known by pyAgrum to save a Markov random field.

  Returns
  ------
  str
    a string which lists all suffixes for supported MRF file formats.
  """
  return "uai|pkl"


def loadMRF(filename, listeners=None, verbose=False):
  """load a MRF from a file with optional listeners and arguments

  Parameters
  ----------
  filename: str
    the name of the input file
  listeners: List[Object]
    list of functions to execute
  verbose: bool
    whether to print or not warning messages

  Returns
  -------
  pyagrum.MarkovRandomField
    a MRF from a file using one of the availableMNExts() suffixes.

  Listeners could be added in order to monitor its loading.

  pkl suffix is used to save a BN using pickle. In this case, options are ignored.

  Examples
  --------
  >>> import pyagrum as gum
  >>>
  >>> # creating listeners
  >>> def foo_listener(progress):
  >>>    if progress==200:
  >>>        print(' BN loaded ')
  >>>        return
  >>>    elif progress==100:
  >>>        car='%'
  >>>    elif progress%10==0:
  >>>        car='#'
  >>>    else:
  >>>        car='.'
  >>>    print(car,end='',flush=True)
  >>>
  >>> def bar_listener(progress):
  >>>    if progress==50:
  >>>        print('50%')
  >>>
  >>> # loadBN with list of listeners
  >>> pyagrum.loadMRF('./bn.uai',listeners=[foo_listener,bar_listener])
  >>> # .........#.........#.........#.........#..50%
  >>> # .......#.........#.........#.........#.........#.........% | bn loaded
  """
  mn = MarkovRandomField()

  extension = filename.split('.')[-1].upper()
  if extension == "UAI":
    warns = mn.loadUAI(filename, listeners)
  elif extension == "PKL":
    import pickle
    with open(filename, "rb") as f:
      mn = pickle.load(f)
  else:
    raise InvalidArgument("extension " + filename.split('.')
    [-1] + " unknown. Please use among " + availableBNExts())

  if verbose:
    print(warns)

  mn.setProperty("name", mn.propertyWithDefault("name", ospath.splitext(ospath.basename(filename))[0]))
  return mn


def saveMRF(mn, filename):
  """
  save a MRF into a file using the format corresponding to one of the availableWriteMNExts() suffixes.

  Parameters
  ----------
  mn : pyagrum.MarkovRandomField)
    the MRF to save
  filename : str
    the name of the output file
  """
  extension = filename.split('.')[-1].upper()

  if extension == "UAI":
    mn.saveUAI(filename)
  elif extension == "PKL":
    import pickle
    with open(filename, "wb") as f:
      pickle.dump(mn, f, pickle.HIGHEST_PROTOCOL)
  else:
    raise InvalidArgument("extension " + filename.split('.')[-1] + " unknown. Please use among " + availableMNExts())

def fastMRF(structure, domain="[2]"):
  """
  Create a Markov random field with a modified dot-like syntax which specifies:
      - the structure 'a-b-c;b-d;c-e;' where each chain 'a-b-c' specifies a factor,
      - the type of the variables with different syntax (cf documentation).

  Examples
  --------
  >>> import pyagrum as gum
  >>> bn=pyagrum.fastMRF('A--B[1,3]--C{yes|No};C--D[2,4]--E[1,2.5,3.9]',6)

  Parameters
  ----------
  structure : str
          the string containing the specification
  domain: int or str
          the default domain size (int) or domain specification (str) for variables (default is "[2]"

  Returns
  -------
  pyagrum.MarkovRandomField
          the resulting Markov random field
  """
  return MarkovRandomField.fastPrototype(structure, domain)


def getPosterior(model, *, target, evs=None):
  """
  Compute the posterior of a single target (variable) in a BN given evidence


  getPosterior uses a VariableElimination inference.
  If more than one target is needed with the same set of evidence or if the same
  target is needed with more than one set of evidence, this function is not
  relevant since it creates a new inference engine every time it is called.

  Parameters
  ----------
  bn : pyagrum.BayesNet or pyagrum.MarkovRandomField
    The probabilistic Graphical Model
  target: string or int
    variable name or id (forced keyword argument)
  evs:  Dict[name|id:val, name|id : List[ val1, val2 ], ...]. (optional forced keyword argument)
    the (hard and soft) evidence

  Returns
  -------
    posterior (pyagrum.Tensor or other)
  """
  if isinstance(model, pyagrum.bn.BayesNet):
    inf = pyagrum.bn.VariableElimination(model)
  elif isinstance(model, MarkovRandomField):
    inf = ShaferShenoyMRFInference(model)
  else:
    raise InvalidArgument("Argument model should be a PGM (BayesNet or MarkovRandomField")

  if evs is not None:
    inf.setEvidence(evs)
  inf.addTarget(target)
  inf.makeInference()
# creating a new Tensor from posterior(will disappear with ie)
  return pyagrum.base.Tensor(inf.posterior(target))


