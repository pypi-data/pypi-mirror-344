# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.4.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""base module"""

from sys import version_info as _swig_python_version_info
# ## added by passForType (pyAgrum)
from typing import List,Set,Dict,Tuple
# ## recursive import for typehints annotation
import pyagrum
# ## end of added by passForType (pyAgrum)

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _base
else:
    import _base

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _base.delete_SwigPyIterator

    def value(self) -> object:
        return _base.SwigPyIterator_value(self)

    def incr(self, n: int=1) -> "swig::SwigPyIterator *":
        return _base.SwigPyIterator_incr(self, n)

    def decr(self, n: int=1) -> "swig::SwigPyIterator *":
        return _base.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _base.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> bool:
        return _base.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _base.SwigPyIterator_copy(self)

    def next(self) -> object:
        return _base.SwigPyIterator_next(self)

    def __next__(self) -> object:
        return _base.SwigPyIterator___next__(self)

    def previous(self) -> object:
        return _base.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _base.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> bool:
        return _base.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> bool:
        return _base.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _base.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _base.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _base.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _base.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _base:
_base.SwigPyIterator_swigregister(SwigPyIterator)
class JunctionTreeGenerator(object):
    r"""

    JunctionTreeGenerator is use to generate junction tree or binary junction tree from Bayesian networks.

    JunctionTreeGenerator() -> JunctionTreeGenerator
        default constructor

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def junctionTree(self, *args) -> "pyagrum.JunctionTree":
        r"""

        Computes the junction tree for its parameters. If the first parameter is a graph, the heurisitcs assume that all the node have the same domain size (2). If given, the heuristic takes into account the partial order for its elimination order.

        Parameters
        ----------
        g : pyagrum.UndiGraph
        	a undirected graph

        dag : pyagrum.DAG
        	a dag

        bn : pyagrum.BayesNet
        	a BayesianNetwork

        partial_order: List[List[int]]
        	a partial order among the nodeIDs

        Returns
        -------
        pyagrum.CliqueGraph
        	the current junction tree.

        """
        return _base.JunctionTreeGenerator_junctionTree(self, *args)

    def eliminationOrder(self, *args) -> object:
        r"""

        Computes the elimination for its parameters. If the first parameter is a graph, the heurisitcs assume that all the node have the same domain size (2). If given, the heuristic takes into account the partial order for its elimination order.

        Parameters
        ----------
        g : pyagrum.UndiGraph
        	a undirected graph

        dag : pyagrum.DAG
        	a dag

        bn : pyagrum.BayesNet
        	a BayesianNetwork

        partial_order: List[List[int]]
        	a partial order among the nodeIDs

        Returns
        -------
        pyagrum.CliqueGraph
        	the current elimination order.

        """
        return _base.JunctionTreeGenerator_eliminationOrder(self, *args)

    def binaryJoinTree(self, *args) -> "pyagrum.JunctionTree":
        r"""

        Computes the binary joint tree for its parameters. If the first parameter is a graph, the heurisitcs assume that all the node have the same domain size (2). If given, the heuristic takes into account the partial order for its elimination order.

        Parameters
        ----------
        g : pyagrum.UndiGraph
        	a undirected graph

        dag : pyagrum.DAG
        	a dag

        bn : pyagrum.BayesNet
        	a BayesianNetwork

        partial_order: List[List[int]]
        	a partial order among the nodeIDs

        Returns
        -------
        pyagrum.CliqueGraph
        	the current binary joint tree

        """
        return _base.JunctionTreeGenerator_binaryJoinTree(self, *args)

    def __init__(self):
        r"""

        JunctionTreeGenerator is use to generate junction tree or binary junction tree from Bayesian networks.

        JunctionTreeGenerator() -> JunctionTreeGenerator
            default constructor

        """
        _base.JunctionTreeGenerator_swiginit(self, _base.new_JunctionTreeGenerator())
    __swig_destroy__ = _base.delete_JunctionTreeGenerator

# Register JunctionTreeGenerator in _base:
_base.JunctionTreeGenerator_swigregister(JunctionTreeGenerator)
class Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _base.Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> bool:
        return _base.Vector___nonzero__(self)

    def __bool__(self) -> bool:
        return _base.Vector___bool__(self)

    def __len__(self) -> int:
        return _base.Vector___len__(self)

    def __getslice__(self, i: int, j: int) -> List[float]:
        return _base.Vector___getslice__(self, i, j)

    def __setslice__(self, *args) -> None:
        return _base.Vector___setslice__(self, *args)

    def __delslice__(self, i: int, j: int) -> None:
        return _base.Vector___delslice__(self, i, j)

    def __delitem__(self, *args) -> None:
        return _base.Vector___delitem__(self, *args)

    def __getitem__(self, *args) -> float:
        return _base.Vector___getitem__(self, *args)

    def __setitem__(self, *args) -> None:
        return _base.Vector___setitem__(self, *args)

    def pop(self) -> float:
        return _base.Vector_pop(self)

    def append(self, x: float) -> None:
        return _base.Vector_append(self, x)

    def empty(self) -> bool:
        return _base.Vector_empty(self)

    def size(self) -> int:
        return _base.Vector_size(self)

    def swap(self, v: "pyagrum.Vector") -> None:
        return _base.Vector_swap(self, v)

    def begin(self) -> int:
        return _base.Vector_begin(self)

    def end(self) -> int:
        return _base.Vector_end(self)

    def rbegin(self) -> int:
        return _base.Vector_rbegin(self)

    def rend(self) -> int:
        return _base.Vector_rend(self)

    def clear(self) -> None:
        return _base.Vector_clear(self)

    def get_allocator(self) -> object:
        return _base.Vector_get_allocator(self)

    def pop_back(self) -> None:
        return _base.Vector_pop_back(self)

    def erase(self, *args) -> int:
        return _base.Vector_erase(self, *args)

    def __init__(self, *args):
        _base.Vector_swiginit(self, _base.new_Vector(*args))

    def push_back(self, x: float) -> None:
        return _base.Vector_push_back(self, x)

    def front(self) -> float:
        return _base.Vector_front(self)

    def back(self) -> float:
        return _base.Vector_back(self)

    def assign(self, n: int, x: float) -> None:
        return _base.Vector_assign(self, n, x)

    def resize(self, *args) -> None:
        return _base.Vector_resize(self, *args)

    def insert(self, *args) -> None:
        return _base.Vector_insert(self, *args)

    def reserve(self, n: int) -> None:
        return _base.Vector_reserve(self, n)

    def capacity(self) -> int:
        return _base.Vector_capacity(self)
    __swig_destroy__ = _base.delete_Vector

# Register Vector in _base:
_base.Vector_swigregister(Vector)
class Vector_uint(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _base.Vector_uint_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> bool:
        return _base.Vector_uint___nonzero__(self)

    def __bool__(self) -> bool:
        return _base.Vector_uint___bool__(self)

    def __len__(self) -> int:
        return _base.Vector_uint___len__(self)

    def __getslice__(self, i: int, j: int) -> List[int]:
        return _base.Vector_uint___getslice__(self, i, j)

    def __setslice__(self, *args) -> None:
        return _base.Vector_uint___setslice__(self, *args)

    def __delslice__(self, i: int, j: int) -> None:
        return _base.Vector_uint___delslice__(self, i, j)

    def __delitem__(self, *args) -> None:
        return _base.Vector_uint___delitem__(self, *args)

    def __getitem__(self, *args) -> int:
        return _base.Vector_uint___getitem__(self, *args)

    def __setitem__(self, *args) -> None:
        return _base.Vector_uint___setitem__(self, *args)

    def pop(self) -> int:
        return _base.Vector_uint_pop(self)

    def append(self, x: int) -> None:
        return _base.Vector_uint_append(self, x)

    def empty(self) -> bool:
        return _base.Vector_uint_empty(self)

    def size(self) -> int:
        return _base.Vector_uint_size(self)

    def swap(self, v: "Vector_uint") -> None:
        return _base.Vector_uint_swap(self, v)

    def begin(self) -> int:
        return _base.Vector_uint_begin(self)

    def end(self) -> int:
        return _base.Vector_uint_end(self)

    def rbegin(self) -> int:
        return _base.Vector_uint_rbegin(self)

    def rend(self) -> int:
        return _base.Vector_uint_rend(self)

    def clear(self) -> None:
        return _base.Vector_uint_clear(self)

    def get_allocator(self) -> object:
        return _base.Vector_uint_get_allocator(self)

    def pop_back(self) -> None:
        return _base.Vector_uint_pop_back(self)

    def erase(self, *args) -> int:
        return _base.Vector_uint_erase(self, *args)

    def __init__(self, *args):
        _base.Vector_uint_swiginit(self, _base.new_Vector_uint(*args))

    def push_back(self, x: int) -> None:
        return _base.Vector_uint_push_back(self, x)

    def front(self) -> int:
        return _base.Vector_uint_front(self)

    def back(self) -> int:
        return _base.Vector_uint_back(self)

    def assign(self, n: int, x: int) -> None:
        return _base.Vector_uint_assign(self, n, x)

    def resize(self, *args) -> None:
        return _base.Vector_uint_resize(self, *args)

    def insert(self, *args) -> None:
        return _base.Vector_uint_insert(self, *args)

    def reserve(self, n: int) -> None:
        return _base.Vector_uint_reserve(self, n)

    def capacity(self) -> int:
        return _base.Vector_uint_capacity(self)
    __swig_destroy__ = _base.delete_Vector_uint

# Register Vector_uint in _base:
_base.Vector_uint_swigregister(Vector_uint)
class Vector_int(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _base.Vector_int_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> bool:
        return _base.Vector_int___nonzero__(self)

    def __bool__(self) -> bool:
        return _base.Vector_int___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _base.Vector_int___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> List[int]:
        return _base.Vector_int___getslice__(self, i, j)

    def __setslice__(self, *args) -> None:
        return _base.Vector_int___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> None:
        return _base.Vector_int___delslice__(self, i, j)

    def __delitem__(self, *args) -> None:
        return _base.Vector_int___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _base.Vector_int___getitem__(self, *args)

    def __setitem__(self, *args) -> None:
        return _base.Vector_int___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _base.Vector_int_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> None:
        return _base.Vector_int_append(self, x)

    def empty(self) -> bool:
        return _base.Vector_int_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _base.Vector_int_size(self)

    def swap(self, v: "Vector_int") -> None:
        return _base.Vector_int_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _base.Vector_int_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _base.Vector_int_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _base.Vector_int_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _base.Vector_int_rend(self)

    def clear(self) -> None:
        return _base.Vector_int_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _base.Vector_int_get_allocator(self)

    def pop_back(self) -> None:
        return _base.Vector_int_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _base.Vector_int_erase(self, *args)

    def __init__(self, *args):
        _base.Vector_int_swiginit(self, _base.new_Vector_int(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> None:
        return _base.Vector_int_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _base.Vector_int_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _base.Vector_int_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> None:
        return _base.Vector_int_assign(self, n, x)

    def resize(self, *args) -> None:
        return _base.Vector_int_resize(self, *args)

    def insert(self, *args) -> None:
        return _base.Vector_int_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> None:
        return _base.Vector_int_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _base.Vector_int_capacity(self)
    __swig_destroy__ = _base.delete_Vector_int

# Register Vector_int in _base:
_base.Vector_int_swigregister(Vector_int)
class Vector_string(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _base.Vector_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> bool:
        return _base.Vector_string___nonzero__(self)

    def __bool__(self) -> bool:
        return _base.Vector_string___bool__(self)

    def __len__(self) -> int:
        return _base.Vector_string___len__(self)

    def __getslice__(self, i: int, j: int) -> List[str]:
        return _base.Vector_string___getslice__(self, i, j)

    def __setslice__(self, *args) -> None:
        return _base.Vector_string___setslice__(self, *args)

    def __delslice__(self, i: int, j: int) -> None:
        return _base.Vector_string___delslice__(self, i, j)

    def __delitem__(self, *args) -> None:
        return _base.Vector_string___delitem__(self, *args)

    def __getitem__(self, *args) -> str:
        return _base.Vector_string___getitem__(self, *args)

    def __setitem__(self, *args) -> None:
        return _base.Vector_string___setitem__(self, *args)

    def pop(self) -> str:
        return _base.Vector_string_pop(self)

    def append(self, x: str) -> None:
        return _base.Vector_string_append(self, x)

    def empty(self) -> bool:
        return _base.Vector_string_empty(self)

    def size(self) -> int:
        return _base.Vector_string_size(self)

    def swap(self, v: List[str]) -> None:
        return _base.Vector_string_swap(self, v)

    def begin(self) -> int:
        return _base.Vector_string_begin(self)

    def end(self) -> int:
        return _base.Vector_string_end(self)

    def rbegin(self) -> int:
        return _base.Vector_string_rbegin(self)

    def rend(self) -> int:
        return _base.Vector_string_rend(self)

    def clear(self) -> None:
        return _base.Vector_string_clear(self)

    def get_allocator(self) -> object:
        return _base.Vector_string_get_allocator(self)

    def pop_back(self) -> None:
        return _base.Vector_string_pop_back(self)

    def erase(self, *args) -> int:
        return _base.Vector_string_erase(self, *args)

    def __init__(self, *args):
        _base.Vector_string_swiginit(self, _base.new_Vector_string(*args))

    def push_back(self, x: str) -> None:
        return _base.Vector_string_push_back(self, x)

    def front(self) -> str:
        return _base.Vector_string_front(self)

    def back(self) -> str:
        return _base.Vector_string_back(self)

    def assign(self, n: int, x: str) -> None:
        return _base.Vector_string_assign(self, n, x)

    def resize(self, *args) -> None:
        return _base.Vector_string_resize(self, *args)

    def insert(self, *args) -> None:
        return _base.Vector_string_insert(self, *args)

    def reserve(self, n: int) -> None:
        return _base.Vector_string_reserve(self, n)

    def capacity(self) -> int:
        return _base.Vector_string_capacity(self)
    __swig_destroy__ = _base.delete_Vector_string

# Register Vector_string in _base:
_base.Vector_string_swigregister(Vector_string)
class GumException(Exception):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.GumException_swiginit(self, _base.new_GumException(*args))
    __swig_destroy__ = _base.delete_GumException

    def what(self) -> str:
        return _base.GumException_what(self)

    def errorContent(self) -> str:
        r"""

        Returns
        -------
        str
        	the error content

        """
        return _base.GumException_errorContent(self)

    def errorType(self) -> str:
        r"""

        Returns
        -------
        str
        	the error type

        """
        return _base.GumException_errorType(self)

    def errorCallStack(self) -> str:
        r"""

        Returns
        -------
        str
        	the error call stack

        """
        return _base.GumException_errorCallStack(self)

# Register GumException in _base:
_base.GumException_swigregister(GumException)
cvar = _base.cvar
_static_Set_end_ = cvar._static_Set_end_
_static_Set_end_safe_ = cvar._static_Set_end_safe_
_Set_end_ = cvar._Set_end_
_Set_end_safe_ = cvar._Set_end_safe_


def _createMsg_(filename: str, function: str, line: int, msg: str) -> str:
    return _base._createMsg_(filename, function, line, msg)
class FatalError(GumException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.FatalError_swiginit(self, _base.new_FatalError(*args))
    __swig_destroy__ = _base.delete_FatalError

# Register FatalError in _base:
_base.FatalError_swigregister(FatalError)
class NotImplementedYet(GumException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.NotImplementedYet_swiginit(self, _base.new_NotImplementedYet(*args))
    __swig_destroy__ = _base.delete_NotImplementedYet

# Register NotImplementedYet in _base:
_base.NotImplementedYet_swigregister(NotImplementedYet)
class IteratorError(GumException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.IteratorError_swiginit(self, _base.new_IteratorError(*args))
    __swig_destroy__ = _base.delete_IteratorError

# Register IteratorError in _base:
_base.IteratorError_swigregister(IteratorError)
class UndefinedIteratorValue(IteratorError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.UndefinedIteratorValue_swiginit(self, _base.new_UndefinedIteratorValue(*args))
    __swig_destroy__ = _base.delete_UndefinedIteratorValue

# Register UndefinedIteratorValue in _base:
_base.UndefinedIteratorValue_swigregister(UndefinedIteratorValue)
class UndefinedIteratorKey(IteratorError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.UndefinedIteratorKey_swiginit(self, _base.new_UndefinedIteratorKey(*args))
    __swig_destroy__ = _base.delete_UndefinedIteratorKey

# Register UndefinedIteratorKey in _base:
_base.UndefinedIteratorKey_swigregister(UndefinedIteratorKey)
class NullElement(GumException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.NullElement_swiginit(self, _base.new_NullElement(*args))
    __swig_destroy__ = _base.delete_NullElement

# Register NullElement in _base:
_base.NullElement_swigregister(NullElement)
class UndefinedElement(GumException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.UndefinedElement_swiginit(self, _base.new_UndefinedElement(*args))
    __swig_destroy__ = _base.delete_UndefinedElement

# Register UndefinedElement in _base:
_base.UndefinedElement_swigregister(UndefinedElement)
class SizeError(GumException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.SizeError_swiginit(self, _base.new_SizeError(*args))
    __swig_destroy__ = _base.delete_SizeError

# Register SizeError in _base:
_base.SizeError_swigregister(SizeError)
class ArgumentError(GumException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.ArgumentError_swiginit(self, _base.new_ArgumentError(*args))
    __swig_destroy__ = _base.delete_ArgumentError

# Register ArgumentError in _base:
_base.ArgumentError_swigregister(ArgumentError)
class InvalidArgumentsNumber(ArgumentError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.InvalidArgumentsNumber_swiginit(self, _base.new_InvalidArgumentsNumber(*args))
    __swig_destroy__ = _base.delete_InvalidArgumentsNumber

# Register InvalidArgumentsNumber in _base:
_base.InvalidArgumentsNumber_swigregister(InvalidArgumentsNumber)
class InvalidArgument(ArgumentError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.InvalidArgument_swiginit(self, _base.new_InvalidArgument(*args))
    __swig_destroy__ = _base.delete_InvalidArgument

# Register InvalidArgument in _base:
_base.InvalidArgument_swigregister(InvalidArgument)
class IOError(GumException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.IOError_swiginit(self, _base.new_IOError(*args))
    __swig_destroy__ = _base.delete_IOError

# Register IOError in _base:
_base.IOError_swigregister(IOError)
class FormatNotFound(IOError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.FormatNotFound_swiginit(self, _base.new_FormatNotFound(*args))
    __swig_destroy__ = _base.delete_FormatNotFound

# Register FormatNotFound in _base:
_base.FormatNotFound_swigregister(FormatNotFound)
class OperationNotAllowed(GumException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.OperationNotAllowed_swiginit(self, _base.new_OperationNotAllowed(*args))
    __swig_destroy__ = _base.delete_OperationNotAllowed

# Register OperationNotAllowed in _base:
_base.OperationNotAllowed_swigregister(OperationNotAllowed)
class NotFound(GumException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.NotFound_swiginit(self, _base.new_NotFound(*args))
    __swig_destroy__ = _base.delete_NotFound

# Register NotFound in _base:
_base.NotFound_swigregister(NotFound)
class OutOfBounds(ArgumentError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.OutOfBounds_swiginit(self, _base.new_OutOfBounds(*args))
    __swig_destroy__ = _base.delete_OutOfBounds

# Register OutOfBounds in _base:
_base.OutOfBounds_swigregister(OutOfBounds)
class DuplicateElement(ArgumentError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.DuplicateElement_swiginit(self, _base.new_DuplicateElement(*args))
    __swig_destroy__ = _base.delete_DuplicateElement

# Register DuplicateElement in _base:
_base.DuplicateElement_swigregister(DuplicateElement)
class DuplicateLabel(ArgumentError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.DuplicateLabel_swiginit(self, _base.new_DuplicateLabel(*args))
    __swig_destroy__ = _base.delete_DuplicateLabel

# Register DuplicateLabel in _base:
_base.DuplicateLabel_swigregister(DuplicateLabel)
class GraphError(GumException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.GraphError_swiginit(self, _base.new_GraphError(*args))
    __swig_destroy__ = _base.delete_GraphError

# Register GraphError in _base:
_base.GraphError_swigregister(GraphError)
class NoNeighbour(GraphError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.NoNeighbour_swiginit(self, _base.new_NoNeighbour(*args))
    __swig_destroy__ = _base.delete_NoNeighbour

# Register NoNeighbour in _base:
_base.NoNeighbour_swigregister(NoNeighbour)
class NoParent(GraphError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.NoParent_swiginit(self, _base.new_NoParent(*args))
    __swig_destroy__ = _base.delete_NoParent

# Register NoParent in _base:
_base.NoParent_swigregister(NoParent)
class NoChild(GraphError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.NoChild_swiginit(self, _base.new_NoChild(*args))
    __swig_destroy__ = _base.delete_NoChild

# Register NoChild in _base:
_base.NoChild_swigregister(NoChild)
class InvalidEdge(GraphError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.InvalidEdge_swiginit(self, _base.new_InvalidEdge(*args))
    __swig_destroy__ = _base.delete_InvalidEdge

# Register InvalidEdge in _base:
_base.InvalidEdge_swigregister(InvalidEdge)
class InvalidArc(GraphError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.InvalidArc_swiginit(self, _base.new_InvalidArc(*args))
    __swig_destroy__ = _base.delete_InvalidArc

# Register InvalidArc in _base:
_base.InvalidArc_swigregister(InvalidArc)
class InvalidNode(GraphError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.InvalidNode_swiginit(self, _base.new_InvalidNode(*args))
    __swig_destroy__ = _base.delete_InvalidNode

# Register InvalidNode in _base:
_base.InvalidNode_swigregister(InvalidNode)
class DefaultInLabel(GraphError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.DefaultInLabel_swiginit(self, _base.new_DefaultInLabel(*args))
    __swig_destroy__ = _base.delete_DefaultInLabel

# Register DefaultInLabel in _base:
_base.DefaultInLabel_swigregister(DefaultInLabel)
class InvalidDirectedCycle(GraphError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.InvalidDirectedCycle_swiginit(self, _base.new_InvalidDirectedCycle(*args))
    __swig_destroy__ = _base.delete_InvalidDirectedCycle

# Register InvalidDirectedCycle in _base:
_base.InvalidDirectedCycle_swigregister(InvalidDirectedCycle)
class InvalidPartiallyDirectedCycle(GraphError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.InvalidPartiallyDirectedCycle_swiginit(self, _base.new_InvalidPartiallyDirectedCycle(*args))
    __swig_destroy__ = _base.delete_InvalidPartiallyDirectedCycle

# Register InvalidPartiallyDirectedCycle in _base:
_base.InvalidPartiallyDirectedCycle_swigregister(InvalidPartiallyDirectedCycle)
class CPTError(GumException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.CPTError_swiginit(self, _base.new_CPTError(*args))
    __swig_destroy__ = _base.delete_CPTError

# Register CPTError in _base:
_base.CPTError_swigregister(CPTError)
class ScheduleMultiDimError(GumException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.ScheduleMultiDimError_swiginit(self, _base.new_ScheduleMultiDimError(*args))
    __swig_destroy__ = _base.delete_ScheduleMultiDimError

# Register ScheduleMultiDimError in _base:
_base.ScheduleMultiDimError_swigregister(ScheduleMultiDimError)
class AbstractScheduleMultiDim(ScheduleMultiDimError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.AbstractScheduleMultiDim_swiginit(self, _base.new_AbstractScheduleMultiDim(*args))
    __swig_destroy__ = _base.delete_AbstractScheduleMultiDim

# Register AbstractScheduleMultiDim in _base:
_base.AbstractScheduleMultiDim_swigregister(AbstractScheduleMultiDim)
class UnknownScheduleMultiDim(ScheduleMultiDimError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.UnknownScheduleMultiDim_swiginit(self, _base.new_UnknownScheduleMultiDim(*args))
    __swig_destroy__ = _base.delete_UnknownScheduleMultiDim

# Register UnknownScheduleMultiDim in _base:
_base.UnknownScheduleMultiDim_swigregister(UnknownScheduleMultiDim)
class DuplicateScheduleMultiDim(ScheduleMultiDimError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.DuplicateScheduleMultiDim_swiginit(self, _base.new_DuplicateScheduleMultiDim(*args))
    __swig_destroy__ = _base.delete_DuplicateScheduleMultiDim

# Register DuplicateScheduleMultiDim in _base:
_base.DuplicateScheduleMultiDim_swigregister(DuplicateScheduleMultiDim)
class ScheduleOperationError(GumException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.ScheduleOperationError_swiginit(self, _base.new_ScheduleOperationError(*args))
    __swig_destroy__ = _base.delete_ScheduleOperationError

# Register ScheduleOperationError in _base:
_base.ScheduleOperationError_swigregister(ScheduleOperationError)
class UnknownScheduleOperation(ScheduleOperationError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.UnknownScheduleOperation_swiginit(self, _base.new_UnknownScheduleOperation(*args))
    __swig_destroy__ = _base.delete_UnknownScheduleOperation

# Register UnknownScheduleOperation in _base:
_base.UnknownScheduleOperation_swigregister(UnknownScheduleOperation)
class UnavailableScheduleOperation(ScheduleOperationError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.UnavailableScheduleOperation_swiginit(self, _base.new_UnavailableScheduleOperation(*args))
    __swig_destroy__ = _base.delete_UnavailableScheduleOperation

# Register UnavailableScheduleOperation in _base:
_base.UnavailableScheduleOperation_swigregister(UnavailableScheduleOperation)
class UnexecutedScheduleOperation(ScheduleOperationError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.UnexecutedScheduleOperation_swiginit(self, _base.new_UnexecutedScheduleOperation(*args))
    __swig_destroy__ = _base.delete_UnexecutedScheduleOperation

# Register UnexecutedScheduleOperation in _base:
_base.UnexecutedScheduleOperation_swigregister(UnexecutedScheduleOperation)
class IncompatibleEvidence(GumException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.IncompatibleEvidence_swiginit(self, _base.new_IncompatibleEvidence(*args))
    __swig_destroy__ = _base.delete_IncompatibleEvidence

# Register IncompatibleEvidence in _base:
_base.IncompatibleEvidence_swigregister(IncompatibleEvidence)
class FactoryError(GumException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.FactoryError_swiginit(self, _base.new_FactoryError(*args))
    __swig_destroy__ = _base.delete_FactoryError

# Register FactoryError in _base:
_base.FactoryError_swigregister(FactoryError)
class FactoryInvalidState(FactoryError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.FactoryInvalidState_swiginit(self, _base.new_FactoryInvalidState(*args))
    __swig_destroy__ = _base.delete_FactoryInvalidState

# Register FactoryInvalidState in _base:
_base.FactoryInvalidState_swigregister(FactoryInvalidState)
class TypeError(FactoryError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.TypeError_swiginit(self, _base.new_TypeError(*args))
    __swig_destroy__ = _base.delete_TypeError

# Register TypeError in _base:
_base.TypeError_swigregister(TypeError)
class WrongClassElement(FactoryError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.WrongClassElement_swiginit(self, _base.new_WrongClassElement(*args))
    __swig_destroy__ = _base.delete_WrongClassElement

# Register WrongClassElement in _base:
_base.WrongClassElement_swigregister(WrongClassElement)
class PRMTypeError(FactoryError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.PRMTypeError_swiginit(self, _base.new_PRMTypeError(*args))
    __swig_destroy__ = _base.delete_PRMTypeError

# Register PRMTypeError in _base:
_base.PRMTypeError_swigregister(PRMTypeError)
class LearningError(GumException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.LearningError_swiginit(self, _base.new_LearningError(*args))
    __swig_destroy__ = _base.delete_LearningError

# Register LearningError in _base:
_base.LearningError_swigregister(LearningError)
class IncompatibleScorePrior(LearningError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.IncompatibleScorePrior_swiginit(self, _base.new_IncompatibleScorePrior(*args))
    __swig_destroy__ = _base.delete_IncompatibleScorePrior

# Register IncompatibleScorePrior in _base:
_base.IncompatibleScorePrior_swigregister(IncompatibleScorePrior)
class PossiblyIncompatibleScorePrior(LearningError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.PossiblyIncompatibleScorePrior_swiginit(self, _base.new_PossiblyIncompatibleScorePrior(*args))
    __swig_destroy__ = _base.delete_PossiblyIncompatibleScorePrior

# Register PossiblyIncompatibleScorePrior in _base:
_base.PossiblyIncompatibleScorePrior_swigregister(PossiblyIncompatibleScorePrior)
class DatabaseError(LearningError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.DatabaseError_swiginit(self, _base.new_DatabaseError(*args))
    __swig_destroy__ = _base.delete_DatabaseError

# Register DatabaseError in _base:
_base.DatabaseError_swigregister(DatabaseError)
class MissingVariableInDatabase(LearningError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.MissingVariableInDatabase_swiginit(self, _base.new_MissingVariableInDatabase(*args))
    __swig_destroy__ = _base.delete_MissingVariableInDatabase

# Register MissingVariableInDatabase in _base:
_base.MissingVariableInDatabase_swigregister(MissingVariableInDatabase)
class MissingValueInDatabase(LearningError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.MissingValueInDatabase_swiginit(self, _base.new_MissingValueInDatabase(*args))
    __swig_destroy__ = _base.delete_MissingValueInDatabase

# Register MissingValueInDatabase in _base:
_base.MissingValueInDatabase_swigregister(MissingValueInDatabase)
class UnknownLabelInDatabase(LearningError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.UnknownLabelInDatabase_swiginit(self, _base.new_UnknownLabelInDatabase(*args))
    __swig_destroy__ = _base.delete_UnknownLabelInDatabase

# Register UnknownLabelInDatabase in _base:
_base.UnknownLabelInDatabase_swigregister(UnknownLabelInDatabase)
class SyntaxError(IOError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.SyntaxError_swiginit(self, _base.new_SyntaxError(*args))

    def col(self) -> int:
        r"""

        Returns
        -------
        int
        	the indice of the colonne of the error

        """
        return _base.SyntaxError_col(self)

    def line(self) -> int:
        r"""

        Returns
        -------
        int
        	the indice of the line of the error

        """
        return _base.SyntaxError_line(self)

    def filename(self) -> str:
        return _base.SyntaxError_filename(self)
    __swig_destroy__ = _base.delete_SyntaxError

# Register SyntaxError in _base:
_base.SyntaxError_swigregister(SyntaxError)

def setNumberOfThreads(number: int) -> None:
    r"""

    To aNone spare cycles (less then 100% CPU occupied), use more threads than logical processors (x2 is a good all-around value).

    Returns
    -------
    number : int
      the number of threads to be used

    """
    return _base.setNumberOfThreads(number)

def isOMP() -> bool:
    r"""

    Returns
    -------
    bool
      True if OMP has been set at compilation, False otherwise

    """
    return _base.isOMP()

def dispatchRangeToThreads(beg: int, end: int, nb_threads: int) -> "std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > >":
    return _base.dispatchRangeToThreads(beg, end, nb_threads)

def randomValue(max: int=2) -> int:
    r"""

    Returns
    -------
    int
      a value randomly drawn (0 or 1)

    """
    return _base.randomValue(max)

def randomProba() -> float:
    r"""

    Returns
    -------
    float
        a random number between 0 and 1 included (i.e. a proba).

    """
    return _base.randomProba()

def randomGeneratorSeed() -> int:
    r"""

    Returns
    -------
    int
      a randomly generated seed

    """
    return _base.randomGeneratorSeed()

def currentRandomGeneratorValue() -> int:
    return _base.currentRandomGeneratorValue()

def initRandom(seed: int=0) -> None:
    r"""

    Initialize random generator seed. If `seed=0`, the generator is initialized from the current time in ms. `seed!=0` allows to fix the generator in a certain stage and then allows to repeat the same pseudo-random numbers sequence.

    Parameters
    ----------
    seed : int
      the seed used to initialize the random generator (0 if using time)

    """
    return _base.initRandom(seed)

def randomGenerator() -> "std::mt19937 &":
    return _base.randomGenerator()
VarType_DISCRETIZED = _base.VarType_DISCRETIZED
VarType_LABELIZED = _base.VarType_LABELIZED
VarType_INTEGER = _base.VarType_INTEGER
VarType_NUMERICAL = _base.VarType_NUMERICAL
VarType_RANGE = _base.VarType_RANGE
VarType_CONTINUOUS = _base.VarType_CONTINUOUS
class Variable(object):
    r"""

    Abstract class used by DiscreteVariable.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _base.delete_Variable

    def clone(self) -> "pyagrum.Variable":
        r"""

        Copy factory

        Returns
        -------
        pyagrum.DiscreteVariable
        	a pointer on a new copy of this

        """
        return _base.Variable_clone(self)

    def __eq__(self, aRV: "pyagrum.Variable") -> bool:
        return _base.Variable___eq__(self, aRV)

    def setName(self, theValue: str) -> None:
        r"""

        sets the name of the variable.

        Parameters
        ----------
        theValue : str
        	the new description of the variable

        """
        return _base.Variable_setName(self, theValue)

    def name(self) -> str:
        r"""

        Returns
        -------
        str
        	the name of the variable

        """
        return _base.Variable_name(self)

    def setDescription(self, theValue: str) -> None:
        r"""

        set the description of the variable.

        Parameters
        ----------
        theValue : str
        	the new description of the variable

        """
        return _base.Variable_setDescription(self, theValue)

    def description(self) -> str:
        r"""

        Returns
        -------
        str
        	the description of the variable

        """
        return _base.Variable_description(self)

    def varType(self) -> int:
        return _base.Variable_varType(self)

    def domain(self) -> str:
        return _base.Variable_domain(self)

# Register Variable in _base:
_base.Variable_swigregister(Variable)
class DiscreteVariable(Variable):
    r"""

    DiscreteVariable is the (abstract) base class for discrete random variables.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _base.delete_DiscreteVariable

    def clone(self) -> "pyagrum.DiscreteVariable":
        r"""

        Returns
        -------
          pyagrum.DiscreteVariable
        	a copy of the DiscreteVariable

        """
        return _base.DiscreteVariable_clone(self)

    def empty(self) -> bool:
        r"""

        Returns
        -------
        bool
        	True if the domain size < 2

        """
        return _base.DiscreteVariable_empty(self)

    def domainSize(self) -> int:
        r"""

        Returns
        -------
        int
        	the number of modalities in the variable domain

        """
        return _base.DiscreteVariable_domainSize(self)

    def labels(self) -> List[str]:
        r"""

        Returns
        -------
        tuple
        	a tuple containing the labels

        """
        return _base.DiscreteVariable_labels(self)

    def numerical(self, indice: int) -> float:
        r"""

        Parameters
        ----------
        indice : int
        	an index

        Returns
        -------
        float
        	the numerical representation of the indice-th value

        """
        return _base.DiscreteVariable_numerical(self, indice)

    def isEmpirical(self) -> bool:
        return _base.DiscreteVariable_isEmpirical(self)

    def closestIndex(self, val: float) -> int:
        return _base.DiscreteVariable_closestIndex(self, val)

    def closestLabel(self, val: float) -> str:
        return _base.DiscreteVariable_closestLabel(self, val)

    def varType(self) -> int:
        r"""

        returns the type of variable

        Returns
        -------
        int :
        	the type of the variable.

        	0: DiscretizedVariable, 1: LabelizedVariable, 2: IntegerVariable, 3: RangeVariable, 4:

        """
        return _base.DiscreteVariable_varType(self)

    def toFast(self) -> str:
        return _base.DiscreteVariable_toFast(self)

    def index(self, label: str) -> int:
        r"""

        Parameters
        ----------
        label : str
        	a label

        Returns
        -------
        int
        	the indice of the label

        """
        return _base.DiscreteVariable_index(self, label)

    def label(self, i: int) -> str:
        r"""

        Parameters
        ----------
        i : int
        	the index of the label we wish to return

        Returns
        -------
        str
        	the indice-th label

        Raises
        ------
        pyagrum.OutOfBounds
        	If the variable does not contain the label

        """
        return _base.DiscreteVariable_label(self, i)

    def toStringWithDescription(self) -> str:
        r"""

        Returns
        -------
        str
        	a description of the variable

        """
        return _base.DiscreteVariable_toStringWithDescription(self)

    def domain(self) -> str:
        r"""

        Returns
        -------
        str
        	the domain of the variable

        """
        return _base.DiscreteVariable_domain(self)

    def stype(self) -> str:
        r"""

        Returns
        -------
        str
        	a description of its type

        """
        return _base.DiscreteVariable_stype(self)

    def __repr__(self) -> str:
        return _base.DiscreteVariable___repr__(self)

    def __str__(self) -> str:
        return _base.DiscreteVariable___str__(self)

    def __iter__(self):
      """
      Iterate over the labels of the variable

      Yield
      -----
      Tuple[int,str]
        The index of the label and its value
      """
      for i in range(self.domainSize()):
        yield i,self.label(i)

    def __hash__(self):
        return hash(self.name()+self.domain())

    def __getitem__(self,label):   # adding the y() function here
        return self.index(label)

    ###########
    # shortcuts for readonly API from derived classes
    ###########
    # Labelized
    def posLabel(self,s):
      try:
        return self.asLabelizedVar().posLabel(s)
      except pyagrum.base.OperationNotAllowed:
         raise NotImplementedError(f"posLabel not implemented for {self}")
    def isLabel(self,s):
      try:
        return self.asLabelizedVar().isLabel(s)
      except pyagrum.base.OperationNotAllowed:
         raise NotImplementedError(f"isLabel not implemented for {self}")
    ###########
    # Range
    def belongs(self,x):
      try:
        return self.asRangeVar().belongs(x)
      except pyagrum.base.OperationNotAllowed:
         raise NotImplementedError(f"belongs not implemented for {self}")
    def minVal(self):
      try:
        return self.asRangeVar().minVal()
      except pyagrum.base.OperationNotAllowed:
         raise NotImplementedError(f"minVal not implemented for {self}")
    def maxVal(self):
      try:
        return self.asRangeVar().maxVal()
      except pyagrum.base.OperationNotAllowed:
         raise NotImplementedError(f"maxVal- not implemented for {self}")
    ###########
    # NumericalDiscrete / Integer
    def numericalDomain(self):
      try:
        return self.asNumericalDiscreteVar().numericalDomain()
      except pyagrum.base.OperationNotAllowed:
         raise NotImplementedError(f"numericalDomain not implemented for {self}")
    def isValue(self,x):
      try:
        return self.asNumericalDiscreteVar().isValue(x)
      except pyagrum.base.OperationNotAllowed:
        try:
          return self.asIntegerVar().isValue(x)
        except pyagrum.base.OperationNotAllowed:
          raise NotImplementedError(f"isValue not implemented for {self}")
    def integerDomain(self):
      try:
        return self.asIntegerVar().integerDomain()
      except pyagrum.base.OperationNotAllowed:
        raise NotImplementedError(f"isValue not implemented for {self}")
    ###########
    # DiscretizedVariable
    def isTick(self,x):
      try:
        return self.asDiscretizedVar().isTick(x)
      except pyagrum.base.OperationNotAllowed:
        raise NotImplementedError(f"isTick not implemented for {self}")
    def ticks(self):
      try:
        return self.asDiscretizedVar().ticks()
      except pyagrum.base.OperationNotAllowed:
        raise NotImplementedError(f"ticks not implemented for {self}")
    def isEmpirical(self):
      try:
        return self.asDiscretizedVar().isEmpirical()
      except pyagrum.base.OperationNotAllowed:
        raise NotImplementedError(f"isEmpirical not implemented for {self}")
    def tick(self,x):
      try:
        return self.asDiscretizedVar().tick(x)
      except pyagrum.base.OperationNotAllowed:
        raise NotImplementedError(f"tick not implemented for {self}")
    def draw(self,x):
      try:
        return self.asDiscretizedVar().draw(x)
      except pyagrum.OperationNotAllowed :
        raise NotImplementedError(f"draw not implemented for {self}")


    def asLabelizedVar(self) -> "pyagrum.LabelizedVariable":
        r"""

        Tries to cast the variable as a `pyagrum.LabelizedVar`.

        Raises
        ------
        pyagrum.OperationNotAllowed if this is not possible

        Returns
        -------
        pyagrum.LabelizedVar
          the variable as a pyagrum.LabelizedVar

        """
        return _base.DiscreteVariable_asLabelizedVar(self)

    def asRangeVar(self) -> "pyagrum.RangeVariable":
        r"""

        Tries to cast the variable as a `pyagrum.RangeVar`.

        Raises
        ------
        pyagrum.OperationNotAllowed if this is not possible

        Returns
        -------
        pyagrum.RangeVar
          the variable as a pyagrum.RangeVar

        """
        return _base.DiscreteVariable_asRangeVar(self)

    def asIntegerVar(self) -> "pyagrum.IntegerVariable":
        r"""

        Tries to cast the variable as a `pyagrum.IntegerVar`.

        Raises
        ------
        pyagrum.OperationNotAllowed if this is not possible

        Returns
        -------
        pyagrum.IntegerVar
          the variable as a pyagrum.IntegerVar

        """
        return _base.DiscreteVariable_asIntegerVar(self)

    def asNumericalDiscreteVar(self) -> "pyagrum.NumericalDiscreteVariable":
        r"""

        Tries to cast the variable as a `pyagrum.NumericalDiscreteVar`.

        Raises
        ------
        pyagrum.OperationNotAllowed if this is not possible

        Returns
        -------
        pyagrum.NumericalDiscreteVar
          the variable as a pyagrum.NumericalDiscreteVar

        """
        return _base.DiscreteVariable_asNumericalDiscreteVar(self)

    def asDiscretizedVar(self) -> "pyagrum.DiscretizedVariable":
        r"""

        Tries to cast the variable as a `pyagrum.DiscretizedVar`.

        Raises
        ------
        pyagrum.OperationNotAllowed if this is not possible

        Returns
        -------
        pyagrum.DiscretizedVar
          the variable as a pyagrum.DiscretizedVar

        """
        return _base.DiscreteVariable_asDiscretizedVar(self)

# Register DiscreteVariable in _base:
_base.DiscreteVariable_swigregister(DiscreteVariable)
class LabelizedVariable(DiscreteVariable):
    r"""

    LabelizedVariable is a discrete random variable with a customizable sequence of labels.

    LabelizedVariable(aName, aDesc='', nbrLabel=2) -> LabelizedVariable
        Parameters:
            - **aName** (str) -- the name of the variable
            - **aDesc** (str) -- the (optional) description of the variable
            - **nbrLabel** (int) -- the number of labels to create (2 by default)

    LabelizedVariable(aName, aDesc='', labels) -> LabelizedVariable
        Parameters:
            - **aName** (str) -- the name of the variable
            - **aDesc** (str) -- the (optional) description of the variable
            - **labels** (List[str]) -- the labels to create

    LabelizedVariable(aLDRV) -> LabelizedVariable
        Parameters:
            - **aLDRV** (*pyagrum.LabelizedVariable*) -- The pyagrum.LabelizedVariable that will be copied

    Examples
    --------
    >>> import pyagrum as gum
    >>> # creating a variable with 3 labels : '0', '1' and '2'
    >>> va=pyagrum.LabelizedVariable('a','a labelized variable',3)
    >>> print(va)
    a:Labelized(<0,1,2>)
    >>> va.addLabel('foo')
    ("pyagrum.LabelizedVariable"@0x7fc4c840dd90) a:Labelized(<0,1,2,foo>)
    >>> va.changeLabel(1,'bar')
    >>> print(va)
    a:Labelized(<0,bar,2,foo>)
    >>> vb=pyagrum.LabelizedVariable('b','b',0).addLabel('A').addLabel('B').addLabel('C')
    >>> print(vb)
    b:Labelized(<A,B,C>)
    >>> vb.labels()
    ('A', 'B', 'C')
    >>> vb.isLabel('E')
    False
    >>> vb.label(2)
    'C'
    >>> vc=pyagrum.LabelizedVariable('b','b',['one','two','three'])
    >>> vc
    ("pyagrum.LabelizedVariable"@0x7fc4c840c130) b:Labelized(<one,two,three>)

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        _base.LabelizedVariable_swiginit(self, _base.new_LabelizedVariable(*args))
    __swig_destroy__ = _base.delete_LabelizedVariable

    def clone(self) -> "pyagrum.LabelizedVariable":
        r"""

        Returns
        -------
        pyagrum.LabelizedVariable
        	a copy of the LabelizedVariable

        """
        return _base.LabelizedVariable_clone(self)

    def index(self, label: str) -> int:
        r"""

        Parameters
        ----------
        label : str
        	a label

        Returns
        -------
        int
        	the indice of the label

        """
        return _base.LabelizedVariable_index(self, label)

    def isLabel(self, aLabel: str) -> bool:
        r"""

        Indicates whether the variable already has the label passed in argument

        Parameters
        ----------
        aLabel : str
        	the label to be tested

        Returns
        -------
        bool
        	True if the label already exists

        """
        return _base.LabelizedVariable_isLabel(self, aLabel)

    def addLabel(self,*args):
        """
        Add a label with a new index (we assume that we will NEVER remove a label).

        Parameters
        ----------
        aLabel : str
            the label to be added to the labelized variable

        Returns
        -------
        pyagrum.LabelizedVariable
            the labelized variable

        Raises
        ------
          pyagrum.DuplicateElement
            If the variable already contains the label
        """
        _base.LabelizedVariable_addLabel(self,*args)
        return self



    def changeLabel(self, pos: int, aLabel: str) -> None:
        r"""

        Change the label at the specified index

        Parameters
        ----------
        pos : int
        	the index of the label to be changed
        aLabel : str
        	the label to be added to the labelized variable

        Raises
        ------
        pyagrum.DuplicateElement
          If the variable already contains the new label
        pyagrum.OutOfBounds
          If the index is greater than the size of the variable

        """
        return _base.LabelizedVariable_changeLabel(self, pos, aLabel)

    def eraseLabels(self) -> None:
        r"""

        Erase all the labels from the variable.

        """
        return _base.LabelizedVariable_eraseLabels(self)

    def label(self, i: int) -> str:
        r"""

        Parameters
        ----------
        i : int
        	the index of the label we wish to return

        Returns
        -------
        str
        	the indice-th label

        Raises
        ------
        pyagrum.OutOfBounds
        	If the variable does not contain the label

        """
        return _base.LabelizedVariable_label(self, i)

    def posLabel(self, label: str) -> int:
        return _base.LabelizedVariable_posLabel(self, label)

    def numerical(self, index: int) -> float:
        r"""

        Parameters
        ----------
        indice : int
        	an index

        Returns
        -------
        float
        	the numerical representation of the indice-th value

        """
        return _base.LabelizedVariable_numerical(self, index)

    def closestIndex(self, val: float) -> int:
        return _base.LabelizedVariable_closestIndex(self, val)

    def domainSize(self) -> int:
        r"""

        Returns
        -------
        int
        	the number of modalities in the variable domain

        """
        return _base.LabelizedVariable_domainSize(self)

    def varType(self) -> int:
        r"""

        returns the type of variable

        Returns
        -------
        int :
        	the type of the variable.

        	0: DiscretizedVariable, 1: LabelizedVariable, 2: IntegerVariable, 3: RangeVariable, 4:

        """
        return _base.LabelizedVariable_varType(self)

    def domain(self) -> str:
        r"""

        Returns
        -------
        str
            the domain of the variable as a string

        """
        return _base.LabelizedVariable_domain(self)

    def stype(self) -> str:
        r"""

        Returns
        -------
        str
        	a description of its type

        """
        return _base.LabelizedVariable_stype(self)

    def toFast(self) -> str:
        return _base.LabelizedVariable_toFast(self)

    def __repr__(self) -> str:
        return _base.LabelizedVariable___repr__(self)

    def __str__(self) -> str:
        return _base.LabelizedVariable___str__(self)

# Register LabelizedVariable in _base:
_base.LabelizedVariable_swigregister(LabelizedVariable)
class RangeVariable(DiscreteVariable):
    r"""

    RangeVariable represents a variable with a range of integers as domain.

    RangeVariable(aName, aDesc,minVal, maxVal) -> RangeVariable
        Parameters:
            - **aName** (*str*) -- the name of the variable
            - **aDesc** (*str*) -- the description of the variable
            - **minVal** (int) -- the minimal integer of the interval
            - **maxVal** (int) -- the maximal integer of the interval

    RangeVariable(aName, aDesc='') -> RangeVariable
        Parameters:
            - **aName** (*str*) -- the name of the variable
            - **aDesc** (*str*) -- the description of the variable

        By default ``minVal=0`` and ``maxVal=1``

    RangeVariable(aRV) -> RangeVariable
        Parameters:
            - **aDV** (*RangeVariable*) -- the pyagrum.RangeVariable that will be copied

    Examples
    --------
    >>> import pyagrum as gum
    >>> vI=pyagrum.RangeVariable('I','I in [4,10]',4,10)
    >>> print(vI)
    I:Range([4,10])
    >>> vI.maxVal()
    10
    >>> vI.belongs(1)
    False
    >>> # where is the value 5 ?
    >>> vI.index('5')
    1
    >>> vI.labels()
    ('4', '5', '6', '7', '8', '9', '10')

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        _base.RangeVariable_swiginit(self, _base.new_RangeVariable(*args))
    __swig_destroy__ = _base.delete_RangeVariable

    def clone(self) -> "pyagrum.RangeVariable":
        r"""

        Returns
        -------
        pyagrum.RangeVariable
        	a copy of the RangeVariable

        """
        return _base.RangeVariable_clone(self)

    def domainSize(self) -> int:
        r"""

        Returns
        -------
        int
        	the number of modalities in the variable domain

        """
        return _base.RangeVariable_domainSize(self)

    def varType(self) -> int:
        r"""

        returns the type of variable

        Returns
        -------
        int :
        	the type of the variable.

        	0: DiscretizedVariable, 1: LabelizedVariable, 2: IntegerVariable, 3: RangeVariable, 4:

        """
        return _base.RangeVariable_varType(self)

    def toFast(self) -> str:
        return _base.RangeVariable_toFast(self)

    def label(self, index: int) -> str:
        r"""

        Parameters
        ----------
        indice : int
          the index of the label we wish to return

        Returns
        -------
        str
          the indice-th label

        Raises
        ------
        pyagrum.OutOfBounds
          If the variable does not contain the label

        """
        return _base.RangeVariable_label(self, index)

    def numerical(self, index: int) -> float:
        r"""

        Parameters
        ----------
        indice : int
        	an index

        Returns
        -------
        float
        	the numerical representation of the indice-th value

        """
        return _base.RangeVariable_numerical(self, index)

    def minVal(self) -> int:
        r"""

        Returns
        -------
        int :
          the lower bound of the variable

        """
        return _base.RangeVariable_minVal(self)

    def setMinVal(self, minVal: int) -> None:
        r"""

        Set a new value of the lower bound

        Parameters
        ----------
        minVal : int
          The new value of the lower bound

        Warnings
        --------
        An error should be raised if the value is higher than the upper bound.

        """
        return _base.RangeVariable_setMinVal(self, minVal)

    def maxVal(self) -> int:
        r"""

        Returns
        -------
        int :
          the upper bound of the variable.

        """
        return _base.RangeVariable_maxVal(self)

    def setMaxVal(self, maxVal: int) -> None:
        r"""

        Set a new value of the upper bound

        Parameters
        ----------
        maxVal : int
          The new value of the upper bound

        Warnings
        --------
        An error should be raised if the value is lower than the lower bound.

        """
        return _base.RangeVariable_setMaxVal(self, maxVal)

    def belongs(self, val: int) -> bool:
        r"""

        Parameters
        ----------
        val : int
          the value to be tested

        Returns
        -------
        bool:
          True if the value in parameters belongs to the variable's interval.

        """
        return _base.RangeVariable_belongs(self, val)

    def index(self, arg2: str) -> int:
        r"""

        Parameters
        ----------
        arg2 : str
          a label

        Returns
        -------
        int
          the indice of the label

        """
        return _base.RangeVariable_index(self, arg2)

    def closestIndex(self, val: float) -> int:
        return _base.RangeVariable_closestIndex(self, val)

    def domain(self) -> str:
        r"""

        Returns
        -------
        str
        	the domain of the variable

        """
        return _base.RangeVariable_domain(self)

    def stype(self) -> str:
        r"""

        Returns
        -------
        str
        	a description of its type

        """
        return _base.RangeVariable_stype(self)

    def __repr__(self) -> str:
        return _base.RangeVariable___repr__(self)

    def __str__(self) -> str:
        return _base.RangeVariable___str__(self)

# Register RangeVariable in _base:
_base.RangeVariable_swigregister(RangeVariable)
class IntegerVariable(DiscreteVariable):
    r"""

    IntegerVariable is a discrete random variable with a customizable sequence of int.

    IntegerVariable(aName, aDesc='', values=None) -> IntegerVariable
        Parameters:
            - **aName** (str) -- the name of the variable
            - **aDesc** (str) -- the (optional) description of the variable
            - **values** (List[int]) -- the values to create

    IntegerVariable(aIDRV) -> IntegerVariable
        Parameters:
            - **aIDRV** (*pyagrum.IntegerVariable*) -- The pyagrum.IntegerVariable that will be copied

    Examples
    --------
    >>> import pyagrum as gum
    >>> # creating a variable with 3 values : 1,34,142
    >>> va=pyagrum.IntegerVariable('a','a integer variable',[1,34,142])
    >>> print(va)
    a:Integer(<1,34,142>)
    >>> va.addValue(25)
    (pyagrum.IntegerVariable@000001E4F5D07490) a:Integer(<1,25,34,142>)
    >>> va.changeValue(34,43)
    >>> print(va)
    a:Integer(<1,25,43,142>)
    >>> vb=pyagrum.IntegerVariable('b','b').addValue(34).addValue(142).addValue(1)
    >>> print(vb)
    b:Integer(<1,34,142>)
    >>> vb.labels()
    ('1', '34', '142')

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        _base.IntegerVariable_swiginit(self, _base.new_IntegerVariable(*args))

    def clone(self) -> "pyagrum.IntegerVariable":
        r"""

        Returns
        -------
          pyagrum.DiscreteVariable
        	a copy of the DiscreteVariable

        """
        return _base.IntegerVariable_clone(self)
    __swig_destroy__ = _base.delete_IntegerVariable

    def domainSize(self) -> int:
        r"""

        Returns
        -------
        int
        	the number of modalities in the variable domain

        """
        return _base.IntegerVariable_domainSize(self)

    def varType(self) -> int:
        r"""

        returns the type of variable

        Returns
        -------
        int :
        	the type of the variable.

        	0: DiscretizedVariable, 1: LabelizedVariable, 2: IntegerVariable, 3: RangeVariable, 4:

        """
        return _base.IntegerVariable_varType(self)

    def toFast(self) -> str:
        return _base.IntegerVariable_toFast(self)

    def index(self, label: str) -> int:
        r"""

        Parameters
        ----------
        label : str
        	a label

        Returns
        -------
        int
        	the indice of the label

        """
        return _base.IntegerVariable_index(self, label)

    def closestIndex(self, val: float) -> int:
        return _base.IntegerVariable_closestIndex(self, val)

    def label(self, index: int) -> str:
        r"""

        Parameters
        ----------
        i : int
        	the index of the label we wish to return

        Returns
        -------
        str
        	the indice-th label

        Raises
        ------
        pyagrum.OutOfBounds
        	If the variable does not contain the label

        """
        return _base.IntegerVariable_label(self, index)

    def numerical(self, index: int) -> float:
        r"""

        Parameters
        ----------
        indice : int
        	an index

        Returns
        -------
        float
        	the numerical representation of the indice-th value

        """
        return _base.IntegerVariable_numerical(self, index)

    def domain(self) -> str:
        r"""

        Returns
        -------
        str
        	the domain of the variable

        """
        return _base.IntegerVariable_domain(self)

    def stype(self) -> str:
        r"""

        Returns
        -------
        str
        	a description of its type

        """
        return _base.IntegerVariable_stype(self)

    def integerDomain(self) -> List[int]:
        r"""

        Returns
        -------
        Tuple[int]
            the tuple of integer values that form the domain of this variable

        """
        return _base.IntegerVariable_integerDomain(self)

    def addValue(self,*args):
        """
        Add a value to the list of values for the variable.

        Parameters
        ----------
        value : int
            the new value

        Returns
        -------
        pyagrum.IntegerVariable
            the Integer variable

        Raises
        ------
          pyagrum.DuplicateElement
            If the variable already contains the value
        """
        _base.IntegerVariable_addValue(self,*args)
        return self



    def isValue(self, value: int) -> bool:
        r"""

        Parameters
        ----------
        value: int
            the value to look at.

        Returns
        -------
        bool
            True if the value is in the domain.

        """
        return _base.IntegerVariable_isValue(self, value)

    def changeValue(self, old_value: int, new_value: int) -> None:
        r"""

        Parameters
        ----------
        old_value : int
            the value to be changed

        new_value : int
            the new value

        """
        return _base.IntegerVariable_changeValue(self, old_value, new_value)

    def eraseValue(self, value: int) -> None:
        r"""

        Parameters
        ----------
        value: int
            the value to erase. If the value is not in the domain, the function does nothing (no exception raised)

        """
        return _base.IntegerVariable_eraseValue(self, value)

    def eraseValues(self) -> None:
        r"""

        Remove all the domain.

        """
        return _base.IntegerVariable_eraseValues(self)

    def closestLabel(self, val: float) -> str:
        return _base.IntegerVariable_closestLabel(self, val)

    def __repr__(self) -> str:
        return _base.IntegerVariable___repr__(self)

    def __str__(self) -> str:
        return _base.IntegerVariable___str__(self)

# Register IntegerVariable in _base:
_base.IntegerVariable_swigregister(IntegerVariable)
class NumericalDiscreteVariable(DiscreteVariable):
    r"""

    NumericalDiscreteVariable is a discrete random variable with a customizable sequence of float.

    NumericalDiscreteVariable(aName, aDesc='', values=None) -> NumericalDiscreteVariable
        Parameters:
            - **aName** (str) -- the name of the variable
            - **aDesc** (str) -- the (optional) description of the variable
            - **values** (List[float]) -- the values to create equivalent to *fast* syntax `{v1|v2|v3|...|vn}`

    NumericalDiscreteVariable(aName, aDesc='', first, last, nbr) -> NumericalDiscreteVariable
        Parameters:
            - **aName** (str) -- the name of the variable
            - **aDesc** (str) -- the (optional) description of the variable
            - **first** (float) -- specify a list of floats from `first` to `last` in `nbr` steps.
            - **last** (float) --
            - **nbr** (int)  -- equivalent to fast syntax `{first:last:nbr}`

    NumericalDiscreteVariable(aNDRV) -> NumericalDiscreteVariable
        Parameters:
            - **aNDRV** (*pyagrum.NumericalDiscreteVariable*) -- The pyagrum.NumericalDiscreteVariable that will be copied

    Examples
    --------
    >>> import pyagrum as gum
    >>> # creating a variable with 3 values : 1.5,3.14,1.42
    >>> va=pyagrum.NumericalDiscreteVariable('a','a numerica variable',[1.5,3.14,1.42])
    >>> print(va)
    a:NumericalDiscrete({1.42|1.5|3.14})
    >>> va.addValue(2.01)
    (pyagrum.NumericalDiscreteVariable@0x55ea157b8d60) a:NumericalDiscrete({1.42|1.5|2.01|3.14})
    >>> va.changeValue(3.14,3.1415)
    >>> print(va)
    a:NumericalDiscrete({1.42|1.5|2.01|3.1415})
    >>> vb=pyagrum.NumericalDiscreteVariable('b','b').addValue(3.14).addValue(1.42).addValue(1.5)
    >>> print(vb)
    b:NumericalDiscrete({1.42|1.5|3.14})
    >>> vb.labels()
    ('1.42', '1.5', '3.14')
    >>>> vc=pyagrum.NumericalDiscreteVariable('c','c',1.2,3.8,5)
    >>> print(vc)
    c:NumericalDiscrete({1.2|1.85|2.5|3.15|3.8})

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        _base.NumericalDiscreteVariable_swiginit(self, _base.new_NumericalDiscreteVariable(*args))

    def clone(self) -> "pyagrum.NumericalDiscreteVariable":
        r"""

        Returns
        -------
          pyagrum.DiscreteVariable
        	a copy of the DiscreteVariable

        """
        return _base.NumericalDiscreteVariable_clone(self)
    __swig_destroy__ = _base.delete_NumericalDiscreteVariable

    def domainSize(self) -> int:
        r"""

        Returns
        -------
        int
        	the number of modalities in the variable domain

        """
        return _base.NumericalDiscreteVariable_domainSize(self)

    def varType(self) -> int:
        r"""

        returns the type of variable

        Returns
        -------
        int :
        	the type of the variable.

        	0: DiscretizedVariable, 1: LabelizedVariable, 2: IntegerVariable, 3: RangeVariable, 4:

        """
        return _base.NumericalDiscreteVariable_varType(self)

    def toFast(self) -> str:
        return _base.NumericalDiscreteVariable_toFast(self)

    def index(self, label: str) -> int:
        r"""

        Parameters
        ----------
        label : str
        	a label

        Returns
        -------
        int
        	the indice of the label

        """
        return _base.NumericalDiscreteVariable_index(self, label)

    def closestIndex(self, val: float) -> int:
        return _base.NumericalDiscreteVariable_closestIndex(self, val)

    def label(self, index: int) -> str:
        r"""

        Parameters
        ----------
        i : int
        	the index of the label we wish to return

        Returns
        -------
        str
        	the indice-th label

        Raises
        ------
        pyagrum.OutOfBounds
        	If the variable does not contain the label

        """
        return _base.NumericalDiscreteVariable_label(self, index)

    def numerical(self, index: int) -> float:
        r"""

        Parameters
        ----------
        indice : int
        	an index

        Returns
        -------
        float
        	the numerical representation of the indice-th value

        """
        return _base.NumericalDiscreteVariable_numerical(self, index)

    def domain(self) -> str:
        r"""

        Returns
        -------
        str
        	the domain of the variable

        """
        return _base.NumericalDiscreteVariable_domain(self)

    def stype(self) -> str:
        r"""

        Returns
        -------
        str
        	a description of its type

        """
        return _base.NumericalDiscreteVariable_stype(self)

    def numericalDomain(self) -> List[float]:
        r"""

        Returns
        -------
        Tuple[float]
            the tuple of float values that form the domain of this variable

        """
        return _base.NumericalDiscreteVariable_numericalDomain(self)

    def addValue(self,*args):
        """
        Add a value to the list of values for the variable.

        Parameters
        ----------
        value : float
            the new value

        Returns
        -------
        pyagrum.IntegerVariable
            the Integer variable

        Raises
        ------
          pyagrum.DuplicateElement
            If the variable already contains the value
        """
        _base.NumericalDiscreteVariable_addValue(self,*args)
        return self



    def isValue(self, value: float) -> bool:
        r"""

        Parameters
        ----------
        value: int
            the value to look at.

        Returns
        -------
        bool
            True if the value is in the domain.

        """
        return _base.NumericalDiscreteVariable_isValue(self, value)

    def changeValue(self, old_value: float, new_value: float) -> None:
        r"""

        Parameters
        ----------
        old_value : int
            the value to be changed

        new_value : int
            the new value

        """
        return _base.NumericalDiscreteVariable_changeValue(self, old_value, new_value)

    def eraseValue(self, value: float) -> None:
        r"""

        Parameters
        ----------
        value: int
            the value to erase. If the value is not in the domain, the function does nothing (no exception raised)

        """
        return _base.NumericalDiscreteVariable_eraseValue(self, value)

    def eraseValues(self) -> None:
        r"""

        Remove all the domain.

        """
        return _base.NumericalDiscreteVariable_eraseValues(self)

    def closestLabel(self, val: float) -> str:
        return _base.NumericalDiscreteVariable_closestLabel(self, val)

    def __repr__(self) -> str:
        return _base.NumericalDiscreteVariable___repr__(self)

    def __str__(self) -> str:
        return _base.NumericalDiscreteVariable___str__(self)

# Register NumericalDiscreteVariable in _base:
_base.NumericalDiscreteVariable_swigregister(NumericalDiscreteVariable)
class IDiscretizedVariable(DiscreteVariable):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _base.delete_IDiscretizedVariable

    def clone(self) -> "pyagrum.DiscretizedVariable":
        r"""

        Returns
        -------
          pyagrum.DiscreteVariable
        	a copy of the DiscreteVariable

        """
        return _base.IDiscretizedVariable_clone(self)

    def isEmpirical(self) -> bool:
        return _base.IDiscretizedVariable_isEmpirical(self)

    def setEmpirical(self, state: bool) -> None:
        return _base.IDiscretizedVariable_setEmpirical(self, state)

    def draw(self, indice: int) -> float:
        return _base.IDiscretizedVariable_draw(self, indice)

# Register IDiscretizedVariable in _base:
_base.IDiscretizedVariable_swigregister(IDiscretizedVariable)
class Edge(object):
    r"""

    pyagrum.Edge is the representation of an arc between two nodes represented by int : the first and the second.

    Edge(aN1,aN2) -> Edge
        Parameters:
            - **aN1** (int) -- the nodeId of the first node
            - **aN2** (int) -- the nodeId of the secondnode

    Edge(src) -> Edge
        Parameters:
            - **src** (*yAgrum.Edge*) -- the Edge to copy

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.Edge_swiginit(self, _base.new_Edge(*args))
    __swig_destroy__ = _base.delete_Edge

    def other(self, id: int) -> int:
        r"""

        Parameters
        ----------
        id : int
          the nodeId of one of the nodes of the Edge


        Returns
        ------
        int
          the nodeId of the other node

        """
        return _base.Edge_other(self, id)

    def first(self) -> int:
        r"""

        Returns
        ------
        int
          the nodeId of the first node of the arc (the tail)

        """
        return _base.Edge_first(self)

    def second(self) -> int:
        r"""

        Returns
        ------
        int
          the nodeId of the second node of the arc (the head)

        """
        return _base.Edge_second(self)

    def __eq__(self, src: "pyagrum.Edge") -> bool:
        return _base.Edge___eq__(self, src)

# Register Edge in _base:
_base.Edge_swigregister(Edge)
class Arc(object):
    r"""

    pyagrum.Arc is the representation of an arc between two nodes represented by int : the head and the tail.

    Arc(tail, head) -> Arc
        Parameters:
            - **tail** (int) -- the tail
            - **head** (int) -- the head

    Arc(src) -> Arc
        Parameters:
            - **src** (*Arc*) -- the pyagrum.Arc to copy

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.Arc_swiginit(self, _base.new_Arc(*args))
    __swig_destroy__ = _base.delete_Arc

    def tail(self) -> int:
        r"""

        Returns
        -------
        int
          the id of the tail node

        """
        return _base.Arc_tail(self)

    def head(self) -> int:
        r"""

        Returns
        ------
        int
          the id of the head node

        """
        return _base.Arc_head(self)

    def other(self, id: int) -> int:
        r"""

        Parameters
        ----------
        id : int
          the nodeId of the head or the tail


        Returns
        -------
        int
          the nodeId of the other node

        """
        return _base.Arc_other(self, id)

    def first(self) -> int:
        r"""

        Returns
        -------
        int
          the nodeId of the first node of the arc (the tail)

        """
        return _base.Arc_first(self)

    def second(self) -> int:
        r"""

        Returns
        -------
        int
          the nodeId of the second node of the arc (the head)

        """
        return _base.Arc_second(self)

    def __eq__(self, src: "pyagrum.Arc") -> bool:
        return _base.Arc___eq__(self, src)

# Register Arc in _base:
_base.Arc_swigregister(Arc)
class UndiGraph(object):
    r"""

    UndiGraph represents an Undirected Graph.

    UndiGraph() -> UndiGraph
        default constructor

    UndiGraph(src) -> UndiGraph
        Parameters!
            - **src** (*UndiGraph*) -- the pyagrum.UndiGraph to copy


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        _base.UndiGraph_swiginit(self, _base.new_UndiGraph(*args))
    __swig_destroy__ = _base.delete_UndiGraph

    @staticmethod
    def completeGraph(n: int) -> "pyagrum.UndiGraph":
        return _base.UndiGraph_completeGraph(n)

    def __eq__(self, g: "pyagrum.UndiGraph") -> bool:
        return _base.UndiGraph___eq__(self, g)

    def __ne__(self, g: "pyagrum.UndiGraph") -> bool:
        return _base.UndiGraph___ne__(self, g)

    def eraseNode(self, id: int) -> None:
        r"""

        Erase the node and all the adjacent edges.

        Parameters
        ----------
        id : int
          the id of the node

        """
        return _base.UndiGraph_eraseNode(self, id)

    def clear(self) -> None:
        r"""

        Remove all the nodes and edges from the graph.

        """
        return _base.UndiGraph_clear(self)

    def toDot(self) -> str:
        r"""

        Returns
        -------
        str
            a friendly display of the graph in DOT format

        """
        return _base.UndiGraph_toDot(self)

    def hasUndirectedCycle(self) -> bool:
        r"""

        Checks whether the graph contains cycles.

        Returns
        -------
        bool
            True if the graph contains a cycle

        """
        return _base.UndiGraph_hasUndirectedCycle(self)

    def partialUndiGraph(self, nodes: List[int]) -> "pyagrum.UndiGraph":
        r"""

        Parameters
        ----------
        nodesSet : Set
            The set of nodes composing the partial graph

        Returns
        -------
        pyagrum.UndiGraph
            The partial graph formed by the nodes given in parameter

        """
        return _base.UndiGraph_partialUndiGraph(self, nodes)

    def nodes2ConnectedComponent(self) -> Dict[int,int]:
        return _base.UndiGraph_nodes2ConnectedComponent(self)

    def __repr__(self) -> str:
        return _base.UndiGraph___repr__(self)

    def __str__(self) -> str:
        return _base.UndiGraph___str__(self)

    def nodes(self) -> object:
        r"""

        Returns
        -------
        set
            the set of ids

        """
        return _base.UndiGraph_nodes(self)

    def connectedComponents(self):
      """ connected components from a graph/graphical models

      Compute the connected components of a pyAgrum's graph or graphical models
      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)

      The firstly visited node for each component is called a 'root' and is used as a key for the component.
      This root has been arbitrarily chosen during the algorithm.

      Returns
      -------
      dict(int,Set[int])
        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.

      """
      nodes=self.nodes()
      connected_components=dict()

      def parcours(node,orig):
          cc={node}
          nodes.discard(node)
          if hasattr(self,'children'):
              for chi in self.children(node):
                  if chi!=orig:
                      if chi in nodes:
                          cc|=parcours(chi,node)

          if hasattr(self,'parents'):
              for par in self.parents(node):
                  if par!=orig:
                      if par in nodes:
                          cc|=parcours(par,node)

          if hasattr(self,'neighbours'):
              for nei in self.neighbours(node):
                  if nei!=orig:
                      if nei in nodes:
                          cc|=parcours(nei,node)
          return cc

      while (len(nodes)>0):
          root=nodes.pop()
          connected_components[root]=parcours(root,None)
      return connected_components

    def adjacencyMatrix(self):
      """ adjacency matrix from a graph/graphical models

      Compute the adjacency matrix of a pyAgrum's graph or graphical models
      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)

      Returns
      -------
      numpy.ndarray
        adjacency matrix (as numpy.ndarray) with nodeId as key.

      """
      import numpy as np
      nodes=self.nodes()
      n=self.size()
      am=np.zeros((n,n)).astype(int)

      for node in nodes:
          if hasattr(self,'children'):
              for children in self.children(node):
                  am[node,children]=1
          if hasattr(self,'neighbours'):
              for neighbour in self.neighbours(node):
                  am[node,neighbour]=1
      return am


    def addNodes(self, n: int) -> object:
        r"""

        Add n nodes.

        Parameters
        ----------
        n : int
          the number of nodes to add.

        Returns
        -------
        Set of int
          the new ids

        """
        return _base.UndiGraph_addNodes(self, n)

    def __iter__(self):
      """
      Iterate over the nodes of the graph

      Yield
      -----
      int
        The index of the node
      """
      for i in self.nodes():
        yield i

    def __getstate__(self):
        state=dict()
        if hasattr(self,'arcs'):
            state['arcs']=self.arcs()
        if hasattr(self,'edges'):
          state['edges']=self.edges()
        return state

    def __setstate__(self,state):
        self.__init__()
        if 'arcs' in state:
            for x,y in state['arcs']:
              if not self.existsNode(x):
                self.addNodeWithId(x)
              if not self.existsNode(y):
                self.addNodeWithId(y)
              self.addArc(x,y)
        if 'edges' in state:
            for x,y in state['edges']:
              if not self.existsNode(x):
                self.addNodeWithId(x)
              if not self.existsNode(y):
                self.addNodeWithId(y)
              self.addEdge(x,y)
        return self


    def edges(self) -> object:
        r"""

        Returns
        -------
        List
          the list of the edges

        """
        return _base.UndiGraph_edges(self)

    def neighbours(self, id: int) -> object:
        r"""

        Parameters
        ----------
        id : int
            the id of the checked node

        Returns
        -------
        Set
            The set of edges adjacent to the given node

        """
        return _base.UndiGraph_neighbours(self, id)

    def addNode(self) -> int:
        r"""

        Returns
        -------
        int
          the new NodeId

        """
        return _base.UndiGraph_addNode(self)

    def addNodeWithId(self, id: int) -> None:
        r"""

        Add a node by choosing a new NodeId.

        Parameters
        ----------
        id : int
          The id of the new node

        Raises
        ------
          pyagrum.DuplicateElement
            If the given id is already used

        """
        return _base.UndiGraph_addNodeWithId(self, id)

    def existsNode(self, id: int) -> bool:
        r"""

        Check if a node with a certain id exists in the graph.

        Parameters
        ----------
        id : int
            the checked id

        Returns
        -------
        bool
            True if the node exists

        """
        return _base.UndiGraph_existsNode(self, id)

    def size(self) -> int:
        r"""

        Returns
        -------
        int
            the number of nodes in the graph

        """
        return _base.UndiGraph_size(self)

    def empty(self) -> bool:
        r"""

        Check if the graph is empty.

        Returns
        -------
        bool
            True if the graph is empty

        """
        return _base.UndiGraph_empty(self)

    def addEdge(self, *args) -> None:
        r"""

        Insert a new edge into the graph.

        Parameters
        ----------
        n1 : int
          the id of one node of the new inserted edge
        n2 : int
          the id of the other node of the new inserted edge

        Raises
        ------
          pyagrum.InvalidNode
            If n1 or n2 does not belong to the graph nodes.

        """
        return _base.UndiGraph_addEdge(self, *args)

    def eraseEdge(self, n1: int, n2: int) -> None:
        r"""

        Erase the edge between n1 and n2.

        Parameters
        ----------
        n1 : int
          the id of the tail node
        n2 : int
          the id of the head node

        """
        return _base.UndiGraph_eraseEdge(self, n1, n2)

    def existsEdge(self, n1: int, n2: int) -> bool:
        r"""

        Check if an edge exists bewteen n1 and n2.

        Parameters
        ----------
        n1 : int
          the id of one extremity of the edge
        n2 : int
          the id of the other extremity if tge edge

        Returns
        -------
        bool
            True if the arc exists

        """
        return _base.UndiGraph_existsEdge(self, n1, n2)

    def sizeEdges(self) -> int:
        r"""

        Returns
        -------
        int
            the number of edges in the graph

        """
        return _base.UndiGraph_sizeEdges(self)

    def emptyEdges(self) -> bool:
        r"""

        Check if the graph doesn't contains edges.

        Returns
        -------
        bool
            True if the graph doesn't contains edges

        """
        return _base.UndiGraph_emptyEdges(self)

    def eraseNeighbours(self, n: int) -> None:
        r"""

        Erase all the edges adjacent to a given node.

        Parameters
        ----------
        n : int
          the id of the node

        """
        return _base.UndiGraph_eraseNeighbours(self, n)

# Register UndiGraph in _base:
_base.UndiGraph_swigregister(UndiGraph)
emptyNodeSet = cvar.emptyNodeSet

class DiGraph(object):
    r"""

    DiGraph represents a Directed Graph.

    DiGraph() -> DiGraph
        default constructor

    DiGraph(src) -> DiGraph
        Parameters:
            - **src** (*pyagrum.DiGraph*) -- the digraph to copy

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        _base.DiGraph_swiginit(self, _base.new_DiGraph(*args))
    __swig_destroy__ = _base.delete_DiGraph

    @staticmethod
    def completeGraph(n: int) -> "pyagrum.DiGraph":
        return _base.DiGraph_completeGraph(n)

    def __eq__(self, g: "DiGraph") -> bool:
        return _base.DiGraph___eq__(self, g)

    def eraseNode(self, id: int) -> None:
        r"""

        Erase the node and all the related arcs.

        Parameters
        ----------
        id : int
        	the id of the node

        """
        return _base.DiGraph_eraseNode(self, id)

    def clear(self) -> None:
        r"""

        Remove all the nodes and arcs from the graph.

        """
        return _base.DiGraph_clear(self)

    def toDot(self) -> str:
        r"""

        Returns
        -------
        str
            a friendly display of the graph in DOT format

        """
        return _base.DiGraph_toDot(self)

    def topologicalOrder(self) -> List[int]:
        r"""

        Returns
        -------
        List
            the list of the nodes Ids in a topological order

        Raises
        ------
        pyagrum.InvalidDirectedCycle
          If this graph contains cycles

        """
        return _base.DiGraph_topologicalOrder(self)

    def hasDirectedPath(self, _from: int, to: int) -> bool:
        r"""

        Check if a directedpath exists bewteen from and to.

        Parameters
        ----------
        from : int
        	the id of the first node of the (possible) path
        to : int
        	the id of the last node of the (possible) path

        Returns
        -------
        bool
            True if the directed path exists

        """
        return _base.DiGraph_hasDirectedPath(self, _from, to)

    def __repr__(self) -> str:
        return _base.DiGraph___repr__(self)

    def __str__(self) -> str:
        return _base.DiGraph___str__(self)

    def nodes(self) -> object:
        r"""

        Returns
        -------
        set
            the set of ids

        """
        return _base.DiGraph_nodes(self)

    def connectedComponents(self):
      """ connected components from a graph/graphical models

      Compute the connected components of a pyAgrum's graph or graphical models
      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)

      The firstly visited node for each component is called a 'root' and is used as a key for the component.
      This root has been arbitrarily chosen during the algorithm.

      Returns
      -------
      dict(int,Set[int])
        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.

      """
      nodes=self.nodes()
      connected_components=dict()

      def parcours(node,orig):
          cc={node}
          nodes.discard(node)
          if hasattr(self,'children'):
              for chi in self.children(node):
                  if chi!=orig:
                      if chi in nodes:
                          cc|=parcours(chi,node)

          if hasattr(self,'parents'):
              for par in self.parents(node):
                  if par!=orig:
                      if par in nodes:
                          cc|=parcours(par,node)

          if hasattr(self,'neighbours'):
              for nei in self.neighbours(node):
                  if nei!=orig:
                      if nei in nodes:
                          cc|=parcours(nei,node)
          return cc

      while (len(nodes)>0):
          root=nodes.pop()
          connected_components[root]=parcours(root,None)
      return connected_components

    def adjacencyMatrix(self):
      """ adjacency matrix from a graph/graphical models

      Compute the adjacency matrix of a pyAgrum's graph or graphical models
      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)

      Returns
      -------
      numpy.ndarray
        adjacency matrix (as numpy.ndarray) with nodeId as key.

      """
      import numpy as np
      nodes=self.nodes()
      n=self.size()
      am=np.zeros((n,n)).astype(int)

      for node in nodes:
          if hasattr(self,'children'):
              for children in self.children(node):
                  am[node,children]=1
          if hasattr(self,'neighbours'):
              for neighbour in self.neighbours(node):
                  am[node,neighbour]=1
      return am


    def addNodes(self, n: int) -> object:
        r"""

        Add a set of n nodes.

        Parameters
        ----------
        n : int
          the number of nodes to add.

        Returns
        -------
        Set of int
          the new ids

        """
        return _base.DiGraph_addNodes(self, n)

    def __iter__(self):
      """
      Iterate over the nodes of the graph

      Yield
      -----
      int
        The index of the node
      """
      for i in self.nodes():
        yield i

    def __getstate__(self):
        state=dict()
        if hasattr(self,'arcs'):
            state['arcs']=self.arcs()
        if hasattr(self,'edges'):
          state['edges']=self.edges()
        return state

    def __setstate__(self,state):
        self.__init__()
        if 'arcs' in state:
            for x,y in state['arcs']:
              if not self.existsNode(x):
                self.addNodeWithId(x)
              if not self.existsNode(y):
                self.addNodeWithId(y)
              self.addArc(x,y)
        if 'edges' in state:
            for x,y in state['edges']:
              if not self.existsNode(x):
                self.addNodeWithId(x)
              if not self.existsNode(y):
                self.addNodeWithId(y)
              self.addEdge(x,y)
        return self


    def arcs(self) -> object:
        r"""

        Returns the set of arcs in the graph.

        Returns
        -------
        Set
        	the set of the arcs

        """
        return _base.DiGraph_arcs(self)

    def parents(self, id: int) -> object:
        r"""

        Parameters
        ----------
        id :
        	The id of the child node

        Returns
        -------
        Set
            the set of the parents ids.

        """
        return _base.DiGraph_parents(self, id)

    def children(self, id: int) -> object:
        r"""

        Parameters
        ----------
        id : int
          the id of the parent

        Returns
        -------
        Set
        	the set of all the children

        """
        return _base.DiGraph_children(self, id)

    def addNode(self) -> int:
        r"""

        Returns
        -------
        int
          the new NodeId

        """
        return _base.DiGraph_addNode(self)

    def addNodeWithId(self, id: int) -> None:
        r"""

        Add a node by choosing a new NodeId.

        Parameters
        ----------
        id : int
          The id of the new node

        Raises
        ------
          pyagrum.DuplicateElement
          If the given id is already used

        """
        return _base.DiGraph_addNodeWithId(self, id)

    def existsNode(self, id: int) -> bool:
        r"""

        Check if a node with a certain id exists in the graph.

        Parameters
        ----------
        id : int
            the checked id

        Returns
        -------
        bool
            True if the node exists

        """
        return _base.DiGraph_existsNode(self, id)

    def size(self) -> int:
        r"""

        Returns
        -------
        int
            the number of nodes in the graph

        """
        return _base.DiGraph_size(self)

    def empty(self) -> bool:
        r"""

        Check if the graph is empty.

        Returns
        -------
        bool
            True if the graph is empty

        """
        return _base.DiGraph_empty(self)

    def addArc(self, *args) -> None:
        r"""

        Add an arc from tail to head.

        Parameters
        ----------
        tail : int
          the id of the tail node
        head : int
          the id of the head node

        Raises
        ------
          pyagrum.InvalidNode
            If head or tail does not belong to the graph nodes.

        """
        return _base.DiGraph_addArc(self, *args)

    def eraseArc(self, n1: int, n2: int) -> None:
        r"""

        Erase the arc between n1 and n2.

        Parameters
        ----------
        n1 : int
        	the id of the tail node
        n2 : int
        	the id of the head node

        """
        return _base.DiGraph_eraseArc(self, n1, n2)

    def existsArc(self, n1: int, n2: int) -> bool:
        r"""

        Check if an arc exists bewteen n1 and n2.

        Parameters
        ----------
        n1 : int
        	the id of the tail node
        n2 : int
        	the id of the head node

        Returns
        -------
        bool
            True if the arc exists

        """
        return _base.DiGraph_existsArc(self, n1, n2)

    def eraseParents(self, n: int) -> None:
        r"""

        Erase the arcs coming to the node.

        Parameters
        ----------
        n : int
        	the id of the child node

        """
        return _base.DiGraph_eraseParents(self, n)

    def eraseChildren(self, n: int) -> None:
        r"""

        Erase the arcs heading through the node's children.

        Parameters
        ----------
        n : int
        	the id of the parent node

        """
        return _base.DiGraph_eraseChildren(self, n)

    def sizeArcs(self) -> int:
        r"""

        Returns
        -------
        int
            the number of arcs in the graph

        """
        return _base.DiGraph_sizeArcs(self)

    def emptyArcs(self) -> bool:
        r"""

        Check if the graph doesn't contains arcs.

        Returns
        -------
        bool
            True if the graph doesn't contains arcs

        """
        return _base.DiGraph_emptyArcs(self)

# Register DiGraph in _base:
_base.DiGraph_swigregister(DiGraph)
class DAG(DiGraph):
    r"""

    DAG represents a Directed Graph.

    DAG() -> DAG
        default constructor

    DAG(src) -> DAG
        Parameters:
            - **src** (*pyagrum.DAG*) -- the DAG to copy

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        _base.DAG_swiginit(self, _base.new_DAG(*args))
    __swig_destroy__ = _base.delete_DAG

    def moralGraph(self) -> "pyagrum.UndiGraph":
        return _base.DAG_moralGraph(self)

    def __repr__(self) -> str:
        return _base.DAG___repr__(self)

    def __str__(self) -> str:
        return _base.DAG___str__(self)

    def dSeparation(self, *args) -> bool:
        return _base.DAG_dSeparation(self, *args)

    def moralizedAncestralGraph(self, *args) -> "pyagrum.UndiGraph":
        return _base.DAG_moralizedAncestralGraph(self, *args)

    def addNodes(self, n: int) -> object:
        r"""

        Add a set of n nodes.

        Parameters
        ----------
        n : int
          the number of nodes to add.

        Returns
        -------
        Set of int
          the new ids

        """
        return _base.DAG_addNodes(self, n)

    def __iter__(self):
      """
      Iterate over the nodes of the graph

      Yield
      -----
      int
        The index of the node
      """
      for i in self.nodes():
        yield i

    def __getstate__(self):
        state=dict()
        if hasattr(self,'arcs'):
            state['arcs']=self.arcs()
        if hasattr(self,'edges'):
          state['edges']=self.edges()
        return state

    def __setstate__(self,state):
        self.__init__()
        if 'arcs' in state:
            for x,y in state['arcs']:
              if not self.existsNode(x):
                self.addNodeWithId(x)
              if not self.existsNode(y):
                self.addNodeWithId(y)
              self.addArc(x,y)
        if 'edges' in state:
            for x,y in state['edges']:
              if not self.existsNode(x):
                self.addNodeWithId(x)
              if not self.existsNode(y):
                self.addNodeWithId(y)
              self.addEdge(x,y)
        return self


    def arcs(self) -> object:
        r"""

        Returns the set of arcs in the graph.

        Returns
        -------
        Set
        	the set of the arcs

        """
        return _base.DAG_arcs(self)

    def parents(self, id: int) -> object:
        r"""

        Parameters
        ----------
        id :
        	The id of the child node

        Returns
        -------
        Set
            the set of the parents ids.

        """
        return _base.DAG_parents(self, id)

    def children(self, id: int) -> object:
        r"""

        Parameters
        ----------
        id : int
          the id of the parent

        Returns
        -------
        Set
        	the set of all the children

        """
        return _base.DAG_children(self, id)

    def addArc(self, *args) -> None:
        r"""

        Add an arc from tail to head.

        Parameters
        ----------
        tail : int
          the id of the tail node
        head : int
          the id of the head node

        Raises
        ------
          pyagrum.InvalidNode
            If head or tail does not belong to the graph nodes.
          pyagrum.CycleDetected
            If a cycle is detected


        """
        return _base.DAG_addArc(self, *args)

    def eraseArc(self, n1: int, n2: int) -> None:
        r"""

        Erase the arc between n1 and n2.

        Parameters
        ----------
        n1 : int
        	the id of the tail node
        n2 : int
        	the id of the head node

        """
        return _base.DAG_eraseArc(self, n1, n2)

    def existsArc(self, n1: int, n2: int) -> bool:
        r"""

        Check if an arc exists bewteen n1 and n2.

        Parameters
        ----------
        n1 : int
        	the id of the tail node
        n2 : int
        	the id of the head node

        Returns
        -------
        bool
            True if the arc exists

        """
        return _base.DAG_existsArc(self, n1, n2)

    def eraseParents(self, n: int) -> None:
        r"""

        Erase the arcs coming to the node.

        Parameters
        ----------
        n : int
        	the id of the child node

        """
        return _base.DAG_eraseParents(self, n)

    def eraseChildren(self, n: int) -> None:
        r"""

        Erase the arcs heading through the node's children.

        Parameters
        ----------
        n : int
        	the id of the parent node

        """
        return _base.DAG_eraseChildren(self, n)

    def sizeArcs(self) -> int:
        r"""

        Returns
        -------
        int
            the number of arcs in the graph

        """
        return _base.DAG_sizeArcs(self)

    def emptyArcs(self) -> bool:
        r"""

        Check if the graph doesn't contains arcs.

        Returns
        -------
        bool
            True if the graph doesn't contains arcs

        """
        return _base.DAG_emptyArcs(self)

# Register DAG in _base:
_base.DAG_swigregister(DAG)
class MixedGraph(UndiGraph, DiGraph):
    r"""

    MixedGraph represents a graph with both arcs and edges.

    MixedGraph() -> MixedGraph
        default constructor

    MixedGraph(src) -> MixedGraph
        Parameters:
            - **src** (*pyagrum.MixedGraph*) --the MixedGraph to copy

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        _base.MixedGraph_swiginit(self, _base.new_MixedGraph(*args))
    __swig_destroy__ = _base.delete_MixedGraph

    def __eq__(self, g: "MixedGraph") -> bool:
        return _base.MixedGraph___eq__(self, g)

    def eraseNode(self, node: int) -> None:
        r"""

        Erase the node and all the related arcs and edges.

        Parameters
        ----------
        id : int
        	the id of the node

        """
        return _base.MixedGraph_eraseNode(self, node)

    def clear(self) -> None:
        r"""

        Remove all the nodes and edges from the graph.

        """
        return _base.MixedGraph_clear(self)

    def hasMixedOrientedPath(self, node1: int, node2: int) -> bool:
        return _base.MixedGraph_hasMixedOrientedPath(self, node1, node2)

    def toDot(self) -> str:
        r"""

        Returns
        -------
        str
            a friendly display of the graph in DOT format

        """
        return _base.MixedGraph_toDot(self)

    def chainComponent(self, node: int) -> List[int]:
        return _base.MixedGraph_chainComponent(self, node)

    def __repr__(self) -> str:
        return _base.MixedGraph___repr__(self)

    def __str__(self) -> str:
        return _base.MixedGraph___str__(self)

    def addNodes(self, n: int) -> object:
        r"""

        Add n nodes.

        Parameters
        ----------
        n : int
          the number of nodes to add.

        Returns
        -------
        Set of int
          the new ids

        """
        return _base.MixedGraph_addNodes(self, n)

    def __iter__(self):
      """
      Iterate over the nodes of the graph

      Yield
      -----
      int
        The index of the node
      """
      for i in self.nodes():
        yield i

    def __getstate__(self):
        state=dict()
        if hasattr(self,'arcs'):
            state['arcs']=self.arcs()
        if hasattr(self,'edges'):
          state['edges']=self.edges()
        return state

    def __setstate__(self,state):
        self.__init__()
        if 'arcs' in state:
            for x,y in state['arcs']:
              if not self.existsNode(x):
                self.addNodeWithId(x)
              if not self.existsNode(y):
                self.addNodeWithId(y)
              self.addArc(x,y)
        if 'edges' in state:
            for x,y in state['edges']:
              if not self.existsNode(x):
                self.addNodeWithId(x)
              if not self.existsNode(y):
                self.addNodeWithId(y)
              self.addEdge(x,y)
        return self


    def arcs(self) -> object:
        return _base.MixedGraph_arcs(self)

    def parents(self, id: int) -> object:
        return _base.MixedGraph_parents(self, id)

    def children(self, id: int) -> object:
        return _base.MixedGraph_children(self, id)

    def edges(self) -> object:
        return _base.MixedGraph_edges(self)

    def neighbours(self, id: int) -> object:
        return _base.MixedGraph_neighbours(self, id)

    def boundary(self, id: int) -> object:
        r"""

        Boundary are neighbours (not oriented), children and parents

        Parameters
        ----------
        id : int
        	the id of the node

        Returns
        -------
        set
            the set of node ids.

        """
        return _base.MixedGraph_boundary(self, id)

    def mixedOrientedPath(self, node1: int, node2: int) -> object:
        r"""

        Parameters
        ----------
        node1 : int
        	the id form which the path begins
        node2 : int
        	the id to witch the path ends

        Returns
        -------
        List
        	 a path from node1 to node2, using edges and/or arcs (following the direction of the arcs). If no path is found, the returned list is empty.

        """
        return _base.MixedGraph_mixedOrientedPath(self, node1, node2)

    def mixedUnorientedPath(self, node1: int, node2: int) -> object:
        r"""

        Parameters
        ----------
        node1 : int
        	the id from which the path begins
        node2 : int
        	the id to which the path ends

        Returns
        -------
        List
        	 a path from node1 to node2, using edges and/or arcs (not necessarily following the direction of the arcs). If no path is found, the list is empty.


        """
        return _base.MixedGraph_mixedUnorientedPath(self, node1, node2)

    def addNode(self) -> int:
        r"""

        Returns
        -------
        int
          the new NodeId

        """
        return _base.MixedGraph_addNode(self)

    def addNodeWithId(self, id: int) -> None:
        r"""

        Add a node by choosing a new NodeId.

        Parameters
        ----------
        id : int
          The id of the new node

        Raises
        ------
          pyagrum.DuplicateElement
            If the given id is already used

        """
        return _base.MixedGraph_addNodeWithId(self, id)

    def existsNode(self, id: int) -> bool:
        r"""

        Check if a node with a certain id exists in the graph.

        Parameters
        ----------
        id : int
            the checked id

        Returns
        -------
        bool
            True if the node exists

        """
        return _base.MixedGraph_existsNode(self, id)

    def size(self) -> int:
        r"""

        Returns
        -------
        int
            the number of nodes in the graph

        """
        return _base.MixedGraph_size(self)

    def empty(self) -> bool:
        r"""

        Check if the graph is empty.

        Returns
        -------
        bool
            True if the graph is empty

        """
        return _base.MixedGraph_empty(self)

    def addEdge(self, n1: int, n2: int) -> None:
        r"""

        Insert a new edge into the graph.

        Parameters
        ----------
        n1 : int
          the id of one node of the new inserted edge
        n2 : int
          the id of the other node of the new inserted edge

        Raises
        ------
          pyagrum.InvalidNode
            If n1 or n2 does not belong to the graph nodes.

        """
        return _base.MixedGraph_addEdge(self, n1, n2)

    def eraseEdge(self, n1: int, n2: int) -> None:
        r"""

        Erase the edge between n1 and n2.

        Parameters
        ----------
        n1 : int
          the id of the tail node
        n2 : int
          the id of the head node

        """
        return _base.MixedGraph_eraseEdge(self, n1, n2)

    def existsEdge(self, n1: int, n2: int) -> bool:
        r"""

        Check if an edge exists bewteen n1 and n2.

        Parameters
        ----------
        n1 : int
          the id of one extremity of the edge
        n2 : int
          the id of the other extremity if tge edge

        Returns
        -------
        bool
            True if the arc exists

        """
        return _base.MixedGraph_existsEdge(self, n1, n2)

    def sizeEdges(self) -> int:
        r"""

        Returns
        -------
        int
            the number of edges in the graph

        """
        return _base.MixedGraph_sizeEdges(self)

    def emptyEdges(self) -> bool:
        r"""

        Check if the graph doesn't contains edges.

        Returns
        -------
        bool
            True if the graph doesn't contains edges

        """
        return _base.MixedGraph_emptyEdges(self)

    def eraseNeighbours(self, n: int) -> None:
        r"""

        Erase all the edges adjacent to a given node.

        Parameters
        ----------
        n : int
          the id of the node

        """
        return _base.MixedGraph_eraseNeighbours(self, n)

    def addArc(self, n1: int, n2: int) -> None:
        return _base.MixedGraph_addArc(self, n1, n2)

    def eraseArc(self, n1: int, n2: int) -> None:
        r"""

        Erase the arc between n1 and n2.

        Parameters
        ----------
        n1 : int
        	the id of the tail node
        n2 : int
        	the id of the head node

        """
        return _base.MixedGraph_eraseArc(self, n1, n2)

    def existsArc(self, n1: int, n2: int) -> bool:
        r"""

        Check if an arc exists bewteen n1 and n2.

        Parameters
        ----------
        n1 : int
        	the id of the tail node
        n2 : int
        	the id of the head node

        Returns
        -------
        bool
            True if the arc exists

        """
        return _base.MixedGraph_existsArc(self, n1, n2)

    def eraseParents(self, n: int) -> None:
        r"""

        Erase the arcs coming to the node.

        Parameters
        ----------
        n : int
        	the id of the child node

        """
        return _base.MixedGraph_eraseParents(self, n)

    def eraseChildren(self, n: int) -> None:
        r"""

        Erase the arcs heading through the node's children.

        Parameters
        ----------
        n : int
        	the id of the parent node

        """
        return _base.MixedGraph_eraseChildren(self, n)

    def sizeArcs(self) -> int:
        r"""

        Returns
        -------
        int
            the number of arcs in the graph

        """
        return _base.MixedGraph_sizeArcs(self)

    def emptyArcs(self) -> bool:
        r"""

        Check if the graph doesn't contains arcs.

        Returns
        -------
        bool
            True if the graph doesn't contains arcs

        """
        return _base.MixedGraph_emptyArcs(self)

# Register MixedGraph in _base:
_base.MixedGraph_swigregister(MixedGraph)
class PDAG(MixedGraph):
    r"""

    PDAG represents a graph with both arcs and edges.

    PDAG() -> PDAG
        default constructor

    PDAG(src) -> PDAG
        Parameters:
            - **src** (*pyagrum.PDAG*) --the PDAG to copy

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        _base.PDAG_swiginit(self, _base.new_PDAG(*args))
    __swig_destroy__ = _base.delete_PDAG

    def moralGraph(self) -> "pyagrum.UndiGraph":
        return _base.PDAG_moralGraph(self)

    def hasMixedReallyOrientedPath(self, n1: int, n2: int) -> bool:
        return _base.PDAG_hasMixedReallyOrientedPath(self, n1, n2)

    def toDot(self) -> str:
        r"""

        Returns
        -------
        str
            a friendly display of the graph in DOT format

        """
        return _base.PDAG_toDot(self)

    def __repr__(self) -> str:
        return _base.PDAG___repr__(self)

    def __str__(self) -> str:
        return _base.PDAG___str__(self)

    def cSeparation(self, *args) -> bool:
        return _base.PDAG_cSeparation(self, *args)

    def moralizedAncestralGraph(self, *args) -> "pyagrum.UndiGraph":
        return _base.PDAG_moralizedAncestralGraph(self, *args)

    def addNodes(self, n: int) -> object:
        return _base.PDAG_addNodes(self, n)

    def __iter__(self):
      """
      Iterate over the nodes of the graph

      Yield
      -----
      int
        The index of the node
      """
      for i in self.nodes():
        yield i

    def __getstate__(self):
        state=dict()
        if hasattr(self,'arcs'):
            state['arcs']=self.arcs()
        if hasattr(self,'edges'):
          state['edges']=self.edges()
        return state

    def __setstate__(self,state):
        self.__init__()
        if 'arcs' in state:
            for x,y in state['arcs']:
              if not self.existsNode(x):
                self.addNodeWithId(x)
              if not self.existsNode(y):
                self.addNodeWithId(y)
              self.addArc(x,y)
        if 'edges' in state:
            for x,y in state['edges']:
              if not self.existsNode(x):
                self.addNodeWithId(x)
              if not self.existsNode(y):
                self.addNodeWithId(y)
              self.addEdge(x,y)
        return self


    def arcs(self) -> object:
        return _base.PDAG_arcs(self)

    def parents(self, id: int) -> object:
        return _base.PDAG_parents(self, id)

    def children(self, id: int) -> object:
        return _base.PDAG_children(self, id)

    def edges(self) -> object:
        return _base.PDAG_edges(self)

    def neighbours(self, id: int) -> object:
        return _base.PDAG_neighbours(self, id)

    def boundary(self, id: int) -> object:
        return _base.PDAG_boundary(self, id)

    def mixedOrientedPath(self, node1: int, node2: int) -> object:
        r"""

        Parameters
        ----------
        node1 : int
        	the id form which the path begins
        node2 : int
        	the id to witch the path ends

        Returns
        -------
        List
        	 a path from node1 to node2, using edges and/or arcs (following the direction of the arcs). If no path is found, the returned list is empty.

        """
        return _base.PDAG_mixedOrientedPath(self, node1, node2)

    def mixedUnorientedPath(self, node1: int, node2: int) -> object:
        r"""

        Parameters
        ----------
        node1 : int
        	the id from which the path begins
        node2 : int
        	the id to which the path ends

        Returns
        -------
        List
        	 a path from node1 to node2, using edges and/or arcs (not necessarily following the direction of the arcs). If no path is found, the list is empty.


        """
        return _base.PDAG_mixedUnorientedPath(self, node1, node2)

    def addNode(self) -> int:
        return _base.PDAG_addNode(self)

    def addNodeWithId(self, id: int) -> None:
        return _base.PDAG_addNodeWithId(self, id)

    def existsNode(self, id: int) -> bool:
        return _base.PDAG_existsNode(self, id)

    def size(self) -> int:
        return _base.PDAG_size(self)

    def empty(self) -> bool:
        return _base.PDAG_empty(self)

    def addEdge(self, *args) -> None:
        r"""

        Insert a new edge into the graph.

        Parameters
        ----------
        n1 : int
          the id of one node of the new inserted edge
        n2 : int
          the id of the other node of the new inserted edge

        Raises
        ------
          pyagrum.InvalidNode
            If n1 or n2 does not belong to the graph nodes.

        """
        return _base.PDAG_addEdge(self, *args)

    def eraseEdge(self, n1: int, n2: int) -> None:
        return _base.PDAG_eraseEdge(self, n1, n2)

    def existsEdge(self, n1: int, n2: int) -> bool:
        return _base.PDAG_existsEdge(self, n1, n2)

    def sizeEdges(self) -> int:
        return _base.PDAG_sizeEdges(self)

    def emptyEdges(self) -> bool:
        return _base.PDAG_emptyEdges(self)

    def eraseNeighbours(self, n: int) -> None:
        return _base.PDAG_eraseNeighbours(self, n)

    def addArc(self, *args) -> None:
        r"""

        Add an arc from tail to head.

        Parameters
        ----------
        tail : int
          the id of the tail node
        head : int
          the id of the head node

        Raises
        ------
          pyagrum.InvalidNode
            If head or tail does not belong to the graph nodes.

          PyAgrum.InvalidDirectedCycle
            if the arc would create a (mixed) cycle.

        """
        return _base.PDAG_addArc(self, *args)

    def eraseArc(self, n1: int, n2: int) -> None:
        return _base.PDAG_eraseArc(self, n1, n2)

    def existsArc(self, n1: int, n2: int) -> bool:
        return _base.PDAG_existsArc(self, n1, n2)

    def eraseParents(self, n: int) -> None:
        return _base.PDAG_eraseParents(self, n)

    def eraseChildren(self, n: int) -> None:
        return _base.PDAG_eraseChildren(self, n)

    def sizeArcs(self) -> int:
        return _base.PDAG_sizeArcs(self)

    def emptyArcs(self) -> bool:
        return _base.PDAG_emptyArcs(self)

# Register PDAG in _base:
_base.PDAG_swigregister(PDAG)
class CliqueGraph(UndiGraph):
    r"""

    CliqueGraph represents a Clique Graph.

    CliqueGraph() -> CliqueGraph
        default constructor

    CliqueGraph(src) -> CliqueGraph
        Parameter
            - **src** (*pyagrum.CliqueGraph*) -- the CliqueGraph to copy

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.CliqueGraph_swiginit(self, _base.new_CliqueGraph(*args))
    __swig_destroy__ = _base.delete_CliqueGraph

    def addEdge(self, first: int, second: int) -> None:
        r"""

        Insert a new edge into the graph.

        Parameters
        ----------
        n1 : int
          the id of one node of the new inserted edge
        n2 : int
          the id of the other node of the new inserted edge

        Raises
        ------
          pyagrum.InvalidNode
            If n1 or n2 does not belong to the graph nodes.

        """
        return _base.CliqueGraph_addEdge(self, first, second)

    def eraseEdge(self, edge: "pyagrum.Edge") -> None:
        r"""

        Erase the edge between n1 and n2.

        Parameters
        ----------
        n1 : int
          the id of the tail node
        n2 : int
          the id of the head node

        """
        return _base.CliqueGraph_eraseEdge(self, edge)

    def clearEdges(self) -> None:
        r"""

        Remove all edges and their separators

        """
        return _base.CliqueGraph_clearEdges(self)

    def addNode(self, *args) -> int:
        r"""

        Returns
        -------
        int
          the new NodeId

        """
        return _base.CliqueGraph_addNode(self, *args)

    def eraseNode(self, node: int) -> None:
        r"""

        Erase the node and all the adjacent edges.

        Parameters
        ----------
        id : int
          the id of the node

        """
        return _base.CliqueGraph_eraseNode(self, node)

    def clear(self) -> None:
        r"""

        Remove all the nodes and edges from the graph.

        """
        return _base.CliqueGraph_clear(self)

    def container(self, idNode: int) -> int:
        r"""

        Parameters
        ----------
        idNode : int
          the id of the node

        Returns
        -------
        int
          the id of a clique containing the node

        Raises
        ------
        pyagrum.NotFound
          If no clique contains idNode

        """
        return _base.CliqueGraph_container(self, idNode)

    def setClique(self, idClique: int, new_clique: List[int]) -> None:
        r"""

        changes the set of nodes included into a given clique

        Parameters
        ----------
        idClique : int
          the id of the clique
        new_clique : Set[int]
          the new set of nodes to be included in the clique

        Raises
        ------
        pyagrum.NotFound
          If idClique is not a clique of the graph

        """
        return _base.CliqueGraph_setClique(self, idClique, new_clique)

    def addToClique(self, clique_id: int, node_id: int) -> None:
        r"""

        Change the set of nodes included into a given clique and returns the new set

        Parameters
        ----------
        clique_id : int
          the id of the clique
        node_id : int
          the id of the node

        Raises
        ------
          pyagrum.NotFound
          If clique_id does not exist
          pyagrum.DuplicateElement
          If clique_id set already contains the ndoe

        """
        return _base.CliqueGraph_addToClique(self, clique_id, node_id)

    def eraseFromClique(self, clique_id: int, node_id: int) -> None:
        r"""

        Remove a node from a clique

        Parameters
        ----------
        clique_id : int
          the id of the clique
        node_id : int
          the id of the node

        Raises
        ------
        pyagrum.NotFound
          If clique_id does not exist

        """
        return _base.CliqueGraph_eraseFromClique(self, clique_id, node_id)

    def containerPath(self, node1: int, node2: int) -> List[int]:
        r"""

        Parameters
        ----------
        node1 : int
          the id of one node
        node2 : int
          the id of the other node

        Returns
        -------
        List
          a path from a clique containing node1 to a clique containing node2

        Raises
        ------
        pyagrum.NotFound
          If such path cannot be found

        """
        return _base.CliqueGraph_containerPath(self, node1, node2)

    def hasRunningIntersection(self) -> bool:
        r"""

        Returns
        -------
        bool
          True if the running intersection property holds

        """
        return _base.CliqueGraph_hasRunningIntersection(self)

    def isJoinTree(self) -> bool:
        r"""

        Returns
        -------
        bool
          True if the graph is a join tree

        """
        return _base.CliqueGraph_isJoinTree(self)

    def toDot(self) -> str:
        r"""

        Returns
        -------
        str
            a friendly display of the graph in DOT format

        """
        return _base.CliqueGraph_toDot(self)

    def __map_str__(self, *args) -> str:
        return _base.CliqueGraph___map_str__(self, *args)

    def __eq__(self, _from: "CliqueGraph") -> bool:
        return _base.CliqueGraph___eq__(self, _from)

    def clique(self, clique: int) -> object:
        r"""

        Parameters
        ----------
        idClique : int
          the id of the clique

        Returns
        -------
        Set[int]
          The set of nodes included in the clique

        Raises
        ------
        pyagrum.NotFound
          If the clique does not belong to the clique graph

        """
        return _base.CliqueGraph_clique(self, clique)

    def separator(self, cliq1: int, cliq2: int) -> object:
        r"""

        Parameters
        ----------
        edge : pyagrum.Edge
          the edge to be checked
        clique1 : int
            one extremity of the edge
        clique : int
          the other extremity of the edge

        Returns
        -------
        Set[int]
          the separator included in a given edge

        Raises
        ------
        pyagrum.NotFound
          If the edge does not belong to the clique graph

        """
        return _base.CliqueGraph_separator(self, cliq1, cliq2)

    def toDotWithNames(self,bn):
        """
        Parameters
        ----------
        bn : pyagrum.BayesNet
        a Bayesian network

        Returns
        -------
        str
          a friendly display of the graph in DOT format where ids have been changed according to their correspondance in the BN
        """
        def local_nameFromId(m):
          return " ".join([bn.variable(int(n)).name()
                           for n in m.group().split("-")])
        import re
        m = re.compile(r'(?<=label=\")\d+[\-\d+]*')
        return m.sub(local_nameFromId,self.toDot())


# Register CliqueGraph in _base:
_base.CliqueGraph_swigregister(CliqueGraph)
class MeekRules(object):
    r"""

    MeekRules class applies the Meek rules to a mixed graph or PDAG (Partially Directed Acyclic Graph) in order to propagate orientation constraints and obtain a CPDAG (Completed Partially Directed Acyclic Graph) or a DAG (Directed Acyclic Graph).

    The Meek Rules help complete the orientation of edges in a mixed graph, resulting in a CPDAG that reflects the possible causal relationships among variables while accounting for the observed conditional independencies in the data. The CPDAG is a more refined and directed version of the original PDAG (Partially Directed Acyclic Graph) obtained from the data.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _base.MeekRules_swiginit(self, _base.new_MeekRules())
    __swig_destroy__ = _base.delete_MeekRules

    def propagate(self, mg: "MixedGraph") -> "pyagrum.MixedGraph":
        return _base.MeekRules_propagate(self, mg)

    def propagateToCPDAG(self, mg: "MixedGraph") -> "pyagrum.PDAG":
        r"""

        Propagates orientation constraints in the graph according to the Meek rules. The Meek rules are applied iteratively until no more orientation constraints can be propagated. And then arbitratily resolves float orientations. This method returns a `pyagrum.PDAG` with the properties of CPDAG.

        The arbitrary resolution of float orientations is not deterministic. It depends on the order of the edges in the graph. `pyagrum.MeekRules.Choices` returns the list of the arbitrary choices made by the last execution of `pyagrum.MeekRules.progagatesToCPDAG`.

        Parameters
        ----------
        mg : pyagrum.MixedGraph
            The graph to be completed.

        Returns
        -------
        pyagrum.PDAG
            The completed `pyagrum.PDAG` (CPDAG).

        """
        return _base.MeekRules_propagateToCPDAG(self, mg)

    def propagateToDAG(self, mg: "MixedGraph") -> "pyagrum.DAG":
        r"""

        Calls `propagateToCPDAG` and then orients the remaining edges arbitrarily according to some heuristics. `pyagrum.MeekRules.Choices` returns the list of the arbitrary choices made by the last execution of `pyagrum.MeekRules.progagatesToDAG`.

        Parameters
        ----------
        mg : `pyagrum.MixedGraph` or `pyagrum.PDAG`
            The graph to be completed.

        Returns
        -------
        `pyagrum.DAG`
            The completed `pyagrum.DAG`.

        """
        return _base.MeekRules_propagateToDAG(self, mg)

    def choices(self) -> object:
        r"""

        Returns the list of the arbitrary choices made by the last execution of `pyagrum.MeekRules.progagatesToCPDAG` or `pyagrum.MeekRules.progagatesToDAG`.

        Returns
        -------
        list of tuple
            The list of the arbitrary choices made by the last execution of `pyagrum.MeekRules.progagatesToCPDAG` or `pyagrum.MeekRules.progagatesToDAG`. Each tuple represents a `pyagrum.Edge`.

        """
        return _base.MeekRules_choices(self)

# Register MeekRules in _base:
_base.MeekRules_swigregister(MeekRules)
class Instantiation(object):
    r"""

    Class for assigning/browsing values to tuples of discrete variables.

    Instantiation is designed to assign values to tuples of variables and to efficiently loop over values of subsets of variables.

    Instantiation() -> Instantiation
        default constructor

    Instantiation(aI) -> Instantiation
        Parameters:
          - **aI** (*pyagrum.Instantiation*) -- the Instantiation we copy

    Returns
    -------
    pyagrum.Instantiation
    	An empty tuple or a copy of the one in parameters

    Instantiation is subscriptable therefore values can be easily accessed/modified.

    Examples
    --------
    >>> ## Access the value of A in an instantiation aI
    >>> valueOfA = aI['A']
    >>> ## Modify the value
    >>> aI['A'] = newValueOfA

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        _base.Instantiation_swiginit(self, _base.new_Instantiation(*args))
    __swig_destroy__ = _base.delete_Instantiation

    def nbrDim(self) -> int:
        r"""

        Returns
        -------
        int
            The number of variables in the Instantiation.

        """
        return _base.Instantiation_nbrDim(self)

    def add(self, v: "pyagrum.DiscreteVariable") -> None:
        r"""

        Adds a new variable in the Instantiation.

        Parameters
        ----------
        v : pyagrum.DiscreteVariable
          The new variable added to the Instantiation

        Raises
        ------
        DuplicateElement
          If the variable is already in this Instantiation


        """
        val = _base.Instantiation_add(self, v)

        return self


        return val


    def erase(self, *args) -> None:
        r"""

        Parameters
        ----------
        v : pyagrum.DiscreteVariable
          The variable to be removed from this Instantiation.

        Raises
        ------
        NotFound
          If v does not belong to this Instantiation.

        """
        return _base.Instantiation_erase(self, *args)

    def clear(self) -> None:
        r"""

        Erase all variables from an Instantiation.

        """
        return _base.Instantiation_clear(self)

    def domainSize(self) -> int:
        r"""

        Returns
        -------
        int
            The product of the variable's domain size in the Instantiation.

        """
        return _base.Instantiation_domainSize(self)

    def pos(self, v: "pyagrum.DiscreteVariable") -> int:
        r"""

        Returns
        -------
        int
           the position of the variable v.

        Parameters
        ----------
        v : pyagrum.DiscreteVariable
            the variable for which its position is return.

        Raises
        ------
        NotFound
          If v does not belong to the instantiation.

        """
        return _base.Instantiation_pos(self, v)

    def val(self, *args) -> int:
        r"""

        Parameters
        ----------
        i : int
        	The index of the variable.
        var : pyagrum.DiscreteVariable
        	The variable the value of which we wish to know

        Returns
        -------
        int
        	the current value of the variable.

        Raises
        ------
        NotFound
          If the element cannot be found.

        """
        return _base.Instantiation_val(self, *args)

    def variable(self, *args) -> "pyagrum.DiscreteVariable":
        r"""

        Parameters
        ----------
        i : int
          The index of the variable

        Returns
        -------
        pyagrum.DiscreteVariable
          the variable at position i in the tuple.

        Raises
        ------
        NotFound
          If the element cannot be found.

        """
        return _base.Instantiation_variable(self, *args)

    def chgVal(self, *args) -> "pyagrum.Instantiation":
        r"""

        Assign newval to v (or to the variable at position varPos) in the Instantiation.

        Parameters
        ----------
        v : pyagrum.DiscreteVariable or string
          The variable whose value is assigned (or its name)
        varPos : int
          The index of the variable whose value is assigned in the tuple of variables of the Instantiation
        newval : int or string
          The index of the value assigned (or its name)

        Returns
        -------
        pyagrum.Instantiation
            The modified instantiation

        Raises
        ------
        NotFound
          If variable v does not belong to the instantiation.
        OutOfBounds
          If newval is not a possible value for the variable.

        """
        return _base.Instantiation_chgVal(self, *args)

    def setVals(self, i: "pyagrum.Instantiation") -> "pyagrum.Instantiation":
        r"""

        Assign the values from i in the Instantiation.

        Parameters
        ----------
        i : pyagrum.Instantiation
          An Instantiation in which the new values are searched

        Returns
        -------
        pyagrum.Instantiation
          a reference to the instantiation

        """
        return _base.Instantiation_setVals(self, i)

    def contains(self, *args) -> bool:
        r"""

        Indicates whether a given variable belongs to the Instantiation.

        Parameters
        ----------
        v : pyagrum.DiscreteVariable
            The variable for which the test is made.

        Returns
        -------
        bool :
            True if the variable is in the Instantiation.

        """
        return _base.Instantiation_contains(self, *args)

    def variablesSequence(self) -> List[object]:
        r"""

        Returns
        -------
        List
            the sequence of DiscreteVariable of this instantiation.

        """
        return _base.Instantiation_variablesSequence(self)

    def empty(self) -> bool:
        r"""

        Returns
        -------
        bool
            True if the instantiation is empty.

        """
        return _base.Instantiation_empty(self)

    def inOverflow(self) -> bool:
        r"""

        Returns
        -------
        bool
          True if the current value of the tuple is correct

        """
        return _base.Instantiation_inOverflow(self)

    def unsetOverflow(self) -> None:
        r"""

        Removes the flag overflow.

        """
        return _base.Instantiation_unsetOverflow(self)

    def unsetEnd(self) -> None:
        r"""

        Alias for unsetOverflow().

        """
        return _base.Instantiation_unsetEnd(self)

    def end(self) -> bool:
        r"""

        Returns
        -------
        bool
            True if the Instantiation reached the end.

        """
        return _base.Instantiation_end(self)

    def rend(self) -> bool:
        r"""

        Returns
        -------
        bool:
          True if the Instantiation reached the rend.

        """
        return _base.Instantiation_rend(self)

    def inc(self) -> None:
        r"""

        Operator ++.

        """
        return _base.Instantiation_inc(self)

    def dec(self) -> None:
        r"""

        Operator --.

        """
        return _base.Instantiation_dec(self)

    def incIn(self, i: "pyagrum.Instantiation") -> None:
        r"""

        Operator ++ for the variables in i.

        Parameters
        ----------
        i : pyagrum.Instantiation
            The set of variables to increment in this Instantiation.

        """
        return _base.Instantiation_incIn(self, i)

    def decIn(self, i: "pyagrum.Instantiation") -> None:
        r"""

        Operator -- for the variables in i.

        Parameters
        ----------
        i : pyagrum.Instantiation
          The set of variables to decrement in this Instantiation

        """
        return _base.Instantiation_decIn(self, i)

    def incOut(self, i: "pyagrum.Instantiation") -> None:
        r"""

        Operator ++ for the variables not in i.

        Parameters
        ----------
        i : Instantiation
            The set of variable to not increment in this Instantiation.

        """
        return _base.Instantiation_incOut(self, i)

    def decOut(self, i: "pyagrum.Instantiation") -> None:
        r"""

        Operator -- for the variables not in i.

        Parameters
        ----------
        i : pyagrum.Instantiation
          The set of variables to not decrement in this Instantiation.

        """
        return _base.Instantiation_decOut(self, i)

    def incNotVar(self, v: "pyagrum.DiscreteVariable") -> None:
        r"""

        Operator ++ for vars which are not v.

        Parameters
        ----------
        v : pyagrum.DiscreteVariable
            The variable not to increment in this Instantiation.

        """
        return _base.Instantiation_incNotVar(self, v)

    def decNotVar(self, v: "pyagrum.DiscreteVariable") -> None:
        r"""

        Operator -- for vars which are not v.

        Parameters
        ----------
        v : pyagrum.DiscreteVariable
          The variable not to decrement in this Instantiation.

        """
        return _base.Instantiation_decNotVar(self, v)

    def incVar(self, v: "pyagrum.DiscreteVariable") -> None:
        r"""

        Operator ++ for variable v only.

        Parameters
        ----------
        v : pyagrum.DiscreteVariable
            The variable to increment in this Instantiation.

        Raises
        ------
        NotFound
          If variable v does not belong to the Instantiation.

        """
        return _base.Instantiation_incVar(self, v)

    def decVar(self, v: "pyagrum.DiscreteVariable") -> None:
        r"""

        Operator -- for variable v only.

        Parameters
        ----------
        v : pyagrum.DiscreteVariable
         The variable to decrement in this Instantiation.

        Raises
        ------
        NotFound
          If variable v does not belong to the Instantiation.

        """
        return _base.Instantiation_decVar(self, v)

    def setFirst(self) -> None:
        r"""

        Assign the first values to the tuple of the Instantiation.

        """
        return _base.Instantiation_setFirst(self)

    def setLast(self) -> None:
        r"""

        Assign the last values in the Instantiation.

        """
        return _base.Instantiation_setLast(self)

    def setFirstIn(self, i: "pyagrum.Instantiation") -> None:
        r"""

        Assign the first values in the Instantiation for the variables in i.

        Parameters
        ----------
        i : pyagrum.Instantiation
          The variables to which their first value is assigned in this Instantiation.

        """
        return _base.Instantiation_setFirstIn(self, i)

    def setLastIn(self, i: "pyagrum.Instantiation") -> None:
        r"""

        Assign the last values in the Instantiation for the variables in i.

        Parameters
        ----------
        i : pyagrum.Instantiation
            The variables to which their last value is assigned in this Instantiation.

        """
        return _base.Instantiation_setLastIn(self, i)

    def setFirstOut(self, i: "pyagrum.Instantiation") -> None:
        r"""

        Assign the first values in the Instantiation for the variables not in i.

        Parameters
        ----------
        i : pyagrum.Instantiation
            The variable that will not be set to their first value in this Instantiation.

        """
        return _base.Instantiation_setFirstOut(self, i)

    def setLastOut(self, i: "pyagrum.Instantiation") -> None:
        r"""

        Assign the last values in the Instantiation for the variables not in i.

        Parameters
        ----------
        i : pyagrum.Instantiation
            The variables that will not be set to their last value in this Instantiation.

        """
        return _base.Instantiation_setLastOut(self, i)

    def setFirstNotVar(self, v: "pyagrum.DiscreteVariable") -> None:
        r"""

        Assign the first values to variables different of v.

        Parameters
        ----------
        v : pyagrum.DiscreteVariable
          The variable that will not be set to its first value in this Instantiation.

        """
        return _base.Instantiation_setFirstNotVar(self, v)

    def setLastNotVar(self, v: "pyagrum.DiscreteVariable") -> None:
        r"""

        Assign the last values to variables different of v.

        Parameters
        ----------
        v : pyagrum.DiscreteVariable
            The variable that will not be set to its last value in this Instantiation.

        """
        return _base.Instantiation_setLastNotVar(self, v)

    def setFirstVar(self, v: "pyagrum.DiscreteVariable") -> None:
        r"""

        Assign the first value in the Instantiation for var v.

        Parameters
        ----------
        v : pyagrum.DiscreteVariable
            The variable that will be set to its first value in this Instantiation.

        """
        return _base.Instantiation_setFirstVar(self, v)

    def setLastVar(self, v: "pyagrum.DiscreteVariable") -> None:
        r"""

        Assign the last value in the Instantiation for var v.

        Parameters
        ----------
        v : pyagrum.DiscreteVariable
          The variable that will be set to its last value in this Instantiation.

        """
        return _base.Instantiation_setLastVar(self, v)

    def __eq__(self, other: "pyagrum.Instantiation") -> bool:
        return _base.Instantiation___eq__(self, other)

    def __iadd__(self, depl: int) -> "pyagrum.Instantiation":
        return _base.Instantiation___iadd__(self, depl)

    def __isub__(self, depl: int) -> "pyagrum.Instantiation":
        return _base.Instantiation___isub__(self, depl)

    def hamming(self) -> int:
        r"""

        Returns
        -------
        int
          the hamming distance of this instantiation.

        """
        return _base.Instantiation_hamming(self)

    def reorder(self, *args) -> None:
        r"""

        Reorder vars of this instantiation giving the order in v (or i).

        Parameters
        ----------
        i : pyagrum.Instantiation
          The sequence of variables with which to reorder this Instantiation.
        v : list
            The new order of variables for this Instantiation.

        """
        return _base.Instantiation_reorder(self, *args)

    def __repr__(self) -> str:
        return _base.Instantiation___repr__(self)

    def __str__(self) -> str:
        return _base.Instantiation___str__(self)

    def setMutable(self) -> None:
        return _base.Instantiation_setMutable(self)

    def isMutable(self) -> bool:
        return _base.Instantiation_isMutable(self)

    def todict(self, withLabels: bool=False) -> object:
        r"""

        Create a dictionary `{variable_name:value}` from an instantiation

        Parameters
        ----------
        withLabels : boolean
        	The value will be a label (string) if True. It will be a position (int) if False. Default is False

        Returns
        -------
        Dict[str,int]
            The dictionary

        """
        return _base.Instantiation_todict(self, withLabels)

    def fromdict(self, dict: object) -> "pyagrum.Instantiation":
        r"""

        Change the values in an instantiation from a dictionary `{variable_name:value}` where value can be a position (int) or a label (string).

        If a variable_name does not occur in the instantiation, nothing is done.

        Warnings
        --------
            OutOfBounds raised if a value cannot be found.

        """
        return _base.Instantiation_fromdict(self, dict)

    def __setitem__(self,key,item):
      self.chgVal(key,item)

    def __getitem__(self,key):
      return self.val(self.variable(key))

    def variablesSequence(self):
      """
      Returns
      -------
      list
          a list containing the sequence of variables
      """
      varlist = []
      for i in range(0, self.nbrDim()):
          varlist.append(self.variable(i))
      return varlist

    def addVarsFromModel(self,model,names):
      r"""
      From a graphical model, add all the variable whose names are in the iterable

      Parameters
      ----------
      model : pyagrum.GraphicalModel
      a (discrete) graphical model such as Bayesian network, Markov random field, Influence Diagram, etc.

      names : iterable of strings
      a list/set/etc of names of variables (as string)

      Returns
      -------
      pyagrum.Instantiation
      the current instantiation (self) in order to chain methods.
      """
      for name in names:
        self.add(model.variable(name))
      return self

    def loopIn(self):
        """
        Generator to iterate on an Instantiation.

        Yield an pyagrum.Instantiation (copy of self) that iterates over all the possible values for the Instantiation.

        Examples
        --------
        >>> import pyagrum as gum
        >>> bn=pyagrum.fastBN("A[3]->B[3]<-C[3]")
        >>> I=pyagrum.Instantiation(bn.cpt("B"))
        >>> for i in I.loopIn():
              print(i)
              print(bn.cpt("B").get(i))
              bn.cpt("B").set(i,0.3)
        """
        J=pyagrum.Instantiation(self)
        J.setFirst()
        while not J.end():
            yield(J)
            J.inc()
        J.setLast()
        return


# Register Instantiation in _base:
_base.Instantiation_swigregister(Instantiation)
GUM_DEFAULT_ITERATOR_NUMBER = _base.GUM_DEFAULT_ITERATOR_NUMBER
class GraphicalModel(object):
    r"""

    Abstract class for all PGM (associating set of variables and a graph).

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _base.delete_GraphicalModel

    def property(self, name: str) -> str:
        r"""

        Returns the value associated to this property.

        Properties are a way to keep some (name,value) together with de model.

        Parameters
        ----------
        name : str
          the name of the property

        Raises
        ------
        NotFound
          if no name property is found

        Returns
        -------
        str
          The value associated to this name

        """
        return _base.GraphicalModel_property(self, name)

    def propertyWithDefault(self, name: str, byDefault: str) -> str:
        r"""

        Returns the value associated to this property or the default value if there is no such property.

        Properties are a way to keep some information (name,value) together with de model.

        Parameters
        ----------
        name : str
          the name of the property
        byDefault: str
          the value by default if no property has been found.

        Returns
        -------
        str
          The value associated to this name or the value by default.

        """
        return _base.GraphicalModel_propertyWithDefault(self, name, byDefault)

    def setProperty(self, name: str, value: str) -> None:
        r"""

        Create or change the couple (name,value) in the properties.

        Properties are a way to keep some information (name,value) together with de model.

        Parameters
        ----------
        name : str
          the name of the property
        value: str
          the value of the property.

        """
        return _base.GraphicalModel_setProperty(self, name, value)

    def properties(self) -> List[str]:
        return _base.GraphicalModel_properties(self)

    def variableNodeMap(self) -> "pyagrum.VariableNodeMap":
        return _base.GraphicalModel_variableNodeMap(self)

    def size(self) -> int:
        return _base.GraphicalModel_size(self)

    def empty(self) -> bool:
        r"""

        Check if there are some variables in the model.

        Returns
        -------
        bool
        	True if there is no variable in the model.

        """
        return _base.GraphicalModel_empty(self)

    def exists(self, *args) -> bool:
        r"""

        Check if a node with this name or id exists

        Parameters
        ----------
        norid: str|int
          name or id of the searched node

        Returns
        -------
        bool
        	True if there is a node with such a name or id

        """
        return _base.GraphicalModel_exists(self, *args)

    def names(self, *args) -> List[str]:
        r"""

        Set of names of variables in the model

        Returns
        -------
        Set[str]
        	The names of the graph variables

        """
        return _base.GraphicalModel_names(self, *args)

    def ids(self, names: List[str]) -> List[int]:
        r"""

        List of ids for a list of names of variables in the model

        Parameters
        ----------
        lov : List[str]
          List of variable names

        Returns
        -------
        List[int]
        	The ids for the list of names of the graph variables

        """
        return _base.GraphicalModel_ids(self, names)

    def nodeset(self, names: List[str]) -> List[int]:
        r"""

        Set of ids for a list of names of variables in the model

        Parameters
        ----------
        lov : List[str]
          List of variable names

        Returns
        -------
        Set[int]
        	The set of ids for the list of names of the graph variables

        """
        return _base.GraphicalModel_nodeset(self, names)

    def variables(self, *args) -> "pyagrum.VariableSet":
        return _base.GraphicalModel_variables(self, *args)

    def nodes(self) -> Set[int]:
        return _base.GraphicalModel_nodes(self)

    def completeInstantiation(self) -> "pyagrum.Instantiation":
        r"""

        Give an instantiation over all the variables of the model

        Returns
        -------
        pyagrum.Instantiation
          a complete Instantiation for the model

        """
        return _base.GraphicalModel_completeInstantiation(self)

    def variable(self, id: int) -> "pyagrum.DiscreteVariable":
        return _base.GraphicalModel_variable(self, id)

    def nodeId(self, var: "pyagrum.DiscreteVariable") -> int:
        return _base.GraphicalModel_nodeId(self, var)

    def idFromName(self, name: str) -> int:
        return _base.GraphicalModel_idFromName(self, name)

    def variableFromName(self, name: str) -> "pyagrum.DiscreteVariable":
        return _base.GraphicalModel_variableFromName(self, name)

    def log10DomainSize(self) -> float:
        r"""

        returns the log10 of the domain size of the model defined as the product of the domain sizes of the variables in the model.

        Returns
        -------
        float
        	the log10 domain size.

        """
        return _base.GraphicalModel_log10DomainSize(self)

    def isIndependent(self, *args) -> bool:
        r"""

        check if nodes X and nodes Y are independent given nodes Z

        Parameters
        ----------
        X : str|intList[str|int]
              a list of of nodeIds or names
        Y : str|intList[str|int]
              a list of of nodeIds or names
        Z : str|intList[str|int]
              a list of of nodeIds or names

        Raises
        ------
        InvalidArgument
          if X and Y share variables

        Returns
        -------
        bool
          True if X and Y are independent given Z in the model

        """
        return _base.GraphicalModel_isIndependent(self, *args)

    def family(self, *args) -> List[int]:
        return _base.GraphicalModel_family(self, *args)

# Register GraphicalModel in _base:
_base.GraphicalModel_swigregister(GraphicalModel)
_static_list_end_safe_ = cvar._static_list_end_safe_
_static_list_end_ = cvar._static_list_end_
_list_end_safe_ = cvar._list_end_safe_
_list_end_ = cvar._list_end_

class DAGmodel(GraphicalModel):
    r"""

    Abstract class used by IBayesNet and InfluenceDiagram.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _base.delete_DAGmodel

    def dag(self) -> "pyagrum.DAG":
        r"""

        Returns
        -------
        pyagrum.DAG
        	a constant reference to the dag of this BayesNet.

        """
        val = _base.DAGmodel_dag(self)

        from pyagrum.base import DAG
        val = DAG(val) # copying the DAG


        return val


    def size(self) -> int:
        r"""

        Returns
        -------
        int
            the number of nodes in the graph

        """
        return _base.DAGmodel_size(self)

    def sizeArcs(self) -> int:
        r"""

        Returns
        -------
        int
            the number of arcs in the graph

        """
        return _base.DAGmodel_sizeArcs(self)

    def nodes(self) -> Set[int]:
        r"""

        Returns
        -------
        set
            the set of ids

        """
        return _base.DAGmodel_nodes(self)

    def exists(self, *args) -> bool:
        r"""

        Check if a node with this name or id exists

        Parameters
        ----------
        norid: str|int
          name or id of the searched node

        Returns
        -------
        bool
        	True if there is a node with such a name or id

        """
        return _base.DAGmodel_exists(self, *args)

    def arcs(self) -> Set[Tuple[int,int]]:
        r"""

        Returns
        -------
        list
        	The lisf of arcs in the graph

        """
        return _base.DAGmodel_arcs(self)

    def existsArc(self, *args) -> bool:
        r"""

        Check if an arc exists

        Parameters
        ---------
        tail : str|int
          the name or id of the tail of the arc

        head : str|int
          the name or the id of the head of the arc

        Returns
        -------
        bool
          True if `tail->head` is an arc.

        """
        return _base.DAGmodel_existsArc(self, *args)

    def parents(self, *args) -> List[int]:
        return _base.DAGmodel_parents(self, *args)

    def family(self, *args) -> List[int]:
        r"""

        give the set of parents of a node and the node

        Parameters
        ---------
        norid : str|int
          the node

        Returns
        -------
        Set[int]
          the set of nodeId of the family of the node `norid`

        """
        return _base.DAGmodel_family(self, *args)

    def children(self, *args) -> List[int]:
        return _base.DAGmodel_children(self, *args)

    def descendants(self, *args) -> List[int]:
        r"""

        give the set of nodeid of descendants of a node

        Parameters
        ----------
        norid : str|int
          the name or the id of the node

        Returns
        -------
        Set[int]
          the set of ids of the descendants of node `norid`.

        """
        return _base.DAGmodel_descendants(self, *args)

    def ancestors(self, *args) -> List[int]:
        r"""

        give the set of nodeid of ancestors of a node

        Parameters
        ----------
        norid : str|int
          the name or the id of the node

        Returns
        -------
        Set[int]
          the set of ids of the ancestors of node `norid`.

        """
        return _base.DAGmodel_ancestors(self, *args)

    def moralizedAncestralGraph(self, *args) -> "pyagrum.UndiGraph":
        r"""

        build a UndiGraph by moralizing the Ancestral Graph of a list of nodes

        Parameters
        ----------
        nodes : str|intList[str|int]
          the list of of nodeIds or names

        Warnings
        --------
          pyagrum.UndiGraph only knows NodeId. Hence the moralized ancestral graph does not include the names of the variables.graph

        Returns
        -------
        pyagrum.UndiGraph
          the moralized ancestral graph of the nodes

        """
        return _base.DAGmodel_moralizedAncestralGraph(self, *args)

    def isIndependent(self, *args) -> bool:
        r"""

        check if nodes X and nodes Y are independent given nodes Z

        Parameters
        ----------
        X : str|intList[str|int]
              a list of of nodeIds or names
        Y : str|intList[str|int]
              a list of of nodeIds or names
        Z : str|intList[str|int]
              a list of of nodeIds or names

        Raises
        ------
        InvalidArgument
          if X and Y share variables

        Returns
        -------
        bool
          True if X and Y are independent given Z in the model

        """
        return _base.DAGmodel_isIndependent(self, *args)

    def moralGraph(self) -> "pyagrum.UndiGraph":
        r"""

        Returns the moral graph of the BayesNet, formed by adding edges between all pairs of nodes that have a common child, and then making all edges in the graph undirected.

        Returns
        -------
        pyagrum.UndiGraph
        	The moral graph

        """
        return _base.DAGmodel_moralGraph(self)

    def topologicalOrder(self) -> List[int]:
        r"""

        Returns
        -------
        List
            the list of the nodes Ids in a topological order

        Raises
        ------
        pyagrum.InvalidDirectedCycle
        	If this graph contains cycles

        """
        return _base.DAGmodel_topologicalOrder(self)

    def hasSameStructure(self, other: "pyagrum.DAGmodel") -> bool:
        r"""

        Parameters
        ----------
        pyagrum.DAGmodel
        	a direct acyclic model

        Returns
        -------
        bool
            True if all the named node are the same and all the named arcs are the same

        """
        return _base.DAGmodel_hasSameStructure(self, other)

# Register DAGmodel in _base:
_base.DAGmodel_swigregister(DAGmodel)
class UGmodel(GraphicalModel):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _base.delete_UGmodel

    def graph(self) -> "pyagrum.UndiGraph":
        return _base.UGmodel_graph(self)

    def size(self) -> int:
        return _base.UGmodel_size(self)

    def sizeEdges(self) -> int:
        return _base.UGmodel_sizeEdges(self)

    def nodes(self) -> Set[int]:
        return _base.UGmodel_nodes(self)

    def exists(self, *args) -> bool:
        r"""

        Check if a node with this name or id exists

        Parameters
        ----------
        norid: str|int
          name or id of the searched node

        Returns
        -------
        bool
        	True if there is a node with such a name or id

        """
        return _base.UGmodel_exists(self, *args)

    def edges(self) -> Set[Tuple[int,int]]:
        return _base.UGmodel_edges(self)

    def existsEdge(self, *args) -> bool:
        return _base.UGmodel_existsEdge(self, *args)

    def neighbours(self, *args) -> List[int]:
        return _base.UGmodel_neighbours(self, *args)

    def isIndependent(self, *args) -> bool:
        r"""

        check if nodes X and nodes Y are independent given nodes Z

        Parameters
        ----------
        X : str|intList[str|int]
              a list of of nodeIds or names
        Y : str|intList[str|int]
              a list of of nodeIds or names
        Z : str|intList[str|int]
              a list of of nodeIds or names

        Raises
        ------
        InvalidArgument
          if X and Y share variables

        Returns
        -------
        bool
          True if X and Y are independent given Z in the model

        """
        return _base.UGmodel_isIndependent(self, *args)

    def hasSameStructure(self, other: "pyagrum.UGmodel") -> bool:
        return _base.UGmodel_hasSameStructure(self, other)

    def family(self, *args) -> List[int]:
        return _base.UGmodel_family(self, *args)

# Register UGmodel in _base:
_base.UGmodel_swigregister(UGmodel)
class ApproximationScheme(object):
    r"""

    Used to parametrize stopping criteria in approximate inference or learning algorithm.

    ApproximationScheme(verbosity=False) -> ApproximationScheme
        Parameters:
          - **verbosity** (*bool) -- to keep (or not) tracks of the learning process (history of epsilons)

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, verbosity: bool=False):
        _base.ApproximationScheme_swiginit(self, _base.new_ApproximationScheme(verbosity))
    __swig_destroy__ = _base.delete_ApproximationScheme

    def setEpsilon(self, eps: float) -> None:
        r"""

        Parameters
        ----------
        eps : float
        	the epsilon we want to use

        Raises
        ------
        pyagrum.OutOfBounds
        	If eps<0

        """
        return _base.ApproximationScheme_setEpsilon(self, eps)

    def epsilon(self) -> float:
        r"""

        Returns
        -------
        float
        	the value of epsilon

        """
        return _base.ApproximationScheme_epsilon(self)

    def disableEpsilon(self) -> None:
        r"""

        Disable epsilon as a stopping criterion.

        """
        return _base.ApproximationScheme_disableEpsilon(self)

    def enableEpsilon(self) -> None:
        r"""

        Enable epsilon as a stopping criterion.

        """
        return _base.ApproximationScheme_enableEpsilon(self)

    def isEnabledEpsilon(self) -> bool:
        r"""

        Returns
        -------
        bool
          True if epsilon is used as a stopping criterion.

        """
        return _base.ApproximationScheme_isEnabledEpsilon(self)

    def setMinEpsilonRate(self, rate: float) -> None:
        r"""

        Parameters
        ----------
        rate : float
        	the minimal epsilon rate

        """
        return _base.ApproximationScheme_setMinEpsilonRate(self, rate)

    def minEpsilonRate(self) -> float:
        r"""

        Returns
        -------
        float
        	the value of the minimal epsilon rate

        """
        return _base.ApproximationScheme_minEpsilonRate(self)

    def disableMinEpsilonRate(self) -> None:
        r"""

        Disable a min epsilon rate as a stopping criterion.

        """
        return _base.ApproximationScheme_disableMinEpsilonRate(self)

    def enableMinEpsilonRate(self) -> None:
        r"""

        Enable a min epsilon rate as a stopping criterion.

        """
        return _base.ApproximationScheme_enableMinEpsilonRate(self)

    def isEnabledMinEpsilonRate(self) -> bool:
        r"""

        Returns
        -------
        bool
          True if epsilon rate is used as a stopping criterion

        """
        return _base.ApproximationScheme_isEnabledMinEpsilonRate(self)

    def setMaxIter(self, max: int) -> None:
        r"""

        Parameters
        ----------
        max : int
        	the maximum number of iteration

        Raises
        ------
        pyagrum.OutOfBounds
        	If max <= 1

        """
        return _base.ApproximationScheme_setMaxIter(self, max)

    def maxIter(self) -> int:
        r"""

        Returns
        -------
        int
        	the criterion on number of iterations

        """
        return _base.ApproximationScheme_maxIter(self)

    def disableMaxIter(self) -> None:
        r"""

        Disable max iterations as a stopping criterion.

        """
        return _base.ApproximationScheme_disableMaxIter(self)

    def enableMaxIter(self) -> None:
        r"""

        Enable max iterations as a stopping criterion.

        """
        return _base.ApproximationScheme_enableMaxIter(self)

    def isEnabledMaxIter(self) -> bool:
        r"""

        Returns
        -------
        bool
          True if max iterations is used as a stopping criterion

        """
        return _base.ApproximationScheme_isEnabledMaxIter(self)

    def setMaxTime(self, timeout: float) -> None:
        r"""

        Parameters
        ----------
        tiemout : float
        	stopping criterion on timeout (in seconds)

        Raises
        ------
        pyagrum.OutOfBounds
        	If timeout<=0.0

        """
        return _base.ApproximationScheme_setMaxTime(self, timeout)

    def maxTime(self) -> float:
        r"""

        Returns
        -------
        float
        	the timeout(in seconds)

        """
        return _base.ApproximationScheme_maxTime(self)

    def currentTime(self) -> float:
        r"""

        Returns
        -------
        float
        	get the current running time in second (float)

        """
        return _base.ApproximationScheme_currentTime(self)

    def disableMaxTime(self) -> None:
        r"""

        Disable max time as a stopping criterion.

        """
        return _base.ApproximationScheme_disableMaxTime(self)

    def enableMaxTime(self) -> None:
        r"""

        Enable max time as a stopping criterion.

        """
        return _base.ApproximationScheme_enableMaxTime(self)

    def isEnabledMaxTime(self) -> bool:
        r"""

        Returns
        -------
        bool
          True if max time is used as a stopping criterion

        """
        return _base.ApproximationScheme_isEnabledMaxTime(self)

    def setPeriodSize(self, p: int) -> None:
        r"""

        Parameters
        ----------
        p : int
        	number of samples between 2 stopping

        Raises
        ------
        pyagrum.OutOfBounds
        	If p<1

        """
        return _base.ApproximationScheme_setPeriodSize(self, p)

    def periodSize(self) -> int:
        r"""

        Returns
        -------
        int
        	the number of samples between 2 stopping

        Raises
        ------
        pyagrum.OutOfBounds
        	If p<1

        """
        return _base.ApproximationScheme_periodSize(self)

    def setVerbosity(self, v: bool) -> None:
        r"""

        Parameters
        ----------
        v : bool
                verbosity

        """
        return _base.ApproximationScheme_setVerbosity(self, v)

    def verbosity(self) -> bool:
        r"""

        Returns
        -------
        bool
        	True if the verbosity is enabled

        """
        return _base.ApproximationScheme_verbosity(self)

    def stateApproximationScheme(self) -> int:
        r"""

        Returns
        -------
        int
          the state of the approximation scheme

        """
        return _base.ApproximationScheme_stateApproximationScheme(self)

    def nbrIterations(self) -> int:
        r"""

        Returns
        -------
        int
        	the number of iterations

        """
        return _base.ApproximationScheme_nbrIterations(self)

    def history(self) -> List[float]:
        r"""

        Returns
        -------
        tuple
        	the scheme history

        Raises
        ------
        pyagrum.OperationNotAllowed
        	If the scheme did not performed or if verbosity is set to false

        """
        return _base.ApproximationScheme_history(self)

    def initApproximationScheme(self) -> None:
        r"""

        Initiate the approximation scheme.

        """
        return _base.ApproximationScheme_initApproximationScheme(self)

    def startOfPeriod(self) -> bool:
        r"""

        Returns
        -------
        bool
          True if it is a start of a period

        """
        return _base.ApproximationScheme_startOfPeriod(self)

    def updateApproximationScheme(self, incr: int=1) -> None:
        r"""

        Update the approximation scheme.

        """
        return _base.ApproximationScheme_updateApproximationScheme(self, incr)

    def remainingBurnIn(self) -> int:
        r"""

        Returns
        -------
        int
          the number of remaining burn in

        """
        return _base.ApproximationScheme_remainingBurnIn(self)

    def stopApproximationScheme(self) -> None:
        r"""

        Stop the approximation scheme.

        """
        return _base.ApproximationScheme_stopApproximationScheme(self)

    def continueApproximationScheme(self, error: float) -> bool:
        r"""

        Continue the approximation scheme.

        Parameters
        ----------
        error : float

        """
        return _base.ApproximationScheme_continueApproximationScheme(self, error)

# Register ApproximationScheme in _base:
_base.ApproximationScheme_swigregister(ApproximationScheme)

def fastVariable(*args) -> "pyagrum.DiscreteVariable":
    r"""

    Use *fast* syntax to add a variable in the BayesNet.

    Raises
    ------
    pyagrum.NotAllowed

    Parameters
    ----------
    fast_description: str
      string following *fast* syntax description
    default_nbrmod: int
      nbr of modality if fast_description does not indicate it.
      `default_nbrmod=1` is the way to create a variable with only one value (for instance for reward in influence diagram).

    Examples
    --------
    >>> print(pyagrum.fastVariable('A{On|Off|Defun}'))
    A:Labelized({On|Off|Defun})
    >>> print(pyagrum.fastVariable('A{3.14|0|1.15}'))
    A:NumericalDiscrete({0|1.15|3.14})
    >>> print(pyagrum.fastVariable('A{1.2:5.2:5}}'))
    A:NumericalDiscrete({1.2|2.2|3.2|4.2|5.2})
    >>> print(pyagrum.fastVariable('A{1|3|9}'))
    A:Integer({1|3|9})
    >>> print(pyagrum.fastVariable('A[4,6]'))
    A:Range([4,6])
    >>> print(pyagrum.fastVariable('A[5]'))
    A:Range([0,4])
    >>> print(pyagrum.fastVariable('A[4,6,10]'))
    A:Discretized(<[4;6[,[6;10]>)
    >>> print(pyagrum.fastVariable('A[1:6:5]'))
    A:Discretized(<[1;2[,[2;3[,[3;4[,[4;5[,[5;6]>)



    """
    return _base.fastVariable(*args)

def randomDistribution(n: int) -> List[float]:
    r"""

    Parameters
    ----------
    n : int
      The number of modalities for the ditribution.

    Returns
    -------
    a random discrete distribution.

    """
    return _base.randomDistribution(n)
class DiscretizedVariable(IDiscretizedVariable):
    r"""

    DiscretizedVariable is a discrete random variable with a set of `ticks` defining intervals.

    DiscretizedVariable(aName, aDesc ,ticks=None,is_empirical=False) -> pyagrum.DiscretizedVariable Parameters:

            - **aName** (*str*) -- the name of the variable
            - **aDesc** (*str*) -- the description of the variable
            - **ticks** (*list[float]*) -- the list of ticks to add
            - **is_empirical** (*bool) -- if False, raise an error if a value is out of bound.


    DiscretizedVariable(aDDRV) -> DiscretizedVariable
        Parameters:

            - **aDDRV** (*pyagrum.DiscretizedVariable*) -- the pyagrum.DiscretizedVariable that will be copied

    Examples
    --------
    >>> import pyagrum as gum
    >>> vX=pyagrum.DiscretizedVariable('X','X has been discretized').addTick(1).addTick(2).addTick(3).addTick(3.1415)
    >>> print(vX)
    X:Discretized(<[1;2[,[2;3[,[3;3.1415]>)
    >>> vX.isTick(4)
    False
    >>> vX.labels()
    ('[1;2[', '[2;3[', '[3;3.1415]')
    >>> # where is the real value 2.5 ?
    >>> vX.index('2.5')
    1

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        _base.DiscretizedVariable_swiginit(self, _base.new_DiscretizedVariable(*args))
    __swig_destroy__ = _base.delete_DiscretizedVariable

    def clone(self) -> "pyagrum.DiscretizedVariable":
        r"""

        Returns
        -------
        pyagrum.DiscretizedVariable
        	a copy of the DiscretizedVariable

        """
        return _base.DiscretizedVariable_clone(self)

    def varType(self) -> int:
        r"""

        returns the type of variable

        Returns
        -------
        int :
        	the type of the variable.

        	0: DiscretizedVariable, 1: LabelizedVariable, 2: IntegerVariable, 3: RangeVariable, 4:

        """
        return _base.DiscretizedVariable_varType(self)

    def isTick(self, aTick: float) -> bool:
        r"""

        Parameters
        ----------
        aTick : float
        	the Tick to be tested

        Returns
        -------
        bool :
        	True if the Tick already exists

        """
        return _base.DiscretizedVariable_isTick(self, aTick)

    def addTick(self,*args):
        """
        Parameters
        ----------
        aTick : float
            the Tick to be added

        Returns
        -------
        pyagrum.DiscretizedVariable
            the discretized variable

        Raises
        ------
          pyagrum.DefaultInLabel
            If the tick is already defined
        """
        _base.DiscretizedVariable_addTick(self,*args)
        return self



    def eraseTicks(self) -> None:
        r"""

        erase all the Ticks

        """
        return _base.DiscretizedVariable_eraseTicks(self)

    def label(self, i: int) -> str:
        r"""

        Parameters
        ----------
        i : int
        	the index of the label we wish to return

        Returns
        -------
        str
        	the indice-th label

        Raises
        ------
        pyagrum.OutOfBounds
        	If the variable does not contain the label

        """
        return _base.DiscretizedVariable_label(self, i)

    def numerical(self, indice: int) -> float:
        r"""

        Parameters
        ----------
        indice : int
        	an index

        Returns
        -------
        float
        	the numerical representation of the indice-th value

        """
        return _base.DiscretizedVariable_numerical(self, indice)

    def draw(self, indice: int) -> float:
        r"""

        Allow to draw a value in the i-th interval of the discretized variable.1

        Parameters
        ----------
        i : int
        	the index of the interval to draw

        Returns
        -------
        float :
        	the value randomly drawn in the i-th interval

        """
        return _base.DiscretizedVariable_draw(self, indice)

    def index(self, *args) -> int:
        r"""

        Parameters
        ----------
        label : str
        	a label

        Returns
        -------
        int
        	the indice of the label

        """
        return _base.DiscretizedVariable_index(self, *args)

    def domainSize(self) -> int:
        r"""

        Returns
        -------
        int
        	the number of modalities in the variable domain

        """
        return _base.DiscretizedVariable_domainSize(self)

    def domain(self) -> str:
        r"""

        Returns
        -------
        str
            the domain of the variable as a string

        """
        return _base.DiscretizedVariable_domain(self)

    def stype(self) -> str:
        r"""

        Returns
        -------
        str
        	a description of its type

        """
        return _base.DiscretizedVariable_stype(self)

    def tick(self, i: int) -> float:
        r"""

        Indicate the index of the Tick

        Parameters
        ----------
        i : int
        	the index of the Tick

        Returns
        -------
        aTick : float
        	the i-th Tick

        Raises
        ------
        pyagrum.NotFound
        	If the index is greater than the number of Ticks

        """
        return _base.DiscretizedVariable_tick(self, i)

    def ticks(self) -> List[float]:
        r"""

        Returns
        -------
        tuple :
        	a tuple containing all the Ticks

        """
        return _base.DiscretizedVariable_ticks(self)

    def closestIndex(self, val: float) -> int:
        return _base.DiscretizedVariable_closestIndex(self, val)

    def toFast(self) -> str:
        return _base.DiscretizedVariable_toFast(self)

    def __repr__(self) -> str:
        return _base.DiscretizedVariable___repr__(self)

    def __str__(self) -> str:
        return _base.DiscretizedVariable___str__(self)

# Register DiscretizedVariable in _base:
_base.DiscretizedVariable_swigregister(DiscretizedVariable)
class MultiDimContainer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _base.delete_MultiDimContainer

    def set(self, i: "pyagrum.Instantiation", value: float) -> None:
        return _base.MultiDimContainer_set(self, i, value)

    def get(self, i: "pyagrum.Instantiation") -> float:
        return _base.MultiDimContainer_get(self, i)

    def fill(self, d: float) -> None:
        return _base.MultiDimContainer_fill(self, d)

    def populate(self, v: "pyagrum.Vector") -> None:
        return _base.MultiDimContainer_populate(self, v)

    def copyFrom(self, *args) -> None:
        return _base.MultiDimContainer_copyFrom(self, *args)

    def extractFrom(self, src: "pyagrum.Tensor", mask: "pyagrum.Instantiation") -> None:
        return _base.MultiDimContainer_extractFrom(self, src, mask)

    def content(self, *args) -> "pyagrum.Tensor":
        return _base.MultiDimContainer_content(self, *args)

    def getMasterRef(self, *args) -> "pyagrum.Tensor":
        return _base.MultiDimContainer_getMasterRef(self, *args)

    def copy(self, src: "pyagrum.Tensor") -> None:
        return _base.MultiDimContainer_copy(self, src)

    def newFactory(self) -> "pyagrum.Tensor":
        return _base.MultiDimContainer_newFactory(self)

    def toString(self, *args) -> str:
        return _base.MultiDimContainer_toString(self, *args)

    def __eq__(self, p: "pyagrum.Tensor") -> bool:
        return _base.MultiDimContainer___eq__(self, p)

    def __ne__(self, p: "pyagrum.Tensor") -> bool:
        return _base.MultiDimContainer___ne__(self, p)

    def apply(self, f: "std::function< float (float) >") -> None:
        return _base.MultiDimContainer_apply(self, f)

    def reduce(self, f: "std::function< float (float,float) >", base: float) -> float:
        return _base.MultiDimContainer_reduce(self, f, base)

    def beginMultipleChanges(self) -> None:
        return _base.MultiDimContainer_beginMultipleChanges(self)

    def endMultipleChanges(self, *args) -> None:
        return _base.MultiDimContainer_endMultipleChanges(self, *args)

# Register MultiDimContainer in _base:
_base.MultiDimContainer_swigregister(MultiDimContainer)
class Tensor(object):
    r"""

    Class representing a tensor.

    Tensor() -> Tensor
        default constructor

    Tensor(src) -> Tensor
        Parameters:
            - **src** (*pyagrum.Tensor*) -- the Tensor to copy

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        _base.Tensor_swiginit(self, _base.new_Tensor(*args))

        self._list_vars=list()



    __swig_destroy__ = _base.delete_Tensor

    def newFactory(self) -> "pyagrum.Tensor":
        r"""

        Erase the Tensor content and create a new empty one.

        Returns
        -------
        pyagrum.Tensor
         a reference to the new Tensor

        """
        return _base.Tensor_newFactory(self)

    def random(self) -> "pyagrum.Tensor":
        return _base.Tensor_random(self)

    def randomDistribution(self) -> "pyagrum.Tensor":
        return _base.Tensor_randomDistribution(self)

    def randomCPT(self) -> "pyagrum.Tensor":
        return _base.Tensor_randomCPT(self)

    def noising(self, alpha: float) -> "pyagrum.Tensor":
        return _base.Tensor_noising(self, alpha)

    def isNonZeroMap(self) -> "pyagrum.Tensor":
        r"""

        Returns
        -------
        pyagrum.Tensor
          a boolean-like tensor using the predicate `isNonZero`.

        """
        return _base.Tensor_isNonZeroMap(self)

    def sum(self) -> float:
        r"""

        Returns
        -------
        float :
          the sum of all elements in the Tensor

        """
        return _base.Tensor_sum(self)

    def product(self) -> float:
        r"""

        Returns
        -------
        float
          the product of all elements in the Tensor

        """
        return _base.Tensor_product(self)

    def max(self) -> float:
        r"""

        Returns
        -------
        float
          the maximum of all elements in the Tensor

        """
        return _base.Tensor_max(self)

    def min(self) -> float:
        r"""

        Returns
        -------
        float
          the min of all elements in the Tensor

        """
        return _base.Tensor_min(self)

    def maxNonOne(self) -> float:
        r"""

        Returns
        -------
        float
          the maximum of non one elements in the Tensor

        Raises
        ------
        pyagrum.NotFound
          If all value == 1.0

        """
        return _base.Tensor_maxNonOne(self)

    def minNonZero(self) -> float:
        r"""

        Returns
        -------
        float
          the min of non zero elements in the Tensor

        Raises
        ------
        pyagrum.NotFound
          If all value == 0.0

        """
        return _base.Tensor_minNonZero(self)

    def findAll(self, v: float) -> List[Dict[str,int]]:
        return _base.Tensor_findAll(self, v)

    def entropy(self) -> float:
        r"""

        Returns
        -------
        float
          the entropy of the tensor

        """
        return _base.Tensor_entropy(self)

    def reorganize(self, *args) -> "pyagrum.Tensor":
        r"""

        Create a new Tensor with another order.

        Returns
        -------
        varnames : list
          a list of the var names in the new order

        Returns
        -------
        pyagrum.Tensor
          a reference to the modified tensor

        """
        return _base.Tensor_reorganize(self, *args)

    def putFirst(self, varname: str) -> "pyagrum.Tensor":
        r"""

        Parameters
        ----------
        v : pyagrum.DiscreteVariable
            The variable for which the index should be 0.

        Returns
        -------
        pyagrum.Tensor
          a reference to the modified tensor

        Raises
        ------
        pyagrum.InvalidArgument
          If the var is not in the tensor

        """
        return _base.Tensor_putFirst(self, varname)

    def fillWith(self, *args) -> "pyagrum.Tensor":
        r"""

        Automatically fills the tensor with v.

        Parameters
        ----------
        v : number or list of values or pyagrum.Tensor
            a value or a list/pyagrum.Tensor containing the values to fill the Tensor with.

        mapping : list|tuple|dict

        Warning
        -------
            - if `v` is a list, the size of the list must be the size of the tensor

            - if `v` is a ref:pyagrum.Tensor, it must contain variables with exactly the same names and labels but not necessarily the same variables. If

            - If the second argument `mapping` is given, `mapping` explains how to map the variables of the tensor source to the variables of the tensor destination.

            - If `mapping` is a sequence, the order follows the same order as `destination.names`. If `mapping` is a dict, the keys are the names in the destination and the values are the names in the source.

        Returns
        -------
        pyagrum.Tensor
              a reference to the modified potentia

        Raises
        ------
        pyagrum.SizeError
          If v size's does not matches the domain size.
        pyagrum.ArgumentError
          If anything wrong with the arguments.

        """

        if len(args)>1:
          d=args[1]
          if type(d)==dict:
            if set(d.keys())==set(self.names):
              return self.fillWith(args[0],[d[s] for s in self.names])
            else:
              raise pyagrum.ArgumentError(f"[pyAgrum] keys in dict {tuple(d.keys())} does not match the Tensor's variables {self.names}")


        val = _base.Tensor_fillWith(self, *args)

        return self


        return val


    def abs(self) -> "pyagrum.Tensor":
        r"""

        Apply abs on every element of the container

        Returns
        -------
        pyagrum.Tensor
            a reference to the modified tensor.

        """
        val = _base.Tensor_abs(self)

        return self


        return val


    def sq(self) -> "pyagrum.Tensor":
        r"""

        Square all the values in the Tensor

        """
        val = _base.Tensor_sq(self)

        return self


        return val


    def log2(self) -> "pyagrum.Tensor":
        r"""

        log2 all the values in the Tensor

        Warning
        -------
        When the Tensor contains 0 or negative values, no exception are raised but `-inf` or `nan` values are assigned.

        """
        val = _base.Tensor_log2(self)

        return self


        return val


    def sgn(self) -> "pyagrum.Tensor":
        val = _base.Tensor_sgn(self)

        return self


        return val


    def new_abs(self) -> "pyagrum.Tensor":
        return _base.Tensor_new_abs(self)

    def new_sq(self) -> "pyagrum.Tensor":
        return _base.Tensor_new_sq(self)

    def new_log2(self) -> "pyagrum.Tensor":
        return _base.Tensor_new_log2(self)

    def new_sgn(self) -> "pyagrum.Tensor":
        return _base.Tensor_new_sgn(self)

    def normalize(self) -> "pyagrum.Tensor":
        r"""

        Normalize the Tensor (do nothing if sum is 0)

        Returns
        -------
        pyagrum.Tensor
          a reference to the normalized Tensor

        """
        val = _base.Tensor_normalize(self)

        return self


        return val


    def KL(self, p: "Tensor") -> float:
        r"""

        Check the compatibility and compute the Kullback-Leibler divergence between the tensor and.

        Parameters
        ----------
        p : pyagrum.Tensor
          the tensor from which we want to calculate the divergence.

        Returns
        -------
        float
          The value of the divergence

        Raises
        ------
          pyagrum.InvalidArgument
            If p is not compatible with the tensor (dimension, variables)
          pyagrum.FatalError
            If a zero is found in p or the tensor and not in the other.

        """
        return _base.Tensor_KL(self, p)

    def normalizeAsCPT(self, varId: int=0) -> "pyagrum.Tensor":
        r"""

        Normalize the Tensor as a CPT

        Returns
        -------
        pyagrum.Tensor
          a reference to the normalized Tensor

        Raises
        ------
        pyagrum.FatalError
          If some distribution sums to 0

        """
        val = _base.Tensor_normalizeAsCPT(self, varId)

        return self


        return val


    def scale(self, v: float) -> "pyagrum.Tensor":
        r"""

        Create a new tensor multiplied by v.

        Parameters
        ----------
        v : float
          a multiplier

        Returns
        -------
          a reference to the modified tensor

        """
        val = _base.Tensor_scale(self, v)

        return self


        return val


    def translate(self, v: float) -> "pyagrum.Tensor":
        r"""

        Create a new tensor added with v.

        Parameters
        ----------
        v : float
          The value to be added

        Returns
        -------
          a reference to the modified tensor

        """
        val = _base.Tensor_translate(self, v)

        return self


        return val


    def inverse(self) -> "pyagrum.Tensor":
        val = _base.Tensor_inverse(self)

        return self


        return val


    def draw(self) -> int:
        r"""

        draw a value using the tensor as a probability table.

        Returns
        -------
        int
          the index of the drawn value

        """
        return _base.Tensor_draw(self)

    def memoryFootprint(self) -> int:
        r"""

        get the size (in byte) of the Tensor representation in memory

        Returns
        -------
        int
          the size in byte of the representation of the Tensor in memory.

        """
        return _base.Tensor_memoryFootprint(self)

    def __add__(self, *args) -> "pyagrum.Tensor":
        return _base.Tensor___add__(self, *args)

    def __sub__(self, *args) -> "pyagrum.Tensor":
        return _base.Tensor___sub__(self, *args)

    def __mul__(self, *args) -> "pyagrum.Tensor":
        return _base.Tensor___mul__(self, *args)

    def __truediv__(self, *args):
        return _base.Tensor___truediv__(self, *args)
    __div__ = __truediv__



    def __iadd__(self, *args) -> "pyagrum.Tensor":
        return _base.Tensor___iadd__(self, *args)

    def __imul__(self, *args) -> "pyagrum.Tensor":
        return _base.Tensor___imul__(self, *args)

    def __isub__(self, *args) -> "pyagrum.Tensor":
        return _base.Tensor___isub__(self, *args)

    def __itruediv__(self, *args):
        return _base.Tensor___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def isEvidence(self) -> bool:
        return _base.Tensor_isEvidence(self)

    def __or__(self, p2: "Tensor") -> "pyagrum.Tensor":
        return _base.Tensor___or__(self, p2)

    def __and__(self, p2: "Tensor") -> "pyagrum.Tensor":
        return _base.Tensor___and__(self, p2)

    def __invert__(self) -> "pyagrum.Tensor":
        return _base.Tensor___invert__(self)

    @staticmethod
    def evEq(v: "pyagrum.DiscreteVariable", val: float) -> "pyagrum.Tensor":
        return _base.Tensor_evEq(v, val)

    @staticmethod
    def evIn(v: "pyagrum.DiscreteVariable", val1: float, val2: float) -> "pyagrum.Tensor":
        return _base.Tensor_evIn(v, val1, val2)

    @staticmethod
    def evGt(v: "pyagrum.DiscreteVariable", val: float) -> "pyagrum.Tensor":
        return _base.Tensor_evGt(v, val)

    @staticmethod
    def evLt(v: "pyagrum.DiscreteVariable", val: float) -> "pyagrum.Tensor":
        return _base.Tensor_evLt(v, val)

    def __repr__(self) -> str:
        return _base.Tensor___repr__(self)

    def __str__(self) -> str:
        return _base.Tensor___str__(self)

    def expectedValue(self, *args) -> object:
        r"""

        Calculate the mathematical expected value of a (joint) random variable using the given function as an argument.

        Parameters
        ----------
        func : function(Dict[str,int])->float
            A function that takes a single argument, representing the value of a python representation of a `pyagrum.Instantiation` (as a dictionary), and returns a float.

        Warnings
        --------
        The `pyagrum.Tensor` is assumed to contain a joint distribution.

        Examples
        --------
        >>> def log2cptA(x):
        ...   return -math.log2(bn.cpt('A')[x])
        >>> entropy_of_A=bn.cpt('A').expectedValue(log2cptA) # OK it A has no parents.

        Returns
        -------
        float
            The mathematical expected value of the random variable calculated using the given function as an argument.

        """
        return _base.Tensor_expectedValue(self, *args)

    def extract(self, *args) -> "pyagrum.Tensor":
        r"""

        create a new Tensor extracted from self given a partial instantiation.

        Parameters
        ----------
        inst : pyagrum.instantiation
          a partial instantiation
        dict : Dict[str,str|int]
          a dictionnary containing values for some discrete variables.

        Warning
        --------
            if the dictionnary contains a key that is not the name of a variable in the `pyagrum.Tensor`,
            this key is just not used without notification. Then `pyagrum.Tensor.extract` concerns
            only the variables that  both are in the Tensor and in the dictionnary.

        Returns
        -------
        pyagrum.Tensor
          the new Tensor

        """
        return _base.Tensor_extract(self, *args)

    def sumOut(self, *args) -> "pyagrum.Tensor":
        r"""

        Projection using sum as operation.

        Parameters
        ----------
        varnames : set
          the set of vars to eliminate

        Returns
        -------
        pyagrum.Tensor
          the projected Tensor

        Raises
        ------
        pyagrum.InvalidArgument
          If varnames contains only one variable that does not exist in the Tensor

        """
        return _base.Tensor_sumOut(self, *args)

    def prodOut(self, *args) -> "pyagrum.Tensor":
        r"""

        Projection using multiplication as operation.

        Parameters
        ----------
        varnames : set
          the set of vars to eliminate

        Returns
        -------
        pyagrum.Tensor
          the projected Tensor

        Raises
        ------
        pyagrum.InvalidArgument
          If varnames contains only one variable that does not exist in the Tensor

        """
        return _base.Tensor_prodOut(self, *args)

    def maxOut(self, *args) -> "pyagrum.Tensor":
        r"""

        Projection using `max` as operation.

        Parameters
        ----------
        varnames : set
          the set of vars to eliminate

        Returns
        -------
        pyagrum.Tensor
          the projected Tensor

        Raises
        ------
        pyagrum.InvalidArgument
          If varnames contains only one variable that does not exist in the Tensor

        """
        return _base.Tensor_maxOut(self, *args)

    def minOut(self, *args) -> "pyagrum.Tensor":
        r"""

        Projection using `min` as operation.

        Parameters
        ----------
        varnames : set
          the set of vars to eliminate

        Returns
        -------
        pyagrum.Tensor
          the projected Tensor

        Warnings
        --------
        InvalidArgument raised if varnames contains only one variable that does not exist in the Tensor

        """
        return _base.Tensor_minOut(self, *args)

    def sumIn(self, *args) -> "pyagrum.Tensor":
        r"""

        Projection using sum as operation.

        Parameters
        ----------
        varnames : set
          the set of vars to keep

        Returns
        -------
        pyagrum.Tensor
          the projected Tensor

        """
        return _base.Tensor_sumIn(self, *args)

    def prodIn(self, *args) -> "pyagrum.Tensor":
        r"""

        Projection using multiplication as operation.

        Parameters
        ----------
        varnames : set
          the set of vars to keep

        Returns
        -------
        pyagrum.Tensor
          the projected Tensor

        """
        return _base.Tensor_prodIn(self, *args)

    def maxIn(self, *args) -> "pyagrum.Tensor":
        r"""

        Projection using `max` as operation.

        Parameters
        ----------
        varnames : set
          the set of vars to keep

        Returns
        -------
        pyagrum.Tensor
          the projected Tensor

        """
        return _base.Tensor_maxIn(self, *args)

    def minIn(self, *args) -> "pyagrum.Tensor":
        r"""

        Projection using `min` as operation.

        Parameters
        ----------
        varnames : set
          the set of vars to keep

        Returns
        -------
        pyagrum.Tensor
          the projected Tensor

        """
        return _base.Tensor_minIn(self, *args)

    def argmin(self) -> object:
        r"""

        Returns
        -------
        Tuple[Dict[str,int],float]
          the list of positions of the min and the min of all elements in the Tensor

        """
        return _base.Tensor_argmin(self)

    def argmax(self) -> object:
        r"""

        Returns
        -------
        Tuple[Dict[str,int],float]
          the list of positions of the max and the max of all elements in the Tensor

        """
        return _base.Tensor_argmax(self)

    def __eq__(self, *args) -> bool:
        return _base.Tensor___eq__(self, *args)

    def __ne__(self, b: "Tensor") -> bool:
        return _base.Tensor___ne__(self, b)

    def __radd__(self,other):
      return self.__add__(other)

    def __rmul__(self,other):
      return self.__mul__(other)

    def __rsub__(self,other):
      return (self*-1)+other

    def __rfloordiv__(self,other):
      return Tensor(self).inverse().scale(other)

    def __rtruediv__(self,other):
      return Tensor(self).inverse().scale(other)

    def __rdiv__(self,other):
      return Tensor(self).inverse().scale(other)

    def __neg__(self):
      return -1*self

    def __abs__(self):
      return Tensor(self).abs()

    def loopIn(self):
      """
      Generator to iterate inside a Tensor.

      Yield an pyagrum.Instantiation that iterates over all the possible values for the pyagrum.Tensor

      Examples
      --------
      >>> import pyagrum as gum
      >>> bn=pyagrum.fastBN("A[3]->B[3]<-C[3]")
      >>> for i in bn.cpt("B").loopIn():
            print(i)
            print(bn.cpt("B").get(i))
            bn.cpt("B").set(i,0.3)
      """
      i=Instantiation(self)
      i.setFirst()
      while not i.end():
        yield i
        i.inc()
      return

    def fillFromExpression(self,s_fn):
      """
      Automatically fills the tensor with the evaluation of the expression s_fn (no matter if is a CPT or not).

      The symbolic expression s_fn gives a value for each parameters of the Tensor

      Examples
      --------
      >>> import pyagrum as gum
      >>> bn=pyagrum.fastBN('A[3]->B[3]<-C[3]')
      >>> bn.cpt('B').fillFromFunction('(B+A+C)/2')

      Parameters
      ----------
      s_fn : str
          a symbolic expression using the name of the variables of the Tensor and giving a value to the first variable of the Tensor. This evaluation is done in a context that inclides 'math' module.

      Warning
      -------
          The expression may have any numerical values, but will be then transformed to the closest correct value for the range of the variable.


      Returns
      -------
      pyagrum.Tensor
            a reference to the modified tensor
      """
      import math
      forbidden=frozenset(['__import__','__class__'])

      I=pyagrum.Instantiation(self)
      code=float(s_fn) if isinstance(s_fn, (int, float)) else compile(s_fn,"<string>","eval")
      if not isinstance(s_fn, (int, float)):
        if forbidden & set(code.co_names):
          raise InvalidArgument("[pyAgrum] '__import__' is not allowed in the expression '"+s_fn+"'")

      I.setFirst()
      while not I.end():
        vars={self.variable(i).name():self.variable(i).numerical(I.val(i)) for i in range(self.nbrDim())}
        res=s_fn if isinstance(s_fn, (int, float)) else eval(code,{'math':math},vars)
        self.set(I,res)
        I.inc()

      return self

    def fillFromFunction(self,s_fn):
      """
      Automatically fills the tensor as a deterministic CPT with the evaluation of the expression s_fn.

      The symbolic expression s_fn gives a value for the first variable, depending on the following variables.
      The computed CPT is deterministic.

      Examples
      --------
      >>> import pyagrum as gum
      >>> bn=pyagrum.fastBN('A[3]->B[3]<-C[3]')
      >>> bn.cpt('B').fillFromFunction('(A+C)/2')

      Parameters
      ----------
      s_fn : str
          a symbolic expression using the name of the second and following variables of the Tensor and giving a value to the first variable of the Tensor. This evaluation is done in a context that inclides 'math' module.

      Warning
      -------
          The expression may have any numerical values, but will be then transformed to the closest correct value for the range of the variable.


      Returns
      -------
      pyagrum.Tensor
            a reference to the modified tensor

      Raises
      ------
        pyagrum.InvalidArgument
          If the first variable is Labelized.
      """
      import math
      forbidden=frozenset(['__import__','__class__'])

      if self.variable(0).varType() == pyagrum.VarType_LABELIZED:
        raise InvalidArgument("[pyAgrum] The variable "+self.variable(0).name()+" is a LabelizedVariable")

      self.fillWith(0)
      I = Instantiation(self)
      code=float(s_fn) if isinstance(s_fn, (int, float)) else compile(s_fn,"<string>","eval")
      if not isinstance(s_fn, (int, float)):
        if forbidden & set(code.co_names):
          raise InvalidArgument("[pyAgrum] '__import__' is not allowed in the expression '"+s_fn+"'")

      I.setFirst()
      while not I.end():
        vars={self.variable(i).name():self.variable(i).numerical(I.val(i)) for i in range(1,self.nbrDim())}
        res=s_fn if isinstance(s_fn, (int, float)) else eval(code,{'math':math},vars)
        pos=self.variable(0).closestIndex(res)
        I.chgVal(0,pos)
        self.set(I,1)
        I.incNotVar(self.variable(0))

      self.normalizeAsCPT()
      return self


    def fillFromDistribution(self,distribution,**s_fns):
      """
      Automatically fills the tensor as a familly of distributions whose parameters are found using evaluation of the expressions s_fns.

      The symbolic expressions s_fns gives a value for the named parameters of the distributions.

      Examples
      --------
      >>> import scipy.stats as stats
      >>> import pyagrum as gum
      >>> bn=pyagrum.fastBN('A[10]->B[10]<-C[10]')
      >>> bn.cpt("B").fillFromDistribution(stats.norm,loc="(A+C)/2",scale=1)

      Parameters
      ----------
      s_fns : a list of named arguments (str)
          the named arguments with an evaluation of the expressions in s_fns are passed as argument for the chosen distribution.

      Returns
      -------
      pyagrum.Tensor
            a reference to the modified tensor

      Raises
      ------
        pyagrum.InvalidArgument
          If the first variable is Labelized.
      """
      import math

      forbidden=frozenset(['__import__','__class__'])

      var=self.variable(0)
      var_ds=var.domainSize()
      if var.varType() == pyagrum.VarType_LABELIZED:
        raise InvalidArgument("[pyAgrum] The variable "+self.variable(0).name()+" is a LabelizedVariable")

      codes={k:float(s_fns[k]) if isinstance(s_fns[k], (int, float)) else compile(s_fns[k],"<string>","eval") for k in s_fns.keys()}
      for _,code in codes.items():
        if not isinstance(code, (int, float)):
          if forbidden & set(code.co_names):
            raise InvalidArgument("[pyAgrum] '__import__' is not allowed in the expression '"+code+"'")

      if hasattr(distribution,'pdf'):
        d=distribution.pdf
      elif hasattr(distribution,'pmf'):
        d=distribution.pmf
      else:
        raise InvalidArgument("[pyAgrum] The distribution must have a pdf or a pmf method")

      Xs=[var.numerical(i) for i in range(var_ds)]

      I=pyagrum.Instantiation()
      for i in range(1,self.nbrDim()):
        I.add(self.variable(i))

      args={}
      fnkeys=set(s_fns.keys())
      for k in s_fns.keys():
          if isinstance(s_fns[k], (int, float)):
              args[k]=float(s_fns[k])
              fnkeys.remove(k)

      l=[]
      for pos,J in enumerate(I.loopIn()):
          vars={J.variable(i).name():J.variable(i).numerical(J.val(i)) for i in range(J.nbrDim())}
          for k in fnkeys:
              args[k]=eval(codes[k],{'math':math},vars)
          l+=list(d(Xs,**args))
      self.fillWith(l)
      self.normalizeAsCPT()
      return self

    def toVarsIn(self,p):
      """
      Create a copy of the Tensor with the same variables as in p.

      Warning
      -------
      p is a pyAgrum's object that can refer to variables through a method `p.variable(name:str)`. For instance, a Potential, an Instantiation or a Graphical Model (Bayesian Network,...).

      Examples
      --------
        >>> import pyagrum as gum
        >>> bn1=pyagrum.fastBN('A[3]->B[3]<-C[3]')
        >>> bn2=pyagrum.fastBN('A[3]<-B[3]<-C[3]')
        >>> # bn1.cpt('A')+bn2.cpt('A') # does not work since the vars 'A' in bn1 and bn2 are not the same.
        >>> bn1.cpt('A').toVars(bn2)+bn2.cpt('A') # OK

      Returns
      -------
        pyagrum.Tensor
            a copy of the Potential with the same variables as p.
      """
      res=pyagrum.Tensor()
      for i in self.names:
        res.add(p.variable(i))
      res.fillWith(self)
      return res

    def variablesSequence(self):
        """
        Returns
        -------
        list
            a list containing the sequence of variables
        """
        varlist = []
        for i in range(0, self.nbrDim()):
            varlist.append(self.variable(i))
        return varlist

    def __prepareIndices__(self,ind):
      """
      From an indice (dict or tuple), returns a pair of pyagrum.Instantiation to loop in a part of the Tensor.
      """
      from numbers import Number

      loopvars=Instantiation(self)
      loopvars.setMutable()

      inst=Instantiation(self)
      inst.setFirst()

      if isinstance(ind, (Number,slice)):
        i = tuple([ind])
      else:
        i = ind

      if isinstance(i,dict):
          for nam in self.names:
              if nam in i:
                  inst.chgVal(nam,i[nam])
                  loopvars.erase(nam)
      elif isinstance(i,tuple):
          vn=[n for n in reversed(self.names)]
          if len(i)>self.nbrDim():
              raise KeyError("Too many values in '"+str(i)+"' for '"+str(self)+"'")
          for k,v in enumerate(i):
              if not isinstance(v,slice):
                  nam=vn[k]
                  inst.chgVal(nam,v)
                  loopvars.erase(nam)
      else:
          raise ValueError("No subscript using '"+str(i)+"'")
      return inst,loopvars

    def __getitem__(self, id):
      import numpy
      if isinstance(id,Instantiation):
          return self.get(id)

      inst,loopvars=self.__prepareIndices__(id)

      if loopvars.nbrDim()==0:
          return self.get(inst)

      if loopvars.nbrDim()==self.nbrDim():
        content=[]

        inst=Instantiation(self)
        while not inst.end():
            content.append(self.get(inst))
            inst.inc()
        tab=numpy.array(content,dtype=numpy.float64)
        tab.shape=tuple(reversed(self.shape))
        return tab

      names=[loopvars.variable(i-1).name() for i in range(loopvars.nbrDim(),0,-1)]
      tab=numpy.zeros(tuple([loopvars.variable(i-1).domainSize() for i in range(loopvars.nbrDim(),0,-1)]))
      while not inst.end():
          indice=[inst.val(name) for name in names]
          tab[tuple(indice)]=self.get(inst)
          inst.incIn(loopvars)
      return tab

    def __setitem__(self, id, value):
      from numbers import Number
      import numpy
      if isinstance(id,Instantiation):
          self.set(id,value)
          return

      inst,loopvars=self.__prepareIndices__(id)

      if loopvars.nbrDim()==0:
          self.set(inst,value)
          return

      if isinstance(value,Number):
        while not inst.end():
            self.set(inst,value)
            inst.incIn(loopvars)
      else:
        if isinstance(value,list):
            value=numpy.array(value)
        elif isinstance(value,dict):
            if loopvars.nbrDim()>1:
                raise ArgumentError("The value can be a dict only when specifying 1D-marginal.")
            var=loopvars.variable(0)
            for label in var.labels():
                if label not in value:
                  raise ArgumentError(f"The label '{label}' can not be found in the value.")
            for label in value.keys():
                if not var.isLabel(label):
                  raise ArgumentError(f"The label '{label}' can not be found in variable {var}.")
            value=numpy.array([value[item] for item in var.labels()])
        else:
            if not isinstance(value,numpy.ndarray):
                raise ArgumentError(f"{value} is not a correct value for a tensor.")

        shape=tuple([loopvars.variable(i-1).domainSize() for i in range(loopvars.nbrDim(),0,-1)])
        if value.shape!=shape:
          raise IndexError("Shape of '"+str(value)+"' is not '"+str(shape)+"'")

        names = [loopvars.variable(i - 1).name() for i in range(loopvars.nbrDim(), 0, -1)]
        while not inst.end():
            indice = tuple([inst.val(name) for name in names])
            self.set(inst,float(value[indice]))
            inst.incIn(loopvars)

    def __iter__(self):
        """
        Iterate over the data of the Tensor

        Yield
        -----
        Tuple[pyagrum.Instantiation,float]
          The instantiation and the value in the Tensor
        """
        for i in self.loopIn():
            yield i,self.get(i)

    def tolist(self):
        """
        Returns
        -------
        list
            the tensor as a list
        """
        return self.__getitem__({}).tolist()

    def toarray(self):
        """
        Returns
        -------
        array
            the tensor as an array
        """
        return self.__getitem__({})

    def topandas(self):
        """
        Returns
        -------
        pandas.DataFrame
           the tensor as an pandas.DataFrame
        """
        import pandas as pd
        varnames = list(reversed(self.names))
        data = []
        pname = ""
        for inst in self.loopIn():
            d = {k:v for k,v in reversed(inst.todict(True).items())}
            d[pname] = self.get(inst)
            d[pname], d[varnames[-1]] = d[varnames[-1]], d[pname]
            data.append(d)
        cols = varnames[:-1] + [pname]
        return pd.DataFrame(data).set_index(cols).unstack(pname)

    def tolatex(self):
        """
        Render object to a LaTeX tabular.

        Requires to include `booktabs` package in the LaTeX document.

        Returns
        -------
        str
         the tensor as LaTeX string
        """
        return self.topandas().to_latex()

    def toclipboard(self,**kwargs):
        """
        Write a text representation of object to the system clipboard. This can be pasted into spreadsheet, for instance.
        """
        return self.topandas().to_clipboard()

    @property
    def names(self):
        """
        Returns
        -------
        list
            a list containing the name of each variables in the tensor

        Warnings
        --------
            listed in the reverse order of the enumeration order of the variables.
        """
        return tuple([self.variable(i).name() for i in range(self.nbrDim())])

    @property
    def shape(self):
        """
        Returns
        -------
        list
            a list containing the dimensions of each variables in the tensor

        Warnings
        --------
            `p.shape` and `p[:].shape` list the dimensions in different order
        """
        return tuple([self.variable(i).domainSize() for i in range(self.nbrDim())])


    def get(self, i: "pyagrum.Instantiation") -> float:
        r"""

        Parameters
        ----------
        i : pyagrum.Instantiation
          an Instantiation

        Returns
        -------
        float
          the value in the Tensor at the position given by the instantiation

        """
        return _base.Tensor_get(self, i)

    def set(self, i: "pyagrum.Instantiation", value: float) -> None:
        r"""

        Change the value pointed by i

        Parameters
        ----------
        i : pyagrum.Instantiation
          The Instantiation to be changed
        value : float
          The new value of the Instantiation

        """
        return _base.Tensor_set(self, i, value)

    def empty(self) -> bool:
        r"""

        Returns
        -------
        bool
            Returns true if no variable is in the tensor.

        """
        return _base.Tensor_empty(self)

    def pos(self, v: "pyagrum.DiscreteVariable") -> int:
        r"""

        Parameters
        ----------
        v : pyagrum.DiscreteVariable
            The variable for which the index is returned.

        Returns
        -------
            Returns the index of a variable.

        Raises
        ------
        pyagrum.NotFound
          If v is not in this multidimensional matrix.

        """
        return _base.Tensor_pos(self, v)

    def contains(self, v: "pyagrum.DiscreteVariable") -> bool:
        r"""

        Parameters
        ----------
        v : pyagrum.Tensor
            a DiscreteVariable.

        Returns
        -------
        bool
            True if the var is in the tensor

        """
        return _base.Tensor_contains(self, v)

    def variable(self, *args) -> "pyagrum.DiscreteVariable":
        r"""

        Parameters
        ----------
        i : int
          An index of this multidimensional matrix.

        Returns
        -------
          the varible at the ith index

        Raises
        ------
        pyagrum.NotFound
          If i does not reference a variable in this multidimensional matrix.

        """
        return _base.Tensor_variable(self, *args)

    def remove(self, var: "pyagrum.DiscreteVariable") -> None:
        r"""

        Parameters
        ----------
        v : pyagrum.DiscreteVariable
            The variable to be removed

        Returns
        -------
        pyagrum.Tensor
          a reference to the modified tensor

        Warnings
        --------
        IndexError raised if the var is not in the tensor

        """
        val = _base.Tensor_remove(self, var)

        self._list_vars.remove(var)


        return val


    def add(self, v: "pyagrum.DiscreteVariable") -> None:
        r"""

        Add a discrete variable to the tensor.

        Parameters
        ----------
        v : pyagrum.DiscreteVariable
          the var to be added

        Raises
        ------
        DuplicateElement
          If the variable is already in this Tensor.
        InvalidArgument
          If the variable is empty.

        Returns
        -------
        pyagrum.Tensor
            a reference to the modified tensor.

        """
        val = _base.Tensor_add(self, v)

        self._list_vars.append(v)
        return self


        return val


    def domainSize(self) -> int:
        return _base.Tensor_domainSize(self)

    def nbrDim(self, *args) -> int:
        r"""

        Returns
        -------
        int
          the number of vars in the multidimensional container.

        """
        return _base.Tensor_nbrDim(self, *args)

# Register Tensor in _base:
_base.Tensor_swigregister(Tensor)
class PairMPE(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _base.PairMPE_swiginit(self, _base.new_PairMPE(*args))
    first = property(_base.PairMPE_first_get, _base.PairMPE_first_set)
    second = property(_base.PairMPE_second_get, _base.PairMPE_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _base.delete_PairMPE

# Register PairMPE in _base:
_base.PairMPE_swigregister(PairMPE)

def statsObj() -> None:
    return _base.statsObj()

def getNumberOfThreads() -> int:
    return _base.getNumberOfThreads()

def getMaxNumberOfThreads() -> int:
    return _base.getMaxNumberOfThreads()

def getNumberOfLogicalProcessors() -> int:
    return _base.getNumberOfLogicalProcessors()

__version__ = '2.0.1'
__license__ = __doc__
__project_url__ = 'https://agrum.org'
__project_name__ = 'pyAgrum'
__project_description__ = __doc__
__project__ = __doc__


def about():
  """
  about() for pyAgrum

  """
  print(f"pyAgrum {__version__}")
  print("(c) 2015-2024 Pierre-Henri Wuillemin, Christophe Gonzales")
  print("""
    This is free software; see the source code for copying conditions.
    There is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  For details, see 'pyagrum.warranty'.
    """)


import warnings

# seed is chosen randomly :)
initRandom(0)

def _update_config_core():
# hook to control some parameters for core params
  setNumberOfThreads(config.asInt['core', 'default_maxNumberOfThreads'])

# configuration object
from .config import PyAgrumConfiguration
config = PyAgrumConfiguration()
config.add_hook(_update_config_core)
config.run_hooks()

try:
# load custom configuration if any
  config.load()
except FileNotFoundError:
  pass


def _gum_add_properties_while_getstate_(model):
  if not hasattr(model, "setProperty"):
    return

  if config.asBool["Pickle", "add_version"]:
    model.setProperty("version", f"pyAgrum {__version__}")
  if config.asBool["Pickle", "add_date"]:
    from datetime import datetime
    model.setProperty("creation", model.propertyWithDefault("creation", datetime.now().strftime("%Y-%m-%d %H:%M:%S%z")))
    model.setProperty("lastModification", datetime.now().strftime("%Y-%m-%d %H:%M:%S%z"))


def log2(p):
  """Compute p.log2() in a new Tensor without modifying p

  Parameters
  ----------
  p : pyagrum.Tensor
    The tensor on which to apply log2 function

  Returns
  -------
    a pyagrum.Tensor
  """
  return Tensor(p).log2()


def fastGraph(msg:str):
  """
  Create a graph with a dot-like syntax which specifies the structure 'a->b->c;b-d<-e;' where a,b,c,d,e,.. are int

  Warnings
  --------
    The choice of "-" for edges is unambiguous because "-" is not a valid character for a node id (int).
    Moreover, "--" is already used by `pyagrum.fastMRF` to specify factors.

  Parameters
  ----------
    msg : str
      the string containing the specification

  Returns
  -------
    pyagrum.DiGraph ou pyagrum.UndiGraph ou pyagrum.MixedGraph
  """
# regexp to recognize strings with only int, ";", "-" followed by ">" or ">"


  import re
  if not re.match(r"^[\d;\-><]+$", msg):
    raise InvalidArgument("fastGraph only accepts strings with only int, ';', '->' and '<-'")

  is_arc="->" in msg or "<-" in msg
  is_edge="-" in msg
  if is_arc:
    if is_edge:
      m=pyagrum.MixedGraph()
    else:
      m=pyagrum.DiGraph()
  else:
    m=pyagrum.UndiGraph()

  def addEdgeIn(m,msg):
    t=msg.split("-")
    if len(t)==1:
      n1=int(msg)
      deb=n1
      if not m.existsNode(n1):
        m.addNodeWithId(n1)
    else:
      deb,n1=addEdgeIn(m,t[0])
      for i in range(1,len(t)):
        d,f=addEdgeIn(m,t[i])
        m.addEdge(n1,d)
        n1=f
    return deb,n1
  def addRevArcsIn(m,msg):
    t=msg.split("<-")
    if len(t)==1:
      deb,n1=addEdgeIn(m,msg)
    else:
      deb,fin=addEdgeIn(m,t[0])
      n1=fin
      for i in range(1,len(t)):
        d,f=addEdgeIn(m,t[i])
        m.addArc(d,n1)
        n1=f
    return deb,n1
  def addArcsIn(m,msg):
    t=msg.split("->")
    if len(t)==1:
      deb,n1=addRevArcsIn(m,msg)
    else:
      deb,fin=addRevArcsIn(m,t[0])
      n1=fin
      for i in range(1,len(t)):
        d,f=addRevArcsIn(m,t[i])
        m.addArc(n1,d)
        n1=f
    return deb,n1

  for l in msg.split(";"):
    if len(l)>0:
      t=addArcsIn(m,l)

  return m



####################################################################################
def Potential(*args, **kwargs):
  warnings.warn("** pyAgrum : The class pyagrum.Potential is deprecated since `pyAgrum>=2.0.0`. A pyagrum.Tensor will be returned instead."
                , DeprecationWarning, stacklevel=2)
  return Tensor(*args, **kwargs)



