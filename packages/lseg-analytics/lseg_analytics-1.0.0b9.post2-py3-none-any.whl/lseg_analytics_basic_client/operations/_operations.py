# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8

import datetime
import json
import sys
from io import IOBase
from typing import (
    IO,
    Any,
    Callable,
    Dict,
    List,
    Optional,
    Type,
    TypeVar,
    Union,
    overload,
)

from corehttp.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from corehttp.rest import HttpRequest, HttpResponse
from corehttp.runtime.pipeline import PipelineResponse
from corehttp.utils import case_insensitive_dict

from .. import models as _models
from .._model_base import SdkJSONEncoder, _deserialize
from .._serialization import Serializer

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import (
        MutableMapping,  # type: ignore  # pylint: disable=ungrouped-imports
    )
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
_Unset: Any = object()
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_calendars_resource_list_request(
    *,
    item_per_page: Optional[int] = None,
    names: Optional[List[str]] = None,
    spaces: Optional[List[str]] = None,
    tags: Optional[List[str]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1"

    # Construct parameters
    if item_per_page is not None:
        _params["itemPerPage"] = _SERIALIZER.query("item_per_page", item_per_page, "int")
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if spaces is not None:
        _params["spaces"] = [_SERIALIZER.query("spaces", q, "str") if q is not None else "" for q in spaces]
    if tags is not None:
        _params["tags"] = [_SERIALIZER.query("tags", q, "str") if q is not None else "" for q in tags]

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_calendars_resource_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_calendars_resource_generate_holidays_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/$generate-holidays"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_calendars_resource_compute_dates_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/$compute-dates"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_calendars_resource_generate_date_schedule_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/$generate-date-schedule"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_calendars_resource_count_periods_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/$count-periods"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_calendar_resource_read_request(calendar_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/{calendarId}"
    path_format_arguments = {
        "calendarId": _SERIALIZER.url("calendar_id", calendar_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_calendar_resource_delete_request(calendar_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/{calendarId}"
    path_format_arguments = {
        "calendarId": _SERIALIZER.url("calendar_id", calendar_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_calendar_resource_overwrite_request(  # pylint: disable=name-too-long
    calendar_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/{calendarId}"
    path_format_arguments = {
        "calendarId": _SERIALIZER.url("calendar_id", calendar_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_calendar_resource_update_request(calendar_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/{calendarId}"
    path_format_arguments = {
        "calendarId": _SERIALIZER.url("calendar_id", calendar_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_calendar_resource_generate_holidays_request(  # pylint: disable=name-too-long
    calendar_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/{calendarId}/$generate-holidays"
    path_format_arguments = {
        "calendarId": _SERIALIZER.url("calendar_id", calendar_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_calendar_resource_compute_dates_request(  # pylint: disable=name-too-long
    calendar_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/{calendarId}/$compute-dates"
    path_format_arguments = {
        "calendarId": _SERIALIZER.url("calendar_id", calendar_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_calendar_resource_generate_date_schedule_request(  # pylint: disable=name-too-long
    calendar_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/{calendarId}/$generate-date-schedule"
    path_format_arguments = {
        "calendarId": _SERIALIZER.url("calendar_id", calendar_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_calendar_resource_count_periods_request(  # pylint: disable=name-too-long
    calendar_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/{calendarId}/$count-periods"
    path_format_arguments = {
        "calendarId": _SERIALIZER.url("calendar_id", calendar_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_cross_currencies_resource_list_request(  # pylint: disable=name-too-long
    *,
    item_per_page: Optional[int] = None,
    names: Optional[List[str]] = None,
    spaces: Optional[List[str]] = None,
    tags: Optional[List[str]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/cross-currencies/v1"

    # Construct parameters
    if item_per_page is not None:
        _params["itemPerPage"] = _SERIALIZER.query("item_per_page", item_per_page, "int")
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if spaces is not None:
        _params["spaces"] = [_SERIALIZER.query("spaces", q, "str") if q is not None else "" for q in spaces]
    if tags is not None:
        _params["tags"] = [_SERIALIZER.query("tags", q, "str") if q is not None else "" for q in tags]

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_cross_currencies_resource_create_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/cross-currencies/v1"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_cross_currency_resource_read_request(  # pylint: disable=name-too-long
    cross_currency_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/cross-currencies/v1/{crossCurrencyId}"
    path_format_arguments = {
        "crossCurrencyId": _SERIALIZER.url("cross_currency_id", cross_currency_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_cross_currency_resource_delete_request(  # pylint: disable=name-too-long
    cross_currency_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/cross-currencies/v1/{crossCurrencyId}"
    path_format_arguments = {
        "crossCurrencyId": _SERIALIZER.url("cross_currency_id", cross_currency_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_cross_currency_resource_overwrite_request(  # pylint: disable=name-too-long
    cross_currency_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/cross-currencies/v1/{crossCurrencyId}"
    path_format_arguments = {
        "crossCurrencyId": _SERIALIZER.url("cross_currency_id", cross_currency_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_cross_currency_resource_update_request(  # pylint: disable=name-too-long
    cross_currency_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/cross-currencies/v1/{crossCurrencyId}"
    path_format_arguments = {
        "crossCurrencyId": _SERIALIZER.url("cross_currency_id", cross_currency_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_currencies_resource_list_request(
    *,
    item_per_page: Optional[int] = None,
    names: Optional[List[str]] = None,
    spaces: Optional[List[str]] = None,
    tags: Optional[List[str]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/currencies/v1"

    # Construct parameters
    if item_per_page is not None:
        _params["itemPerPage"] = _SERIALIZER.query("item_per_page", item_per_page, "int")
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if spaces is not None:
        _params["spaces"] = [_SERIALIZER.query("spaces", q, "str") if q is not None else "" for q in spaces]
    if tags is not None:
        _params["tags"] = [_SERIALIZER.query("tags", q, "str") if q is not None else "" for q in tags]

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_currencies_resource_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/currencies/v1"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_currency_resource_read_request(currency_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/currencies/v1/{currencyId}"
    path_format_arguments = {
        "currencyId": _SERIALIZER.url("currency_id", currency_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_currency_resource_delete_request(currency_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/currencies/v1/{currencyId}"
    path_format_arguments = {
        "currencyId": _SERIALIZER.url("currency_id", currency_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_currency_resource_overwrite_request(  # pylint: disable=name-too-long
    currency_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/currencies/v1/{currencyId}"
    path_format_arguments = {
        "currencyId": _SERIALIZER.url("currency_id", currency_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_currency_resource_update_request(currency_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/currencies/v1/{currencyId}"
    path_format_arguments = {
        "currencyId": _SERIALIZER.url("currency_id", currency_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_fx_forward_curves_resource_list_request(  # pylint: disable=name-too-long
    *,
    item_per_page: Optional[int] = None,
    names: Optional[List[str]] = None,
    spaces: Optional[List[str]] = None,
    tags: Optional[List[str]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1"

    # Construct parameters
    if item_per_page is not None:
        _params["itemPerPage"] = _SERIALIZER.query("item_per_page", item_per_page, "int")
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if spaces is not None:
        _params["spaces"] = [_SERIALIZER.query("spaces", q, "str") if q is not None else "" for q in spaces]
    if tags is not None:
        _params["tags"] = [_SERIALIZER.query("tags", q, "str") if q is not None else "" for q in tags]

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_fx_forward_curves_resource_create_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_forward_curves_resource_create_definition_from_fx_forwards_in_direct_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1/$create-definition-from-fx-forwards"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_forward_curves_resource_create_definition_from_deposits_in_direct_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1/$create-definition-from-deposits"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_forward_curves_resource_calculate_on_the_fly_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1/$calculate"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_forward_curve_resource_read_request(  # pylint: disable=name-too-long
    curve_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1/{curveId}"
    path_format_arguments = {
        "curveId": _SERIALIZER.url("curve_id", curve_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_fx_forward_curve_resource_delete_request(  # pylint: disable=name-too-long
    curve_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1/{curveId}"
    path_format_arguments = {
        "curveId": _SERIALIZER.url("curve_id", curve_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_fx_forward_curve_resource_overwrite_request(  # pylint: disable=name-too-long
    curve_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1/{curveId}"
    path_format_arguments = {
        "curveId": _SERIALIZER.url("curve_id", curve_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_fx_forward_curve_resource_update_request(  # pylint: disable=name-too-long
    curve_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1/{curveId}"
    path_format_arguments = {
        "curveId": _SERIALIZER.url("curve_id", curve_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_fx_forward_curve_resource_calculate_request(  # pylint: disable=name-too-long
    curve_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1/{curveId}/$calculate"
    path_format_arguments = {
        "curveId": _SERIALIZER.url("curve_id", curve_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_forwards_resource_list_request(
    *,
    item_per_page: Optional[int] = None,
    names: Optional[List[str]] = None,
    spaces: Optional[List[str]] = None,
    tags: Optional[List[str]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1"

    # Construct parameters
    if item_per_page is not None:
        _params["itemPerPage"] = _SERIALIZER.query("item_per_page", item_per_page, "int")
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if spaces is not None:
        _params["spaces"] = [_SERIALIZER.query("spaces", q, "str") if q is not None else "" for q in spaces]
    if tags is not None:
        _params["tags"] = [_SERIALIZER.query("tags", q, "str") if q is not None else "" for q in tags]

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_fx_forwards_resource_create_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_forwards_resource_price_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1/$price"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_forwards_resource_value_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1/$value"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_forward_resource_read_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1/{instrumentId}"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_fx_forward_resource_delete_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1/{instrumentId}"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_fx_forward_resource_overwrite_request(  # pylint: disable=name-too-long
    instrument_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1/{instrumentId}"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_fx_forward_resource_update_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1/{instrumentId}"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_fx_forward_resource_price_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1/{instrumentId}/$price"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_forward_resource_value_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1/{instrumentId}/$value"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_spots_resource_list_request(
    *,
    item_per_page: Optional[int] = None,
    names: Optional[List[str]] = None,
    spaces: Optional[List[str]] = None,
    tags: Optional[List[str]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1"

    # Construct parameters
    if item_per_page is not None:
        _params["itemPerPage"] = _SERIALIZER.query("item_per_page", item_per_page, "int")
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if spaces is not None:
        _params["spaces"] = [_SERIALIZER.query("spaces", q, "str") if q is not None else "" for q in spaces]
    if tags is not None:
        _params["tags"] = [_SERIALIZER.query("tags", q, "str") if q is not None else "" for q in tags]

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_fx_spots_resource_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_spots_resource_price_on_the_fly_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1/$price"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_spots_resource_value_on_the_fly_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1/$value"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_spot_resource_read_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1/{instrumentId}"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_fx_spot_resource_delete_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1/{instrumentId}"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_fx_spot_resource_overwrite_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1/{instrumentId}"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_fx_spot_resource_update_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1/{instrumentId}"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_fx_spot_resource_price_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1/{instrumentId}/$price"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_spot_resource_value_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1/{instrumentId}/$value"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


class calendarsResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`calendars_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        names: Optional[List[str]] = None,
        spaces: Optional[List[str]] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Union[_models.CalendarCollectionResponse, _models.ServiceErrorResponse]:
        """Search resources via combination of name, space and tags.

        :keyword item_per_page: The maximum number of items for each search request. The valid range is
         1-500. If not provided, 50 will be used. Default value is None.
        :paramtype item_per_page: int
        :keyword names: The list of resource names to be searched. Exact match is applied for each
         name. Default value is None.
        :paramtype names: list[str]
        :keyword spaces: The space where the resource is stored. Space is like a namespace where
         resources are stored. By default there are two spaces:
         LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space. If
         space is not specified, HOME will be used. Default value is None.
        :paramtype spaces: list[str]
        :keyword tags: The list of resource tags to be searched. Default value is None.
        :paramtype tags: list[str]
        :return: CalendarCollectionResponse or ServiceErrorResponse. The CalendarCollectionResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.CalendarCollectionResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "description": {
                                "summary": "str",
                                "tags": [
                                    "str"
                                ]
                            },
                            "id": "str",
                            "type": "str"
                        }
                    ],
                    "links": {
                        "computeDates": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "generateDateSchedule": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "generateHolidays": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.CalendarCollectionResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_calendars_resource_list_request(
            item_per_page=item_per_page,
            names=names,
            spaces=spaces,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CalendarCollectionResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "firstDayOfWeek": "str",
                        "holidayExceptionRules": [
                            {
                                "duration": duration,
                                "name": "str",
                                "validityPeriod": {
                                    "endDate": "2020-02-20",
                                    "startDate": "2020-02-20"
                                },
                                "when": when,
                                "description": "str"
                            }
                        ],
                        "holidayRules": [
                            {
                                "duration": duration,
                                "name": "str",
                                "validityPeriod": {
                                    "endDate": "2020-02-20",
                                    "startDate": "2020-02-20"
                                },
                                "when": when,
                                "description": "str"
                            }
                        ],
                        "restDays": [
                            {
                                "restDays": [
                                    "str"
                                ],
                                "validityPeriod": {
                                    "endDate": "2020-02-20",
                                    "startDate": "2020-02-20"
                                }
                            }
                        ]
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def create(
        self,
        *,
        location: _models.Location,
        definition: _models.CalendarDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Calendar definition. Required.
        :paramtype definition: ~analyticsapi.models.CalendarDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Calendar description. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def create(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.CalendarDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Calendar definition. Required.
        :paramtype definition: ~analyticsapi.models.CalendarDefinition
        :keyword description: Calendar description. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "firstDayOfWeek": "str",
                        "holidayExceptionRules": [
                            {
                                "duration": duration,
                                "name": "str",
                                "validityPeriod": {
                                    "endDate": "2020-02-20",
                                    "startDate": "2020-02-20"
                                },
                                "when": when,
                                "description": "str"
                            }
                        ],
                        "holidayRules": [
                            {
                                "duration": duration,
                                "name": "str",
                                "validityPeriod": {
                                    "endDate": "2020-02-20",
                                    "startDate": "2020-02-20"
                                },
                                "when": when,
                                "description": "str"
                            }
                        ],
                        "restDays": [
                            {
                                "restDays": [
                                    "str"
                                ],
                                "validityPeriod": {
                                    "endDate": "2020-02-20",
                                    "startDate": "2020-02-20"
                                }
                            }
                        ]
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CalendarResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendars_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        response_headers = {}
        if response.status_code == 201:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CalendarResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def generate_holidays(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]:
        """Gets the holidays for the calendar within a date range. Start and End Dates are included in the
        calculation. Only saved calendars are supported.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GenerateHolidaysResponse or ServiceErrorResponse. The GenerateHolidaysResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "endDate": "2020-02-20",
                    "startDate": "2020-02-20"
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "date": "2020-02-20",
                            "names": [
                                {
                                    "calendars": [
                                        {
                                            "id": "str",
                                            "location": {
                                                "name": "str",
                                                "space": "str"
                                            },
                                            "type": "str"
                                        }
                                    ],
                                    "countries": [
                                        "str"
                                    ],
                                    "name": "str"
                                }
                            ],
                            "processingInformation": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def generate_holidays(
        self,
        *,
        end_date: datetime.date,
        calendars: List[_models.CalendarRelatedResource],
        content_type: str = "application/json",
        start_date: Optional[datetime.date] = None,
        **kwargs: Any,
    ) -> Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]:
        """Gets the holidays for the calendar within a date range. Start and End Dates are included in the
        calculation. Only saved calendars are supported.

        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01). Required.
        :paramtype end_date: ~datetime.date
        :keyword calendars: An array of calendar reference strings for which the calculation should be
         done. Each string being composed of the space and name of a calendar. For example 'LSEG.UKG' is
         the string referencing the 'UKG' calendar stored in the 'LSEG' space. Required.
        :paramtype calendars: list[~analyticsapi.models.CalendarRelatedResource]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Default is today. Default value is None.
        :paramtype start_date: ~datetime.date
        :return: GenerateHolidaysResponse or ServiceErrorResponse. The GenerateHolidaysResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "date": "2020-02-20",
                            "names": [
                                {
                                    "calendars": [
                                        {
                                            "id": "str",
                                            "location": {
                                                "name": "str",
                                                "space": "str"
                                            },
                                            "type": "str"
                                        }
                                    ],
                                    "countries": [
                                        "str"
                                    ],
                                    "name": "str"
                                }
                            ],
                            "processingInformation": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def generate_holidays(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]:
        """Gets the holidays for the calendar within a date range. Start and End Dates are included in the
        calculation. Only saved calendars are supported.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GenerateHolidaysResponse or ServiceErrorResponse. The GenerateHolidaysResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "date": "2020-02-20",
                            "names": [
                                {
                                    "calendars": [
                                        {
                                            "id": "str",
                                            "location": {
                                                "name": "str",
                                                "space": "str"
                                            },
                                            "type": "str"
                                        }
                                    ],
                                    "countries": [
                                        "str"
                                    ],
                                    "name": "str"
                                }
                            ],
                            "processingInformation": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def generate_holidays(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        end_date: datetime.date = _Unset,
        calendars: List[_models.CalendarRelatedResource] = _Unset,
        start_date: Optional[datetime.date] = None,
        **kwargs: Any,
    ) -> Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]:
        """Gets the holidays for the calendar within a date range. Start and End Dates are included in the
        calculation. Only saved calendars are supported.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01). Required.
        :paramtype end_date: ~datetime.date
        :keyword calendars: An array of calendar reference strings for which the calculation should be
         done. Each string being composed of the space and name of a calendar. For example 'LSEG.UKG' is
         the string referencing the 'UKG' calendar stored in the 'LSEG' space. Required.
        :paramtype calendars: list[~analyticsapi.models.CalendarRelatedResource]
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Default is today. Default value is None.
        :paramtype start_date: ~datetime.date
        :return: GenerateHolidaysResponse or ServiceErrorResponse. The GenerateHolidaysResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "endDate": "2020-02-20",
                    "startDate": "2020-02-20"
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "date": "2020-02-20",
                            "names": [
                                {
                                    "calendars": [
                                        {
                                            "id": "str",
                                            "location": {
                                                "name": "str",
                                                "space": "str"
                                            },
                                            "type": "str"
                                        }
                                    ],
                                    "countries": [
                                        "str"
                                    ],
                                    "name": "str"
                                }
                            ],
                            "processingInformation": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if end_date is _Unset:
                raise TypeError("missing required argument: end_date")
            if calendars is _Unset:
                raise TypeError("missing required argument: calendars")
            body = {"calendars": calendars, "endDate": end_date, "startDate": start_date}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendars_resource_generate_holidays_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.GenerateHolidaysResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def compute_dates(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]:
        """Computes dates for the calendar according to specified conditions. Start Date is included in
        the calculation. Only saved calendars are supported.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ComputeDatesResponse or ServiceErrorResponse. The ComputeDatesResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "tenors": [
                        "str"
                    ],
                    "dateMovingConvention": "str",
                    "startDate": "2020-02-20"
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "endDate": "2020-02-20",
                            "processingInformation": "str",
                            "tenor": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def compute_dates(
        self,
        *,
        tenors: List[str],
        calendars: List[_models.CalendarRelatedResource],
        content_type: str = "application/json",
        start_date: Optional[datetime.date] = None,
        date_moving_convention: Optional[Union[str, _models.DateMovingConvention]] = None,
        **kwargs: Any,
    ) -> Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]:
        """Computes dates for the calendar according to specified conditions. Start Date is included in
        the calculation. Only saved calendars are supported.

        :keyword tenors: Tenors to be added to startDate to calculate the resulted dates.
         A tenor expresses a period of time using a specific syntax. For example "1D" for one day, "2W"
         for two weeks or "3W1M" for three weeks and a month.
         There are common tenors like ON, TN, SN, SW, 1W, 2W, 1M, 2M, etc. Required.
        :paramtype tenors: list[str]
        :keyword calendars: An array of calendar reference strings for which the calculation should be
         done. Each string being composed of the space and name of a calendar. For example 'LSEG.UKG' is
         the string referencing the 'UKG' calendar stored in the 'LSEG' space. Required.
        :paramtype calendars: list[~analyticsapi.models.CalendarRelatedResource]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Default is Today. Default value is None.
        :paramtype start_date: ~datetime.date
        :keyword date_moving_convention: The method to adjust dates to working days. Known values are:
         "ModifiedFollowing", "NextBusinessDay", "PreviousBusinessDay", "NoMoving",
         "EveryThirdWednesday", and "BbswModifiedFollowing". Default value is None.
        :paramtype date_moving_convention: str or ~analyticsapi.models.DateMovingConvention
        :return: ComputeDatesResponse or ServiceErrorResponse. The ComputeDatesResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "endDate": "2020-02-20",
                            "processingInformation": "str",
                            "tenor": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def compute_dates(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]:
        """Computes dates for the calendar according to specified conditions. Start Date is included in
        the calculation. Only saved calendars are supported.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ComputeDatesResponse or ServiceErrorResponse. The ComputeDatesResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "endDate": "2020-02-20",
                            "processingInformation": "str",
                            "tenor": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def compute_dates(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        tenors: List[str] = _Unset,
        calendars: List[_models.CalendarRelatedResource] = _Unset,
        start_date: Optional[datetime.date] = None,
        date_moving_convention: Optional[Union[str, _models.DateMovingConvention]] = None,
        **kwargs: Any,
    ) -> Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]:
        """Computes dates for the calendar according to specified conditions. Start Date is included in
        the calculation. Only saved calendars are supported.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword tenors: Tenors to be added to startDate to calculate the resulted dates.
         A tenor expresses a period of time using a specific syntax. For example "1D" for one day, "2W"
         for two weeks or "3W1M" for three weeks and a month.
         There are common tenors like ON, TN, SN, SW, 1W, 2W, 1M, 2M, etc. Required.
        :paramtype tenors: list[str]
        :keyword calendars: An array of calendar reference strings for which the calculation should be
         done. Each string being composed of the space and name of a calendar. For example 'LSEG.UKG' is
         the string referencing the 'UKG' calendar stored in the 'LSEG' space. Required.
        :paramtype calendars: list[~analyticsapi.models.CalendarRelatedResource]
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Default is Today. Default value is None.
        :paramtype start_date: ~datetime.date
        :keyword date_moving_convention: The method to adjust dates to working days. Known values are:
         "ModifiedFollowing", "NextBusinessDay", "PreviousBusinessDay", "NoMoving",
         "EveryThirdWednesday", and "BbswModifiedFollowing". Default value is None.
        :paramtype date_moving_convention: str or ~analyticsapi.models.DateMovingConvention
        :return: ComputeDatesResponse or ServiceErrorResponse. The ComputeDatesResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "tenors": [
                        "str"
                    ],
                    "dateMovingConvention": "str",
                    "startDate": "2020-02-20"
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "endDate": "2020-02-20",
                            "processingInformation": "str",
                            "tenor": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if tenors is _Unset:
                raise TypeError("missing required argument: tenors")
            if calendars is _Unset:
                raise TypeError("missing required argument: calendars")
            body = {
                "calendars": calendars,
                "dateMovingConvention": date_moving_convention,
                "startDate": start_date,
                "tenors": tenors,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendars_resource_compute_dates_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ComputeDatesResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def generate_date_schedule(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]:
        """Generates a date schedule for the calendar according to specified conditions. Start and End
        Dates are included in the calculation. Only saved calendars are supported.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GenerateDateScheduleResponse or ServiceErrorResponse. The GenerateDateScheduleResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "frequency": "str",
                    "calendarDayOfMonth": 0,
                    "count": 0,
                    "dayOfWeek": "str",
                    "endDate": "2020-02-20",
                    "startDate": "2020-02-20"
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        "2020-02-20"
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def generate_date_schedule(
        self,
        *,
        frequency: Union[str, _models.Frequency],
        calendars: List[_models.CalendarRelatedResource],
        content_type: str = "application/json",
        start_date: Optional[datetime.date] = None,
        end_date: Optional[datetime.date] = None,
        calendar_day_of_month: Optional[int] = None,
        count: Optional[int] = None,
        day_of_week: Optional[Union[str, _models.WeekDay]] = None,
        **kwargs: Any,
    ) -> Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]:
        """Generates a date schedule for the calendar according to specified conditions. Start and End
        Dates are included in the calculation. Only saved calendars are supported.

        :keyword frequency: The frequency of dates in the schedule which should be generated. Note that
         "Daily" refers to working days only. Known values are: "Daily", "Weekly", "BiWeekly", and
         "Monthly". Required.
        :paramtype frequency: str or ~analyticsapi.models.Frequency
        :keyword calendars: An array of calendar reference strings for which the calculation should be
         done. Each string being composed of the space and name of a calendar. For example 'LSEG.UKG' is
         the string referencing the 'UKG' calendar stored in the 'LSEG' space. Required.
        :paramtype calendars: list[~analyticsapi.models.CalendarRelatedResource]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01).
         The start date must be before the end date.
         Required if endDate is in the past. Default value is None.
        :paramtype start_date: ~datetime.date
        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01).
         If startDate is not specified, endDate is used to define the list of dates from today's date
         to the end date.
         The end date must be after the start date.
         Required if count is not specified. Only one of endDate and count can be set at a time.
         Default value is None.
        :paramtype end_date: ~datetime.date
        :keyword calendar_day_of_month: The number of the day of the month. Required if frequency is
         Monthly; do not use otherwise. The minimum value is 1. The maximum value is 31. Default value
         is None.
        :paramtype calendar_day_of_month: int
        :keyword count: The number of dates to be generated, counting from the start date (or today's
         date if the start date is not set).
         It should not have a negative value.
         Required if endDate is not specified. Only one of endDate and count can be set at a time.
         Default value is None.
        :paramtype count: int
        :keyword day_of_week: The day of the week. Required if frequency is Weekly or BiWeekly; do not
         use otherwise. Known values are: "Monday", "Tuesday", "Wednesday", "Thursday", "Friday",
         "Saturday", and "Sunday". Default value is None.
        :paramtype day_of_week: str or ~analyticsapi.models.WeekDay
        :return: GenerateDateScheduleResponse or ServiceErrorResponse. The GenerateDateScheduleResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        "2020-02-20"
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def generate_date_schedule(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]:
        """Generates a date schedule for the calendar according to specified conditions. Start and End
        Dates are included in the calculation. Only saved calendars are supported.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GenerateDateScheduleResponse or ServiceErrorResponse. The GenerateDateScheduleResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        "2020-02-20"
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def generate_date_schedule(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        frequency: Union[str, _models.Frequency] = _Unset,
        calendars: List[_models.CalendarRelatedResource] = _Unset,
        start_date: Optional[datetime.date] = None,
        end_date: Optional[datetime.date] = None,
        calendar_day_of_month: Optional[int] = None,
        count: Optional[int] = None,
        day_of_week: Optional[Union[str, _models.WeekDay]] = None,
        **kwargs: Any,
    ) -> Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]:
        """Generates a date schedule for the calendar according to specified conditions. Start and End
        Dates are included in the calculation. Only saved calendars are supported.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword frequency: The frequency of dates in the schedule which should be generated. Note that
         "Daily" refers to working days only. Known values are: "Daily", "Weekly", "BiWeekly", and
         "Monthly". Required.
        :paramtype frequency: str or ~analyticsapi.models.Frequency
        :keyword calendars: An array of calendar reference strings for which the calculation should be
         done. Each string being composed of the space and name of a calendar. For example 'LSEG.UKG' is
         the string referencing the 'UKG' calendar stored in the 'LSEG' space. Required.
        :paramtype calendars: list[~analyticsapi.models.CalendarRelatedResource]
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01).
         The start date must be before the end date.
         Required if endDate is in the past. Default value is None.
        :paramtype start_date: ~datetime.date
        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01).
         If startDate is not specified, endDate is used to define the list of dates from today's date
         to the end date.
         The end date must be after the start date.
         Required if count is not specified. Only one of endDate and count can be set at a time.
         Default value is None.
        :paramtype end_date: ~datetime.date
        :keyword calendar_day_of_month: The number of the day of the month. Required if frequency is
         Monthly; do not use otherwise. The minimum value is 1. The maximum value is 31. Default value
         is None.
        :paramtype calendar_day_of_month: int
        :keyword count: The number of dates to be generated, counting from the start date (or today's
         date if the start date is not set).
         It should not have a negative value.
         Required if endDate is not specified. Only one of endDate and count can be set at a time.
         Default value is None.
        :paramtype count: int
        :keyword day_of_week: The day of the week. Required if frequency is Weekly or BiWeekly; do not
         use otherwise. Known values are: "Monday", "Tuesday", "Wednesday", "Thursday", "Friday",
         "Saturday", and "Sunday". Default value is None.
        :paramtype day_of_week: str or ~analyticsapi.models.WeekDay
        :return: GenerateDateScheduleResponse or ServiceErrorResponse. The GenerateDateScheduleResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "frequency": "str",
                    "calendarDayOfMonth": 0,
                    "count": 0,
                    "dayOfWeek": "str",
                    "endDate": "2020-02-20",
                    "startDate": "2020-02-20"
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        "2020-02-20"
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        if body is _Unset:
            if frequency is _Unset:
                raise TypeError("missing required argument: frequency")
            if calendars is _Unset:
                raise TypeError("missing required argument: calendars")
            body = {
                "calendarDayOfMonth": calendar_day_of_month,
                "calendars": calendars,
                "count": count,
                "dayOfWeek": day_of_week,
                "endDate": end_date,
                "frequency": frequency,
                "startDate": start_date,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendars_resource_generate_date_schedule_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.GenerateDateScheduleResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def count_periods(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]:
        """Counts the time periods that satisfy specified conditions. Note the use of date strings for
        convenience. Start and End Dates are included in the calculation. Only saved calendars are
        supported.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CountPeriodsResponse or ServiceErrorResponse. The CountPeriodsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "endDate": "2020-02-20",
                    "startDate": "2020-02-20",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dayCountBasis": "str",
                    "periodType": "str"
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "count": 0,
                        "periodType": "str",
                        "processingInformation": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def count_periods(
        self,
        *,
        start_date: datetime.date,
        end_date: datetime.date,
        content_type: str = "application/json",
        day_count_basis: Optional[Union[str, _models.DayCountBasis]] = None,
        period_type: Optional[Union[str, _models.PeriodType]] = None,
        calendars: Optional[List[_models.CalendarRelatedResource]] = None,
        **kwargs: Any,
    ) -> Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]:
        """Counts the time periods that satisfy specified conditions. Note the use of date strings for
        convenience. Start and End Dates are included in the calculation. Only saved calendars are
        supported.

        :keyword start_date: Start date for counting periods. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Required.
        :paramtype start_date: ~datetime.date
        :keyword end_date: End date for counting periods. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01). Required.
        :paramtype end_date: ~datetime.date
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword day_count_basis: The day count basis convention used to calculate the period between
         two dates. Default is Actual/Actual.
         It is used when periodType is set to Year.
         Each convention defines the number of days between two dates and the year length in days
         (basis) for the period calculation. Known values are: "Dcb_30_360", "Dcb_30_360_US",
         "Dcb_30_360_German", "Dcb_30_360_ISDA", "Dcb_30_365_ISDA", "Dcb_30_365_German",
         "Dcb_30_365_Brazil", "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
         "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364", "Dcb_Actual_365", "Dcb_Actual_Actual",
         "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252", "Dcb_Actual_365L",
         "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360", "Dcb_Actual_36525", and
         "Dcb_Actual_365_CanadianConvention". Default value is None.
        :paramtype day_count_basis: str or ~analyticsapi.models.DayCountBasis
        :keyword period_type: The method of the period calculation. Default is Day. Known values are:
         "WorkingDay", "NonWorkingDay", "Day", "Week", "Month", "Quarter", and "Year". Default value is
         None.
        :paramtype period_type: str or ~analyticsapi.models.PeriodType
        :keyword calendars: An array of calendar reference strings for which the calculation should be
         done. Each string being composed of the space and name of a calendar.
         For example 'LSEG.UKG' is the string referencing the 'UKG' calendar stored in the 'LSEG'
         space.
         The calendars parameter is optional only when periodType is "Day" or "Year".
         For a given day to be considered a working day, it must be a working day in all of the
         selected calendars. If it is a non-working day in any of the calendars, it is a non-working
         day. Default value is None.
        :paramtype calendars: list[~analyticsapi.models.CalendarRelatedResource]
        :return: CountPeriodsResponse or ServiceErrorResponse. The CountPeriodsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "count": 0,
                        "periodType": "str",
                        "processingInformation": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def count_periods(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]:
        """Counts the time periods that satisfy specified conditions. Note the use of date strings for
        convenience. Start and End Dates are included in the calculation. Only saved calendars are
        supported.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CountPeriodsResponse or ServiceErrorResponse. The CountPeriodsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "count": 0,
                        "periodType": "str",
                        "processingInformation": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def count_periods(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        start_date: datetime.date = _Unset,
        end_date: datetime.date = _Unset,
        day_count_basis: Optional[Union[str, _models.DayCountBasis]] = None,
        period_type: Optional[Union[str, _models.PeriodType]] = None,
        calendars: Optional[List[_models.CalendarRelatedResource]] = None,
        **kwargs: Any,
    ) -> Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]:
        """Counts the time periods that satisfy specified conditions. Note the use of date strings for
        convenience. Start and End Dates are included in the calculation. Only saved calendars are
        supported.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword start_date: Start date for counting periods. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Required.
        :paramtype start_date: ~datetime.date
        :keyword end_date: End date for counting periods. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01). Required.
        :paramtype end_date: ~datetime.date
        :keyword day_count_basis: The day count basis convention used to calculate the period between
         two dates. Default is Actual/Actual.
         It is used when periodType is set to Year.
         Each convention defines the number of days between two dates and the year length in days
         (basis) for the period calculation. Known values are: "Dcb_30_360", "Dcb_30_360_US",
         "Dcb_30_360_German", "Dcb_30_360_ISDA", "Dcb_30_365_ISDA", "Dcb_30_365_German",
         "Dcb_30_365_Brazil", "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
         "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364", "Dcb_Actual_365", "Dcb_Actual_Actual",
         "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252", "Dcb_Actual_365L",
         "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360", "Dcb_Actual_36525", and
         "Dcb_Actual_365_CanadianConvention". Default value is None.
        :paramtype day_count_basis: str or ~analyticsapi.models.DayCountBasis
        :keyword period_type: The method of the period calculation. Default is Day. Known values are:
         "WorkingDay", "NonWorkingDay", "Day", "Week", "Month", "Quarter", and "Year". Default value is
         None.
        :paramtype period_type: str or ~analyticsapi.models.PeriodType
        :keyword calendars: An array of calendar reference strings for which the calculation should be
         done. Each string being composed of the space and name of a calendar.
         For example 'LSEG.UKG' is the string referencing the 'UKG' calendar stored in the 'LSEG'
         space.
         The calendars parameter is optional only when periodType is "Day" or "Year".
         For a given day to be considered a working day, it must be a working day in all of the
         selected calendars. If it is a non-working day in any of the calendars, it is a non-working
         day. Default value is None.
        :paramtype calendars: list[~analyticsapi.models.CalendarRelatedResource]
        :return: CountPeriodsResponse or ServiceErrorResponse. The CountPeriodsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "endDate": "2020-02-20",
                    "startDate": "2020-02-20",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dayCountBasis": "str",
                    "periodType": "str"
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "count": 0,
                        "periodType": "str",
                        "processingInformation": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if start_date is _Unset:
                raise TypeError("missing required argument: start_date")
            if end_date is _Unset:
                raise TypeError("missing required argument: end_date")
            body = {
                "calendars": calendars,
                "dayCountBasis": day_count_basis,
                "endDate": end_date,
                "periodType": period_type,
                "startDate": start_date,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendars_resource_count_periods_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CountPeriodsResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class calendarResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`calendar_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def read(self, calendar_id: str, **kwargs: Any) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        """Read resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.CalendarResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_calendar_resource_read_request(
            calendar_id=calendar_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CalendarResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def delete(self, calendar_id: str, **kwargs: Any) -> Optional[_models.ServiceErrorResponse]:
        """Delete resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :return: ServiceErrorResponse or None. The ServiceErrorResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ServiceErrorResponse or None
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_calendar_resource_delete_request(
            calendar_id=calendar_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            204,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        deserialized = None
        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def overwrite(
        self, calendar_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "firstDayOfWeek": "str",
                        "holidayExceptionRules": [
                            {
                                "duration": duration,
                                "name": "str",
                                "validityPeriod": {
                                    "endDate": "2020-02-20",
                                    "startDate": "2020-02-20"
                                },
                                "when": when,
                                "description": "str"
                            }
                        ],
                        "holidayRules": [
                            {
                                "duration": duration,
                                "name": "str",
                                "validityPeriod": {
                                    "endDate": "2020-02-20",
                                    "startDate": "2020-02-20"
                                },
                                "when": when,
                                "description": "str"
                            }
                        ],
                        "restDays": [
                            {
                                "restDays": [
                                    "str"
                                ],
                                "validityPeriod": {
                                    "endDate": "2020-02-20",
                                    "startDate": "2020-02-20"
                                }
                            }
                        ]
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def overwrite(
        self,
        calendar_id: str,
        *,
        location: _models.Location,
        definition: _models.CalendarDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Calendar definition. Required.
        :paramtype definition: ~analyticsapi.models.CalendarDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Calendar description. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def overwrite(
        self, calendar_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def overwrite(
        self,
        calendar_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.CalendarDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Calendar definition. Required.
        :paramtype definition: ~analyticsapi.models.CalendarDefinition
        :keyword description: Calendar description. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "firstDayOfWeek": "str",
                        "holidayExceptionRules": [
                            {
                                "duration": duration,
                                "name": "str",
                                "validityPeriod": {
                                    "endDate": "2020-02-20",
                                    "startDate": "2020-02-20"
                                },
                                "when": when,
                                "description": "str"
                            }
                        ],
                        "holidayRules": [
                            {
                                "duration": duration,
                                "name": "str",
                                "validityPeriod": {
                                    "endDate": "2020-02-20",
                                    "startDate": "2020-02-20"
                                },
                                "when": when,
                                "description": "str"
                            }
                        ],
                        "restDays": [
                            {
                                "restDays": [
                                    "str"
                                ],
                                "validityPeriod": {
                                    "endDate": "2020-02-20",
                                    "startDate": "2020-02-20"
                                }
                            }
                        ]
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CalendarResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendar_resource_overwrite_request(
            calendar_id=calendar_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CalendarResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(
        self, calendar_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "firstDayOfWeek": "str",
                        "holidayExceptionRules": [
                            {
                                "duration": duration,
                                "name": "str",
                                "validityPeriod": {
                                    "endDate": "2020-02-20",
                                    "startDate": "2020-02-20"
                                },
                                "when": when,
                                "description": "str"
                            }
                        ],
                        "holidayRules": [
                            {
                                "duration": duration,
                                "name": "str",
                                "validityPeriod": {
                                    "endDate": "2020-02-20",
                                    "startDate": "2020-02-20"
                                },
                                "when": when,
                                "description": "str"
                            }
                        ],
                        "restDays": [
                            {
                                "restDays": [
                                    "str"
                                ],
                                "validityPeriod": {
                                    "endDate": "2020-02-20",
                                    "startDate": "2020-02-20"
                                }
                            }
                        ]
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def update(
        self,
        calendar_id: str,
        *,
        location: _models.Location,
        definition: _models.CalendarDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Calendar definition. Required.
        :paramtype definition: ~analyticsapi.models.CalendarDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Calendar description. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def update(
        self, calendar_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def update(
        self,
        calendar_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.CalendarDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Calendar definition. Required.
        :paramtype definition: ~analyticsapi.models.CalendarDefinition
        :keyword description: Calendar description. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "firstDayOfWeek": "str",
                        "holidayExceptionRules": [
                            {
                                "duration": duration,
                                "name": "str",
                                "validityPeriod": {
                                    "endDate": "2020-02-20",
                                    "startDate": "2020-02-20"
                                },
                                "when": when,
                                "description": "str"
                            }
                        ],
                        "holidayRules": [
                            {
                                "duration": duration,
                                "name": "str",
                                "validityPeriod": {
                                    "endDate": "2020-02-20",
                                    "startDate": "2020-02-20"
                                },
                                "when": when,
                                "description": "str"
                            }
                        ],
                        "restDays": [
                            {
                                "restDays": [
                                    "str"
                                ],
                                "validityPeriod": {
                                    "endDate": "2020-02-20",
                                    "startDate": "2020-02-20"
                                }
                            }
                        ]
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    },
                                    "when": when,
                                    "description": "str"
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",
                                        "startDate": "2020-02-20"
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CalendarResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendar_resource_update_request(
            calendar_id=calendar_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CalendarResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def generate_holidays(
        self, calendar_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]:
        """Gets the holidays for the calendar within a date range. Start and End Dates are included in the
        calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GenerateHolidaysResponse or ServiceErrorResponse. The GenerateHolidaysResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "endDate": "2020-02-20",
                    "startDate": "2020-02-20"
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "date": "2020-02-20",
                            "names": [
                                {
                                    "calendars": [
                                        {
                                            "id": "str",
                                            "location": {
                                                "name": "str",
                                                "space": "str"
                                            },
                                            "type": "str"
                                        }
                                    ],
                                    "countries": [
                                        "str"
                                    ],
                                    "name": "str"
                                }
                            ],
                            "processingInformation": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def generate_holidays(
        self,
        calendar_id: str,
        *,
        end_date: datetime.date,
        content_type: str = "application/json",
        start_date: Optional[datetime.date] = None,
        **kwargs: Any,
    ) -> Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]:
        """Gets the holidays for the calendar within a date range. Start and End Dates are included in the
        calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01). Required.
        :paramtype end_date: ~datetime.date
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Default is today. Default value is None.
        :paramtype start_date: ~datetime.date
        :return: GenerateHolidaysResponse or ServiceErrorResponse. The GenerateHolidaysResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "date": "2020-02-20",
                            "names": [
                                {
                                    "calendars": [
                                        {
                                            "id": "str",
                                            "location": {
                                                "name": "str",
                                                "space": "str"
                                            },
                                            "type": "str"
                                        }
                                    ],
                                    "countries": [
                                        "str"
                                    ],
                                    "name": "str"
                                }
                            ],
                            "processingInformation": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def generate_holidays(
        self, calendar_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]:
        """Gets the holidays for the calendar within a date range. Start and End Dates are included in the
        calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GenerateHolidaysResponse or ServiceErrorResponse. The GenerateHolidaysResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "date": "2020-02-20",
                            "names": [
                                {
                                    "calendars": [
                                        {
                                            "id": "str",
                                            "location": {
                                                "name": "str",
                                                "space": "str"
                                            },
                                            "type": "str"
                                        }
                                    ],
                                    "countries": [
                                        "str"
                                    ],
                                    "name": "str"
                                }
                            ],
                            "processingInformation": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def generate_holidays(
        self,
        calendar_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        end_date: datetime.date = _Unset,
        start_date: Optional[datetime.date] = None,
        **kwargs: Any,
    ) -> Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]:
        """Gets the holidays for the calendar within a date range. Start and End Dates are included in the
        calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01). Required.
        :paramtype end_date: ~datetime.date
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Default is today. Default value is None.
        :paramtype start_date: ~datetime.date
        :return: GenerateHolidaysResponse or ServiceErrorResponse. The GenerateHolidaysResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "endDate": "2020-02-20",
                    "startDate": "2020-02-20"
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "date": "2020-02-20",
                            "names": [
                                {
                                    "calendars": [
                                        {
                                            "id": "str",
                                            "location": {
                                                "name": "str",
                                                "space": "str"
                                            },
                                            "type": "str"
                                        }
                                    ],
                                    "countries": [
                                        "str"
                                    ],
                                    "name": "str"
                                }
                            ],
                            "processingInformation": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if end_date is _Unset:
                raise TypeError("missing required argument: end_date")
            body = {"endDate": end_date, "startDate": start_date}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendar_resource_generate_holidays_request(
            calendar_id=calendar_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.GenerateHolidaysResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def compute_dates(
        self, calendar_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]:
        """Computes dates for the calendar according to specified conditions. Start Date is included in
        the calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ComputeDatesResponse or ServiceErrorResponse. The ComputeDatesResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "tenors": [
                        "str"
                    ],
                    "dateMovingConvention": "str",
                    "startDate": "2020-02-20"
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "endDate": "2020-02-20",
                            "processingInformation": "str",
                            "tenor": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def compute_dates(
        self,
        calendar_id: str,
        *,
        tenors: List[str],
        content_type: str = "application/json",
        start_date: Optional[datetime.date] = None,
        date_moving_convention: Optional[Union[str, _models.DateMovingConvention]] = None,
        **kwargs: Any,
    ) -> Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]:
        """Computes dates for the calendar according to specified conditions. Start Date is included in
        the calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :keyword tenors: Tenors to be added to startDate to calculate the resulted dates.
         A tenor expresses a period of time using a specific syntax. For example "1D" for one day, "2W"
         for two weeks or "3W1M" for three weeks and a month.
         There are common tenors like ON, TN, SN, SW, 1W, 2W, 1M, 2M, etc. Required.
        :paramtype tenors: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Default is Today. Default value is None.
        :paramtype start_date: ~datetime.date
        :keyword date_moving_convention: The method to adjust dates to working days. Known values are:
         "ModifiedFollowing", "NextBusinessDay", "PreviousBusinessDay", "NoMoving",
         "EveryThirdWednesday", and "BbswModifiedFollowing". Default value is None.
        :paramtype date_moving_convention: str or ~analyticsapi.models.DateMovingConvention
        :return: ComputeDatesResponse or ServiceErrorResponse. The ComputeDatesResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "endDate": "2020-02-20",
                            "processingInformation": "str",
                            "tenor": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def compute_dates(
        self, calendar_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]:
        """Computes dates for the calendar according to specified conditions. Start Date is included in
        the calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ComputeDatesResponse or ServiceErrorResponse. The ComputeDatesResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "endDate": "2020-02-20",
                            "processingInformation": "str",
                            "tenor": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def compute_dates(
        self,
        calendar_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        tenors: List[str] = _Unset,
        start_date: Optional[datetime.date] = None,
        date_moving_convention: Optional[Union[str, _models.DateMovingConvention]] = None,
        **kwargs: Any,
    ) -> Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]:
        """Computes dates for the calendar according to specified conditions. Start Date is included in
        the calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword tenors: Tenors to be added to startDate to calculate the resulted dates.
         A tenor expresses a period of time using a specific syntax. For example "1D" for one day, "2W"
         for two weeks or "3W1M" for three weeks and a month.
         There are common tenors like ON, TN, SN, SW, 1W, 2W, 1M, 2M, etc. Required.
        :paramtype tenors: list[str]
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Default is Today. Default value is None.
        :paramtype start_date: ~datetime.date
        :keyword date_moving_convention: The method to adjust dates to working days. Known values are:
         "ModifiedFollowing", "NextBusinessDay", "PreviousBusinessDay", "NoMoving",
         "EveryThirdWednesday", and "BbswModifiedFollowing". Default value is None.
        :paramtype date_moving_convention: str or ~analyticsapi.models.DateMovingConvention
        :return: ComputeDatesResponse or ServiceErrorResponse. The ComputeDatesResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "tenors": [
                        "str"
                    ],
                    "dateMovingConvention": "str",
                    "startDate": "2020-02-20"
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "endDate": "2020-02-20",
                            "processingInformation": "str",
                            "tenor": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if tenors is _Unset:
                raise TypeError("missing required argument: tenors")
            body = {"dateMovingConvention": date_moving_convention, "startDate": start_date, "tenors": tenors}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendar_resource_compute_dates_request(
            calendar_id=calendar_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ComputeDatesResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def generate_date_schedule(
        self, calendar_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]:
        """Generates a date schedule for the calendar according to specified conditions. Start and End
        Dates are included in the calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GenerateDateScheduleResponse or ServiceErrorResponse. The GenerateDateScheduleResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "frequency": "str",
                    "calendarDayOfMonth": 0,
                    "count": 0,
                    "dayOfWeek": "str",
                    "endDate": "2020-02-20",
                    "startDate": "2020-02-20"
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        "2020-02-20"
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def generate_date_schedule(
        self,
        calendar_id: str,
        *,
        frequency: Union[str, _models.Frequency],
        content_type: str = "application/json",
        start_date: Optional[datetime.date] = None,
        end_date: Optional[datetime.date] = None,
        calendar_day_of_month: Optional[int] = None,
        count: Optional[int] = None,
        day_of_week: Optional[Union[str, _models.WeekDay]] = None,
        **kwargs: Any,
    ) -> Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]:
        """Generates a date schedule for the calendar according to specified conditions. Start and End
        Dates are included in the calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :keyword frequency: The frequency of dates in the schedule which should be generated. Note that
         "Daily" refers to working days only. Known values are: "Daily", "Weekly", "BiWeekly", and
         "Monthly". Required.
        :paramtype frequency: str or ~analyticsapi.models.Frequency
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01).
         The start date must be before the end date.
         Required if endDate is in the past. Default value is None.
        :paramtype start_date: ~datetime.date
        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01).
         If startDate is not specified, endDate is used to define the list of dates from today's date
         to the end date.
         The end date must be after the start date.
         Required if count is not specified. Only one of endDate and count can be set at a time.
         Default value is None.
        :paramtype end_date: ~datetime.date
        :keyword calendar_day_of_month: The number of the day of the month. Required if frequency is
         Monthly; do not use otherwise. The minimum value is 1. The maximum value is 31. Default value
         is None.
        :paramtype calendar_day_of_month: int
        :keyword count: The number of dates to be generated, counting from the start date (or today's
         date if the start date is not set).
         It should not have a negative value.
         Required if endDate is not specified. Only one of endDate and count can be set at a time.
         Default value is None.
        :paramtype count: int
        :keyword day_of_week: The day of the week. Required if frequency is Weekly or BiWeekly; do not
         use otherwise. Known values are: "Monday", "Tuesday", "Wednesday", "Thursday", "Friday",
         "Saturday", and "Sunday". Default value is None.
        :paramtype day_of_week: str or ~analyticsapi.models.WeekDay
        :return: GenerateDateScheduleResponse or ServiceErrorResponse. The GenerateDateScheduleResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        "2020-02-20"
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def generate_date_schedule(
        self, calendar_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]:
        """Generates a date schedule for the calendar according to specified conditions. Start and End
        Dates are included in the calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GenerateDateScheduleResponse or ServiceErrorResponse. The GenerateDateScheduleResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        "2020-02-20"
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def generate_date_schedule(
        self,
        calendar_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        frequency: Union[str, _models.Frequency] = _Unset,
        start_date: Optional[datetime.date] = None,
        end_date: Optional[datetime.date] = None,
        calendar_day_of_month: Optional[int] = None,
        count: Optional[int] = None,
        day_of_week: Optional[Union[str, _models.WeekDay]] = None,
        **kwargs: Any,
    ) -> Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]:
        """Generates a date schedule for the calendar according to specified conditions. Start and End
        Dates are included in the calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword frequency: The frequency of dates in the schedule which should be generated. Note that
         "Daily" refers to working days only. Known values are: "Daily", "Weekly", "BiWeekly", and
         "Monthly". Required.
        :paramtype frequency: str or ~analyticsapi.models.Frequency
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01).
         The start date must be before the end date.
         Required if endDate is in the past. Default value is None.
        :paramtype start_date: ~datetime.date
        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01).
         If startDate is not specified, endDate is used to define the list of dates from today's date
         to the end date.
         The end date must be after the start date.
         Required if count is not specified. Only one of endDate and count can be set at a time.
         Default value is None.
        :paramtype end_date: ~datetime.date
        :keyword calendar_day_of_month: The number of the day of the month. Required if frequency is
         Monthly; do not use otherwise. The minimum value is 1. The maximum value is 31. Default value
         is None.
        :paramtype calendar_day_of_month: int
        :keyword count: The number of dates to be generated, counting from the start date (or today's
         date if the start date is not set).
         It should not have a negative value.
         Required if endDate is not specified. Only one of endDate and count can be set at a time.
         Default value is None.
        :paramtype count: int
        :keyword day_of_week: The day of the week. Required if frequency is Weekly or BiWeekly; do not
         use otherwise. Known values are: "Monday", "Tuesday", "Wednesday", "Thursday", "Friday",
         "Saturday", and "Sunday". Default value is None.
        :paramtype day_of_week: str or ~analyticsapi.models.WeekDay
        :return: GenerateDateScheduleResponse or ServiceErrorResponse. The GenerateDateScheduleResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "frequency": "str",
                    "calendarDayOfMonth": 0,
                    "count": 0,
                    "dayOfWeek": "str",
                    "endDate": "2020-02-20",
                    "startDate": "2020-02-20"
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        "2020-02-20"
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        if body is _Unset:
            if frequency is _Unset:
                raise TypeError("missing required argument: frequency")
            body = {
                "calendarDayOfMonth": calendar_day_of_month,
                "count": count,
                "dayOfWeek": day_of_week,
                "endDate": end_date,
                "frequency": frequency,
                "startDate": start_date,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendar_resource_generate_date_schedule_request(
            calendar_id=calendar_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.GenerateDateScheduleResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def count_periods(
        self, calendar_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]:
        """Counts the time periods that satisfy specified conditions. Note the use of date strings for
        convenience. Start and End Dates are included in the calculation. Only saved calendars are
        supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CountPeriodsResponse or ServiceErrorResponse. The CountPeriodsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "endDate": "2020-02-20",
                    "startDate": "2020-02-20",
                    "dayCountBasis": "str",
                    "periodType": "str"
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "count": 0,
                        "periodType": "str",
                        "processingInformation": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def count_periods(
        self,
        calendar_id: str,
        *,
        start_date: datetime.date,
        end_date: datetime.date,
        content_type: str = "application/json",
        day_count_basis: Optional[Union[str, _models.DayCountBasis]] = None,
        period_type: Optional[Union[str, _models.PeriodType]] = None,
        **kwargs: Any,
    ) -> Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]:
        """Counts the time periods that satisfy specified conditions. Note the use of date strings for
        convenience. Start and End Dates are included in the calculation. Only saved calendars are
        supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :keyword start_date: Start date for counting periods. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Required.
        :paramtype start_date: ~datetime.date
        :keyword end_date: End date for counting periods. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01). Required.
        :paramtype end_date: ~datetime.date
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword day_count_basis: The day count basis convention used to calculate the period between
         two dates. Default is Actual/Actual.
         It is used when periodType is set to Year.
         Each convention defines the number of days between two dates and the year length in days
         (basis) for the period calculation. Known values are: "Dcb_30_360", "Dcb_30_360_US",
         "Dcb_30_360_German", "Dcb_30_360_ISDA", "Dcb_30_365_ISDA", "Dcb_30_365_German",
         "Dcb_30_365_Brazil", "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
         "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364", "Dcb_Actual_365", "Dcb_Actual_Actual",
         "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252", "Dcb_Actual_365L",
         "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360", "Dcb_Actual_36525", and
         "Dcb_Actual_365_CanadianConvention". Default value is None.
        :paramtype day_count_basis: str or ~analyticsapi.models.DayCountBasis
        :keyword period_type: The method of the period calculation. Default is Day. Known values are:
         "WorkingDay", "NonWorkingDay", "Day", "Week", "Month", "Quarter", and "Year". Default value is
         None.
        :paramtype period_type: str or ~analyticsapi.models.PeriodType
        :return: CountPeriodsResponse or ServiceErrorResponse. The CountPeriodsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "count": 0,
                        "periodType": "str",
                        "processingInformation": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def count_periods(
        self, calendar_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]:
        """Counts the time periods that satisfy specified conditions. Note the use of date strings for
        convenience. Start and End Dates are included in the calculation. Only saved calendars are
        supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CountPeriodsResponse or ServiceErrorResponse. The CountPeriodsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "count": 0,
                        "periodType": "str",
                        "processingInformation": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def count_periods(
        self,
        calendar_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        start_date: datetime.date = _Unset,
        end_date: datetime.date = _Unset,
        day_count_basis: Optional[Union[str, _models.DayCountBasis]] = None,
        period_type: Optional[Union[str, _models.PeriodType]] = None,
        **kwargs: Any,
    ) -> Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]:
        """Counts the time periods that satisfy specified conditions. Note the use of date strings for
        convenience. Start and End Dates are included in the calculation. Only saved calendars are
        supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword start_date: Start date for counting periods. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Required.
        :paramtype start_date: ~datetime.date
        :keyword end_date: End date for counting periods. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01). Required.
        :paramtype end_date: ~datetime.date
        :keyword day_count_basis: The day count basis convention used to calculate the period between
         two dates. Default is Actual/Actual.
         It is used when periodType is set to Year.
         Each convention defines the number of days between two dates and the year length in days
         (basis) for the period calculation. Known values are: "Dcb_30_360", "Dcb_30_360_US",
         "Dcb_30_360_German", "Dcb_30_360_ISDA", "Dcb_30_365_ISDA", "Dcb_30_365_German",
         "Dcb_30_365_Brazil", "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
         "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364", "Dcb_Actual_365", "Dcb_Actual_Actual",
         "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252", "Dcb_Actual_365L",
         "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360", "Dcb_Actual_36525", and
         "Dcb_Actual_365_CanadianConvention". Default value is None.
        :paramtype day_count_basis: str or ~analyticsapi.models.DayCountBasis
        :keyword period_type: The method of the period calculation. Default is Day. Known values are:
         "WorkingDay", "NonWorkingDay", "Day", "Week", "Month", "Quarter", and "Year". Default value is
         None.
        :paramtype period_type: str or ~analyticsapi.models.PeriodType
        :return: CountPeriodsResponse or ServiceErrorResponse. The CountPeriodsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "endDate": "2020-02-20",
                    "startDate": "2020-02-20",
                    "dayCountBasis": "str",
                    "periodType": "str"
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "count": 0,
                        "periodType": "str",
                        "processingInformation": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if start_date is _Unset:
                raise TypeError("missing required argument: start_date")
            if end_date is _Unset:
                raise TypeError("missing required argument: end_date")
            body = {
                "dayCountBasis": day_count_basis,
                "endDate": end_date,
                "periodType": period_type,
                "startDate": start_date,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendar_resource_count_periods_request(
            calendar_id=calendar_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CountPeriodsResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class crossCurrenciesResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`cross_currencies_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        names: Optional[List[str]] = None,
        spaces: Optional[List[str]] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Union[_models.CrossCurrencyCollectionResponse, _models.ServiceErrorResponse]:
        """Search resources via combination of name, space and tags.

        :keyword item_per_page: The maximum number of items for each search request. The valid range is
         1-500. If not provided, 50 will be used. Default value is None.
        :paramtype item_per_page: int
        :keyword names: The list of resource names to be searched. Exact match is applied for each
         name. Default value is None.
        :paramtype names: list[str]
        :keyword spaces: The space where the resource is stored. Space is like a namespace where
         resources are stored. By default there are two spaces:
         LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space. If
         space is not specified, HOME will be used. Default value is None.
        :paramtype spaces: list[str]
        :keyword tags: The list of resource tags to be searched. Default value is None.
        :paramtype tags: list[str]
        :return: CrossCurrencyCollectionResponse or ServiceErrorResponse. The
         CrossCurrencyCollectionResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyCollectionResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "description": {
                                "summary": "str",
                                "tags": [
                                    "str"
                                ]
                            },
                            "id": "str",
                            "type": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.CrossCurrencyCollectionResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        _request = build_cross_currencies_resource_list_request(
            item_per_page=item_per_page,
            names=names,
            spaces=spaces,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CrossCurrencyCollectionResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossRatePrecision": 0,
                        "crossScalingFactor": 0.0,
                        "spotLag": 0,
                        "swapPointPrecision": 0,
                        "swapPointScalingFactor": 0.0
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,
                            "crossScalingFactor": 0.0,
                            "spotLag": 0,
                            "swapPointPrecision": 0,
                            "swapPointScalingFactor": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def create(
        self,
        *,
        location: _models.Location,
        definition: _models.CrossCurrencyDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.CrossCurrencyDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,
                            "crossScalingFactor": 0.0,
                            "spotLag": 0,
                            "swapPointPrecision": 0,
                            "swapPointScalingFactor": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,
                            "crossScalingFactor": 0.0,
                            "spotLag": 0,
                            "swapPointPrecision": 0,
                            "swapPointScalingFactor": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def create(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.CrossCurrencyDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.CrossCurrencyDefinition
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossRatePrecision": 0,
                        "crossScalingFactor": 0.0,
                        "spotLag": 0,
                        "swapPointPrecision": 0,
                        "swapPointScalingFactor": 0.0
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,
                            "crossScalingFactor": 0.0,
                            "spotLag": 0,
                            "swapPointPrecision": 0,
                            "swapPointScalingFactor": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_cross_currencies_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        response_headers = {}
        if response.status_code == 201:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CrossCurrencyResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class crossCurrencyResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`cross_currency_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def read(
        self, cross_currency_id: str, **kwargs: Any
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        """Read resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,
                            "crossScalingFactor": 0.0,
                            "spotLag": 0,
                            "swapPointPrecision": 0,
                            "swapPointScalingFactor": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_cross_currency_resource_read_request(
            cross_currency_id=cross_currency_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CrossCurrencyResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def delete(self, cross_currency_id: str, **kwargs: Any) -> Optional[_models.ServiceErrorResponse]:
        """Delete resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :return: ServiceErrorResponse or None. The ServiceErrorResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ServiceErrorResponse or None
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_cross_currency_resource_delete_request(
            cross_currency_id=cross_currency_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            204,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        deserialized = None
        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def overwrite(
        self, cross_currency_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossRatePrecision": 0,
                        "crossScalingFactor": 0.0,
                        "spotLag": 0,
                        "swapPointPrecision": 0,
                        "swapPointScalingFactor": 0.0
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,
                            "crossScalingFactor": 0.0,
                            "spotLag": 0,
                            "swapPointPrecision": 0,
                            "swapPointScalingFactor": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def overwrite(
        self,
        cross_currency_id: str,
        *,
        location: _models.Location,
        definition: _models.CrossCurrencyDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.CrossCurrencyDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,
                            "crossScalingFactor": 0.0,
                            "spotLag": 0,
                            "swapPointPrecision": 0,
                            "swapPointScalingFactor": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def overwrite(
        self, cross_currency_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,
                            "crossScalingFactor": 0.0,
                            "spotLag": 0,
                            "swapPointPrecision": 0,
                            "swapPointScalingFactor": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def overwrite(
        self,
        cross_currency_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.CrossCurrencyDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.CrossCurrencyDefinition
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossRatePrecision": 0,
                        "crossScalingFactor": 0.0,
                        "spotLag": 0,
                        "swapPointPrecision": 0,
                        "swapPointScalingFactor": 0.0
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,
                            "crossScalingFactor": 0.0,
                            "spotLag": 0,
                            "swapPointPrecision": 0,
                            "swapPointScalingFactor": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_cross_currency_resource_overwrite_request(
            cross_currency_id=cross_currency_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CrossCurrencyResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(
        self, cross_currency_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossRatePrecision": 0,
                        "crossScalingFactor": 0.0,
                        "spotLag": 0,
                        "swapPointPrecision": 0,
                        "swapPointScalingFactor": 0.0
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,
                            "crossScalingFactor": 0.0,
                            "spotLag": 0,
                            "swapPointPrecision": 0,
                            "swapPointScalingFactor": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def update(
        self,
        cross_currency_id: str,
        *,
        location: _models.Location,
        definition: _models.CrossCurrencyDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.CrossCurrencyDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,
                            "crossScalingFactor": 0.0,
                            "spotLag": 0,
                            "swapPointPrecision": 0,
                            "swapPointScalingFactor": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def update(
        self, cross_currency_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,
                            "crossScalingFactor": 0.0,
                            "spotLag": 0,
                            "swapPointPrecision": 0,
                            "swapPointScalingFactor": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def update(
        self,
        cross_currency_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.CrossCurrencyDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.CrossCurrencyDefinition
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossRatePrecision": 0,
                        "crossScalingFactor": 0.0,
                        "spotLag": 0,
                        "swapPointPrecision": 0,
                        "swapPointScalingFactor": 0.0
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,
                            "crossScalingFactor": 0.0,
                            "spotLag": 0,
                            "swapPointPrecision": 0,
                            "swapPointScalingFactor": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_cross_currency_resource_update_request(
            cross_currency_id=cross_currency_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CrossCurrencyResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class currenciesResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`currencies_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        names: Optional[List[str]] = None,
        spaces: Optional[List[str]] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Union[_models.CurrencyCollectionResponse, _models.ServiceErrorResponse]:
        """Search resources via combination of name, space and tags.

        :keyword item_per_page: The maximum number of items for each search request. The valid range is
         1-500. If not provided, 50 will be used. Default value is None.
        :paramtype item_per_page: int
        :keyword names: The list of resource names to be searched. Exact match is applied for each
         name. Default value is None.
        :paramtype names: list[str]
        :keyword spaces: The space where the resource is stored. Space is like a namespace where
         resources are stored. By default there are two spaces:
         LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space. If
         space is not specified, HOME will be used. Default value is None.
        :paramtype spaces: list[str]
        :keyword tags: The list of resource tags to be searched. Default value is None.
        :paramtype tags: list[str]
        :return: CurrencyCollectionResponse or ServiceErrorResponse. The CurrencyCollectionResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.CurrencyCollectionResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "description": {
                                "summary": "str",
                                "tags": [
                                    "str"
                                ]
                            },
                            "id": "str",
                            "type": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.CurrencyCollectionResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_currencies_resource_list_request(
            item_per_page=item_per_page,
            names=names,
            spaces=spaces,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CurrencyCollectionResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "calendar": {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        },
                        "spotLag": 0,
                        "yearBasis": "str"
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",
                                "location": {
                                    "name": "str",
                                    "space": "str"
                                },
                                "type": "str"
                            },
                            "spotLag": 0,
                            "yearBasis": "str"
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def create(
        self,
        *,
        location: _models.Location,
        definition: _models.CurrencyDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.CurrencyDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",
                                "location": {
                                    "name": "str",
                                    "space": "str"
                                },
                                "type": "str"
                            },
                            "spotLag": 0,
                            "yearBasis": "str"
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",
                                "location": {
                                    "name": "str",
                                    "space": "str"
                                },
                                "type": "str"
                            },
                            "spotLag": 0,
                            "yearBasis": "str"
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def create(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.CurrencyDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.CurrencyDefinition
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "calendar": {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        },
                        "spotLag": 0,
                        "yearBasis": "str"
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",
                                "location": {
                                    "name": "str",
                                    "space": "str"
                                },
                                "type": "str"
                            },
                            "spotLag": 0,
                            "yearBasis": "str"
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CurrencyResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_currencies_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        response_headers = {}
        if response.status_code == 201:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CurrencyResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class currencyResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`currency_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def read(self, currency_id: str, **kwargs: Any) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        """Read resource.

        :param currency_id: Required.
        :type currency_id: str
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",
                                "location": {
                                    "name": "str",
                                    "space": "str"
                                },
                                "type": "str"
                            },
                            "spotLag": 0,
                            "yearBasis": "str"
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.CurrencyResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_currency_resource_read_request(
            currency_id=currency_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CurrencyResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def delete(self, currency_id: str, **kwargs: Any) -> Optional[_models.ServiceErrorResponse]:
        """Delete resource.

        :param currency_id: Required.
        :type currency_id: str
        :return: ServiceErrorResponse or None. The ServiceErrorResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ServiceErrorResponse or None
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_currency_resource_delete_request(
            currency_id=currency_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            204,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        deserialized = None
        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def overwrite(
        self, currency_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param currency_id: Required.
        :type currency_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "calendar": {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        },
                        "spotLag": 0,
                        "yearBasis": "str"
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",
                                "location": {
                                    "name": "str",
                                    "space": "str"
                                },
                                "type": "str"
                            },
                            "spotLag": 0,
                            "yearBasis": "str"
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def overwrite(
        self,
        currency_id: str,
        *,
        location: _models.Location,
        definition: _models.CurrencyDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param currency_id: Required.
        :type currency_id: str
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.CurrencyDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",
                                "location": {
                                    "name": "str",
                                    "space": "str"
                                },
                                "type": "str"
                            },
                            "spotLag": 0,
                            "yearBasis": "str"
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def overwrite(
        self, currency_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param currency_id: Required.
        :type currency_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",
                                "location": {
                                    "name": "str",
                                    "space": "str"
                                },
                                "type": "str"
                            },
                            "spotLag": 0,
                            "yearBasis": "str"
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def overwrite(
        self,
        currency_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.CurrencyDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param currency_id: Required.
        :type currency_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.CurrencyDefinition
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "calendar": {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        },
                        "spotLag": 0,
                        "yearBasis": "str"
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",
                                "location": {
                                    "name": "str",
                                    "space": "str"
                                },
                                "type": "str"
                            },
                            "spotLag": 0,
                            "yearBasis": "str"
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CurrencyResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_currency_resource_overwrite_request(
            currency_id=currency_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CurrencyResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(
        self, currency_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param currency_id: Required.
        :type currency_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "calendar": {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        },
                        "spotLag": 0,
                        "yearBasis": "str"
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",
                                "location": {
                                    "name": "str",
                                    "space": "str"
                                },
                                "type": "str"
                            },
                            "spotLag": 0,
                            "yearBasis": "str"
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def update(
        self,
        currency_id: str,
        *,
        location: _models.Location,
        definition: _models.CurrencyDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param currency_id: Required.
        :type currency_id: str
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.CurrencyDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",
                                "location": {
                                    "name": "str",
                                    "space": "str"
                                },
                                "type": "str"
                            },
                            "spotLag": 0,
                            "yearBasis": "str"
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def update(
        self, currency_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param currency_id: Required.
        :type currency_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",
                                "location": {
                                    "name": "str",
                                    "space": "str"
                                },
                                "type": "str"
                            },
                            "spotLag": 0,
                            "yearBasis": "str"
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def update(
        self,
        currency_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.CurrencyDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param currency_id: Required.
        :type currency_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.CurrencyDefinition
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "calendar": {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        },
                        "spotLag": 0,
                        "yearBasis": "str"
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",
                                "location": {
                                    "name": "str",
                                    "space": "str"
                                },
                                "type": "str"
                            },
                            "spotLag": 0,
                            "yearBasis": "str"
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CurrencyResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_currency_resource_update_request(
            currency_id=currency_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CurrencyResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class fxForwardCurvesResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`fx_forward_curves_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        names: Optional[List[str]] = None,
        spaces: Optional[List[str]] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardCurveCollectionResponse, _models.ServiceErrorResponse]:
        """Search resources via combination of name, space and tags.

        :keyword item_per_page: The maximum number of items for each search request. The valid range is
         1-500. If not provided, 50 will be used. Default value is None.
        :paramtype item_per_page: int
        :keyword names: The list of resource names to be searched. Exact match is applied for each
         name. Default value is None.
        :paramtype names: list[str]
        :keyword spaces: The space where the resource is stored. Space is like a namespace where
         resources are stored. By default there are two spaces:
         LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space. If
         space is not specified, HOME will be used. Default value is None.
        :paramtype spaces: list[str]
        :keyword tags: The list of resource tags to be searched. Default value is None.
        :paramtype tags: list[str]
        :return: FxForwardCurveCollectionResponse or ServiceErrorResponse. The
         FxForwardCurveCollectionResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCollectionResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "description": {
                                "summary": "str",
                                "tags": [
                                    "str"
                                ]
                            },
                            "id": "str",
                            "type": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.FxForwardCurveCollectionResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        _request = build_fx_forward_curves_resource_list_request(
            item_per_page=item_per_page,
            names=names,
            spaces=spaces,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardCurveCollectionResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossCurrency": {
                            "code": "str"
                        },
                        "constituents": [
                            fx_forward_curve_constituent
                        ],
                        "referenceCurrency": {
                            "code": "str"
                        }
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def create(
        self,
        *,
        location: _models.Location,
        definition: _models.FxForwardCurveDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxForwardCurveDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def create(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.FxForwardCurveDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxForwardCurveDefinition
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossCurrency": {
                            "code": "str"
                        },
                        "constituents": [
                            fx_forward_curve_constituent
                        ],
                        "referenceCurrency": {
                            "code": "str"
                        }
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curves_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        response_headers = {}
        if response.status_code == 201:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardCurveResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_definition_from_fx_forwards_in_direct(  # pylint: disable=name-too-long
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]:
        """Create fx forward curve using Fx Forward constituents - via reference currency.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BuildDirectFromDepositsResponse or ServiceErrorResponse. The
         BuildDirectFromDepositsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildDirectFromDepositsResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "crossCurrency": {
                        "code": "str"
                    },
                    "additionalTenorTypes": [
                        "str"
                    ],
                    "referenceCurrency": {
                        "code": "str"
                    },
                    "sources": {
                        "baseFxForwards": "str",
                        "baseFxSpot": "str",
                        "quotedFxForwards": "str",
                        "quotedFxSpot": "str"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "type": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def create_definition_from_fx_forwards_in_direct(  # pylint: disable=name-too-long
        self,
        *,
        cross_currency: _models.CrossCurrencyInput,
        content_type: str = "application/json",
        reference_currency: Optional[_models.CurrencyInput] = None,
        additional_tenor_types: Optional[List[Union[str, _models.TenorType]]] = None,
        sources: Optional[_models.IndirectSourcesSwaps] = None,
        **kwargs: Any,
    ) -> Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]:
        """Create fx forward curve using Fx Forward constituents - via reference currency.

        :keyword cross_currency: A string to define the currency pair of the curve. Required.
        :paramtype cross_currency: ~analyticsapi.models.CrossCurrencyInput
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword reference_currency: A string to define the reference currency for the cross-currency
         pair of the curve. Default is the base currency of the specified cross currency pair. Default
         value is None.
        :paramtype reference_currency: ~analyticsapi.models.CurrencyInput
        :keyword additional_tenor_types: An array of tenor types that can be used for instruments in
         addition to the standard tenor. When passing a string value, it must be one of the TenorType
         values. Default value is None.
        :paramtype additional_tenor_types: list[str or ~analyticsapi.models.TenorType]
        :keyword sources: An object that defines the sources containing the market data for the
         instruments used to create the curve definition. Default value is None.
        :paramtype sources: ~analyticsapi.models.IndirectSourcesSwaps
        :return: BuildDirectFromDepositsResponse or ServiceErrorResponse. The
         BuildDirectFromDepositsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildDirectFromDepositsResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "type": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def create_definition_from_fx_forwards_in_direct(  # pylint: disable=name-too-long
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]:
        """Create fx forward curve using Fx Forward constituents - via reference currency.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BuildDirectFromDepositsResponse or ServiceErrorResponse. The
         BuildDirectFromDepositsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildDirectFromDepositsResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "type": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def create_definition_from_fx_forwards_in_direct(  # pylint: disable=name-too-long
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        cross_currency: _models.CrossCurrencyInput = _Unset,
        reference_currency: Optional[_models.CurrencyInput] = None,
        additional_tenor_types: Optional[List[Union[str, _models.TenorType]]] = None,
        sources: Optional[_models.IndirectSourcesSwaps] = None,
        **kwargs: Any,
    ) -> Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]:
        """Create fx forward curve using Fx Forward constituents - via reference currency.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword cross_currency: A string to define the currency pair of the curve. Required.
        :paramtype cross_currency: ~analyticsapi.models.CrossCurrencyInput
        :keyword reference_currency: A string to define the reference currency for the cross-currency
         pair of the curve. Default is the base currency of the specified cross currency pair. Default
         value is None.
        :paramtype reference_currency: ~analyticsapi.models.CurrencyInput
        :keyword additional_tenor_types: An array of tenor types that can be used for instruments in
         addition to the standard tenor. When passing a string value, it must be one of the TenorType
         values. Default value is None.
        :paramtype additional_tenor_types: list[str or ~analyticsapi.models.TenorType]
        :keyword sources: An object that defines the sources containing the market data for the
         instruments used to create the curve definition. Default value is None.
        :paramtype sources: ~analyticsapi.models.IndirectSourcesSwaps
        :return: BuildDirectFromDepositsResponse or ServiceErrorResponse. The
         BuildDirectFromDepositsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildDirectFromDepositsResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "crossCurrency": {
                        "code": "str"
                    },
                    "additionalTenorTypes": [
                        "str"
                    ],
                    "referenceCurrency": {
                        "code": "str"
                    },
                    "sources": {
                        "baseFxForwards": "str",
                        "baseFxSpot": "str",
                        "quotedFxForwards": "str",
                        "quotedFxSpot": "str"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "type": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        if body is _Unset:
            if cross_currency is _Unset:
                raise TypeError("missing required argument: cross_currency")
            body = {
                "additionalTenorTypes": additional_tenor_types,
                "crossCurrency": cross_currency,
                "referenceCurrency": reference_currency,
                "sources": sources,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curves_resource_create_definition_from_fx_forwards_in_direct_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.BuildDirectFromDepositsResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_definition_from_deposits_in_direct(  # pylint: disable=name-too-long
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]:
        """Create fx forward curve using Deposit constituents - via reference currency.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BuildDirectFromDepositsResponse or ServiceErrorResponse. The
         BuildDirectFromDepositsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildDirectFromDepositsResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "crossCurrency": {
                        "code": "str"
                    },
                    "additionalTenorTypes": [
                        "str"
                    ],
                    "referenceCurrency": {
                        "code": "str"
                    },
                    "sources": {
                        "baseDeposit": "str",
                        "baseFxSpot": "str",
                        "quotedDeposit": "str",
                        "quotedFxSpot": "str"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "type": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def create_definition_from_deposits_in_direct(  # pylint: disable=name-too-long
        self,
        *,
        cross_currency: _models.CrossCurrencyInput,
        content_type: str = "application/json",
        reference_currency: Optional[_models.CurrencyInput] = None,
        additional_tenor_types: Optional[List[Union[str, _models.TenorType]]] = None,
        sources: Optional[_models.IndirectSourcesDeposits] = None,
        **kwargs: Any,
    ) -> Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]:
        """Create fx forward curve using Deposit constituents - via reference currency.

        :keyword cross_currency: A string to define the currency pair of the curve. Required.
        :paramtype cross_currency: ~analyticsapi.models.CrossCurrencyInput
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword reference_currency: A string to define the reference currency for the cross-currency
         pair of the curve. Default is the base currency of the specified cross currency pair. Default
         value is None.
        :paramtype reference_currency: ~analyticsapi.models.CurrencyInput
        :keyword additional_tenor_types: An array of tenor types that can be used for instruments in
         addition to the standard tenor. When passing a string value, it must be one of the TenorType
         values. Default value is None.
        :paramtype additional_tenor_types: list[str or ~analyticsapi.models.TenorType]
        :keyword sources: An object that defines the sources containing the market data for the
         instruments used to create the curve definition. Default value is None.
        :paramtype sources: ~analyticsapi.models.IndirectSourcesDeposits
        :return: BuildDirectFromDepositsResponse or ServiceErrorResponse. The
         BuildDirectFromDepositsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildDirectFromDepositsResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "type": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def create_definition_from_deposits_in_direct(  # pylint: disable=name-too-long
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]:
        """Create fx forward curve using Deposit constituents - via reference currency.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BuildDirectFromDepositsResponse or ServiceErrorResponse. The
         BuildDirectFromDepositsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildDirectFromDepositsResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "type": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def create_definition_from_deposits_in_direct(  # pylint: disable=name-too-long
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        cross_currency: _models.CrossCurrencyInput = _Unset,
        reference_currency: Optional[_models.CurrencyInput] = None,
        additional_tenor_types: Optional[List[Union[str, _models.TenorType]]] = None,
        sources: Optional[_models.IndirectSourcesDeposits] = None,
        **kwargs: Any,
    ) -> Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]:
        """Create fx forward curve using Deposit constituents - via reference currency.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword cross_currency: A string to define the currency pair of the curve. Required.
        :paramtype cross_currency: ~analyticsapi.models.CrossCurrencyInput
        :keyword reference_currency: A string to define the reference currency for the cross-currency
         pair of the curve. Default is the base currency of the specified cross currency pair. Default
         value is None.
        :paramtype reference_currency: ~analyticsapi.models.CurrencyInput
        :keyword additional_tenor_types: An array of tenor types that can be used for instruments in
         addition to the standard tenor. When passing a string value, it must be one of the TenorType
         values. Default value is None.
        :paramtype additional_tenor_types: list[str or ~analyticsapi.models.TenorType]
        :keyword sources: An object that defines the sources containing the market data for the
         instruments used to create the curve definition. Default value is None.
        :paramtype sources: ~analyticsapi.models.IndirectSourcesDeposits
        :return: BuildDirectFromDepositsResponse or ServiceErrorResponse. The
         BuildDirectFromDepositsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildDirectFromDepositsResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "crossCurrency": {
                        "code": "str"
                    },
                    "additionalTenorTypes": [
                        "str"
                    ],
                    "referenceCurrency": {
                        "code": "str"
                    },
                    "sources": {
                        "baseDeposit": "str",
                        "baseFxSpot": "str",
                        "quotedDeposit": "str",
                        "quotedFxSpot": "str"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "type": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        if body is _Unset:
            if cross_currency is _Unset:
                raise TypeError("missing required argument: cross_currency")
            body = {
                "additionalTenorTypes": additional_tenor_types,
                "crossCurrency": cross_currency,
                "referenceCurrency": reference_currency,
                "sources": sources,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curves_resource_create_definition_from_deposits_in_direct_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.BuildDirectFromDepositsResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def calculate_on_the_fly(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveCalculateOnTheFlyResponse, _models.ServiceErrorResponse]:
        """Calculate fx forward curve points from curve constituents - on the fly.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardCurveCalculateOnTheFlyResponse or ServiceErrorResponse. The
         FxForwardCurveCalculateOnTheFlyResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateOnTheFlyResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossCurrency": {
                            "code": "str"
                        },
                        "constituents": [
                            fx_forward_curve_constituent
                        ],
                        "referenceCurrency": {
                            "code": "str"
                        }
                    },
                    "parameters": {
                        "fxForwardCurveCalculationPreferences": {
                            "adjustAllDepositPointsToCrossCalendars": bool,
                            "adjustAllSwapPointsToCrossCalendars": bool,
                            "extrapolationMode": "str",
                            "ignoreInvalidInstruments": bool,
                            "ignorePivotCurrencyHolidays": bool,
                            "interpolationMode": "str",
                            "useDelayedDataIfDenied": bool
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "parameters": {
                            "fxForwardCurveCalculationPreferences": {
                                "adjustAllDepositPointsToCrossCalendars": bool,
                                "adjustAllSwapPointsToCrossCalendars": bool,
                                "extrapolationMode": "str",
                                "ignoreInvalidInstruments": bool,
                                "ignorePivotCurrencyHolidays": bool,
                                "interpolationMode": "str",
                                "useDelayedDataIfDenied": bool
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "curve": {
                            "constituents": [
                                fx_forward_curve_constituent_values
                            ],
                            "curvePoints": [
                                {
                                    "endDate": "2020-02-20",
                                    "outright": {
                                        "ask": 0.0,
                                        "bid": 0.0,
                                        "mid": 0.0
                                    },
                                    "startDate": "2020-02-20",
                                    "swapPoint": {
                                        "ask": 0.0,
                                        "bid": 0.0,
                                        "mid": 0.0
                                    },
                                    "tenor": "str",
                                    "instruments": [
                                        {
                                            "instrumentCode": "str"
                                        }
                                    ]
                                }
                            ],
                            "invalidConstituents": [
                                fx_invalid_constituent
                            ],
                            "underlyingCurves": {
                                "fxForwardCurves": [
                                    {
                                        "crossCurrency": {
                                            "code": "str"
                                        },
                                        "curvePoints": [
                                            {
                                                "endDate":
                                                  "2020-02-20",
                                                "outright": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "startDate":
                                                  "2020-02-20",
                                                "swapPoint": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "tenor": "str",
                                                "instruments": [
                                                    {
                "instrumentCode": "str"
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ],
                                "interestRateCurves": [
                                    {
                                        "currency": {
                                            "code": "str"
                                        },
                                        "curvePoints": [
                                            {
                                                "discountFactor":
                                                  0.0,
                                                "endDate":
                                                  "2020-02-20",
                                                "ratePercent": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "startDate":
                                                  "2020-02-20",
                                                "tenor": "str",
                                                "instruments": [
                                                    {
                "instrumentCode": "str"
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def calculate_on_the_fly(
        self,
        *,
        definition: _models.FxForwardCurveDefinition,
        content_type: str = "application/json",
        parameters: Optional[_models.FxForwardCurvePricingParameters] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardCurveCalculateOnTheFlyResponse, _models.ServiceErrorResponse]:
        """Calculate fx forward curve points from curve constituents - on the fly.

        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxForwardCurveDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.FxForwardCurvePricingParameters
        :return: FxForwardCurveCalculateOnTheFlyResponse or ServiceErrorResponse. The
         FxForwardCurveCalculateOnTheFlyResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateOnTheFlyResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "parameters": {
                            "fxForwardCurveCalculationPreferences": {
                                "adjustAllDepositPointsToCrossCalendars": bool,
                                "adjustAllSwapPointsToCrossCalendars": bool,
                                "extrapolationMode": "str",
                                "ignoreInvalidInstruments": bool,
                                "ignorePivotCurrencyHolidays": bool,
                                "interpolationMode": "str",
                                "useDelayedDataIfDenied": bool
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "curve": {
                            "constituents": [
                                fx_forward_curve_constituent_values
                            ],
                            "curvePoints": [
                                {
                                    "endDate": "2020-02-20",
                                    "outright": {
                                        "ask": 0.0,
                                        "bid": 0.0,
                                        "mid": 0.0
                                    },
                                    "startDate": "2020-02-20",
                                    "swapPoint": {
                                        "ask": 0.0,
                                        "bid": 0.0,
                                        "mid": 0.0
                                    },
                                    "tenor": "str",
                                    "instruments": [
                                        {
                                            "instrumentCode": "str"
                                        }
                                    ]
                                }
                            ],
                            "invalidConstituents": [
                                fx_invalid_constituent
                            ],
                            "underlyingCurves": {
                                "fxForwardCurves": [
                                    {
                                        "crossCurrency": {
                                            "code": "str"
                                        },
                                        "curvePoints": [
                                            {
                                                "endDate":
                                                  "2020-02-20",
                                                "outright": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "startDate":
                                                  "2020-02-20",
                                                "swapPoint": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "tenor": "str",
                                                "instruments": [
                                                    {
                "instrumentCode": "str"
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ],
                                "interestRateCurves": [
                                    {
                                        "currency": {
                                            "code": "str"
                                        },
                                        "curvePoints": [
                                            {
                                                "discountFactor":
                                                  0.0,
                                                "endDate":
                                                  "2020-02-20",
                                                "ratePercent": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "startDate":
                                                  "2020-02-20",
                                                "tenor": "str",
                                                "instruments": [
                                                    {
                "instrumentCode": "str"
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def calculate_on_the_fly(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveCalculateOnTheFlyResponse, _models.ServiceErrorResponse]:
        """Calculate fx forward curve points from curve constituents - on the fly.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardCurveCalculateOnTheFlyResponse or ServiceErrorResponse. The
         FxForwardCurveCalculateOnTheFlyResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateOnTheFlyResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "parameters": {
                            "fxForwardCurveCalculationPreferences": {
                                "adjustAllDepositPointsToCrossCalendars": bool,
                                "adjustAllSwapPointsToCrossCalendars": bool,
                                "extrapolationMode": "str",
                                "ignoreInvalidInstruments": bool,
                                "ignorePivotCurrencyHolidays": bool,
                                "interpolationMode": "str",
                                "useDelayedDataIfDenied": bool
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "curve": {
                            "constituents": [
                                fx_forward_curve_constituent_values
                            ],
                            "curvePoints": [
                                {
                                    "endDate": "2020-02-20",
                                    "outright": {
                                        "ask": 0.0,
                                        "bid": 0.0,
                                        "mid": 0.0
                                    },
                                    "startDate": "2020-02-20",
                                    "swapPoint": {
                                        "ask": 0.0,
                                        "bid": 0.0,
                                        "mid": 0.0
                                    },
                                    "tenor": "str",
                                    "instruments": [
                                        {
                                            "instrumentCode": "str"
                                        }
                                    ]
                                }
                            ],
                            "invalidConstituents": [
                                fx_invalid_constituent
                            ],
                            "underlyingCurves": {
                                "fxForwardCurves": [
                                    {
                                        "crossCurrency": {
                                            "code": "str"
                                        },
                                        "curvePoints": [
                                            {
                                                "endDate":
                                                  "2020-02-20",
                                                "outright": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "startDate":
                                                  "2020-02-20",
                                                "swapPoint": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "tenor": "str",
                                                "instruments": [
                                                    {
                "instrumentCode": "str"
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ],
                                "interestRateCurves": [
                                    {
                                        "currency": {
                                            "code": "str"
                                        },
                                        "curvePoints": [
                                            {
                                                "discountFactor":
                                                  0.0,
                                                "endDate":
                                                  "2020-02-20",
                                                "ratePercent": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "startDate":
                                                  "2020-02-20",
                                                "tenor": "str",
                                                "instruments": [
                                                    {
                "instrumentCode": "str"
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def calculate_on_the_fly(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definition: _models.FxForwardCurveDefinition = _Unset,
        parameters: Optional[_models.FxForwardCurvePricingParameters] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardCurveCalculateOnTheFlyResponse, _models.ServiceErrorResponse]:
        """Calculate fx forward curve points from curve constituents - on the fly.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxForwardCurveDefinition
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.FxForwardCurvePricingParameters
        :return: FxForwardCurveCalculateOnTheFlyResponse or ServiceErrorResponse. The
         FxForwardCurveCalculateOnTheFlyResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateOnTheFlyResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossCurrency": {
                            "code": "str"
                        },
                        "constituents": [
                            fx_forward_curve_constituent
                        ],
                        "referenceCurrency": {
                            "code": "str"
                        }
                    },
                    "parameters": {
                        "fxForwardCurveCalculationPreferences": {
                            "adjustAllDepositPointsToCrossCalendars": bool,
                            "adjustAllSwapPointsToCrossCalendars": bool,
                            "extrapolationMode": "str",
                            "ignoreInvalidInstruments": bool,
                            "ignorePivotCurrencyHolidays": bool,
                            "interpolationMode": "str",
                            "useDelayedDataIfDenied": bool
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "parameters": {
                            "fxForwardCurveCalculationPreferences": {
                                "adjustAllDepositPointsToCrossCalendars": bool,
                                "adjustAllSwapPointsToCrossCalendars": bool,
                                "extrapolationMode": "str",
                                "ignoreInvalidInstruments": bool,
                                "ignorePivotCurrencyHolidays": bool,
                                "interpolationMode": "str",
                                "useDelayedDataIfDenied": bool
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "curve": {
                            "constituents": [
                                fx_forward_curve_constituent_values
                            ],
                            "curvePoints": [
                                {
                                    "endDate": "2020-02-20",
                                    "outright": {
                                        "ask": 0.0,
                                        "bid": 0.0,
                                        "mid": 0.0
                                    },
                                    "startDate": "2020-02-20",
                                    "swapPoint": {
                                        "ask": 0.0,
                                        "bid": 0.0,
                                        "mid": 0.0
                                    },
                                    "tenor": "str",
                                    "instruments": [
                                        {
                                            "instrumentCode": "str"
                                        }
                                    ]
                                }
                            ],
                            "invalidConstituents": [
                                fx_invalid_constituent
                            ],
                            "underlyingCurves": {
                                "fxForwardCurves": [
                                    {
                                        "crossCurrency": {
                                            "code": "str"
                                        },
                                        "curvePoints": [
                                            {
                                                "endDate":
                                                  "2020-02-20",
                                                "outright": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "startDate":
                                                  "2020-02-20",
                                                "swapPoint": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "tenor": "str",
                                                "instruments": [
                                                    {
                "instrumentCode": "str"
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ],
                                "interestRateCurves": [
                                    {
                                        "currency": {
                                            "code": "str"
                                        },
                                        "curvePoints": [
                                            {
                                                "discountFactor":
                                                  0.0,
                                                "endDate":
                                                  "2020-02-20",
                                                "ratePercent": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "startDate":
                                                  "2020-02-20",
                                                "tenor": "str",
                                                "instruments": [
                                                    {
                "instrumentCode": "str"
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardCurveCalculateOnTheFlyResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        if body is _Unset:
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "parameters": parameters}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curves_resource_calculate_on_the_fly_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardCurveCalculateOnTheFlyResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class fxForwardCurveResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`fx_forward_curve_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def read(self, curve_id: str, **kwargs: Any) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        """Read resource.

        :param curve_id: Required.
        :type curve_id: str
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_fx_forward_curve_resource_read_request(
            curve_id=curve_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardCurveResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def delete(self, curve_id: str, **kwargs: Any) -> Optional[_models.ServiceErrorResponse]:
        """Delete resource.

        :param curve_id: Required.
        :type curve_id: str
        :return: ServiceErrorResponse or None. The ServiceErrorResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ServiceErrorResponse or None
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_fx_forward_curve_resource_delete_request(
            curve_id=curve_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            204,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        deserialized = None
        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def overwrite(
        self, curve_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossCurrency": {
                            "code": "str"
                        },
                        "constituents": [
                            fx_forward_curve_constituent
                        ],
                        "referenceCurrency": {
                            "code": "str"
                        }
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def overwrite(
        self,
        curve_id: str,
        *,
        location: _models.Location,
        definition: _models.FxForwardCurveDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param curve_id: Required.
        :type curve_id: str
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxForwardCurveDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def overwrite(
        self, curve_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def overwrite(
        self,
        curve_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.FxForwardCurveDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxForwardCurveDefinition
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossCurrency": {
                            "code": "str"
                        },
                        "constituents": [
                            fx_forward_curve_constituent
                        ],
                        "referenceCurrency": {
                            "code": "str"
                        }
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curve_resource_overwrite_request(
            curve_id=curve_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardCurveResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(
        self, curve_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossCurrency": {
                            "code": "str"
                        },
                        "constituents": [
                            fx_forward_curve_constituent
                        ],
                        "referenceCurrency": {
                            "code": "str"
                        }
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def update(
        self,
        curve_id: str,
        *,
        location: _models.Location,
        definition: _models.FxForwardCurveDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param curve_id: Required.
        :type curve_id: str
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxForwardCurveDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def update(
        self, curve_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def update(
        self,
        curve_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.FxForwardCurveDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxForwardCurveDefinition
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossCurrency": {
                            "code": "str"
                        },
                        "constituents": [
                            fx_forward_curve_constituent
                        ],
                        "referenceCurrency": {
                            "code": "str"
                        }
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curve_resource_update_request(
            curve_id=curve_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardCurveResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def calculate(
        self, curve_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveCalculateResponse, _models.ServiceErrorResponse]:
        """Calculate fx forward curve points from curve definition.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardCurveCalculateResponse or ServiceErrorResponse. The
         FxForwardCurveCalculateResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "parameters": {
                        "fxForwardCurveCalculationPreferences": {
                            "adjustAllDepositPointsToCrossCalendars": bool,
                            "adjustAllSwapPointsToCrossCalendars": bool,
                            "extrapolationMode": "str",
                            "ignoreInvalidInstruments": bool,
                            "ignorePivotCurrencyHolidays": bool,
                            "interpolationMode": "str",
                            "useDelayedDataIfDenied": bool
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "parameters": {
                            "fxForwardCurveCalculationPreferences": {
                                "adjustAllDepositPointsToCrossCalendars": bool,
                                "adjustAllSwapPointsToCrossCalendars": bool,
                                "extrapolationMode": "str",
                                "ignoreInvalidInstruments": bool,
                                "ignorePivotCurrencyHolidays": bool,
                                "interpolationMode": "str",
                                "useDelayedDataIfDenied": bool
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "curve": {
                            "constituents": [
                                fx_forward_curve_constituent_values
                            ],
                            "curvePoints": [
                                {
                                    "endDate": "2020-02-20",
                                    "outright": {
                                        "ask": 0.0,
                                        "bid": 0.0,
                                        "mid": 0.0
                                    },
                                    "startDate": "2020-02-20",
                                    "swapPoint": {
                                        "ask": 0.0,
                                        "bid": 0.0,
                                        "mid": 0.0
                                    },
                                    "tenor": "str",
                                    "instruments": [
                                        {
                                            "instrumentCode": "str"
                                        }
                                    ]
                                }
                            ],
                            "invalidConstituents": [
                                fx_invalid_constituent
                            ],
                            "underlyingCurves": {
                                "fxForwardCurves": [
                                    {
                                        "crossCurrency": {
                                            "code": "str"
                                        },
                                        "curvePoints": [
                                            {
                                                "endDate":
                                                  "2020-02-20",
                                                "outright": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "startDate":
                                                  "2020-02-20",
                                                "swapPoint": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "tenor": "str",
                                                "instruments": [
                                                    {
                "instrumentCode": "str"
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ],
                                "interestRateCurves": [
                                    {
                                        "currency": {
                                            "code": "str"
                                        },
                                        "curvePoints": [
                                            {
                                                "discountFactor":
                                                  0.0,
                                                "endDate":
                                                  "2020-02-20",
                                                "ratePercent": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "startDate":
                                                  "2020-02-20",
                                                "tenor": "str",
                                                "instruments": [
                                                    {
                "instrumentCode": "str"
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def calculate(
        self,
        curve_id: str,
        *,
        content_type: str = "application/json",
        parameters: Optional[_models.FxForwardCurvePricingParameters] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardCurveCalculateResponse, _models.ServiceErrorResponse]:
        """Calculate fx forward curve points from curve definition.

        :param curve_id: Required.
        :type curve_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.FxForwardCurvePricingParameters
        :return: FxForwardCurveCalculateResponse or ServiceErrorResponse. The
         FxForwardCurveCalculateResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "parameters": {
                            "fxForwardCurveCalculationPreferences": {
                                "adjustAllDepositPointsToCrossCalendars": bool,
                                "adjustAllSwapPointsToCrossCalendars": bool,
                                "extrapolationMode": "str",
                                "ignoreInvalidInstruments": bool,
                                "ignorePivotCurrencyHolidays": bool,
                                "interpolationMode": "str",
                                "useDelayedDataIfDenied": bool
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "curve": {
                            "constituents": [
                                fx_forward_curve_constituent_values
                            ],
                            "curvePoints": [
                                {
                                    "endDate": "2020-02-20",
                                    "outright": {
                                        "ask": 0.0,
                                        "bid": 0.0,
                                        "mid": 0.0
                                    },
                                    "startDate": "2020-02-20",
                                    "swapPoint": {
                                        "ask": 0.0,
                                        "bid": 0.0,
                                        "mid": 0.0
                                    },
                                    "tenor": "str",
                                    "instruments": [
                                        {
                                            "instrumentCode": "str"
                                        }
                                    ]
                                }
                            ],
                            "invalidConstituents": [
                                fx_invalid_constituent
                            ],
                            "underlyingCurves": {
                                "fxForwardCurves": [
                                    {
                                        "crossCurrency": {
                                            "code": "str"
                                        },
                                        "curvePoints": [
                                            {
                                                "endDate":
                                                  "2020-02-20",
                                                "outright": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "startDate":
                                                  "2020-02-20",
                                                "swapPoint": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "tenor": "str",
                                                "instruments": [
                                                    {
                "instrumentCode": "str"
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ],
                                "interestRateCurves": [
                                    {
                                        "currency": {
                                            "code": "str"
                                        },
                                        "curvePoints": [
                                            {
                                                "discountFactor":
                                                  0.0,
                                                "endDate":
                                                  "2020-02-20",
                                                "ratePercent": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "startDate":
                                                  "2020-02-20",
                                                "tenor": "str",
                                                "instruments": [
                                                    {
                "instrumentCode": "str"
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def calculate(
        self, curve_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveCalculateResponse, _models.ServiceErrorResponse]:
        """Calculate fx forward curve points from curve definition.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardCurveCalculateResponse or ServiceErrorResponse. The
         FxForwardCurveCalculateResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "parameters": {
                            "fxForwardCurveCalculationPreferences": {
                                "adjustAllDepositPointsToCrossCalendars": bool,
                                "adjustAllSwapPointsToCrossCalendars": bool,
                                "extrapolationMode": "str",
                                "ignoreInvalidInstruments": bool,
                                "ignorePivotCurrencyHolidays": bool,
                                "interpolationMode": "str",
                                "useDelayedDataIfDenied": bool
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "curve": {
                            "constituents": [
                                fx_forward_curve_constituent_values
                            ],
                            "curvePoints": [
                                {
                                    "endDate": "2020-02-20",
                                    "outright": {
                                        "ask": 0.0,
                                        "bid": 0.0,
                                        "mid": 0.0
                                    },
                                    "startDate": "2020-02-20",
                                    "swapPoint": {
                                        "ask": 0.0,
                                        "bid": 0.0,
                                        "mid": 0.0
                                    },
                                    "tenor": "str",
                                    "instruments": [
                                        {
                                            "instrumentCode": "str"
                                        }
                                    ]
                                }
                            ],
                            "invalidConstituents": [
                                fx_invalid_constituent
                            ],
                            "underlyingCurves": {
                                "fxForwardCurves": [
                                    {
                                        "crossCurrency": {
                                            "code": "str"
                                        },
                                        "curvePoints": [
                                            {
                                                "endDate":
                                                  "2020-02-20",
                                                "outright": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "startDate":
                                                  "2020-02-20",
                                                "swapPoint": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "tenor": "str",
                                                "instruments": [
                                                    {
                "instrumentCode": "str"
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ],
                                "interestRateCurves": [
                                    {
                                        "currency": {
                                            "code": "str"
                                        },
                                        "curvePoints": [
                                            {
                                                "discountFactor":
                                                  0.0,
                                                "endDate":
                                                  "2020-02-20",
                                                "ratePercent": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "startDate":
                                                  "2020-02-20",
                                                "tenor": "str",
                                                "instruments": [
                                                    {
                "instrumentCode": "str"
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def calculate(
        self,
        curve_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        parameters: Optional[_models.FxForwardCurvePricingParameters] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardCurveCalculateResponse, _models.ServiceErrorResponse]:
        """Calculate fx forward curve points from curve definition.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.FxForwardCurvePricingParameters
        :return: FxForwardCurveCalculateResponse or ServiceErrorResponse. The
         FxForwardCurveCalculateResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "parameters": {
                        "fxForwardCurveCalculationPreferences": {
                            "adjustAllDepositPointsToCrossCalendars": bool,
                            "adjustAllSwapPointsToCrossCalendars": bool,
                            "extrapolationMode": "str",
                            "ignoreInvalidInstruments": bool,
                            "ignorePivotCurrencyHolidays": bool,
                            "interpolationMode": "str",
                            "useDelayedDataIfDenied": bool
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"
                            }
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "parameters": {
                            "fxForwardCurveCalculationPreferences": {
                                "adjustAllDepositPointsToCrossCalendars": bool,
                                "adjustAllSwapPointsToCrossCalendars": bool,
                                "extrapolationMode": "str",
                                "ignoreInvalidInstruments": bool,
                                "ignorePivotCurrencyHolidays": bool,
                                "interpolationMode": "str",
                                "useDelayedDataIfDenied": bool
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "curve": {
                            "constituents": [
                                fx_forward_curve_constituent_values
                            ],
                            "curvePoints": [
                                {
                                    "endDate": "2020-02-20",
                                    "outright": {
                                        "ask": 0.0,
                                        "bid": 0.0,
                                        "mid": 0.0
                                    },
                                    "startDate": "2020-02-20",
                                    "swapPoint": {
                                        "ask": 0.0,
                                        "bid": 0.0,
                                        "mid": 0.0
                                    },
                                    "tenor": "str",
                                    "instruments": [
                                        {
                                            "instrumentCode": "str"
                                        }
                                    ]
                                }
                            ],
                            "invalidConstituents": [
                                fx_invalid_constituent
                            ],
                            "underlyingCurves": {
                                "fxForwardCurves": [
                                    {
                                        "crossCurrency": {
                                            "code": "str"
                                        },
                                        "curvePoints": [
                                            {
                                                "endDate":
                                                  "2020-02-20",
                                                "outright": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "startDate":
                                                  "2020-02-20",
                                                "swapPoint": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "tenor": "str",
                                                "instruments": [
                                                    {
                "instrumentCode": "str"
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ],
                                "interestRateCurves": [
                                    {
                                        "currency": {
                                            "code": "str"
                                        },
                                        "curvePoints": [
                                            {
                                                "discountFactor":
                                                  0.0,
                                                "endDate":
                                                  "2020-02-20",
                                                "ratePercent": {
                                                    "ask": 0.0,
                                                    "bid": 0.0,
                                                    "mid": 0.0
                                                },
                                                "startDate":
                                                  "2020-02-20",
                                                "tenor": "str",
                                                "instruments": [
                                                    {
                "instrumentCode": "str"
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardCurveCalculateResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        if body is _Unset:
            body = {"parameters": parameters}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curve_resource_calculate_request(
            curve_id=curve_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardCurveCalculateResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class fxForwardsResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`fx_forwards_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        names: Optional[List[str]] = None,
        spaces: Optional[List[str]] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardCollectionResponse, _models.ServiceErrorResponse]:
        """Search resources via combination of name, space and tags.

        :keyword item_per_page: The maximum number of items for each search request. The valid range is
         1-500. If not provided, 50 will be used. Default value is None.
        :paramtype item_per_page: int
        :keyword names: The list of resource names to be searched. Exact match is applied for each
         name. Default value is None.
        :paramtype names: list[str]
        :keyword spaces: The space where the resource is stored. Space is like a namespace where
         resources are stored. By default there are two spaces:
         LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space. If
         space is not specified, HOME will be used. Default value is None.
        :paramtype spaces: list[str]
        :keyword tags: The list of resource tags to be searched. Default value is None.
        :paramtype tags: list[str]
        :return: FxForwardCollectionResponse or ServiceErrorResponse. The FxForwardCollectionResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCollectionResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "description": {
                                "summary": "str",
                                "tags": [
                                    "str"
                                ]
                            },
                            "id": "str",
                            "type": "str"
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.FxForwardCollectionResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_fx_forwards_resource_list_request(
            item_per_page=item_per_page,
            names=names,
            spaces=spaces,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardCollectionResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0,
                        "settlementType": "str",
                        "startDate": date
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def create(
        self,
        *,
        location: _models.Location,
        definition: _models.FxForwardInstrument,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxForwardInstrument
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def create(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.FxForwardInstrument = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxForwardInstrument
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0,
                        "settlementType": "str",
                        "startDate": date
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forwards_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        response_headers = {}
        if response.status_code == 201:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def price(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardOnTheFlyPriceResponse, _models.ServiceErrorResponse]:
        """Price a FX Forward Instrument (pre-trade) on the fly.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardOnTheFlyPriceResponse or ServiceErrorResponse. The
         FxForwardOnTheFlyPriceResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardOnTheFlyPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0,
                        "settlementType": "str",
                        "startDate": date
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "template": {
                                    "id": "str",
                                    "location": {
                                        "name": "str",
                                        "space": "str"
                                    },
                                    "type": "str"
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,
                            "referenceCurrency": {
                                "code": "str"
                            },
                            "reportCurrency": {
                                "code": "str"
                            }
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "pricingAnalysis": {
                            "tradedCrossRate": 0.0,
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "fxOutrightCcy1Ccy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSpot": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy1": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy1Ccy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "settlementAmount": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def price(
        self,
        *,
        definition: _models.FxForwardInstrument,
        content_type: str = "application/json",
        parameters: Optional[_models.PricingParameters] = None,
        market_data: Optional[_models.MarketDataInput] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardOnTheFlyPriceResponse, _models.ServiceErrorResponse]:
        """Price a FX Forward Instrument (pre-trade) on the fly.

        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxForwardInstrument
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.PricingParameters
        :keyword market_data: Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataInput
        :return: FxForwardOnTheFlyPriceResponse or ServiceErrorResponse. The
         FxForwardOnTheFlyPriceResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardOnTheFlyPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "pricingAnalysis": {
                            "tradedCrossRate": 0.0,
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "fxOutrightCcy1Ccy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSpot": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy1": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy1Ccy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "settlementAmount": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def price(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardOnTheFlyPriceResponse, _models.ServiceErrorResponse]:
        """Price a FX Forward Instrument (pre-trade) on the fly.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardOnTheFlyPriceResponse or ServiceErrorResponse. The
         FxForwardOnTheFlyPriceResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardOnTheFlyPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "pricingAnalysis": {
                            "tradedCrossRate": 0.0,
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "fxOutrightCcy1Ccy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSpot": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy1": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy1Ccy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "settlementAmount": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def price(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definition: _models.FxForwardInstrument = _Unset,
        parameters: Optional[_models.PricingParameters] = None,
        market_data: Optional[_models.MarketDataInput] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardOnTheFlyPriceResponse, _models.ServiceErrorResponse]:
        """Price a FX Forward Instrument (pre-trade) on the fly.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxForwardInstrument
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.PricingParameters
        :keyword market_data: Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataInput
        :return: FxForwardOnTheFlyPriceResponse or ServiceErrorResponse. The
         FxForwardOnTheFlyPriceResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardOnTheFlyPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0,
                        "settlementType": "str",
                        "startDate": date
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "template": {
                                    "id": "str",
                                    "location": {
                                        "name": "str",
                                        "space": "str"
                                    },
                                    "type": "str"
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,
                            "referenceCurrency": {
                                "code": "str"
                            },
                            "reportCurrency": {
                                "code": "str"
                            }
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "pricingAnalysis": {
                            "tradedCrossRate": 0.0,
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "fxOutrightCcy1Ccy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSpot": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy1": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy1Ccy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "settlementAmount": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardOnTheFlyPriceResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        if body is _Unset:
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "marketData": market_data, "parameters": parameters}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forwards_resource_price_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardOnTheFlyPriceResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def value(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardOnTheFlyValuationResponse, _models.ServiceErrorResponse]:
        """Valuate a FX Forward Instrument (post-trade) on the fly.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardOnTheFlyValuationResponse or ServiceErrorResponse. The
         FxForwardOnTheFlyValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardOnTheFlyValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0,
                        "settlementType": "str",
                        "startDate": date
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "template": {
                                    "id": "str",
                                    "location": {
                                        "name": "str",
                                        "space": "str"
                                    },
                                    "type": "str"
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,
                            "referenceCurrency": {
                                "code": "str"
                            },
                            "reportCurrency": {
                                "code": "str"
                            }
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "valuation": {
                            "discountFactor": 0.0,
                            "marketValueInContraCcy": 0.0,
                            "marketValueInDealCcy": 0.0,
                            "marketValueInReportCcy": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def value(
        self,
        *,
        definition: _models.FxForwardInstrument,
        content_type: str = "application/json",
        parameters: Optional[_models.PricingParameters] = None,
        market_data: Optional[_models.MarketDataInput] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardOnTheFlyValuationResponse, _models.ServiceErrorResponse]:
        """Valuate a FX Forward Instrument (post-trade) on the fly.

        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxForwardInstrument
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.PricingParameters
        :keyword market_data: Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataInput
        :return: FxForwardOnTheFlyValuationResponse or ServiceErrorResponse. The
         FxForwardOnTheFlyValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardOnTheFlyValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "valuation": {
                            "discountFactor": 0.0,
                            "marketValueInContraCcy": 0.0,
                            "marketValueInDealCcy": 0.0,
                            "marketValueInReportCcy": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def value(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardOnTheFlyValuationResponse, _models.ServiceErrorResponse]:
        """Valuate a FX Forward Instrument (post-trade) on the fly.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardOnTheFlyValuationResponse or ServiceErrorResponse. The
         FxForwardOnTheFlyValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardOnTheFlyValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "valuation": {
                            "discountFactor": 0.0,
                            "marketValueInContraCcy": 0.0,
                            "marketValueInDealCcy": 0.0,
                            "marketValueInReportCcy": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def value(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definition: _models.FxForwardInstrument = _Unset,
        parameters: Optional[_models.PricingParameters] = None,
        market_data: Optional[_models.MarketDataInput] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardOnTheFlyValuationResponse, _models.ServiceErrorResponse]:
        """Valuate a FX Forward Instrument (post-trade) on the fly.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxForwardInstrument
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.PricingParameters
        :keyword market_data: Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataInput
        :return: FxForwardOnTheFlyValuationResponse or ServiceErrorResponse. The
         FxForwardOnTheFlyValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardOnTheFlyValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0,
                        "settlementType": "str",
                        "startDate": date
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "template": {
                                    "id": "str",
                                    "location": {
                                        "name": "str",
                                        "space": "str"
                                    },
                                    "type": "str"
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,
                            "referenceCurrency": {
                                "code": "str"
                            },
                            "reportCurrency": {
                                "code": "str"
                            }
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "valuation": {
                            "discountFactor": 0.0,
                            "marketValueInContraCcy": 0.0,
                            "marketValueInDealCcy": 0.0,
                            "marketValueInReportCcy": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardOnTheFlyValuationResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        if body is _Unset:
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "marketData": market_data, "parameters": parameters}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forwards_resource_value_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardOnTheFlyValuationResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class fxForwardResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`fx_forward_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def read(self, instrument_id: str, **kwargs: Any) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        """Read resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.FxForwardResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_fx_forward_resource_read_request(
            instrument_id=instrument_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def delete(self, instrument_id: str, **kwargs: Any) -> Optional[_models.ServiceErrorResponse]:
        """Delete resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :return: ServiceErrorResponse or None. The ServiceErrorResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ServiceErrorResponse or None
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_fx_forward_resource_delete_request(
            instrument_id=instrument_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            204,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        deserialized = None
        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def overwrite(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0,
                        "settlementType": "str",
                        "startDate": date
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def overwrite(
        self,
        instrument_id: str,
        *,
        location: _models.Location,
        definition: _models.FxForwardInstrument,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxForwardInstrument
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def overwrite(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def overwrite(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.FxForwardInstrument = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxForwardInstrument
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0,
                        "settlementType": "str",
                        "startDate": date
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_resource_overwrite_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0,
                        "settlementType": "str",
                        "startDate": date
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def update(
        self,
        instrument_id: str,
        *,
        location: _models.Location,
        definition: _models.FxForwardInstrument,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxForwardInstrument
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def update(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def update(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.FxForwardInstrument = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxForwardInstrument
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0,
                        "settlementType": "str",
                        "startDate": date
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_resource_update_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def price(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardPriceResponse, _models.ServiceErrorResponse]:
        """Price a FX Forward Instrument (pre-trade). Currently, only NextBusinessDay is supported for the
        date moving convention in the start date or end date.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardPriceResponse or ServiceErrorResponse. The FxForwardPriceResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "template": {
                                    "id": "str",
                                    "location": {
                                        "name": "str",
                                        "space": "str"
                                    },
                                    "type": "str"
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,
                            "referenceCurrency": {
                                "code": "str"
                            },
                            "reportCurrency": {
                                "code": "str"
                            }
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "pricingAnalysis": {
                            "tradedCrossRate": 0.0,
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "fxOutrightCcy1Ccy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSpot": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy1": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy1Ccy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "settlementAmount": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def price(
        self,
        instrument_id: str,
        *,
        content_type: str = "application/json",
        parameters: Optional[_models.PricingParameters] = None,
        market_data: Optional[_models.MarketDataInput] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardPriceResponse, _models.ServiceErrorResponse]:
        """Price a FX Forward Instrument (pre-trade). Currently, only NextBusinessDay is supported for the
        date moving convention in the start date or end date.

        :param instrument_id: Required.
        :type instrument_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.PricingParameters
        :keyword market_data: Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataInput
        :return: FxForwardPriceResponse or ServiceErrorResponse. The FxForwardPriceResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "pricingAnalysis": {
                            "tradedCrossRate": 0.0,
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "fxOutrightCcy1Ccy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSpot": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy1": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy1Ccy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "settlementAmount": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def price(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardPriceResponse, _models.ServiceErrorResponse]:
        """Price a FX Forward Instrument (pre-trade). Currently, only NextBusinessDay is supported for the
        date moving convention in the start date or end date.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardPriceResponse or ServiceErrorResponse. The FxForwardPriceResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "pricingAnalysis": {
                            "tradedCrossRate": 0.0,
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "fxOutrightCcy1Ccy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSpot": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy1": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy1Ccy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "settlementAmount": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def price(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        parameters: Optional[_models.PricingParameters] = None,
        market_data: Optional[_models.MarketDataInput] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardPriceResponse, _models.ServiceErrorResponse]:
        """Price a FX Forward Instrument (pre-trade). Currently, only NextBusinessDay is supported for the
        date moving convention in the start date or end date.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.PricingParameters
        :keyword market_data: Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataInput
        :return: FxForwardPriceResponse or ServiceErrorResponse. The FxForwardPriceResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "template": {
                                    "id": "str",
                                    "location": {
                                        "name": "str",
                                        "space": "str"
                                    },
                                    "type": "str"
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,
                            "referenceCurrency": {
                                "code": "str"
                            },
                            "reportCurrency": {
                                "code": "str"
                            }
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "pricingAnalysis": {
                            "tradedCrossRate": 0.0,
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "fxOutrightCcy1Ccy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSpot": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy1": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy1Ccy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "fxSwapsCcy2": {
                                "ask": 0.0,
                                "bid": 0.0
                            },
                            "settlementAmount": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardPriceResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"marketData": market_data, "parameters": parameters}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_resource_price_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardPriceResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def value(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardValuationResponse, _models.ServiceErrorResponse]:
        """Valuate a FX Forward Instrument (post-trade). Currently, only NextBusinessDay is supported for
        the date moving convention in the start date or end date.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardValuationResponse or ServiceErrorResponse. The FxForwardValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "template": {
                                    "id": "str",
                                    "location": {
                                        "name": "str",
                                        "space": "str"
                                    },
                                    "type": "str"
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,
                            "referenceCurrency": {
                                "code": "str"
                            },
                            "reportCurrency": {
                                "code": "str"
                            }
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "valuation": {
                            "discountFactor": 0.0,
                            "marketValueInContraCcy": 0.0,
                            "marketValueInDealCcy": 0.0,
                            "marketValueInReportCcy": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def value(
        self,
        instrument_id: str,
        *,
        content_type: str = "application/json",
        parameters: Optional[_models.PricingParameters] = None,
        market_data: Optional[_models.MarketDataInput] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardValuationResponse, _models.ServiceErrorResponse]:
        """Valuate a FX Forward Instrument (post-trade). Currently, only NextBusinessDay is supported for
        the date moving convention in the start date or end date.

        :param instrument_id: Required.
        :type instrument_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.PricingParameters
        :keyword market_data: Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataInput
        :return: FxForwardValuationResponse or ServiceErrorResponse. The FxForwardValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "valuation": {
                            "discountFactor": 0.0,
                            "marketValueInContraCcy": 0.0,
                            "marketValueInDealCcy": 0.0,
                            "marketValueInReportCcy": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def value(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardValuationResponse, _models.ServiceErrorResponse]:
        """Valuate a FX Forward Instrument (post-trade). Currently, only NextBusinessDay is supported for
        the date moving convention in the start date or end date.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardValuationResponse or ServiceErrorResponse. The FxForwardValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "valuation": {
                            "discountFactor": 0.0,
                            "marketValueInContraCcy": 0.0,
                            "marketValueInDealCcy": 0.0,
                            "marketValueInReportCcy": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def value(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        parameters: Optional[_models.PricingParameters] = None,
        market_data: Optional[_models.MarketDataInput] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardValuationResponse, _models.ServiceErrorResponse]:
        """Valuate a FX Forward Instrument (post-trade). Currently, only NextBusinessDay is supported for
        the date moving convention in the start date or end date.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.PricingParameters
        :keyword market_data: Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataInput
        :return: FxForwardValuationResponse or ServiceErrorResponse. The FxForwardValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "template": {
                                    "id": "str",
                                    "location": {
                                        "name": "str",
                                        "space": "str"
                                    },
                                    "type": "str"
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,
                            "referenceCurrency": {
                                "code": "str"
                            },
                            "reportCurrency": {
                                "code": "str"
                            }
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str"
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",
                    "calendars": [
                        {
                            "id": "str",
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "type": "str"
                        }
                    ],
                    "dateMovingConvention": "str",
                    "referenceDate": "str"
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "settlementType": "str",
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "valuation": {
                            "discountFactor": 0.0,
                            "marketValueInContraCcy": 0.0,
                            "marketValueInDealCcy": 0.0,
                            "marketValueInReportCcy": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardValuationResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"marketData": market_data, "parameters": parameters}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_resource_value_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardValuationResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class fxSpotsResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`fx_spots_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        names: Optional[List[str]] = None,
        spaces: Optional[List[str]] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Union[_models.FxSpotCollectionResponse, _models.ServiceErrorResponse]:
        """Search resources via combination of name, space and tags.

        :keyword item_per_page: The maximum number of items for each search request. The valid range is
         1-500. If not provided, 50 will be used. Default value is None.
        :paramtype item_per_page: int
        :keyword names: The list of resource names to be searched. Exact match is applied for each
         name. Default value is None.
        :paramtype names: list[str]
        :keyword spaces: The space where the resource is stored. Space is like a namespace where
         resources are stored. By default there are two spaces:
         LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space. If
         space is not specified, HOME will be used. Default value is None.
        :paramtype spaces: list[str]
        :keyword tags: The list of resource tags to be searched. Default value is None.
        :paramtype tags: list[str]
        :return: FxSpotCollectionResponse or ServiceErrorResponse. The FxSpotCollectionResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotCollectionResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "location": {
                                "name": "str",
                                "space": "str"
                            },
                            "description": {
                                "summary": "str",
                                "tags": [
                                    "str"
                                ]
                            },
                            "id": "str",
                            "type": "str"
                        }
                    ],
                    "links": {
                        "price": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "self": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "value": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "first": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "last": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "next": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        },
                        "prev": {
                            "href": "str",
                            "hrefSchema": "str",
                            "httpMethod": "str"
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.FxSpotCollectionResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_fx_spots_resource_list_request(
            item_per_page=item_per_page,
            names=names,
            spaces=spaces,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxSpotCollectionResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def create(
        self,
        *,
        location: _models.Location,
        definition: _models.FxSpotInstrument,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxSpotInstrument
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def create(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.FxSpotInstrument = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        """Create resource.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxSpotInstrument
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxSpotResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spots_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        response_headers = {}
        if response.status_code == 201:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxSpotResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def price_on_the_fly(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotOnTheFlyPriceResponse, _models.ServiceErrorResponse]:
        """Price a Fx Spot Instrument (pre-trade) on the fly.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotOnTheFlyPriceResponse or ServiceErrorResponse. The FxSpotOnTheFlyPriceResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotOnTheFlyPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "template": {
                                    "id": "str",
                                    "location": {
                                        "name": "str",
                                        "space": "str"
                                    },
                                    "type": "str"
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,
                            "referenceCurrency": {
                                "code": "str"
                            },
                            "reportCurrency": {
                                "code": "str"
                            }
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "pricingAnalysis": {
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "fxSpot": {
                                "ask": 0.0,
                                "bid": 0.0
                            }
                        },
                        "processingInformation": [
                            "str"
                        ]
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def price_on_the_fly(
        self,
        *,
        definition: _models.FxSpotInstrument,
        content_type: str = "application/json",
        parameters: Optional[_models.PricingParameters] = None,
        market_data: Optional[_models.MarketDataInput] = None,
        **kwargs: Any,
    ) -> Union[_models.FxSpotOnTheFlyPriceResponse, _models.ServiceErrorResponse]:
        """Price a Fx Spot Instrument (pre-trade) on the fly.

        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxSpotInstrument
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.PricingParameters
        :keyword market_data: Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataInput
        :return: FxSpotOnTheFlyPriceResponse or ServiceErrorResponse. The FxSpotOnTheFlyPriceResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotOnTheFlyPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "pricingAnalysis": {
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "fxSpot": {
                                "ask": 0.0,
                                "bid": 0.0
                            }
                        },
                        "processingInformation": [
                            "str"
                        ]
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def price_on_the_fly(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotOnTheFlyPriceResponse, _models.ServiceErrorResponse]:
        """Price a Fx Spot Instrument (pre-trade) on the fly.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotOnTheFlyPriceResponse or ServiceErrorResponse. The FxSpotOnTheFlyPriceResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotOnTheFlyPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "pricingAnalysis": {
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "fxSpot": {
                                "ask": 0.0,
                                "bid": 0.0
                            }
                        },
                        "processingInformation": [
                            "str"
                        ]
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def price_on_the_fly(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definition: _models.FxSpotInstrument = _Unset,
        parameters: Optional[_models.PricingParameters] = None,
        market_data: Optional[_models.MarketDataInput] = None,
        **kwargs: Any,
    ) -> Union[_models.FxSpotOnTheFlyPriceResponse, _models.ServiceErrorResponse]:
        """Price a Fx Spot Instrument (pre-trade) on the fly.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxSpotInstrument
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.PricingParameters
        :keyword market_data: Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataInput
        :return: FxSpotOnTheFlyPriceResponse or ServiceErrorResponse. The FxSpotOnTheFlyPriceResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotOnTheFlyPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "template": {
                                    "id": "str",
                                    "location": {
                                        "name": "str",
                                        "space": "str"
                                    },
                                    "type": "str"
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,
                            "referenceCurrency": {
                                "code": "str"
                            },
                            "reportCurrency": {
                                "code": "str"
                            }
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "pricingAnalysis": {
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "fxSpot": {
                                "ask": 0.0,
                                "bid": 0.0
                            }
                        },
                        "processingInformation": [
                            "str"
                        ]
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxSpotOnTheFlyPriceResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "marketData": market_data, "parameters": parameters}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spots_resource_price_on_the_fly_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxSpotOnTheFlyPriceResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def value_on_the_fly(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotOnTheFlyValuationResponse, _models.ServiceErrorResponse]:
        """Valuate a Fx Spot Instrument (post-trade) on the fly.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotOnTheFlyValuationResponse or ServiceErrorResponse. The
         FxSpotOnTheFlyValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotOnTheFlyValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "template": {
                                    "id": "str",
                                    "location": {
                                        "name": "str",
                                        "space": "str"
                                    },
                                    "type": "str"
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,
                            "referenceCurrency": {
                                "code": "str"
                            },
                            "reportCurrency": {
                                "code": "str"
                            }
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "processingInformation": [
                            "str"
                        ],
                        "valuation": {
                            "marketValueInContraCcy": 0.0,
                            "marketValueInDealCcy": 0.0,
                            "marketValueInReportCcy": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def value_on_the_fly(
        self,
        *,
        definition: _models.FxSpotInstrument,
        content_type: str = "application/json",
        parameters: Optional[_models.PricingParameters] = None,
        market_data: Optional[_models.MarketDataInput] = None,
        **kwargs: Any,
    ) -> Union[_models.FxSpotOnTheFlyValuationResponse, _models.ServiceErrorResponse]:
        """Valuate a Fx Spot Instrument (post-trade) on the fly.

        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxSpotInstrument
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.PricingParameters
        :keyword market_data: Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataInput
        :return: FxSpotOnTheFlyValuationResponse or ServiceErrorResponse. The
         FxSpotOnTheFlyValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotOnTheFlyValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "processingInformation": [
                            "str"
                        ],
                        "valuation": {
                            "marketValueInContraCcy": 0.0,
                            "marketValueInDealCcy": 0.0,
                            "marketValueInReportCcy": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def value_on_the_fly(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotOnTheFlyValuationResponse, _models.ServiceErrorResponse]:
        """Valuate a Fx Spot Instrument (post-trade) on the fly.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotOnTheFlyValuationResponse or ServiceErrorResponse. The
         FxSpotOnTheFlyValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotOnTheFlyValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "processingInformation": [
                            "str"
                        ],
                        "valuation": {
                            "marketValueInContraCcy": 0.0,
                            "marketValueInDealCcy": 0.0,
                            "marketValueInReportCcy": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def value_on_the_fly(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definition: _models.FxSpotInstrument = _Unset,
        parameters: Optional[_models.PricingParameters] = None,
        market_data: Optional[_models.MarketDataInput] = None,
        **kwargs: Any,
    ) -> Union[_models.FxSpotOnTheFlyValuationResponse, _models.ServiceErrorResponse]:
        """Valuate a Fx Spot Instrument (post-trade) on the fly.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxSpotInstrument
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.PricingParameters
        :keyword market_data: Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataInput
        :return: FxSpotOnTheFlyValuationResponse or ServiceErrorResponse. The
         FxSpotOnTheFlyValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotOnTheFlyValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "template": {
                                    "id": "str",
                                    "location": {
                                        "name": "str",
                                        "space": "str"
                                    },
                                    "type": "str"
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,
                            "referenceCurrency": {
                                "code": "str"
                            },
                            "reportCurrency": {
                                "code": "str"
                            }
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "processingInformation": [
                            "str"
                        ],
                        "valuation": {
                            "marketValueInContraCcy": 0.0,
                            "marketValueInDealCcy": 0.0,
                            "marketValueInReportCcy": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxSpotOnTheFlyValuationResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        if body is _Unset:
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "marketData": market_data, "parameters": parameters}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spots_resource_value_on_the_fly_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxSpotOnTheFlyValuationResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class fxSpotResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`fx_spot_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def read(self, instrument_id: str, **kwargs: Any) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        """Read resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.FxSpotResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_fx_spot_resource_read_request(
            instrument_id=instrument_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxSpotResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def delete(self, instrument_id: str, **kwargs: Any) -> Optional[_models.ServiceErrorResponse]:
        """Delete resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :return: ServiceErrorResponse or None. The ServiceErrorResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ServiceErrorResponse or None
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_fx_spot_resource_delete_request(
            instrument_id=instrument_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            204,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        deserialized = None
        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def overwrite(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def overwrite(
        self,
        instrument_id: str,
        *,
        location: _models.Location,
        definition: _models.FxSpotInstrument,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxSpotInstrument
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def overwrite(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def overwrite(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.FxSpotInstrument = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        """Overwrite resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxSpotInstrument
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxSpotResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spot_resource_overwrite_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxSpotResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def update(
        self,
        instrument_id: str,
        *,
        location: _models.Location,
        definition: _models.FxSpotInstrument,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxSpotInstrument
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def update(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def update(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.FxSpotInstrument = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        """Patch resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Name and space are location attributes, which are automatically set when a
         resource object is saved for the first time. Unsaved resources have thier name and space set to
         None. Location attributes are read-only. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Required.
        :paramtype definition: ~analyticsapi.models.FxSpotInstrument
        :keyword description: Description object that contains the resource summary and tags. Default
         value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"
                            },
                            "rate": 0.0
                        },
                        "contraAmount": 0.0,
                        "dealAmount": 0.0
                    },
                    "location": {
                        "name": "str",
                        "space": "str"
                    },
                    "description": {
                        "summary": "str",
                        "tags": [
                            "str"
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "type": "str"
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",
                        "creator": "str",
                        "revision": "str",
                        "status": "str",
                        "deleteTime": "2020-02-20 00:00:00",
                        "updateTime": "2020-02-20 00:00:00",
                        "updatedBy": "str"
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxSpotResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spot_resource_update_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxSpotResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def price(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotPriceResponse, _models.ServiceErrorResponse]:
        """Price a Fx Spot Instrument (pre-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotPriceResponse or ServiceErrorResponse. The FxSpotPriceResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotPriceResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "template": {
                                    "id": "str",
                                    "location": {
                                        "name": "str",
                                        "space": "str"
                                    },
                                    "type": "str"
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,
                            "referenceCurrency": {
                                "code": "str"
                            },
                            "reportCurrency": {
                                "code": "str"
                            }
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "pricingAnalysis": {
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "fxSpot": {
                                "ask": 0.0,
                                "bid": 0.0
                            }
                        },
                        "processingInformation": [
                            "str"
                        ]
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def price(
        self,
        instrument_id: str,
        *,
        content_type: str = "application/json",
        parameters: Optional[_models.PricingParameters] = None,
        market_data: Optional[_models.MarketDataInput] = None,
        **kwargs: Any,
    ) -> Union[_models.FxSpotPriceResponse, _models.ServiceErrorResponse]:
        """Price a Fx Spot Instrument (pre-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.PricingParameters
        :keyword market_data: Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataInput
        :return: FxSpotPriceResponse or ServiceErrorResponse. The FxSpotPriceResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotPriceResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "pricingAnalysis": {
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "fxSpot": {
                                "ask": 0.0,
                                "bid": 0.0
                            }
                        },
                        "processingInformation": [
                            "str"
                        ]
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def price(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotPriceResponse, _models.ServiceErrorResponse]:
        """Price a Fx Spot Instrument (pre-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotPriceResponse or ServiceErrorResponse. The FxSpotPriceResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotPriceResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "pricingAnalysis": {
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "fxSpot": {
                                "ask": 0.0,
                                "bid": 0.0
                            }
                        },
                        "processingInformation": [
                            "str"
                        ]
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def price(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        parameters: Optional[_models.PricingParameters] = None,
        market_data: Optional[_models.MarketDataInput] = None,
        **kwargs: Any,
    ) -> Union[_models.FxSpotPriceResponse, _models.ServiceErrorResponse]:
        """Price a Fx Spot Instrument (pre-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.PricingParameters
        :keyword market_data: Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataInput
        :return: FxSpotPriceResponse or ServiceErrorResponse. The FxSpotPriceResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotPriceResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "template": {
                                    "id": "str",
                                    "location": {
                                        "name": "str",
                                        "space": "str"
                                    },
                                    "type": "str"
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,
                            "referenceCurrency": {
                                "code": "str"
                            },
                            "reportCurrency": {
                                "code": "str"
                            }
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "pricingAnalysis": {
                            "contraAmount": 0.0,
                            "dealAmount": 0.0,
                            "fxSpot": {
                                "ask": 0.0,
                                "bid": 0.0
                            }
                        },
                        "processingInformation": [
                            "str"
                        ]
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxSpotPriceResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"marketData": market_data, "parameters": parameters}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spot_resource_price_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxSpotPriceResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def value(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotValuationResponse, _models.ServiceErrorResponse]:
        """Valuate a Fx Spot Instrument (post-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotValuationResponse or ServiceErrorResponse. The FxSpotValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "template": {
                                    "id": "str",
                                    "location": {
                                        "name": "str",
                                        "space": "str"
                                    },
                                    "type": "str"
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,
                            "referenceCurrency": {
                                "code": "str"
                            },
                            "reportCurrency": {
                                "code": "str"
                            }
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "processingInformation": [
                            "str"
                        ],
                        "valuation": {
                            "marketValueInContraCcy": 0.0,
                            "marketValueInDealCcy": 0.0,
                            "marketValueInReportCcy": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def value(
        self,
        instrument_id: str,
        *,
        content_type: str = "application/json",
        parameters: Optional[_models.PricingParameters] = None,
        market_data: Optional[_models.MarketDataInput] = None,
        **kwargs: Any,
    ) -> Union[_models.FxSpotValuationResponse, _models.ServiceErrorResponse]:
        """Valuate a Fx Spot Instrument (post-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.PricingParameters
        :keyword market_data: Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataInput
        :return: FxSpotValuationResponse or ServiceErrorResponse. The FxSpotValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "processingInformation": [
                            "str"
                        ],
                        "valuation": {
                            "marketValueInContraCcy": 0.0,
                            "marketValueInDealCcy": 0.0,
                            "marketValueInReportCcy": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    @overload
    def value(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotValuationResponse, _models.ServiceErrorResponse]:
        """Valuate a Fx Spot Instrument (post-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotValuationResponse or ServiceErrorResponse. The FxSpotValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "processingInformation": [
                            "str"
                        ],
                        "valuation": {
                            "marketValueInContraCcy": 0.0,
                            "marketValueInDealCcy": 0.0,
                            "marketValueInReportCcy": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """

    def value(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        parameters: Optional[_models.PricingParameters] = None,
        market_data: Optional[_models.MarketDataInput] = None,
        **kwargs: Any,
    ) -> Union[_models.FxSpotValuationResponse, _models.ServiceErrorResponse]:
        """Valuate a Fx Spot Instrument (post-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword parameters: Default value is None.
        :paramtype parameters: ~analyticsapi.models.PricingParameters
        :keyword market_data: Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataInput
        :return: FxSpotValuationResponse or ServiceErrorResponse. The FxSpotValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "template": {
                                    "id": "str",
                                    "location": {
                                        "name": "str",
                                        "space": "str"
                                    },
                                    "type": "str"
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,
                            "referenceCurrency": {
                                "code": "str"
                            },
                            "reportCurrency": {
                                "code": "str"
                            }
                        },
                        "valuationDate": "2020-02-20"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"
                                },
                                "rate": 0.0
                            },
                            "contraAmount": 0.0,
                            "dealAmount": 0.0
                        },
                        "location": {
                            "name": "str",
                            "space": "str"
                        },
                        "description": {
                            "summary": "str",
                            "tags": [
                                "str"
                            ]
                        },
                        "id": "str",
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    },
                                    "template": {
                                        "id": "str",
                                        "location": {
                                            "name": "str",
                                            "space": "str"
                                        },
                                        "type": "str"
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,
                                "referenceCurrency": {
                                    "code": "str"
                                },
                                "reportCurrency": {
                                    "code": "str"
                                }
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "type": "str"
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",
                                "dateMovingConvention": "str",
                                "unAdjusted": "2020-02-20",
                                "date": "2020-02-20",
                                "processingInformation": "str",
                                "referenceDate": "str",
                                "tenor": "str"
                            },
                            "valuationDate": "2020-02-20"
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,
                            "deltaAmountInDealCcy": 0.0,
                            "deltaAmountInReportCcy": 0.0,
                            "deltaPercent": 0.0
                        },
                        "processingInformation": [
                            "str"
                        ],
                        "valuation": {
                            "marketValueInContraCcy": 0.0,
                            "marketValueInDealCcy": 0.0,
                            "marketValueInReportCcy": 0.0
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",
                                        "outright": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "startDate": "2020-02-20",
                                        "swapPoint": {
                                            "ask": 0.0,
                                            "bid": 0.0,
                                            "mid": 0.0
                                        },
                                        "tenor": "str",
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",
                        "id": "str",
                        "message": "str",
                        "errors": [
                            {
                                "key": "str",
                                "reason": "str",
                                "invalidName": "str",
                                "name": "str"
                            }
                        ],
                        "status": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxSpotValuationResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"marketData": market_data, "parameters": parameters}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spot_resource_value_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            return _deserialize(
                _models.ServiceErrorResponse,
                {
                    "error": {
                        "id": "",
                        "code": response.status_code,
                        "status": response.status_code,
                        "message": f"unsupported content type {str(response.content_type)}. Original message is {str(response.content)}",
                    }
                },
            )

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxSpotValuationResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
