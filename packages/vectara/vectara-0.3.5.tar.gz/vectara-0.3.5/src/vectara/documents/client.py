# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.pagination import AsyncPager, SyncPager
from ..core.request_options import RequestOptions
from ..types.corpus_key import CorpusKey
from ..types.create_document_request import CreateDocumentRequest
from ..types.document import Document
from ..types.summarize_document_response import SummarizeDocumentResponse
from .raw_client import AsyncRawDocumentsClient, RawDocumentsClient

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class DocumentsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawDocumentsClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawDocumentsClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawDocumentsClient
        """
        return self._raw_client

    def list(
        self,
        corpus_key: CorpusKey,
        *,
        limit: typing.Optional[int] = None,
        metadata_filter: typing.Optional[str] = None,
        page_key: typing.Optional[str] = None,
        request_timeout: typing.Optional[int] = None,
        request_timeout_millis: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPager[Document]:
        """
        Retrieve a list of documents stored in a specific corpus. This endpoint
        provides an overview of document metadata without returning the full content of
        each document.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the queried corpus.

        limit : typing.Optional[int]
            The maximum number of documents to return at one time.

        metadata_filter : typing.Optional[str]
            Filter documents by metadata. Uses the same expression as a query metadata filter, but only
            allows filtering on document metadata.

        page_key : typing.Optional[str]
            Used to retrieve the next page of documents after the limit has been reached.

        request_timeout : typing.Optional[int]
            The API will make a best effort to complete the request in the specified seconds or time out.

        request_timeout_millis : typing.Optional[int]
            The API will make a best effort to complete the request in the specified milliseconds or time out.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPager[Document]
            List of documents.

        Examples
        --------
        from vectara import Vectara
        client = Vectara(api_key="YOUR_API_KEY", client_id="YOUR_CLIENT_ID", client_secret="YOUR_CLIENT_SECRET", )
        response = client.documents.list(corpus_key='my-corpus', )
        for item in response:
            yield item
        # alternatively, you can paginate page-by-page
        for page in response.iter_pages():
            yield page
        """
        response = self._raw_client.list(
            corpus_key,
            limit=limit,
            metadata_filter=metadata_filter,
            page_key=page_key,
            request_timeout=request_timeout,
            request_timeout_millis=request_timeout_millis,
            request_options=request_options,
        )
        return response.data

    def create(
        self,
        corpus_key: CorpusKey,
        *,
        request: CreateDocumentRequest,
        request_timeout: typing.Optional[int] = None,
        request_timeout_millis: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Document:
        """
        Add a document to a corpus. This endpoint supports two document formats, structured and core.

        * **Structured** documents have a more conventional structure that provide document sections
        and parts in a format created by Vectara's proprietary strategy automatically. You provide
        a logical document structure, and Vectara handles the partitioning.
        * **Core** documents differ in that they follow an advanced, granular structure that
        explicitly defines each document part in an array. Each part becomes a distinct,
        searchable item in query results. You have precise control over the document structure
        and content.

        For more details, see [Indexing](https://docs.vectara.com/docs/learn/select-ideal-indexing-api).

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the queried corpus.

        request : CreateDocumentRequest

        request_timeout : typing.Optional[int]
            The API will make a best effort to complete the request in the specified seconds or time out.

        request_timeout_millis : typing.Optional[int]
            The API will make a best effort to complete the request in the specified milliseconds or time out.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Document
            Document added to the corpus.

        Examples
        --------
        from vectara import Vectara
        from vectara import StructuredDocument
        from vectara import StructuredDocumentSection
        client = Vectara(api_key="YOUR_API_KEY", client_id="YOUR_CLIENT_ID", client_secret="YOUR_CLIENT_SECRET", )
        client.documents.create(corpus_key='my-corpus-key', request=StructuredDocument(id='my-doc-id', sections=[StructuredDocumentSection(id=1, title='A nice title.', text="I'm a nice document section.", metadata={'section': '1.1'
        }, ), StructuredDocumentSection(id=2, title='Another nice title.', text="I'm another document section on something else.", metadata={'section': '1.2'
        }, )], metadata={'url': 'https://example.com'
        }, ), )
        """
        response = self._raw_client.create(
            corpus_key,
            request=request,
            request_timeout=request_timeout,
            request_timeout_millis=request_timeout_millis,
            request_options=request_options,
        )
        return response.data

    def get(
        self,
        corpus_key: CorpusKey,
        document_id: str,
        *,
        request_timeout: typing.Optional[int] = None,
        request_timeout_millis: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Document:
        """
        Retrieve the content and metadata of a specific document, identified by its
        unique `document_id` from a specific corpus.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus containing the document to retrieve.

        document_id : str
            The document ID of the document to retrieve.
            This `document_id` must be percent encoded.

        request_timeout : typing.Optional[int]
            The API will make a best effort to complete the request in the specified seconds or time out.

        request_timeout_millis : typing.Optional[int]
            The API will make a best effort to complete the request in the specified milliseconds or time out.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Document
            Successfully retrieved the document.

        Examples
        --------
        from vectara import Vectara
        client = Vectara(api_key="YOUR_API_KEY", client_id="YOUR_CLIENT_ID", client_secret="YOUR_CLIENT_SECRET", )
        client.documents.get(corpus_key='my-corpus', document_id='document_id', )
        """
        response = self._raw_client.get(
            corpus_key,
            document_id,
            request_timeout=request_timeout,
            request_timeout_millis=request_timeout_millis,
            request_options=request_options,
        )
        return response.data

    def delete(
        self,
        corpus_key: CorpusKey,
        document_id: str,
        *,
        request_timeout: typing.Optional[int] = None,
        request_timeout_millis: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Permanently delete a document identified by its unique `document_id` from a specific
        corpus. This operation cannot be undone, so use it with caution.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus with the document to delete.

        document_id : str
            The document ID of the document to delete.
            This `document_id` must be percent encoded.

        request_timeout : typing.Optional[int]
            The API will make a best effort to complete the request in the specified seconds or time out.

        request_timeout_millis : typing.Optional[int]
            The API will make a best effort to complete the request in the specified milliseconds or time out.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from vectara import Vectara
        client = Vectara(api_key="YOUR_API_KEY", client_id="YOUR_CLIENT_ID", client_secret="YOUR_CLIENT_SECRET", )
        client.documents.delete(corpus_key='my-corpus', document_id='document_id', )
        """
        response = self._raw_client.delete(
            corpus_key,
            document_id,
            request_timeout=request_timeout,
            request_timeout_millis=request_timeout_millis,
            request_options=request_options,
        )
        return response.data

    def update(
        self,
        corpus_key: CorpusKey,
        document_id: str,
        *,
        request_timeout: typing.Optional[int] = None,
        request_timeout_millis: typing.Optional[int] = None,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Document:
        """
        Updates document identified by its unique `document_id` from a specific
        corpus. The request body metadata is merged with the existing metadata,
        adding or modifying only the specified fields.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus with the document to update.

        document_id : str
            The document ID of the document to update.
            This `document_id` must be percent encoded.

        request_timeout : typing.Optional[int]
            The API will make a best effort to complete the request in the specified seconds or time out.

        request_timeout_millis : typing.Optional[int]
            The API will make a best effort to complete the request in the specified milliseconds or time out.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            The metadata for a document as an arbitrary object. Properties of this object
            can be used by document level filter attributes.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Document
            Successfully updated the document.

        Examples
        --------
        from vectara import Vectara
        client = Vectara(api_key="YOUR_API_KEY", client_id="YOUR_CLIENT_ID", client_secret="YOUR_CLIENT_SECRET", )
        client.documents.update(corpus_key='my-corpus', document_id='document_id', )
        """
        response = self._raw_client.update(
            corpus_key,
            document_id,
            request_timeout=request_timeout,
            request_timeout_millis=request_timeout_millis,
            metadata=metadata,
            request_options=request_options,
        )
        return response.data

    def update_metadata(
        self,
        corpus_key: CorpusKey,
        document_id: str,
        *,
        request_timeout: typing.Optional[int] = None,
        request_timeout_millis: typing.Optional[int] = None,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Document:
        """
        Replaces metadata of a document identified by its unique `document_id`
        from a specific corpus.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus with the document to update.

        document_id : str
            The document ID of the document to update.
            This `document_id` must be percent encoded.

        request_timeout : typing.Optional[int]
            The API will make a best effort to complete the request in the specified seconds or time out.

        request_timeout_millis : typing.Optional[int]
            The API will make a best effort to complete the request in the specified milliseconds or time out.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            The metadata for a document as an arbitrary object. Properties of this object
            can be used by document level filter attributes.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Document
            Successfully updated the document.

        Examples
        --------
        from vectara import Vectara
        client = Vectara(api_key="YOUR_API_KEY", client_id="YOUR_CLIENT_ID", client_secret="YOUR_CLIENT_SECRET", )
        client.documents.update_metadata(corpus_key='my-corpus', document_id='document_id', )
        """
        response = self._raw_client.update_metadata(
            corpus_key,
            document_id,
            request_timeout=request_timeout,
            request_timeout_millis=request_timeout_millis,
            metadata=metadata,
            request_options=request_options,
        )
        return response.data

    def summarize(
        self,
        corpus_key: CorpusKey,
        document_id: str,
        *,
        llm_name: str,
        request_timeout: typing.Optional[int] = None,
        request_timeout_millis: typing.Optional[int] = None,
        prompt_template: typing.Optional[str] = OMIT,
        model_parameters: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        stream_response: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SummarizeDocumentResponse:
        """
        Summarize a document identified by its unique `document_id` from a specific corpus.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus containing the document to retrieve.

        document_id : str
            The document ID of the document to retrieve.
            This `document_id` must be percent encoded.

        llm_name : str
            The name of the LLM.

        request_timeout : typing.Optional[int]
            The API will make a best effort to complete the request in the specified seconds or time out.

        request_timeout_millis : typing.Optional[int]
            The API will make a best effort to complete the request in the specified milliseconds or time out.

        prompt_template : typing.Optional[str]
            The prompt template to use when generating the summary.
            Vectara manages both system and user roles and prompts for the generative
            LLM out of the box by default. However, users can override the
            `prompt_template` via this variable. The `prompt_template` is in the form of an
            Apache Velocity template. For more details on how to configure the
            `prompt_template`, see the [long-form documentation](https://docs.vectara.com/docs/prompts/vectara-prompt-engine).

        model_parameters : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Optional parameters for the specified model used when generating the summary.

        stream_response : typing.Optional[bool]
            Indicates whether the response should be streamed or not.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SummarizeDocumentResponse
            Document summarization response on success.

        Examples
        --------
        from vectara import Vectara
        client = Vectara(api_key="YOUR_API_KEY", client_id="YOUR_CLIENT_ID", client_secret="YOUR_CLIENT_SECRET", )
        client.documents.summarize(corpus_key='my-corpus', document_id='document_id', llm_name='llm_name', )
        """
        response = self._raw_client.summarize(
            corpus_key,
            document_id,
            llm_name=llm_name,
            request_timeout=request_timeout,
            request_timeout_millis=request_timeout_millis,
            prompt_template=prompt_template,
            model_parameters=model_parameters,
            stream_response=stream_response,
            request_options=request_options,
        )
        return response.data


class AsyncDocumentsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawDocumentsClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawDocumentsClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawDocumentsClient
        """
        return self._raw_client

    async def list(
        self,
        corpus_key: CorpusKey,
        *,
        limit: typing.Optional[int] = None,
        metadata_filter: typing.Optional[str] = None,
        page_key: typing.Optional[str] = None,
        request_timeout: typing.Optional[int] = None,
        request_timeout_millis: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPager[Document]:
        """
        Retrieve a list of documents stored in a specific corpus. This endpoint
        provides an overview of document metadata without returning the full content of
        each document.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the queried corpus.

        limit : typing.Optional[int]
            The maximum number of documents to return at one time.

        metadata_filter : typing.Optional[str]
            Filter documents by metadata. Uses the same expression as a query metadata filter, but only
            allows filtering on document metadata.

        page_key : typing.Optional[str]
            Used to retrieve the next page of documents after the limit has been reached.

        request_timeout : typing.Optional[int]
            The API will make a best effort to complete the request in the specified seconds or time out.

        request_timeout_millis : typing.Optional[int]
            The API will make a best effort to complete the request in the specified milliseconds or time out.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPager[Document]
            List of documents.

        Examples
        --------
        from vectara import AsyncVectara
        import asyncio
        client = AsyncVectara(api_key="YOUR_API_KEY", client_id="YOUR_CLIENT_ID", client_secret="YOUR_CLIENT_SECRET", )
        async def main() -> None:
            response = await client.documents.list(corpus_key='my-corpus', )
            async for item in response:
                yield item

            # alternatively, you can paginate page-by-page
            async for page in response.iter_pages():
                yield page
        asyncio.run(main())
        """
        response = await self._raw_client.list(
            corpus_key,
            limit=limit,
            metadata_filter=metadata_filter,
            page_key=page_key,
            request_timeout=request_timeout,
            request_timeout_millis=request_timeout_millis,
            request_options=request_options,
        )
        return response.data

    async def create(
        self,
        corpus_key: CorpusKey,
        *,
        request: CreateDocumentRequest,
        request_timeout: typing.Optional[int] = None,
        request_timeout_millis: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Document:
        """
        Add a document to a corpus. This endpoint supports two document formats, structured and core.

        * **Structured** documents have a more conventional structure that provide document sections
        and parts in a format created by Vectara's proprietary strategy automatically. You provide
        a logical document structure, and Vectara handles the partitioning.
        * **Core** documents differ in that they follow an advanced, granular structure that
        explicitly defines each document part in an array. Each part becomes a distinct,
        searchable item in query results. You have precise control over the document structure
        and content.

        For more details, see [Indexing](https://docs.vectara.com/docs/learn/select-ideal-indexing-api).

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the queried corpus.

        request : CreateDocumentRequest

        request_timeout : typing.Optional[int]
            The API will make a best effort to complete the request in the specified seconds or time out.

        request_timeout_millis : typing.Optional[int]
            The API will make a best effort to complete the request in the specified milliseconds or time out.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Document
            Document added to the corpus.

        Examples
        --------
        from vectara import AsyncVectara
        from vectara import StructuredDocument
        from vectara import StructuredDocumentSection
        import asyncio
        client = AsyncVectara(api_key="YOUR_API_KEY", client_id="YOUR_CLIENT_ID", client_secret="YOUR_CLIENT_SECRET", )
        async def main() -> None:
            await client.documents.create(corpus_key='my-corpus-key', request=StructuredDocument(id='my-doc-id', sections=[StructuredDocumentSection(id=1, title='A nice title.', text="I'm a nice document section.", metadata={'section': '1.1'
            }, ), StructuredDocumentSection(id=2, title='Another nice title.', text="I'm another document section on something else.", metadata={'section': '1.2'
            }, )], metadata={'url': 'https://example.com'
            }, ), )
        asyncio.run(main())
        """
        response = await self._raw_client.create(
            corpus_key,
            request=request,
            request_timeout=request_timeout,
            request_timeout_millis=request_timeout_millis,
            request_options=request_options,
        )
        return response.data

    async def get(
        self,
        corpus_key: CorpusKey,
        document_id: str,
        *,
        request_timeout: typing.Optional[int] = None,
        request_timeout_millis: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Document:
        """
        Retrieve the content and metadata of a specific document, identified by its
        unique `document_id` from a specific corpus.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus containing the document to retrieve.

        document_id : str
            The document ID of the document to retrieve.
            This `document_id` must be percent encoded.

        request_timeout : typing.Optional[int]
            The API will make a best effort to complete the request in the specified seconds or time out.

        request_timeout_millis : typing.Optional[int]
            The API will make a best effort to complete the request in the specified milliseconds or time out.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Document
            Successfully retrieved the document.

        Examples
        --------
        from vectara import AsyncVectara
        import asyncio
        client = AsyncVectara(api_key="YOUR_API_KEY", client_id="YOUR_CLIENT_ID", client_secret="YOUR_CLIENT_SECRET", )
        async def main() -> None:
            await client.documents.get(corpus_key='my-corpus', document_id='document_id', )
        asyncio.run(main())
        """
        response = await self._raw_client.get(
            corpus_key,
            document_id,
            request_timeout=request_timeout,
            request_timeout_millis=request_timeout_millis,
            request_options=request_options,
        )
        return response.data

    async def delete(
        self,
        corpus_key: CorpusKey,
        document_id: str,
        *,
        request_timeout: typing.Optional[int] = None,
        request_timeout_millis: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Permanently delete a document identified by its unique `document_id` from a specific
        corpus. This operation cannot be undone, so use it with caution.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus with the document to delete.

        document_id : str
            The document ID of the document to delete.
            This `document_id` must be percent encoded.

        request_timeout : typing.Optional[int]
            The API will make a best effort to complete the request in the specified seconds or time out.

        request_timeout_millis : typing.Optional[int]
            The API will make a best effort to complete the request in the specified milliseconds or time out.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from vectara import AsyncVectara
        import asyncio
        client = AsyncVectara(api_key="YOUR_API_KEY", client_id="YOUR_CLIENT_ID", client_secret="YOUR_CLIENT_SECRET", )
        async def main() -> None:
            await client.documents.delete(corpus_key='my-corpus', document_id='document_id', )
        asyncio.run(main())
        """
        response = await self._raw_client.delete(
            corpus_key,
            document_id,
            request_timeout=request_timeout,
            request_timeout_millis=request_timeout_millis,
            request_options=request_options,
        )
        return response.data

    async def update(
        self,
        corpus_key: CorpusKey,
        document_id: str,
        *,
        request_timeout: typing.Optional[int] = None,
        request_timeout_millis: typing.Optional[int] = None,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Document:
        """
        Updates document identified by its unique `document_id` from a specific
        corpus. The request body metadata is merged with the existing metadata,
        adding or modifying only the specified fields.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus with the document to update.

        document_id : str
            The document ID of the document to update.
            This `document_id` must be percent encoded.

        request_timeout : typing.Optional[int]
            The API will make a best effort to complete the request in the specified seconds or time out.

        request_timeout_millis : typing.Optional[int]
            The API will make a best effort to complete the request in the specified milliseconds or time out.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            The metadata for a document as an arbitrary object. Properties of this object
            can be used by document level filter attributes.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Document
            Successfully updated the document.

        Examples
        --------
        from vectara import AsyncVectara
        import asyncio
        client = AsyncVectara(api_key="YOUR_API_KEY", client_id="YOUR_CLIENT_ID", client_secret="YOUR_CLIENT_SECRET", )
        async def main() -> None:
            await client.documents.update(corpus_key='my-corpus', document_id='document_id', )
        asyncio.run(main())
        """
        response = await self._raw_client.update(
            corpus_key,
            document_id,
            request_timeout=request_timeout,
            request_timeout_millis=request_timeout_millis,
            metadata=metadata,
            request_options=request_options,
        )
        return response.data

    async def update_metadata(
        self,
        corpus_key: CorpusKey,
        document_id: str,
        *,
        request_timeout: typing.Optional[int] = None,
        request_timeout_millis: typing.Optional[int] = None,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Document:
        """
        Replaces metadata of a document identified by its unique `document_id`
        from a specific corpus.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus with the document to update.

        document_id : str
            The document ID of the document to update.
            This `document_id` must be percent encoded.

        request_timeout : typing.Optional[int]
            The API will make a best effort to complete the request in the specified seconds or time out.

        request_timeout_millis : typing.Optional[int]
            The API will make a best effort to complete the request in the specified milliseconds or time out.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            The metadata for a document as an arbitrary object. Properties of this object
            can be used by document level filter attributes.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Document
            Successfully updated the document.

        Examples
        --------
        from vectara import AsyncVectara
        import asyncio
        client = AsyncVectara(api_key="YOUR_API_KEY", client_id="YOUR_CLIENT_ID", client_secret="YOUR_CLIENT_SECRET", )
        async def main() -> None:
            await client.documents.update_metadata(corpus_key='my-corpus', document_id='document_id', )
        asyncio.run(main())
        """
        response = await self._raw_client.update_metadata(
            corpus_key,
            document_id,
            request_timeout=request_timeout,
            request_timeout_millis=request_timeout_millis,
            metadata=metadata,
            request_options=request_options,
        )
        return response.data

    async def summarize(
        self,
        corpus_key: CorpusKey,
        document_id: str,
        *,
        llm_name: str,
        request_timeout: typing.Optional[int] = None,
        request_timeout_millis: typing.Optional[int] = None,
        prompt_template: typing.Optional[str] = OMIT,
        model_parameters: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        stream_response: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SummarizeDocumentResponse:
        """
        Summarize a document identified by its unique `document_id` from a specific corpus.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus containing the document to retrieve.

        document_id : str
            The document ID of the document to retrieve.
            This `document_id` must be percent encoded.

        llm_name : str
            The name of the LLM.

        request_timeout : typing.Optional[int]
            The API will make a best effort to complete the request in the specified seconds or time out.

        request_timeout_millis : typing.Optional[int]
            The API will make a best effort to complete the request in the specified milliseconds or time out.

        prompt_template : typing.Optional[str]
            The prompt template to use when generating the summary.
            Vectara manages both system and user roles and prompts for the generative
            LLM out of the box by default. However, users can override the
            `prompt_template` via this variable. The `prompt_template` is in the form of an
            Apache Velocity template. For more details on how to configure the
            `prompt_template`, see the [long-form documentation](https://docs.vectara.com/docs/prompts/vectara-prompt-engine).

        model_parameters : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Optional parameters for the specified model used when generating the summary.

        stream_response : typing.Optional[bool]
            Indicates whether the response should be streamed or not.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SummarizeDocumentResponse
            Document summarization response on success.

        Examples
        --------
        from vectara import AsyncVectara
        import asyncio
        client = AsyncVectara(api_key="YOUR_API_KEY", client_id="YOUR_CLIENT_ID", client_secret="YOUR_CLIENT_SECRET", )
        async def main() -> None:
            await client.documents.summarize(corpus_key='my-corpus', document_id='document_id', llm_name='llm_name', )
        asyncio.run(main())
        """
        response = await self._raw_client.summarize(
            corpus_key,
            document_id,
            llm_name=llm_name,
            request_timeout=request_timeout,
            request_timeout_millis=request_timeout_millis,
            prompt_template=prompt_template,
            model_parameters=model_parameters,
            stream_response=stream_response,
            request_options=request_options,
        )
        return response.data
