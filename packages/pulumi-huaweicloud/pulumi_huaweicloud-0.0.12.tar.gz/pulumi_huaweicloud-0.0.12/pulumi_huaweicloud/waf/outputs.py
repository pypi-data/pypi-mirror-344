# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'DedicatedDomainConnectionProtection',
    'DedicatedDomainCustomPage',
    'DedicatedDomainServer',
    'DedicatedDomainTimeoutSettings',
    'DedicatedDomainTrafficMark',
    'DomainCustomPage',
    'DomainServer',
    'DomainTimeoutSettings',
    'DomainTrafficMark',
    'PolicyBindHost',
    'PolicyOption',
    'GetDedicatedInstancesInstanceResult',
    'GetInstanceGroupsGroupResult',
    'GetInstanceGroupsGroupDedicatedInstanceResult',
    'GetInstanceGroupsGroupDomainNameResult',
    'GetPoliciesPolicyResult',
    'GetPoliciesPolicyBindHostResult',
    'GetPoliciesPolicyOptionResult',
    'GetReferenceTablesTableResult',
]

@pulumi.output_type
class DedicatedDomainConnectionProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorPercentage":
            suggest = "error_percentage"
        elif key == "errorThreshold":
            suggest = "error_threshold"
        elif key == "initialDowntime":
            suggest = "initial_downtime"
        elif key == "multiplierForConsecutiveBreakdowns":
            suggest = "multiplier_for_consecutive_breakdowns"
        elif key == "pendingUrlRequestThreshold":
            suggest = "pending_url_request_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DedicatedDomainConnectionProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DedicatedDomainConnectionProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DedicatedDomainConnectionProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: Optional[int] = None,
                 error_percentage: Optional[float] = None,
                 error_threshold: Optional[int] = None,
                 initial_downtime: Optional[int] = None,
                 multiplier_for_consecutive_breakdowns: Optional[int] = None,
                 pending_url_request_threshold: Optional[int] = None,
                 status: Optional[bool] = None):
        """
        :param int duration: Specifies the protection duration (s) for connection protection. During this period, WAF
               stops forwarding website requests. Valid value ranges from `0` to `2,147,483,647`.
        :param float error_percentage: Specifies the `502`/`504` error percentage. A breakdown protection is triggered
               when the `502`/`504` error threshold and percentage threshold have been reached. Valid value ranges from `0` to `99`.
        :param int error_threshold: Specifies the `502`/`504` error threshold for every 30 seconds. Valid value ranges
               from `0` to `2,147,483,647`.
        :param int initial_downtime: Specifies the breakdown duration (s) when the breakdown is triggered for the first
               time. Valid value ranges from `0` to `2,147,483,647`.
        :param int multiplier_for_consecutive_breakdowns: Specifies the maximum multiplier for consecutive breakdowns
               that occur within an hour. Valid value ranges from `0` to `2,147,483,647`.
               For example: Assume that you set the initial downtime to `180s` and the maximum multiplier to `3`. If the breakdown
               protection is triggered for the second time, the website downtime is 360s (180s X 2).
               If the breakdown protection is triggered for the third or fourth time, the website downtime is 540s (180s x 3).
               The breakdowns are calculated every one hour.
        :param int pending_url_request_threshold: Specifies the pending URL request threshold. Connection protection
               is triggered when the number of read URL requests reaches the threshold you configure. Valid value ranges from `0` to
               `2,147,483,647`.
        :param bool status: Specifies whether to enable connection protection. Defaults to **false**.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if error_percentage is not None:
            pulumi.set(__self__, "error_percentage", error_percentage)
        if error_threshold is not None:
            pulumi.set(__self__, "error_threshold", error_threshold)
        if initial_downtime is not None:
            pulumi.set(__self__, "initial_downtime", initial_downtime)
        if multiplier_for_consecutive_breakdowns is not None:
            pulumi.set(__self__, "multiplier_for_consecutive_breakdowns", multiplier_for_consecutive_breakdowns)
        if pending_url_request_threshold is not None:
            pulumi.set(__self__, "pending_url_request_threshold", pending_url_request_threshold)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def duration(self) -> Optional[int]:
        """
        Specifies the protection duration (s) for connection protection. During this period, WAF
        stops forwarding website requests. Valid value ranges from `0` to `2,147,483,647`.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="errorPercentage")
    def error_percentage(self) -> Optional[float]:
        """
        Specifies the `502`/`504` error percentage. A breakdown protection is triggered
        when the `502`/`504` error threshold and percentage threshold have been reached. Valid value ranges from `0` to `99`.
        """
        return pulumi.get(self, "error_percentage")

    @property
    @pulumi.getter(name="errorThreshold")
    def error_threshold(self) -> Optional[int]:
        """
        Specifies the `502`/`504` error threshold for every 30 seconds. Valid value ranges
        from `0` to `2,147,483,647`.
        """
        return pulumi.get(self, "error_threshold")

    @property
    @pulumi.getter(name="initialDowntime")
    def initial_downtime(self) -> Optional[int]:
        """
        Specifies the breakdown duration (s) when the breakdown is triggered for the first
        time. Valid value ranges from `0` to `2,147,483,647`.
        """
        return pulumi.get(self, "initial_downtime")

    @property
    @pulumi.getter(name="multiplierForConsecutiveBreakdowns")
    def multiplier_for_consecutive_breakdowns(self) -> Optional[int]:
        """
        Specifies the maximum multiplier for consecutive breakdowns
        that occur within an hour. Valid value ranges from `0` to `2,147,483,647`.
        For example: Assume that you set the initial downtime to `180s` and the maximum multiplier to `3`. If the breakdown
        protection is triggered for the second time, the website downtime is 360s (180s X 2).
        If the breakdown protection is triggered for the third or fourth time, the website downtime is 540s (180s x 3).
        The breakdowns are calculated every one hour.
        """
        return pulumi.get(self, "multiplier_for_consecutive_breakdowns")

    @property
    @pulumi.getter(name="pendingUrlRequestThreshold")
    def pending_url_request_threshold(self) -> Optional[int]:
        """
        Specifies the pending URL request threshold. Connection protection
        is triggered when the number of read URL requests reaches the threshold you configure. Valid value ranges from `0` to
        `2,147,483,647`.
        """
        return pulumi.get(self, "pending_url_request_threshold")

    @property
    @pulumi.getter
    def status(self) -> Optional[bool]:
        """
        Specifies whether to enable connection protection. Defaults to **false**.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class DedicatedDomainCustomPage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockPageType":
            suggest = "block_page_type"
        elif key == "httpReturnCode":
            suggest = "http_return_code"
        elif key == "pageContent":
            suggest = "page_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DedicatedDomainCustomPage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DedicatedDomainCustomPage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DedicatedDomainCustomPage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_page_type: str,
                 http_return_code: str,
                 page_content: str):
        """
        :param str block_page_type: Specifies the content type of the custom alarm page.
               The value can be **text/html**, **text/xml** or **application/json**.
        :param str http_return_code: Specifies the HTTP return code.
               The value can be a positive integer in the range of `200`-`599` except `408`, `444` and `499`.
        :param str page_content: Specifies the page content. The page content based on the selected page type.
               The available **${waf_event_id}** in the page content indicates an event ID, and only one **${waf_event_id}** variable
               can be available.
        """
        pulumi.set(__self__, "block_page_type", block_page_type)
        pulumi.set(__self__, "http_return_code", http_return_code)
        pulumi.set(__self__, "page_content", page_content)

    @property
    @pulumi.getter(name="blockPageType")
    def block_page_type(self) -> str:
        """
        Specifies the content type of the custom alarm page.
        The value can be **text/html**, **text/xml** or **application/json**.
        """
        return pulumi.get(self, "block_page_type")

    @property
    @pulumi.getter(name="httpReturnCode")
    def http_return_code(self) -> str:
        """
        Specifies the HTTP return code.
        The value can be a positive integer in the range of `200`-`599` except `408`, `444` and `499`.
        """
        return pulumi.get(self, "http_return_code")

    @property
    @pulumi.getter(name="pageContent")
    def page_content(self) -> str:
        """
        Specifies the page content. The page content based on the selected page type.
        The available **${waf_event_id}** in the page content indicates an event ID, and only one **${waf_event_id}** variable
        can be available.
        """
        return pulumi.get(self, "page_content")


@pulumi.output_type
class DedicatedDomainServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientProtocol":
            suggest = "client_protocol"
        elif key == "serverProtocol":
            suggest = "server_protocol"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DedicatedDomainServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DedicatedDomainServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DedicatedDomainServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 client_protocol: str,
                 port: int,
                 server_protocol: str,
                 type: str,
                 vpc_id: str):
        """
        :param str address: Specifies the IP address or domain name of the web server accessed by the
               client. For example, `192.168.1.1` or `www.example.com`. Changing this creates a new service.
        :param str client_protocol: Specifies the protocol type of the client. The options include **HTTP**
               and **HTTPS**. Changing this creates a new service.
        :param int port: Specifies the port number used by the web server. The value ranges from `0` to
               `65,535`. Changing this creates a new service.
        :param str server_protocol: Specifies the protocol used by WAF to forward client requests to the
               server. The valid values are **HTTP** and **HTTPS**. Changing this creates a new service.
        :param str type: Specifies the server network type, IPv4 or IPv6.
               Valid values are **ipv4** and **ipv6**. Changing this creates a new service.
        :param str vpc_id: Specifies the ID of the VPC used by the server. Changing this creates a service.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "client_protocol", client_protocol)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "server_protocol", server_protocol)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Specifies the IP address or domain name of the web server accessed by the
        client. For example, `192.168.1.1` or `www.example.com`. Changing this creates a new service.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="clientProtocol")
    def client_protocol(self) -> str:
        """
        Specifies the protocol type of the client. The options include **HTTP**
        and **HTTPS**. Changing this creates a new service.
        """
        return pulumi.get(self, "client_protocol")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Specifies the port number used by the web server. The value ranges from `0` to
        `65,535`. Changing this creates a new service.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serverProtocol")
    def server_protocol(self) -> str:
        """
        Specifies the protocol used by WAF to forward client requests to the
        server. The valid values are **HTTP** and **HTTPS**. Changing this creates a new service.
        """
        return pulumi.get(self, "server_protocol")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the server network type, IPv4 or IPv6.
        Valid values are **ipv4** and **ipv6**. Changing this creates a new service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        Specifies the ID of the VPC used by the server. Changing this creates a service.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class DedicatedDomainTimeoutSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionTimeout":
            suggest = "connection_timeout"
        elif key == "readTimeout":
            suggest = "read_timeout"
        elif key == "writeTimeout":
            suggest = "write_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DedicatedDomainTimeoutSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DedicatedDomainTimeoutSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DedicatedDomainTimeoutSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_timeout: Optional[int] = None,
                 read_timeout: Optional[int] = None,
                 write_timeout: Optional[int] = None):
        """
        :param int connection_timeout: Specifies the timeout for WAF to connect to the origin server. The unit is second.
               Valid value ranges from `0` to `180`.
        :param int read_timeout: Specifies the timeout for WAF to receive responses from the origin server.
               The unit is second. Valid value ranges from `0` to `3,600`.
        :param int write_timeout: Specifies the timeout for WAF to send requests to the origin server. The unit is second.
               Valid value ranges from `0` to `3,600`.
        """
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if read_timeout is not None:
            pulumi.set(__self__, "read_timeout", read_timeout)
        if write_timeout is not None:
            pulumi.set(__self__, "write_timeout", write_timeout)

    @property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[int]:
        """
        Specifies the timeout for WAF to connect to the origin server. The unit is second.
        Valid value ranges from `0` to `180`.
        """
        return pulumi.get(self, "connection_timeout")

    @property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> Optional[int]:
        """
        Specifies the timeout for WAF to receive responses from the origin server.
        The unit is second. Valid value ranges from `0` to `3,600`.
        """
        return pulumi.get(self, "read_timeout")

    @property
    @pulumi.getter(name="writeTimeout")
    def write_timeout(self) -> Optional[int]:
        """
        Specifies the timeout for WAF to send requests to the origin server. The unit is second.
        Valid value ranges from `0` to `3,600`.
        """
        return pulumi.get(self, "write_timeout")


@pulumi.output_type
class DedicatedDomainTrafficMark(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipTags":
            suggest = "ip_tags"
        elif key == "sessionTag":
            suggest = "session_tag"
        elif key == "userTag":
            suggest = "user_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DedicatedDomainTrafficMark. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DedicatedDomainTrafficMark.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DedicatedDomainTrafficMark.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_tags: Optional[Sequence[str]] = None,
                 session_tag: Optional[str] = None,
                 user_tag: Optional[str] = None):
        """
        :param Sequence[str] ip_tags: Specifies the IP tags. HTTP request header field of the original client IP address.
               This field is used to store the real IP address of the client. After the configuration, WAF preferentially reads the
               configured field to obtain the real IP address of the client. If multiple fields are configured, WAF reads the IP
               address list in order. Note:
               + If you want to use a TCP connection IP address as the client IP address, set IP Tag to `$remote_addr`.
               + If WAF does not obtain the real IP address of a client from fields you configure, WAF reads the `cdn-src-ip`,
               `x-real-ip`, `x-forwarded-for` and `$remote_addr` fields in sequence to read the client IP address.
        :param str session_tag: Specifies the session tag. This tag is used by known attack source rules to block
               malicious attacks based on cookie attributes. This parameter must be configured in known attack source rules to block
               requests based on cookie attributes.
        :param str user_tag: Specifies the user tag. This tag is used by known attack source rules to block malicious
               attacks based on params attributes. This parameter must be configured to block requests based on the params attributes.
        """
        if ip_tags is not None:
            pulumi.set(__self__, "ip_tags", ip_tags)
        if session_tag is not None:
            pulumi.set(__self__, "session_tag", session_tag)
        if user_tag is not None:
            pulumi.set(__self__, "user_tag", user_tag)

    @property
    @pulumi.getter(name="ipTags")
    def ip_tags(self) -> Optional[Sequence[str]]:
        """
        Specifies the IP tags. HTTP request header field of the original client IP address.
        This field is used to store the real IP address of the client. After the configuration, WAF preferentially reads the
        configured field to obtain the real IP address of the client. If multiple fields are configured, WAF reads the IP
        address list in order. Note:
        + If you want to use a TCP connection IP address as the client IP address, set IP Tag to `$remote_addr`.
        + If WAF does not obtain the real IP address of a client from fields you configure, WAF reads the `cdn-src-ip`,
        `x-real-ip`, `x-forwarded-for` and `$remote_addr` fields in sequence to read the client IP address.
        """
        return pulumi.get(self, "ip_tags")

    @property
    @pulumi.getter(name="sessionTag")
    def session_tag(self) -> Optional[str]:
        """
        Specifies the session tag. This tag is used by known attack source rules to block
        malicious attacks based on cookie attributes. This parameter must be configured in known attack source rules to block
        requests based on cookie attributes.
        """
        return pulumi.get(self, "session_tag")

    @property
    @pulumi.getter(name="userTag")
    def user_tag(self) -> Optional[str]:
        """
        Specifies the user tag. This tag is used by known attack source rules to block malicious
        attacks based on params attributes. This parameter must be configured to block requests based on the params attributes.
        """
        return pulumi.get(self, "user_tag")


@pulumi.output_type
class DomainCustomPage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockPageType":
            suggest = "block_page_type"
        elif key == "httpReturnCode":
            suggest = "http_return_code"
        elif key == "pageContent":
            suggest = "page_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainCustomPage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainCustomPage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainCustomPage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_page_type: str,
                 http_return_code: str,
                 page_content: str):
        """
        :param str block_page_type: Specifies the content type of the custom alarm page.
               The value can be **text/html**, **text/xml** or **application/json**.
        :param str http_return_code: Specifies the HTTP return code.
               The value can be a positive integer in the range of `200` to `599` except `408`, `444` and `499`.
        :param str page_content: Specifies the page content. The page content based on the selected page type.
               The available **${waf_event_id}** in the page content indicates an event ID, and only one **${waf_event_id}** variable
               can be available.
        """
        pulumi.set(__self__, "block_page_type", block_page_type)
        pulumi.set(__self__, "http_return_code", http_return_code)
        pulumi.set(__self__, "page_content", page_content)

    @property
    @pulumi.getter(name="blockPageType")
    def block_page_type(self) -> str:
        """
        Specifies the content type of the custom alarm page.
        The value can be **text/html**, **text/xml** or **application/json**.
        """
        return pulumi.get(self, "block_page_type")

    @property
    @pulumi.getter(name="httpReturnCode")
    def http_return_code(self) -> str:
        """
        Specifies the HTTP return code.
        The value can be a positive integer in the range of `200` to `599` except `408`, `444` and `499`.
        """
        return pulumi.get(self, "http_return_code")

    @property
    @pulumi.getter(name="pageContent")
    def page_content(self) -> str:
        """
        Specifies the page content. The page content based on the selected page type.
        The available **${waf_event_id}** in the page content indicates an event ID, and only one **${waf_event_id}** variable
        can be available.
        """
        return pulumi.get(self, "page_content")


@pulumi.output_type
class DomainServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientProtocol":
            suggest = "client_protocol"
        elif key == "serverProtocol":
            suggest = "server_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 client_protocol: str,
                 port: int,
                 server_protocol: str,
                 type: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        :param str address: Specifies the IP address or domain name of the web server that the client accesses.
        :param str client_protocol: Specifies the protocol type of the client. The options include **HTTP** and **HTTPS**.
        :param int port: Specifies the port number used by the web server. The value ranges from `0` to `65,535`,
               for example, `8,080`.
        :param str server_protocol: Specifies the protocol used by WAF to forward client requests to the server.
               The options include **HTTP** and **HTTPS**.
        :param str type: Specifies the server network type. Valid values are: **ipv4** and **ipv6**.
               + When this field is set to **ipv4**, `address` must be set to an IPv4 address.
               + When this field is set to **ipv6**, `address` must be set to an IPv6 address.
        :param int weight: Specifies the load balancing algorithm will assign requests to the origin
               site according to this weight.
               Defaults to `1`.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "client_protocol", client_protocol)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "server_protocol", server_protocol)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Specifies the IP address or domain name of the web server that the client accesses.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="clientProtocol")
    def client_protocol(self) -> str:
        """
        Specifies the protocol type of the client. The options include **HTTP** and **HTTPS**.
        """
        return pulumi.get(self, "client_protocol")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Specifies the port number used by the web server. The value ranges from `0` to `65,535`,
        for example, `8,080`.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serverProtocol")
    def server_protocol(self) -> str:
        """
        Specifies the protocol used by WAF to forward client requests to the server.
        The options include **HTTP** and **HTTPS**.
        """
        return pulumi.get(self, "server_protocol")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Specifies the server network type. Valid values are: **ipv4** and **ipv6**.
        + When this field is set to **ipv4**, `address` must be set to an IPv4 address.
        + When this field is set to **ipv6**, `address` must be set to an IPv6 address.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Specifies the load balancing algorithm will assign requests to the origin
        site according to this weight.
        Defaults to `1`.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class DomainTimeoutSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionTimeout":
            suggest = "connection_timeout"
        elif key == "readTimeout":
            suggest = "read_timeout"
        elif key == "writeTimeout":
            suggest = "write_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainTimeoutSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainTimeoutSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainTimeoutSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_timeout: Optional[int] = None,
                 read_timeout: Optional[int] = None,
                 write_timeout: Optional[int] = None):
        """
        :param int connection_timeout: Specifies the timeout for WAF to connect to the origin server. The unit is second.
               Valid value ranges from `0` to `180`.
        :param int read_timeout: Specifies the timeout for WAF to receive responses from the origin server.
               The unit is second. Valid value ranges from `0` to `3,600`.
        :param int write_timeout: Specifies the timeout for WAF to send requests to the origin server. The unit is second.
               Valid value ranges from `0` to `3,600`.
        """
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if read_timeout is not None:
            pulumi.set(__self__, "read_timeout", read_timeout)
        if write_timeout is not None:
            pulumi.set(__self__, "write_timeout", write_timeout)

    @property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[int]:
        """
        Specifies the timeout for WAF to connect to the origin server. The unit is second.
        Valid value ranges from `0` to `180`.
        """
        return pulumi.get(self, "connection_timeout")

    @property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> Optional[int]:
        """
        Specifies the timeout for WAF to receive responses from the origin server.
        The unit is second. Valid value ranges from `0` to `3,600`.
        """
        return pulumi.get(self, "read_timeout")

    @property
    @pulumi.getter(name="writeTimeout")
    def write_timeout(self) -> Optional[int]:
        """
        Specifies the timeout for WAF to send requests to the origin server. The unit is second.
        Valid value ranges from `0` to `3,600`.
        """
        return pulumi.get(self, "write_timeout")


@pulumi.output_type
class DomainTrafficMark(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipTags":
            suggest = "ip_tags"
        elif key == "sessionTag":
            suggest = "session_tag"
        elif key == "userTag":
            suggest = "user_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainTrafficMark. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainTrafficMark.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainTrafficMark.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_tags: Optional[Sequence[str]] = None,
                 session_tag: Optional[str] = None,
                 user_tag: Optional[str] = None):
        """
        :param Sequence[str] ip_tags: Specifies the IP tags. HTTP request header field of the original client IP address.
               This field is used to store the real IP address of the client. After the configuration, WAF preferentially reads the
               configured field to obtain the real IP address of the client. If multiple fields are configured, WAF reads the IP
               address list in order. Note:
               + If you want to use a TCP connection IP address as the client IP address, set IP Tag to **$remote_addr**.
               + If WAF does not obtain the real IP address of a client from fields you configure, WAF reads the **cdn-src-ip**,
               **x-real-ip**, **x-forwarded-for** and **$remote_addr** fields in sequence to read the client IP address.
               + When the website setting `proxy` is configured as **false**, this field does not take effect,
               and the client IP is only obtained through the `$remote_addr` field.
        :param str session_tag: Specifies the session tag. This tag is used by known attack source rules to block
               malicious attacks based on cookie attributes. This parameter must be configured in known attack source rules to block
               requests based on cookie attributes.
        :param str user_tag: Specifies the user tag. This tag is used by known attack source rules to block malicious
               attacks based on params attributes. This parameter must be configured to block requests based on the params attributes.
        """
        if ip_tags is not None:
            pulumi.set(__self__, "ip_tags", ip_tags)
        if session_tag is not None:
            pulumi.set(__self__, "session_tag", session_tag)
        if user_tag is not None:
            pulumi.set(__self__, "user_tag", user_tag)

    @property
    @pulumi.getter(name="ipTags")
    def ip_tags(self) -> Optional[Sequence[str]]:
        """
        Specifies the IP tags. HTTP request header field of the original client IP address.
        This field is used to store the real IP address of the client. After the configuration, WAF preferentially reads the
        configured field to obtain the real IP address of the client. If multiple fields are configured, WAF reads the IP
        address list in order. Note:
        + If you want to use a TCP connection IP address as the client IP address, set IP Tag to **$remote_addr**.
        + If WAF does not obtain the real IP address of a client from fields you configure, WAF reads the **cdn-src-ip**,
        **x-real-ip**, **x-forwarded-for** and **$remote_addr** fields in sequence to read the client IP address.
        + When the website setting `proxy` is configured as **false**, this field does not take effect,
        and the client IP is only obtained through the `$remote_addr` field.
        """
        return pulumi.get(self, "ip_tags")

    @property
    @pulumi.getter(name="sessionTag")
    def session_tag(self) -> Optional[str]:
        """
        Specifies the session tag. This tag is used by known attack source rules to block
        malicious attacks based on cookie attributes. This parameter must be configured in known attack source rules to block
        requests based on cookie attributes.
        """
        return pulumi.get(self, "session_tag")

    @property
    @pulumi.getter(name="userTag")
    def user_tag(self) -> Optional[str]:
        """
        Specifies the user tag. This tag is used by known attack source rules to block malicious
        attacks based on params attributes. This parameter must be configured to block requests based on the params attributes.
        """
        return pulumi.get(self, "user_tag")


@pulumi.output_type
class PolicyBindHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wafType":
            suggest = "waf_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyBindHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyBindHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyBindHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 mode: Optional[str] = None,
                 waf_type: Optional[str] = None):
        """
        :param str hostname: The domain name.
        :param str id: The domain name ID.
        :param str mode: The special domain name mode. This attribute is only valid for dedicated mode.
        :param str waf_type: The deployment mode of WAF instance that is used for the domain name. The value can be **cloud** for
               cloud WAF or **premium** for dedicated WAF instances.
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if waf_type is not None:
            pulumi.set(__self__, "waf_type", waf_type)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The domain name.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The domain name ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The special domain name mode. This attribute is only valid for dedicated mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="wafType")
    def waf_type(self) -> Optional[str]:
        """
        The deployment mode of WAF instance that is used for the domain name. The value can be **cloud** for
        cloud WAF or **premium** for dedicated WAF instances.
        """
        return pulumi.get(self, "waf_type")


@pulumi.output_type
class PolicyOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "antiCrawler":
            suggest = "anti_crawler"
        elif key == "basicWebProtection":
            suggest = "basic_web_protection"
        elif key == "botEnable":
            suggest = "bot_enable"
        elif key == "ccAttackProtection":
            suggest = "cc_attack_protection"
        elif key == "crawlerEngine":
            suggest = "crawler_engine"
        elif key == "crawlerOther":
            suggest = "crawler_other"
        elif key == "crawlerScanner":
            suggest = "crawler_scanner"
        elif key == "crawlerScript":
            suggest = "crawler_script"
        elif key == "dataMasking":
            suggest = "data_masking"
        elif key == "falseAlarmMasking":
            suggest = "false_alarm_masking"
        elif key == "generalCheck":
            suggest = "general_check"
        elif key == "geolocationAccessControl":
            suggest = "geolocation_access_control"
        elif key == "informationLeakagePrevention":
            suggest = "information_leakage_prevention"
        elif key == "knownAttackSource":
            suggest = "known_attack_source"
        elif key == "preciseProtection":
            suggest = "precise_protection"
        elif key == "webTamperProtection":
            suggest = "web_tamper_protection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anti_crawler: Optional[bool] = None,
                 basic_web_protection: Optional[bool] = None,
                 blacklist: Optional[bool] = None,
                 bot_enable: Optional[bool] = None,
                 cc_attack_protection: Optional[bool] = None,
                 crawler: Optional[bool] = None,
                 crawler_engine: Optional[bool] = None,
                 crawler_other: Optional[bool] = None,
                 crawler_scanner: Optional[bool] = None,
                 crawler_script: Optional[bool] = None,
                 data_masking: Optional[bool] = None,
                 false_alarm_masking: Optional[bool] = None,
                 general_check: Optional[bool] = None,
                 geolocation_access_control: Optional[bool] = None,
                 information_leakage_prevention: Optional[bool] = None,
                 known_attack_source: Optional[bool] = None,
                 precise_protection: Optional[bool] = None,
                 web_tamper_protection: Optional[bool] = None,
                 webshell: Optional[bool] = None):
        """
        :param bool anti_crawler: Specifies whether the javascript anti-crawler is enabled. Defaults to **false**.
        :param bool basic_web_protection: Specifies whether basic web protection is enabled. Defaults to **false**.
        :param bool blacklist: Specifies whether the blacklist and whitelist protection is enabled.
               Defaults to **false**.
        :param bool bot_enable: Specifies whether the anti-crawler protection is enabled. Defaults to **false**.
        :param bool cc_attack_protection: Specifies whether the cc attack protection rules are enabled.
               Defaults to **false**.
        :param bool crawler_engine: Specifies whether the search engine is enabled. Defaults to **false**.
        :param bool crawler_other: Specifies whether other crawler check is enabled. Defaults to **false**.
        :param bool crawler_scanner: Specifies whether the anti-crawler detection is enabled. Defaults to **false**.
        :param bool crawler_script: Specifies whether the script tool is enabled. Defaults to **false**.
        :param bool data_masking: Specifies whether data masking is enabled. Defaults to **false**.
        :param bool false_alarm_masking: Specifies whether false alarm masking is enabled. Defaults to **false**.
        :param bool general_check: Specifies whether the general check in basic web protection is enabled.
               Defaults to **false**.
        :param bool geolocation_access_control: Specifies whether the geolocation access control is enabled.
               Defaults to **false**.
        :param bool information_leakage_prevention: Specifies whether the information leakage prevention is enabled.
               Defaults to **false**.
        :param bool known_attack_source: Specifies whether the known attack source is enabled. Defaults to **false**.
        :param bool precise_protection: Specifies whether the precise protection is enabled. Defaults to **false**.
        :param bool web_tamper_protection: Specifies whether the web tamper protection is enabled.
               Defaults to **false**.
        :param bool webshell: Specifies whether the web shell detection in basic web protection is enabled.
               Defaults to **false**.
        """
        if anti_crawler is not None:
            pulumi.set(__self__, "anti_crawler", anti_crawler)
        if basic_web_protection is not None:
            pulumi.set(__self__, "basic_web_protection", basic_web_protection)
        if blacklist is not None:
            pulumi.set(__self__, "blacklist", blacklist)
        if bot_enable is not None:
            pulumi.set(__self__, "bot_enable", bot_enable)
        if cc_attack_protection is not None:
            pulumi.set(__self__, "cc_attack_protection", cc_attack_protection)
        if crawler is not None:
            pulumi.set(__self__, "crawler", crawler)
        if crawler_engine is not None:
            pulumi.set(__self__, "crawler_engine", crawler_engine)
        if crawler_other is not None:
            pulumi.set(__self__, "crawler_other", crawler_other)
        if crawler_scanner is not None:
            pulumi.set(__self__, "crawler_scanner", crawler_scanner)
        if crawler_script is not None:
            pulumi.set(__self__, "crawler_script", crawler_script)
        if data_masking is not None:
            pulumi.set(__self__, "data_masking", data_masking)
        if false_alarm_masking is not None:
            pulumi.set(__self__, "false_alarm_masking", false_alarm_masking)
        if general_check is not None:
            pulumi.set(__self__, "general_check", general_check)
        if geolocation_access_control is not None:
            pulumi.set(__self__, "geolocation_access_control", geolocation_access_control)
        if information_leakage_prevention is not None:
            pulumi.set(__self__, "information_leakage_prevention", information_leakage_prevention)
        if known_attack_source is not None:
            pulumi.set(__self__, "known_attack_source", known_attack_source)
        if precise_protection is not None:
            pulumi.set(__self__, "precise_protection", precise_protection)
        if web_tamper_protection is not None:
            pulumi.set(__self__, "web_tamper_protection", web_tamper_protection)
        if webshell is not None:
            pulumi.set(__self__, "webshell", webshell)

    @property
    @pulumi.getter(name="antiCrawler")
    def anti_crawler(self) -> Optional[bool]:
        """
        Specifies whether the javascript anti-crawler is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "anti_crawler")

    @property
    @pulumi.getter(name="basicWebProtection")
    def basic_web_protection(self) -> Optional[bool]:
        """
        Specifies whether basic web protection is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "basic_web_protection")

    @property
    @pulumi.getter
    def blacklist(self) -> Optional[bool]:
        """
        Specifies whether the blacklist and whitelist protection is enabled.
        Defaults to **false**.
        """
        return pulumi.get(self, "blacklist")

    @property
    @pulumi.getter(name="botEnable")
    def bot_enable(self) -> Optional[bool]:
        """
        Specifies whether the anti-crawler protection is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "bot_enable")

    @property
    @pulumi.getter(name="ccAttackProtection")
    def cc_attack_protection(self) -> Optional[bool]:
        """
        Specifies whether the cc attack protection rules are enabled.
        Defaults to **false**.
        """
        return pulumi.get(self, "cc_attack_protection")

    @property
    @pulumi.getter
    def crawler(self) -> Optional[bool]:
        return pulumi.get(self, "crawler")

    @property
    @pulumi.getter(name="crawlerEngine")
    def crawler_engine(self) -> Optional[bool]:
        """
        Specifies whether the search engine is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "crawler_engine")

    @property
    @pulumi.getter(name="crawlerOther")
    def crawler_other(self) -> Optional[bool]:
        """
        Specifies whether other crawler check is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "crawler_other")

    @property
    @pulumi.getter(name="crawlerScanner")
    def crawler_scanner(self) -> Optional[bool]:
        """
        Specifies whether the anti-crawler detection is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "crawler_scanner")

    @property
    @pulumi.getter(name="crawlerScript")
    def crawler_script(self) -> Optional[bool]:
        """
        Specifies whether the script tool is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "crawler_script")

    @property
    @pulumi.getter(name="dataMasking")
    def data_masking(self) -> Optional[bool]:
        """
        Specifies whether data masking is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "data_masking")

    @property
    @pulumi.getter(name="falseAlarmMasking")
    def false_alarm_masking(self) -> Optional[bool]:
        """
        Specifies whether false alarm masking is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "false_alarm_masking")

    @property
    @pulumi.getter(name="generalCheck")
    def general_check(self) -> Optional[bool]:
        """
        Specifies whether the general check in basic web protection is enabled.
        Defaults to **false**.
        """
        return pulumi.get(self, "general_check")

    @property
    @pulumi.getter(name="geolocationAccessControl")
    def geolocation_access_control(self) -> Optional[bool]:
        """
        Specifies whether the geolocation access control is enabled.
        Defaults to **false**.
        """
        return pulumi.get(self, "geolocation_access_control")

    @property
    @pulumi.getter(name="informationLeakagePrevention")
    def information_leakage_prevention(self) -> Optional[bool]:
        """
        Specifies whether the information leakage prevention is enabled.
        Defaults to **false**.
        """
        return pulumi.get(self, "information_leakage_prevention")

    @property
    @pulumi.getter(name="knownAttackSource")
    def known_attack_source(self) -> Optional[bool]:
        """
        Specifies whether the known attack source is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "known_attack_source")

    @property
    @pulumi.getter(name="preciseProtection")
    def precise_protection(self) -> Optional[bool]:
        """
        Specifies whether the precise protection is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "precise_protection")

    @property
    @pulumi.getter(name="webTamperProtection")
    def web_tamper_protection(self) -> Optional[bool]:
        """
        Specifies whether the web tamper protection is enabled.
        Defaults to **false**.
        """
        return pulumi.get(self, "web_tamper_protection")

    @property
    @pulumi.getter
    def webshell(self) -> Optional[bool]:
        """
        Specifies whether the web shell detection in basic web protection is enabled.
        Defaults to **false**.
        """
        return pulumi.get(self, "webshell")


@pulumi.output_type
class GetDedicatedInstancesInstanceResult(dict):
    def __init__(__self__, *,
                 access_status: int,
                 available_zone: str,
                 cpu_architecture: str,
                 ecs_flavor: str,
                 group_id: str,
                 id: str,
                 name: str,
                 run_status: int,
                 security_groups: Sequence[str],
                 server_id: str,
                 service_ip: str,
                 subnet_id: str,
                 upgradable: int,
                 vpc_id: str):
        """
        :param int access_status: The access status of the instance. `0`: inaccessible, `1`: accessible.
        :param str available_zone: The available zone name of the WAF dedicated instance.
        :param str cpu_architecture: The ECS CPU architecture of WAF dedicated instance.
        :param str ecs_flavor: The flavor of the ECS used by the WAF instance.
        :param str id: Specifies the ID of WAF dedicated instance.
        :param str name: Specifies the name of WAF dedicated instance.
        :param int run_status: The running status of the instance. Values are:
        :param Sequence[str] security_groups: The security group of the instance. This is an array of security group IDs.
        :param str server_id: The ID of the ECS hosting the dedicated engine.
        :param str service_ip: The service plane IP address of the dedicated WAF instance.
        :param str subnet_id: The subnet ID of WAF dedicated instance VPC.
        :param int upgradable: Whether the dedicated WAF instance can be upgraded. `0`: Cannot be upgraded; `1`: Can be upgraded.
        :param str vpc_id: The VPC ID of WAF dedicated instance.
        """
        pulumi.set(__self__, "access_status", access_status)
        pulumi.set(__self__, "available_zone", available_zone)
        pulumi.set(__self__, "cpu_architecture", cpu_architecture)
        pulumi.set(__self__, "ecs_flavor", ecs_flavor)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "run_status", run_status)
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "server_id", server_id)
        pulumi.set(__self__, "service_ip", service_ip)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "upgradable", upgradable)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="accessStatus")
    def access_status(self) -> int:
        """
        The access status of the instance. `0`: inaccessible, `1`: accessible.
        """
        return pulumi.get(self, "access_status")

    @property
    @pulumi.getter(name="availableZone")
    def available_zone(self) -> str:
        """
        The available zone name of the WAF dedicated instance.
        """
        return pulumi.get(self, "available_zone")

    @property
    @pulumi.getter(name="cpuArchitecture")
    def cpu_architecture(self) -> str:
        """
        The ECS CPU architecture of WAF dedicated instance.
        """
        return pulumi.get(self, "cpu_architecture")

    @property
    @pulumi.getter(name="ecsFlavor")
    def ecs_flavor(self) -> str:
        """
        The flavor of the ECS used by the WAF instance.
        """
        return pulumi.get(self, "ecs_flavor")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Specifies the ID of WAF dedicated instance.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of WAF dedicated instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="runStatus")
    def run_status(self) -> int:
        """
        The running status of the instance. Values are:
        """
        return pulumi.get(self, "run_status")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence[str]:
        """
        The security group of the instance. This is an array of security group IDs.
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> str:
        """
        The ID of the ECS hosting the dedicated engine.
        """
        return pulumi.get(self, "server_id")

    @property
    @pulumi.getter(name="serviceIp")
    def service_ip(self) -> str:
        """
        The service plane IP address of the dedicated WAF instance.
        """
        return pulumi.get(self, "service_ip")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The subnet ID of WAF dedicated instance VPC.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def upgradable(self) -> int:
        """
        Whether the dedicated WAF instance can be upgraded. `0`: Cannot be upgraded; `1`: Can be upgraded.
        """
        return pulumi.get(self, "upgradable")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The VPC ID of WAF dedicated instance.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetInstanceGroupsGroupResult(dict):
    def __init__(__self__, *,
                 body_limit: int,
                 connection_timeout: int,
                 dedicated_instances: Sequence['outputs.GetInstanceGroupsGroupDedicatedInstanceResult'],
                 description: str,
                 domain_names: Sequence['outputs.GetInstanceGroupsGroupDomainNameResult'],
                 header_limit: int,
                 load_balancers: Sequence[str],
                 name: str,
                 read_timeout: int,
                 region: str,
                 vpc_id: str,
                 write_timeout: int):
        pulumi.set(__self__, "body_limit", body_limit)
        pulumi.set(__self__, "connection_timeout", connection_timeout)
        pulumi.set(__self__, "dedicated_instances", dedicated_instances)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "domain_names", domain_names)
        pulumi.set(__self__, "header_limit", header_limit)
        pulumi.set(__self__, "load_balancers", load_balancers)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "read_timeout", read_timeout)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "write_timeout", write_timeout)

    @property
    @pulumi.getter(name="bodyLimit")
    def body_limit(self) -> int:
        return pulumi.get(self, "body_limit")

    @property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> int:
        return pulumi.get(self, "connection_timeout")

    @property
    @pulumi.getter(name="dedicatedInstances")
    def dedicated_instances(self) -> Sequence['outputs.GetInstanceGroupsGroupDedicatedInstanceResult']:
        return pulumi.get(self, "dedicated_instances")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Sequence['outputs.GetInstanceGroupsGroupDomainNameResult']:
        return pulumi.get(self, "domain_names")

    @property
    @pulumi.getter(name="headerLimit")
    def header_limit(self) -> int:
        return pulumi.get(self, "header_limit")

    @property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> Sequence[str]:
        return pulumi.get(self, "load_balancers")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> int:
        return pulumi.get(self, "read_timeout")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="writeTimeout")
    def write_timeout(self) -> int:
        return pulumi.get(self, "write_timeout")


@pulumi.output_type
class GetInstanceGroupsGroupDedicatedInstanceResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstanceGroupsGroupDomainNameResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPoliciesPolicyResult(dict):
    def __init__(__self__, *,
                 bind_hosts: Sequence['outputs.GetPoliciesPolicyBindHostResult'],
                 deep_inspection: bool,
                 full_detection: bool,
                 header_inspection: bool,
                 id: str,
                 level: int,
                 name: str,
                 options: Sequence['outputs.GetPoliciesPolicyOptionResult'],
                 protection_mode: str,
                 robot_action: str,
                 shiro_decryption_check: bool):
        """
        :param Sequence['GetPoliciesPolicyBindHostArgs'] bind_hosts: The protection switches. The object structure is documented below.
        :param bool deep_inspection: The deep inspection in basic web protection.
        :param bool full_detection: The detection mode in precise protection.
               + **false**: Instant detection. When a request hits the blocking conditions in precise protection, WAF terminates
               checks and blocks the request immediately.
               + **true**: Full detection. If a request hits the blocking conditions in precise protection, WAF does not block the
               request immediately. Instead, it blocks the requests until other checks are finished.
        :param bool header_inspection: The header inspection in basic web protection.
        :param str id: The domain name ID.
        :param int level: The protection level. Valid values are:
               + **1**: Low. At this protection level, WAF blocks only requests with obvious attack features. If a large number of
               false alarms have been reported, this value is recommended.
               + **2**: Medium. This protection level meets web protection requirements in most scenarios.
               + **3**: High. At this protection level, WAF provides the finest granular protection and can intercept attacks with
               complex bypass features, such as Jolokia cyberattacks, common gateway interface (CGI) vulnerability detection,
               and Druid SQL injection attacks.
        :param str name: Specifies the policy name used for matching. The value is case-sensitive and supports
               fuzzy matching.
        :param Sequence['GetPoliciesPolicyOptionArgs'] options: The protection switches. The options object structure is documented below.
        :param str protection_mode: The protective action after a rule is matched. Valid values are:
               + **block**: WAF blocks and logs detected attacks.
               + **log**: WAF logs detected attacks only.
        :param str robot_action: The protective actions for each rule in anti-crawler protection. Valid values are:
               + **block**: WAF blocks discovered attacks.
               + **log**: WAF only logs discovered attacks.
        :param bool shiro_decryption_check: The shiro decryption check in basic web protection.
        """
        pulumi.set(__self__, "bind_hosts", bind_hosts)
        pulumi.set(__self__, "deep_inspection", deep_inspection)
        pulumi.set(__self__, "full_detection", full_detection)
        pulumi.set(__self__, "header_inspection", header_inspection)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "protection_mode", protection_mode)
        pulumi.set(__self__, "robot_action", robot_action)
        pulumi.set(__self__, "shiro_decryption_check", shiro_decryption_check)

    @property
    @pulumi.getter(name="bindHosts")
    def bind_hosts(self) -> Sequence['outputs.GetPoliciesPolicyBindHostResult']:
        """
        The protection switches. The object structure is documented below.
        """
        return pulumi.get(self, "bind_hosts")

    @property
    @pulumi.getter(name="deepInspection")
    def deep_inspection(self) -> bool:
        """
        The deep inspection in basic web protection.
        """
        return pulumi.get(self, "deep_inspection")

    @property
    @pulumi.getter(name="fullDetection")
    def full_detection(self) -> bool:
        """
        The detection mode in precise protection.
        + **false**: Instant detection. When a request hits the blocking conditions in precise protection, WAF terminates
        checks and blocks the request immediately.
        + **true**: Full detection. If a request hits the blocking conditions in precise protection, WAF does not block the
        request immediately. Instead, it blocks the requests until other checks are finished.
        """
        return pulumi.get(self, "full_detection")

    @property
    @pulumi.getter(name="headerInspection")
    def header_inspection(self) -> bool:
        """
        The header inspection in basic web protection.
        """
        return pulumi.get(self, "header_inspection")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The domain name ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def level(self) -> int:
        """
        The protection level. Valid values are:
        + **1**: Low. At this protection level, WAF blocks only requests with obvious attack features. If a large number of
        false alarms have been reported, this value is recommended.
        + **2**: Medium. This protection level meets web protection requirements in most scenarios.
        + **3**: High. At this protection level, WAF provides the finest granular protection and can intercept attacks with
        complex bypass features, such as Jolokia cyberattacks, common gateway interface (CGI) vulnerability detection,
        and Druid SQL injection attacks.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the policy name used for matching. The value is case-sensitive and supports
        fuzzy matching.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def options(self) -> Sequence['outputs.GetPoliciesPolicyOptionResult']:
        """
        The protection switches. The options object structure is documented below.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> str:
        """
        The protective action after a rule is matched. Valid values are:
        + **block**: WAF blocks and logs detected attacks.
        + **log**: WAF logs detected attacks only.
        """
        return pulumi.get(self, "protection_mode")

    @property
    @pulumi.getter(name="robotAction")
    def robot_action(self) -> str:
        """
        The protective actions for each rule in anti-crawler protection. Valid values are:
        + **block**: WAF blocks discovered attacks.
        + **log**: WAF only logs discovered attacks.
        """
        return pulumi.get(self, "robot_action")

    @property
    @pulumi.getter(name="shiroDecryptionCheck")
    def shiro_decryption_check(self) -> bool:
        """
        The shiro decryption check in basic web protection.
        """
        return pulumi.get(self, "shiro_decryption_check")


@pulumi.output_type
class GetPoliciesPolicyBindHostResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 id: str,
                 mode: str,
                 waf_type: str):
        """
        :param str hostname: The domain name.
        :param str id: The domain name ID.
        :param str mode: The special domain name mode. This attribute is only valid for dedicated mode.
        :param str waf_type: The deployment mode of WAF instance that is used for the domain name. The value can be **cloud** for
               cloud WAF or **premium** for dedicated WAF instances.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "waf_type", waf_type)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The domain name.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The domain name ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The special domain name mode. This attribute is only valid for dedicated mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="wafType")
    def waf_type(self) -> str:
        """
        The deployment mode of WAF instance that is used for the domain name. The value can be **cloud** for
        cloud WAF or **premium** for dedicated WAF instances.
        """
        return pulumi.get(self, "waf_type")


@pulumi.output_type
class GetPoliciesPolicyOptionResult(dict):
    def __init__(__self__, *,
                 anti_crawler: bool,
                 basic_web_protection: bool,
                 blacklist: bool,
                 bot_enable: bool,
                 cc_attack_protection: bool,
                 crawler: bool,
                 crawler_engine: bool,
                 crawler_other: bool,
                 crawler_scanner: bool,
                 crawler_script: bool,
                 data_masking: bool,
                 false_alarm_masking: bool,
                 general_check: bool,
                 geolocation_access_control: bool,
                 information_leakage_prevention: bool,
                 known_attack_source: bool,
                 precise_protection: bool,
                 web_tamper_protection: bool,
                 webshell: bool):
        """
        :param bool anti_crawler: Indicates whether the javascript anti-crawler is enabled.
        :param bool basic_web_protection: Indicates whether Basic Web Protection is enabled.
        :param bool blacklist: Indicates whether the blacklist and whitelist protection is enabled.
        :param bool bot_enable: Indicates whether the anti-crawler protection is enabled.
        :param bool cc_attack_protection: Indicates whether the cc attack protection rules are enabled.
        :param bool crawler_engine: Indicates whether the search engine is enabled.
        :param bool crawler_other: Indicates whether other crawler check is enabled.
        :param bool crawler_scanner: Indicates whether the anti-crawler detection is enabled.
        :param bool crawler_script: Indicates whether the script tool is enabled.
        :param bool data_masking: Indicates whether data masking is enabled.
        :param bool false_alarm_masking: Indicates whether false alarm masking is enabled.
        :param bool general_check: Indicates whether General Check in Basic Web Protection is enabled.
        :param bool geolocation_access_control: Indicates whether the geolocation access control is enabled.
        :param bool information_leakage_prevention: Indicates whether the information leakage prevention is enabled.
        :param bool known_attack_source: Indicates whether the known attack source is enabled.
        :param bool precise_protection: Indicates whether the precise protection is enabled.
        :param bool web_tamper_protection: Indicates whether the web tamper protection is enabled.
        :param bool webshell: Indicates whether the web shell detection in basic web protection is enabled.
        """
        pulumi.set(__self__, "anti_crawler", anti_crawler)
        pulumi.set(__self__, "basic_web_protection", basic_web_protection)
        pulumi.set(__self__, "blacklist", blacklist)
        pulumi.set(__self__, "bot_enable", bot_enable)
        pulumi.set(__self__, "cc_attack_protection", cc_attack_protection)
        pulumi.set(__self__, "crawler", crawler)
        pulumi.set(__self__, "crawler_engine", crawler_engine)
        pulumi.set(__self__, "crawler_other", crawler_other)
        pulumi.set(__self__, "crawler_scanner", crawler_scanner)
        pulumi.set(__self__, "crawler_script", crawler_script)
        pulumi.set(__self__, "data_masking", data_masking)
        pulumi.set(__self__, "false_alarm_masking", false_alarm_masking)
        pulumi.set(__self__, "general_check", general_check)
        pulumi.set(__self__, "geolocation_access_control", geolocation_access_control)
        pulumi.set(__self__, "information_leakage_prevention", information_leakage_prevention)
        pulumi.set(__self__, "known_attack_source", known_attack_source)
        pulumi.set(__self__, "precise_protection", precise_protection)
        pulumi.set(__self__, "web_tamper_protection", web_tamper_protection)
        pulumi.set(__self__, "webshell", webshell)

    @property
    @pulumi.getter(name="antiCrawler")
    def anti_crawler(self) -> bool:
        """
        Indicates whether the javascript anti-crawler is enabled.
        """
        return pulumi.get(self, "anti_crawler")

    @property
    @pulumi.getter(name="basicWebProtection")
    def basic_web_protection(self) -> bool:
        """
        Indicates whether Basic Web Protection is enabled.
        """
        return pulumi.get(self, "basic_web_protection")

    @property
    @pulumi.getter
    def blacklist(self) -> bool:
        """
        Indicates whether the blacklist and whitelist protection is enabled.
        """
        return pulumi.get(self, "blacklist")

    @property
    @pulumi.getter(name="botEnable")
    def bot_enable(self) -> bool:
        """
        Indicates whether the anti-crawler protection is enabled.
        """
        return pulumi.get(self, "bot_enable")

    @property
    @pulumi.getter(name="ccAttackProtection")
    def cc_attack_protection(self) -> bool:
        """
        Indicates whether the cc attack protection rules are enabled.
        """
        return pulumi.get(self, "cc_attack_protection")

    @property
    @pulumi.getter
    def crawler(self) -> bool:
        return pulumi.get(self, "crawler")

    @property
    @pulumi.getter(name="crawlerEngine")
    def crawler_engine(self) -> bool:
        """
        Indicates whether the search engine is enabled.
        """
        return pulumi.get(self, "crawler_engine")

    @property
    @pulumi.getter(name="crawlerOther")
    def crawler_other(self) -> bool:
        """
        Indicates whether other crawler check is enabled.
        """
        return pulumi.get(self, "crawler_other")

    @property
    @pulumi.getter(name="crawlerScanner")
    def crawler_scanner(self) -> bool:
        """
        Indicates whether the anti-crawler detection is enabled.
        """
        return pulumi.get(self, "crawler_scanner")

    @property
    @pulumi.getter(name="crawlerScript")
    def crawler_script(self) -> bool:
        """
        Indicates whether the script tool is enabled.
        """
        return pulumi.get(self, "crawler_script")

    @property
    @pulumi.getter(name="dataMasking")
    def data_masking(self) -> bool:
        """
        Indicates whether data masking is enabled.
        """
        return pulumi.get(self, "data_masking")

    @property
    @pulumi.getter(name="falseAlarmMasking")
    def false_alarm_masking(self) -> bool:
        """
        Indicates whether false alarm masking is enabled.
        """
        return pulumi.get(self, "false_alarm_masking")

    @property
    @pulumi.getter(name="generalCheck")
    def general_check(self) -> bool:
        """
        Indicates whether General Check in Basic Web Protection is enabled.
        """
        return pulumi.get(self, "general_check")

    @property
    @pulumi.getter(name="geolocationAccessControl")
    def geolocation_access_control(self) -> bool:
        """
        Indicates whether the geolocation access control is enabled.
        """
        return pulumi.get(self, "geolocation_access_control")

    @property
    @pulumi.getter(name="informationLeakagePrevention")
    def information_leakage_prevention(self) -> bool:
        """
        Indicates whether the information leakage prevention is enabled.
        """
        return pulumi.get(self, "information_leakage_prevention")

    @property
    @pulumi.getter(name="knownAttackSource")
    def known_attack_source(self) -> bool:
        """
        Indicates whether the known attack source is enabled.
        """
        return pulumi.get(self, "known_attack_source")

    @property
    @pulumi.getter(name="preciseProtection")
    def precise_protection(self) -> bool:
        """
        Indicates whether the precise protection is enabled.
        """
        return pulumi.get(self, "precise_protection")

    @property
    @pulumi.getter(name="webTamperProtection")
    def web_tamper_protection(self) -> bool:
        """
        Indicates whether the web tamper protection is enabled.
        """
        return pulumi.get(self, "web_tamper_protection")

    @property
    @pulumi.getter
    def webshell(self) -> bool:
        """
        Indicates whether the web shell detection in basic web protection is enabled.
        """
        return pulumi.get(self, "webshell")


@pulumi.output_type
class GetReferenceTablesTableResult(dict):
    def __init__(__self__, *,
                 conditions: Sequence[str],
                 creation_time: str,
                 description: str,
                 id: str,
                 name: str,
                 type: str):
        """
        :param Sequence[str] conditions: The conditions of the reference table.
        :param str creation_time: The server time when reference table was created.
        :param str description: The description of the reference table.
        :param str id: The ID of the reference table.
        :param str name: Specifies the name of the reference table. The value is case-sensitive and matches exactly.
        :param str type: The type of the reference table, The options are: `url`, `user-agent`, `ip`, `params`, `cookie`, `referer`
               and `header`.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "creation_time", creation_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence[str]:
        """
        The conditions of the reference table.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> str:
        """
        The server time when reference table was created.
        """
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the reference table.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the reference table.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the reference table. The value is case-sensitive and matches exactly.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the reference table, The options are: `url`, `user-agent`, `ip`, `params`, `cookie`, `referer`
        and `header`.
        """
        return pulumi.get(self, "type")


