# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = ['LoadbalancerCopyArgs', 'LoadbalancerCopy']

@pulumi.input_type
class LoadbalancerCopyArgs:
    def __init__(__self__, *,
                 loadbalancer_id: pulumi.Input[str],
                 auto_renew: Optional[pulumi.Input[str]] = None,
                 availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 backend_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 charging_mode: Optional[pulumi.Input[str]] = None,
                 cross_vpc_backend: Optional[pulumi.Input[str]] = None,
                 deletion_protection_enable: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_force_new: Optional[pulumi.Input[str]] = None,
                 enterprise_project_id: Optional[pulumi.Input[str]] = None,
                 force_delete: Optional[pulumi.Input[bool]] = None,
                 ipv4_address: Optional[pulumi.Input[str]] = None,
                 ipv4_subnet_id: Optional[pulumi.Input[str]] = None,
                 ipv6_address: Optional[pulumi.Input[str]] = None,
                 ipv6_bandwidth_id: Optional[pulumi.Input[str]] = None,
                 ipv6_network_id: Optional[pulumi.Input[str]] = None,
                 l4_flavor_id: Optional[pulumi.Input[str]] = None,
                 l7_flavor_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 period_unit: Optional[pulumi.Input[str]] = None,
                 protection_reason: Optional[pulumi.Input[str]] = None,
                 protection_status: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 reuse_pool: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 waf_failure_action: Optional[pulumi.Input[str]] = None):
        """
        The set of arguments for constructing a LoadbalancerCopy resource.
        :param pulumi.Input[str] loadbalancer_id: Specifies the source load balancer ID.
        :param pulumi.Input[str] auto_renew: Specifies whether auto-renew is enabled. Valid values are **true** and **false**.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] availability_zones: Specifies the list of AZ names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] backend_subnets: Specifies the ID of the backend subnet of the load balancer. If it is not specified,
               the backend subnet of the original load balancer is used. The subnets where the original and new load balancers work must
               be in the same VPC.
        :param pulumi.Input[str] charging_mode: Specifies the charging mode of the ELB load balancer.
               Valid values are **prePaid** and **postPaid**, defaults to **postPaid**.
        :param pulumi.Input[str] cross_vpc_backend: Specifies whether to add backend servers that are not in the load balancer's
               VPC. Can only be **true** when updating. Value options: **true**, **false**.
        :param pulumi.Input[str] deletion_protection_enable: Specifies whether to enable deletion protection for the load balancer.
               Value options:
               + **true**: Enable deletion protection.
               + **false**: Disable deletion protection.
        :param pulumi.Input[str] description: Specifies the description of the load balancer.
        :param pulumi.Input[str] enterprise_project_id: The enterprise project ID of the load balancer.
        :param pulumi.Input[bool] force_delete: Specifies whether to forcibly delete the load balancer, remove the load
               balancer, listeners, unbind associated pools. Defaults to **false**.
        :param pulumi.Input[str] ipv4_address: Specifies the private IPv4 address of the load balancer.
        :param pulumi.Input[str] ipv4_subnet_id: Specifies the ID of the IPv4 subnet where the load balancer works. If it is not
               specified, the IPv4 subnet of the original load balancer is used. The subnets where the original and new load balancers
               work must be in the same VPC.
        :param pulumi.Input[str] ipv6_address: Specifies the private IPv6 address of the load balancer.
        :param pulumi.Input[str] ipv6_bandwidth_id: Specifies the ipv6 bandwidth ID. Only support shared bandwidth.
        :param pulumi.Input[str] ipv6_network_id: Specifies the ID of the IPv6 subnet where the new load balancer works. If it is
               not specified, the IPv6 subnet of the original load balancer is used. The subnets where the original and new load
               balancers work must be in the same VPC.
        :param pulumi.Input[str] l4_flavor_id: Specifies the Layer 4 specifications of the new load balancer. If it is not specified,
               the Layer 4 specifications of the original load balancer are used.
        :param pulumi.Input[str] l7_flavor_id: Specifies the Layer 7 specifications of the new load balancer. If it is not specified,
               the Layer 7 specifications of the original load balancer are used.
        :param pulumi.Input[str] name: Specifies the load balancer name.
        :param pulumi.Input[int] period: Specifies the charging period of the ELB load balancer.
               If `period_unit` is set to **month**, the value ranges from `1` to `9`.
               If `period_unit` is set to **year**, the value ranges from `1` to `3`.
               This parameter is mandatory if `charging_mode` is set to **prePaid**.
        :param pulumi.Input[str] period_unit: Specifies the charging period unit of the ELB load balancer.
               Valid values are **month** and **year**. This parameter is mandatory if `charging_mode` is set to **prePaid**.
        :param pulumi.Input[str] protection_reason: Specifies the reason for update protection. Only valid when `protection_status`
               is **consoleProtection**.
        :param pulumi.Input[str] protection_status: Specifies the protection status for update. Value options:
               + **nonProtection**: No protection.
               + **consoleProtection**: Console modification protection.
        :param pulumi.Input[str] region: The region in which to create the load balancer resource. If omitted, the
               provider-level region will be used. Changing this creates a new load balancer.
        :param pulumi.Input[str] reuse_pool: Specifies whether to reuse the backend server group and backend server
               ID of the original load balancer.
               + If it is set to **true**, the backend server group of the original load balancer will be used.
               + If no backend server group is selected, a new backend server group is created by default.
               + It is invalid when `enterprise_project_id` is set to another enterprise project.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: The key/value pairs to associate with the load balancer.
        :param pulumi.Input[str] waf_failure_action: Specifies traffic distributing policies when the WAF is faulty.
               Value options:
               + **discard**: Traffic will not be distributed.
               + **forward**: Traffic will be distributed to the default backend servers.
        """
        pulumi.set(__self__, "loadbalancer_id", loadbalancer_id)
        if auto_renew is not None:
            pulumi.set(__self__, "auto_renew", auto_renew)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if backend_subnets is not None:
            pulumi.set(__self__, "backend_subnets", backend_subnets)
        if charging_mode is not None:
            pulumi.set(__self__, "charging_mode", charging_mode)
        if cross_vpc_backend is not None:
            pulumi.set(__self__, "cross_vpc_backend", cross_vpc_backend)
        if deletion_protection_enable is not None:
            pulumi.set(__self__, "deletion_protection_enable", deletion_protection_enable)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_force_new is not None:
            pulumi.set(__self__, "enable_force_new", enable_force_new)
        if enterprise_project_id is not None:
            pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        if force_delete is not None:
            pulumi.set(__self__, "force_delete", force_delete)
        if ipv4_address is not None:
            pulumi.set(__self__, "ipv4_address", ipv4_address)
        if ipv4_subnet_id is not None:
            pulumi.set(__self__, "ipv4_subnet_id", ipv4_subnet_id)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if ipv6_bandwidth_id is not None:
            pulumi.set(__self__, "ipv6_bandwidth_id", ipv6_bandwidth_id)
        if ipv6_network_id is not None:
            pulumi.set(__self__, "ipv6_network_id", ipv6_network_id)
        if l4_flavor_id is not None:
            pulumi.set(__self__, "l4_flavor_id", l4_flavor_id)
        if l7_flavor_id is not None:
            pulumi.set(__self__, "l7_flavor_id", l7_flavor_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if period_unit is not None:
            pulumi.set(__self__, "period_unit", period_unit)
        if protection_reason is not None:
            pulumi.set(__self__, "protection_reason", protection_reason)
        if protection_status is not None:
            pulumi.set(__self__, "protection_status", protection_status)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if reuse_pool is not None:
            pulumi.set(__self__, "reuse_pool", reuse_pool)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if waf_failure_action is not None:
            pulumi.set(__self__, "waf_failure_action", waf_failure_action)

    @property
    @pulumi.getter(name="loadbalancerId")
    def loadbalancer_id(self) -> pulumi.Input[str]:
        """
        Specifies the source load balancer ID.
        """
        return pulumi.get(self, "loadbalancer_id")

    @loadbalancer_id.setter
    def loadbalancer_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "loadbalancer_id", value)

    @property
    @pulumi.getter(name="autoRenew")
    def auto_renew(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether auto-renew is enabled. Valid values are **true** and **false**.
        """
        return pulumi.get(self, "auto_renew")

    @auto_renew.setter
    def auto_renew(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_renew", value)

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the list of AZ names.
        """
        return pulumi.get(self, "availability_zones")

    @availability_zones.setter
    def availability_zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "availability_zones", value)

    @property
    @pulumi.getter(name="backendSubnets")
    def backend_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the ID of the backend subnet of the load balancer. If it is not specified,
        the backend subnet of the original load balancer is used. The subnets where the original and new load balancers work must
        be in the same VPC.
        """
        return pulumi.get(self, "backend_subnets")

    @backend_subnets.setter
    def backend_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "backend_subnets", value)

    @property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the charging mode of the ELB load balancer.
        Valid values are **prePaid** and **postPaid**, defaults to **postPaid**.
        """
        return pulumi.get(self, "charging_mode")

    @charging_mode.setter
    def charging_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "charging_mode", value)

    @property
    @pulumi.getter(name="crossVpcBackend")
    def cross_vpc_backend(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to add backend servers that are not in the load balancer's
        VPC. Can only be **true** when updating. Value options: **true**, **false**.
        """
        return pulumi.get(self, "cross_vpc_backend")

    @cross_vpc_backend.setter
    def cross_vpc_backend(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cross_vpc_backend", value)

    @property
    @pulumi.getter(name="deletionProtectionEnable")
    def deletion_protection_enable(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to enable deletion protection for the load balancer.
        Value options:
        + **true**: Enable deletion protection.
        + **false**: Disable deletion protection.
        """
        return pulumi.get(self, "deletion_protection_enable")

    @deletion_protection_enable.setter
    def deletion_protection_enable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deletion_protection_enable", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the description of the load balancer.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="enableForceNew")
    def enable_force_new(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "enable_force_new")

    @enable_force_new.setter
    def enable_force_new(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enable_force_new", value)

    @property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> Optional[pulumi.Input[str]]:
        """
        The enterprise project ID of the load balancer.
        """
        return pulumi.get(self, "enterprise_project_id")

    @enterprise_project_id.setter
    def enterprise_project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enterprise_project_id", value)

    @property
    @pulumi.getter(name="forceDelete")
    def force_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to forcibly delete the load balancer, remove the load
        balancer, listeners, unbind associated pools. Defaults to **false**.
        """
        return pulumi.get(self, "force_delete")

    @force_delete.setter
    def force_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_delete", value)

    @property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the private IPv4 address of the load balancer.
        """
        return pulumi.get(self, "ipv4_address")

    @ipv4_address.setter
    def ipv4_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4_address", value)

    @property
    @pulumi.getter(name="ipv4SubnetId")
    def ipv4_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the ID of the IPv4 subnet where the load balancer works. If it is not
        specified, the IPv4 subnet of the original load balancer is used. The subnets where the original and new load balancers
        work must be in the same VPC.
        """
        return pulumi.get(self, "ipv4_subnet_id")

    @ipv4_subnet_id.setter
    def ipv4_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4_subnet_id", value)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the private IPv6 address of the load balancer.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_address", value)

    @property
    @pulumi.getter(name="ipv6BandwidthId")
    def ipv6_bandwidth_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the ipv6 bandwidth ID. Only support shared bandwidth.
        """
        return pulumi.get(self, "ipv6_bandwidth_id")

    @ipv6_bandwidth_id.setter
    def ipv6_bandwidth_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_bandwidth_id", value)

    @property
    @pulumi.getter(name="ipv6NetworkId")
    def ipv6_network_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the ID of the IPv6 subnet where the new load balancer works. If it is
        not specified, the IPv6 subnet of the original load balancer is used. The subnets where the original and new load
        balancers work must be in the same VPC.
        """
        return pulumi.get(self, "ipv6_network_id")

    @ipv6_network_id.setter
    def ipv6_network_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_network_id", value)

    @property
    @pulumi.getter(name="l4FlavorId")
    def l4_flavor_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Layer 4 specifications of the new load balancer. If it is not specified,
        the Layer 4 specifications of the original load balancer are used.
        """
        return pulumi.get(self, "l4_flavor_id")

    @l4_flavor_id.setter
    def l4_flavor_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "l4_flavor_id", value)

    @property
    @pulumi.getter(name="l7FlavorId")
    def l7_flavor_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Layer 7 specifications of the new load balancer. If it is not specified,
        the Layer 7 specifications of the original load balancer are used.
        """
        return pulumi.get(self, "l7_flavor_id")

    @l7_flavor_id.setter
    def l7_flavor_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "l7_flavor_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the load balancer name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the charging period of the ELB load balancer.
        If `period_unit` is set to **month**, the value ranges from `1` to `9`.
        If `period_unit` is set to **year**, the value ranges from `1` to `3`.
        This parameter is mandatory if `charging_mode` is set to **prePaid**.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter(name="periodUnit")
    def period_unit(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the charging period unit of the ELB load balancer.
        Valid values are **month** and **year**. This parameter is mandatory if `charging_mode` is set to **prePaid**.
        """
        return pulumi.get(self, "period_unit")

    @period_unit.setter
    def period_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "period_unit", value)

    @property
    @pulumi.getter(name="protectionReason")
    def protection_reason(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the reason for update protection. Only valid when `protection_status`
        is **consoleProtection**.
        """
        return pulumi.get(self, "protection_reason")

    @protection_reason.setter
    def protection_reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protection_reason", value)

    @property
    @pulumi.getter(name="protectionStatus")
    def protection_status(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the protection status for update. Value options:
        + **nonProtection**: No protection.
        + **consoleProtection**: Console modification protection.
        """
        return pulumi.get(self, "protection_status")

    @protection_status.setter
    def protection_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protection_status", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The region in which to create the load balancer resource. If omitted, the
        provider-level region will be used. Changing this creates a new load balancer.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="reusePool")
    def reuse_pool(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to reuse the backend server group and backend server
        ID of the original load balancer.
        + If it is set to **true**, the backend server group of the original load balancer will be used.
        + If no backend server group is selected, a new backend server group is created by default.
        + It is invalid when `enterprise_project_id` is set to another enterprise project.
        """
        return pulumi.get(self, "reuse_pool")

    @reuse_pool.setter
    def reuse_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reuse_pool", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The key/value pairs to associate with the load balancer.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="wafFailureAction")
    def waf_failure_action(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies traffic distributing policies when the WAF is faulty.
        Value options:
        + **discard**: Traffic will not be distributed.
        + **forward**: Traffic will be distributed to the default backend servers.
        """
        return pulumi.get(self, "waf_failure_action")

    @waf_failure_action.setter
    def waf_failure_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "waf_failure_action", value)


@pulumi.input_type
class _LoadbalancerCopyState:
    def __init__(__self__, *,
                 auto_renew: Optional[pulumi.Input[str]] = None,
                 availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 backend_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 charge_mode: Optional[pulumi.Input[str]] = None,
                 charging_mode: Optional[pulumi.Input[str]] = None,
                 created_at: Optional[pulumi.Input[str]] = None,
                 cross_vpc_backend: Optional[pulumi.Input[str]] = None,
                 deletion_protection_enable: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 elb_virsubnet_type: Optional[pulumi.Input[str]] = None,
                 enable_force_new: Optional[pulumi.Input[str]] = None,
                 enterprise_project_id: Optional[pulumi.Input[str]] = None,
                 force_delete: Optional[pulumi.Input[bool]] = None,
                 frozen_scene: Optional[pulumi.Input[str]] = None,
                 gw_flavor_id: Optional[pulumi.Input[str]] = None,
                 ipv4_address: Optional[pulumi.Input[str]] = None,
                 ipv4_port_id: Optional[pulumi.Input[str]] = None,
                 ipv4_subnet_id: Optional[pulumi.Input[str]] = None,
                 ipv6_address: Optional[pulumi.Input[str]] = None,
                 ipv6_bandwidth_id: Optional[pulumi.Input[str]] = None,
                 ipv6_network_id: Optional[pulumi.Input[str]] = None,
                 l4_flavor_id: Optional[pulumi.Input[str]] = None,
                 l7_flavor_id: Optional[pulumi.Input[str]] = None,
                 loadbalancer_id: Optional[pulumi.Input[str]] = None,
                 loadbalancer_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 operating_status: Optional[pulumi.Input[str]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 period_unit: Optional[pulumi.Input[str]] = None,
                 protection_reason: Optional[pulumi.Input[str]] = None,
                 protection_status: Optional[pulumi.Input[str]] = None,
                 public_border_group: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 reuse_pool: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None,
                 vpc_id: Optional[pulumi.Input[str]] = None,
                 waf_failure_action: Optional[pulumi.Input[str]] = None):
        """
        Input properties used for looking up and filtering LoadbalancerCopy resources.
        :param pulumi.Input[str] auto_renew: Specifies whether auto-renew is enabled. Valid values are **true** and **false**.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] availability_zones: Specifies the list of AZ names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] backend_subnets: Specifies the ID of the backend subnet of the load balancer. If it is not specified,
               the backend subnet of the original load balancer is used. The subnets where the original and new load balancers work must
               be in the same VPC.
        :param pulumi.Input[str] charge_mode: Indicates the billing mode. The value can be:
               + **flavor**: Billed by the specifications you will select.
               + **lcu**: Billed by LCU usage.
        :param pulumi.Input[str] charging_mode: Specifies the charging mode of the ELB load balancer.
               Valid values are **prePaid** and **postPaid**, defaults to **postPaid**.
        :param pulumi.Input[str] created_at: Indicates the time when the load balancer was created, in RFC3339 format.
        :param pulumi.Input[str] cross_vpc_backend: Specifies whether to add backend servers that are not in the load balancer's
               VPC. Can only be **true** when updating. Value options: **true**, **false**.
        :param pulumi.Input[str] deletion_protection_enable: Specifies whether to enable deletion protection for the load balancer.
               Value options:
               + **true**: Enable deletion protection.
               + **false**: Disable deletion protection.
        :param pulumi.Input[str] description: Specifies the description of the load balancer.
        :param pulumi.Input[str] elb_virsubnet_type: Indicates the type of the subnet on the downstream plane. The value can be:
               + **ipv4**: IPv4 subnet
               + **dualstack**: subnet that supports IPv4/IPv6 dual stack
        :param pulumi.Input[str] enterprise_project_id: The enterprise project ID of the load balancer.
        :param pulumi.Input[bool] force_delete: Specifies whether to forcibly delete the load balancer, remove the load
               balancer, listeners, unbind associated pools. Defaults to **false**.
        :param pulumi.Input[str] frozen_scene: Indicates the scenario where the load balancer is frozen. Multiple values are separated using commas (,).
               The value can be:
               + **POLICE**: The load balancer is frozen due to security reasons.
               + **ILLEGAL**: The load balancer is frozen due to violation of laws and regulations.
               + **VERIFY**: Your account has not completed real-name authentication.
               + **PARTNER**: The load balancer is frozen by the partner.
               + **ARREAR**: Your account is in arrears.
        :param pulumi.Input[str] gw_flavor_id: Indicates the flavor ID of the gateway load balancer.
        :param pulumi.Input[str] ipv4_address: Specifies the private IPv4 address of the load balancer.
        :param pulumi.Input[str] ipv4_port_id: Indicates the ID of the port bound to the private IPv4 address of the load balancer.
        :param pulumi.Input[str] ipv4_subnet_id: Specifies the ID of the IPv4 subnet where the load balancer works. If it is not
               specified, the IPv4 subnet of the original load balancer is used. The subnets where the original and new load balancers
               work must be in the same VPC.
        :param pulumi.Input[str] ipv6_address: Specifies the private IPv6 address of the load balancer.
        :param pulumi.Input[str] ipv6_bandwidth_id: Specifies the ipv6 bandwidth ID. Only support shared bandwidth.
        :param pulumi.Input[str] ipv6_network_id: Specifies the ID of the IPv6 subnet where the new load balancer works. If it is
               not specified, the IPv6 subnet of the original load balancer is used. The subnets where the original and new load
               balancers work must be in the same VPC.
        :param pulumi.Input[str] l4_flavor_id: Specifies the Layer 4 specifications of the new load balancer. If it is not specified,
               the Layer 4 specifications of the original load balancer are used.
        :param pulumi.Input[str] l7_flavor_id: Specifies the Layer 7 specifications of the new load balancer. If it is not specified,
               the Layer 7 specifications of the original load balancer are used.
        :param pulumi.Input[str] loadbalancer_id: Specifies the source load balancer ID.
        :param pulumi.Input[str] loadbalancer_type: Indicates the type of the load balancer.
        :param pulumi.Input[str] name: Specifies the load balancer name.
        :param pulumi.Input[str] operating_status: Indicates the operating status of the load balancer. The value can be:
               + **ONLINE**: indicates that the load balancer is running normally.
               + **FROZEN**: indicates that the load balancer is frozen.
        :param pulumi.Input[int] period: Specifies the charging period of the ELB load balancer.
               If `period_unit` is set to **month**, the value ranges from `1` to `9`.
               If `period_unit` is set to **year**, the value ranges from `1` to `3`.
               This parameter is mandatory if `charging_mode` is set to **prePaid**.
        :param pulumi.Input[str] period_unit: Specifies the charging period unit of the ELB load balancer.
               Valid values are **month** and **year**. This parameter is mandatory if `charging_mode` is set to **prePaid**.
        :param pulumi.Input[str] protection_reason: Specifies the reason for update protection. Only valid when `protection_status`
               is **consoleProtection**.
        :param pulumi.Input[str] protection_status: Specifies the protection status for update. Value options:
               + **nonProtection**: No protection.
               + **consoleProtection**: Console modification protection.
        :param pulumi.Input[str] public_border_group: Indicates the AZ group to which the load balancer belongs.
        :param pulumi.Input[str] region: The region in which to create the load balancer resource. If omitted, the
               provider-level region will be used. Changing this creates a new load balancer.
        :param pulumi.Input[str] reuse_pool: Specifies whether to reuse the backend server group and backend server
               ID of the original load balancer.
               + If it is set to **true**, the backend server group of the original load balancer will be used.
               + If no backend server group is selected, a new backend server group is created by default.
               + It is invalid when `enterprise_project_id` is set to another enterprise project.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: The key/value pairs to associate with the load balancer.
        :param pulumi.Input[str] updated_at: Indicates the time when the load balancer was updated, in RFC3339 format.
        :param pulumi.Input[str] vpc_id: Indicates the ID of the VPC where the load balancer resides.
        :param pulumi.Input[str] waf_failure_action: Specifies traffic distributing policies when the WAF is faulty.
               Value options:
               + **discard**: Traffic will not be distributed.
               + **forward**: Traffic will be distributed to the default backend servers.
        """
        if auto_renew is not None:
            pulumi.set(__self__, "auto_renew", auto_renew)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if backend_subnets is not None:
            pulumi.set(__self__, "backend_subnets", backend_subnets)
        if charge_mode is not None:
            pulumi.set(__self__, "charge_mode", charge_mode)
        if charging_mode is not None:
            pulumi.set(__self__, "charging_mode", charging_mode)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if cross_vpc_backend is not None:
            pulumi.set(__self__, "cross_vpc_backend", cross_vpc_backend)
        if deletion_protection_enable is not None:
            pulumi.set(__self__, "deletion_protection_enable", deletion_protection_enable)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if elb_virsubnet_type is not None:
            pulumi.set(__self__, "elb_virsubnet_type", elb_virsubnet_type)
        if enable_force_new is not None:
            pulumi.set(__self__, "enable_force_new", enable_force_new)
        if enterprise_project_id is not None:
            pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        if force_delete is not None:
            pulumi.set(__self__, "force_delete", force_delete)
        if frozen_scene is not None:
            pulumi.set(__self__, "frozen_scene", frozen_scene)
        if gw_flavor_id is not None:
            pulumi.set(__self__, "gw_flavor_id", gw_flavor_id)
        if ipv4_address is not None:
            pulumi.set(__self__, "ipv4_address", ipv4_address)
        if ipv4_port_id is not None:
            pulumi.set(__self__, "ipv4_port_id", ipv4_port_id)
        if ipv4_subnet_id is not None:
            pulumi.set(__self__, "ipv4_subnet_id", ipv4_subnet_id)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if ipv6_bandwidth_id is not None:
            pulumi.set(__self__, "ipv6_bandwidth_id", ipv6_bandwidth_id)
        if ipv6_network_id is not None:
            pulumi.set(__self__, "ipv6_network_id", ipv6_network_id)
        if l4_flavor_id is not None:
            pulumi.set(__self__, "l4_flavor_id", l4_flavor_id)
        if l7_flavor_id is not None:
            pulumi.set(__self__, "l7_flavor_id", l7_flavor_id)
        if loadbalancer_id is not None:
            pulumi.set(__self__, "loadbalancer_id", loadbalancer_id)
        if loadbalancer_type is not None:
            pulumi.set(__self__, "loadbalancer_type", loadbalancer_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operating_status is not None:
            pulumi.set(__self__, "operating_status", operating_status)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if period_unit is not None:
            pulumi.set(__self__, "period_unit", period_unit)
        if protection_reason is not None:
            pulumi.set(__self__, "protection_reason", protection_reason)
        if protection_status is not None:
            pulumi.set(__self__, "protection_status", protection_status)
        if public_border_group is not None:
            pulumi.set(__self__, "public_border_group", public_border_group)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if reuse_pool is not None:
            pulumi.set(__self__, "reuse_pool", reuse_pool)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)
        if waf_failure_action is not None:
            pulumi.set(__self__, "waf_failure_action", waf_failure_action)

    @property
    @pulumi.getter(name="autoRenew")
    def auto_renew(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether auto-renew is enabled. Valid values are **true** and **false**.
        """
        return pulumi.get(self, "auto_renew")

    @auto_renew.setter
    def auto_renew(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_renew", value)

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the list of AZ names.
        """
        return pulumi.get(self, "availability_zones")

    @availability_zones.setter
    def availability_zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "availability_zones", value)

    @property
    @pulumi.getter(name="backendSubnets")
    def backend_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the ID of the backend subnet of the load balancer. If it is not specified,
        the backend subnet of the original load balancer is used. The subnets where the original and new load balancers work must
        be in the same VPC.
        """
        return pulumi.get(self, "backend_subnets")

    @backend_subnets.setter
    def backend_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "backend_subnets", value)

    @property
    @pulumi.getter(name="chargeMode")
    def charge_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the billing mode. The value can be:
        + **flavor**: Billed by the specifications you will select.
        + **lcu**: Billed by LCU usage.
        """
        return pulumi.get(self, "charge_mode")

    @charge_mode.setter
    def charge_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "charge_mode", value)

    @property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the charging mode of the ELB load balancer.
        Valid values are **prePaid** and **postPaid**, defaults to **postPaid**.
        """
        return pulumi.get(self, "charging_mode")

    @charging_mode.setter
    def charging_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "charging_mode", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the time when the load balancer was created, in RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="crossVpcBackend")
    def cross_vpc_backend(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to add backend servers that are not in the load balancer's
        VPC. Can only be **true** when updating. Value options: **true**, **false**.
        """
        return pulumi.get(self, "cross_vpc_backend")

    @cross_vpc_backend.setter
    def cross_vpc_backend(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cross_vpc_backend", value)

    @property
    @pulumi.getter(name="deletionProtectionEnable")
    def deletion_protection_enable(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to enable deletion protection for the load balancer.
        Value options:
        + **true**: Enable deletion protection.
        + **false**: Disable deletion protection.
        """
        return pulumi.get(self, "deletion_protection_enable")

    @deletion_protection_enable.setter
    def deletion_protection_enable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deletion_protection_enable", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the description of the load balancer.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="elbVirsubnetType")
    def elb_virsubnet_type(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the type of the subnet on the downstream plane. The value can be:
        + **ipv4**: IPv4 subnet
        + **dualstack**: subnet that supports IPv4/IPv6 dual stack
        """
        return pulumi.get(self, "elb_virsubnet_type")

    @elb_virsubnet_type.setter
    def elb_virsubnet_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "elb_virsubnet_type", value)

    @property
    @pulumi.getter(name="enableForceNew")
    def enable_force_new(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "enable_force_new")

    @enable_force_new.setter
    def enable_force_new(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enable_force_new", value)

    @property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> Optional[pulumi.Input[str]]:
        """
        The enterprise project ID of the load balancer.
        """
        return pulumi.get(self, "enterprise_project_id")

    @enterprise_project_id.setter
    def enterprise_project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enterprise_project_id", value)

    @property
    @pulumi.getter(name="forceDelete")
    def force_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to forcibly delete the load balancer, remove the load
        balancer, listeners, unbind associated pools. Defaults to **false**.
        """
        return pulumi.get(self, "force_delete")

    @force_delete.setter
    def force_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_delete", value)

    @property
    @pulumi.getter(name="frozenScene")
    def frozen_scene(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the scenario where the load balancer is frozen. Multiple values are separated using commas (,).
        The value can be:
        + **POLICE**: The load balancer is frozen due to security reasons.
        + **ILLEGAL**: The load balancer is frozen due to violation of laws and regulations.
        + **VERIFY**: Your account has not completed real-name authentication.
        + **PARTNER**: The load balancer is frozen by the partner.
        + **ARREAR**: Your account is in arrears.
        """
        return pulumi.get(self, "frozen_scene")

    @frozen_scene.setter
    def frozen_scene(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frozen_scene", value)

    @property
    @pulumi.getter(name="gwFlavorId")
    def gw_flavor_id(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the flavor ID of the gateway load balancer.
        """
        return pulumi.get(self, "gw_flavor_id")

    @gw_flavor_id.setter
    def gw_flavor_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gw_flavor_id", value)

    @property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the private IPv4 address of the load balancer.
        """
        return pulumi.get(self, "ipv4_address")

    @ipv4_address.setter
    def ipv4_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4_address", value)

    @property
    @pulumi.getter(name="ipv4PortId")
    def ipv4_port_id(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the ID of the port bound to the private IPv4 address of the load balancer.
        """
        return pulumi.get(self, "ipv4_port_id")

    @ipv4_port_id.setter
    def ipv4_port_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4_port_id", value)

    @property
    @pulumi.getter(name="ipv4SubnetId")
    def ipv4_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the ID of the IPv4 subnet where the load balancer works. If it is not
        specified, the IPv4 subnet of the original load balancer is used. The subnets where the original and new load balancers
        work must be in the same VPC.
        """
        return pulumi.get(self, "ipv4_subnet_id")

    @ipv4_subnet_id.setter
    def ipv4_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4_subnet_id", value)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the private IPv6 address of the load balancer.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_address", value)

    @property
    @pulumi.getter(name="ipv6BandwidthId")
    def ipv6_bandwidth_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the ipv6 bandwidth ID. Only support shared bandwidth.
        """
        return pulumi.get(self, "ipv6_bandwidth_id")

    @ipv6_bandwidth_id.setter
    def ipv6_bandwidth_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_bandwidth_id", value)

    @property
    @pulumi.getter(name="ipv6NetworkId")
    def ipv6_network_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the ID of the IPv6 subnet where the new load balancer works. If it is
        not specified, the IPv6 subnet of the original load balancer is used. The subnets where the original and new load
        balancers work must be in the same VPC.
        """
        return pulumi.get(self, "ipv6_network_id")

    @ipv6_network_id.setter
    def ipv6_network_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_network_id", value)

    @property
    @pulumi.getter(name="l4FlavorId")
    def l4_flavor_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Layer 4 specifications of the new load balancer. If it is not specified,
        the Layer 4 specifications of the original load balancer are used.
        """
        return pulumi.get(self, "l4_flavor_id")

    @l4_flavor_id.setter
    def l4_flavor_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "l4_flavor_id", value)

    @property
    @pulumi.getter(name="l7FlavorId")
    def l7_flavor_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Layer 7 specifications of the new load balancer. If it is not specified,
        the Layer 7 specifications of the original load balancer are used.
        """
        return pulumi.get(self, "l7_flavor_id")

    @l7_flavor_id.setter
    def l7_flavor_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "l7_flavor_id", value)

    @property
    @pulumi.getter(name="loadbalancerId")
    def loadbalancer_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the source load balancer ID.
        """
        return pulumi.get(self, "loadbalancer_id")

    @loadbalancer_id.setter
    def loadbalancer_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "loadbalancer_id", value)

    @property
    @pulumi.getter(name="loadbalancerType")
    def loadbalancer_type(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the type of the load balancer.
        """
        return pulumi.get(self, "loadbalancer_type")

    @loadbalancer_type.setter
    def loadbalancer_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "loadbalancer_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the load balancer name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operatingStatus")
    def operating_status(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the operating status of the load balancer. The value can be:
        + **ONLINE**: indicates that the load balancer is running normally.
        + **FROZEN**: indicates that the load balancer is frozen.
        """
        return pulumi.get(self, "operating_status")

    @operating_status.setter
    def operating_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operating_status", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the charging period of the ELB load balancer.
        If `period_unit` is set to **month**, the value ranges from `1` to `9`.
        If `period_unit` is set to **year**, the value ranges from `1` to `3`.
        This parameter is mandatory if `charging_mode` is set to **prePaid**.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter(name="periodUnit")
    def period_unit(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the charging period unit of the ELB load balancer.
        Valid values are **month** and **year**. This parameter is mandatory if `charging_mode` is set to **prePaid**.
        """
        return pulumi.get(self, "period_unit")

    @period_unit.setter
    def period_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "period_unit", value)

    @property
    @pulumi.getter(name="protectionReason")
    def protection_reason(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the reason for update protection. Only valid when `protection_status`
        is **consoleProtection**.
        """
        return pulumi.get(self, "protection_reason")

    @protection_reason.setter
    def protection_reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protection_reason", value)

    @property
    @pulumi.getter(name="protectionStatus")
    def protection_status(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the protection status for update. Value options:
        + **nonProtection**: No protection.
        + **consoleProtection**: Console modification protection.
        """
        return pulumi.get(self, "protection_status")

    @protection_status.setter
    def protection_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protection_status", value)

    @property
    @pulumi.getter(name="publicBorderGroup")
    def public_border_group(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the AZ group to which the load balancer belongs.
        """
        return pulumi.get(self, "public_border_group")

    @public_border_group.setter
    def public_border_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_border_group", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The region in which to create the load balancer resource. If omitted, the
        provider-level region will be used. Changing this creates a new load balancer.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="reusePool")
    def reuse_pool(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to reuse the backend server group and backend server
        ID of the original load balancer.
        + If it is set to **true**, the backend server group of the original load balancer will be used.
        + If no backend server group is selected, a new backend server group is created by default.
        + It is invalid when `enterprise_project_id` is set to another enterprise project.
        """
        return pulumi.get(self, "reuse_pool")

    @reuse_pool.setter
    def reuse_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reuse_pool", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The key/value pairs to associate with the load balancer.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the time when the load balancer was updated, in RFC3339 format.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the ID of the VPC where the load balancer resides.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_id", value)

    @property
    @pulumi.getter(name="wafFailureAction")
    def waf_failure_action(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies traffic distributing policies when the WAF is faulty.
        Value options:
        + **discard**: Traffic will not be distributed.
        + **forward**: Traffic will be distributed to the default backend servers.
        """
        return pulumi.get(self, "waf_failure_action")

    @waf_failure_action.setter
    def waf_failure_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "waf_failure_action", value)


class LoadbalancerCopy(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 auto_renew: Optional[pulumi.Input[str]] = None,
                 availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 backend_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 charging_mode: Optional[pulumi.Input[str]] = None,
                 cross_vpc_backend: Optional[pulumi.Input[str]] = None,
                 deletion_protection_enable: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_force_new: Optional[pulumi.Input[str]] = None,
                 enterprise_project_id: Optional[pulumi.Input[str]] = None,
                 force_delete: Optional[pulumi.Input[bool]] = None,
                 ipv4_address: Optional[pulumi.Input[str]] = None,
                 ipv4_subnet_id: Optional[pulumi.Input[str]] = None,
                 ipv6_address: Optional[pulumi.Input[str]] = None,
                 ipv6_bandwidth_id: Optional[pulumi.Input[str]] = None,
                 ipv6_network_id: Optional[pulumi.Input[str]] = None,
                 l4_flavor_id: Optional[pulumi.Input[str]] = None,
                 l7_flavor_id: Optional[pulumi.Input[str]] = None,
                 loadbalancer_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 period_unit: Optional[pulumi.Input[str]] = None,
                 protection_reason: Optional[pulumi.Input[str]] = None,
                 protection_status: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 reuse_pool: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 waf_failure_action: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        Manages a Dedicated load balancer copy resource within HuaweiCloud.

        ## Example Usage

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        loadbalancer_id = config.require_object("loadbalancerId")
        ipv4_subnet_id = config.require_object("ipv4SubnetId")
        ipv6_network_id = config.require_object("ipv6NetworkId")
        backend_subnet_id = config.require_object("backendSubnetId")
        l4_flavor_id = config.require_object("l4FlavorId")
        l7_flavor_id = config.require_object("l7FlavorId")
        ipv6_bandwidth_id = config.require_object("ipv6BandwidthId")
        test = huaweicloud.dedicated_elb.LoadbalancerCopy("test",
            loadbalancer_id=loadbalancer_id,
            availability_zones=[
                "cn-north-4a",
                "cn-north-4b",
            ],
            ipv4_subnet_id=ipv4_subnet_id,
            ipv4_address="192.168.0.216",
            ipv6_network_id=ipv6_network_id,
            ipv6_address="2407:c080:1200:2a02:34e6:8059:ce7f:1add",
            backend_subnets=[backend_subnet_id],
            l4_flavor_id=l4_flavor_id,
            l7_flavor_id=l7_flavor_id,
            reuse_pool="true",
            description="test elb description",
            ipv6_bandwidth_id=ipv6_bandwidth_id,
            cross_vpc_backend="true",
            protection_status="consoleProtection",
            protection_reason="test protection reason",
            deletion_protection_enable="true",
            waf_failure_action="discard")
        ```

        ## Import

        The ELB load balancer copy can be imported using the `id`, e.g. bash

        ```sh
         $ pulumi import huaweicloud:DedicatedElb/loadbalancerCopy:LoadbalancerCopy test <id>
        ```

         Note that the imported state may not be identical to your resource definition, due to some attributes missing from the API response, security or some other reason. The missing attributes include`loadbalancer_id`, `ipv6_bandwidth_id`, `deletion_protection_enable`, `reuse_pool`,

        `period_unit`, `period`, `auto_renew` and `force_delete`. It is generally recommended running `terraform plan` after importing a load balancer copy. You can then decide if changes should be applied to the load balancer copy, or the resource definition should be updated to align with the load balancer. Also you can ignore changes as below. hcl resource "huaweicloud_elb_loadbalancer_copy" "test" {

         ...

         lifecycle {

         ignore_changes = [

         loadbalancer_id, ipv6_bandwidth_id, deletion_protection_enable, reuse_pool, period_unit, period, auto_renew,

         force_delete,

         ]

         } }

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] auto_renew: Specifies whether auto-renew is enabled. Valid values are **true** and **false**.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] availability_zones: Specifies the list of AZ names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] backend_subnets: Specifies the ID of the backend subnet of the load balancer. If it is not specified,
               the backend subnet of the original load balancer is used. The subnets where the original and new load balancers work must
               be in the same VPC.
        :param pulumi.Input[str] charging_mode: Specifies the charging mode of the ELB load balancer.
               Valid values are **prePaid** and **postPaid**, defaults to **postPaid**.
        :param pulumi.Input[str] cross_vpc_backend: Specifies whether to add backend servers that are not in the load balancer's
               VPC. Can only be **true** when updating. Value options: **true**, **false**.
        :param pulumi.Input[str] deletion_protection_enable: Specifies whether to enable deletion protection for the load balancer.
               Value options:
               + **true**: Enable deletion protection.
               + **false**: Disable deletion protection.
        :param pulumi.Input[str] description: Specifies the description of the load balancer.
        :param pulumi.Input[str] enterprise_project_id: The enterprise project ID of the load balancer.
        :param pulumi.Input[bool] force_delete: Specifies whether to forcibly delete the load balancer, remove the load
               balancer, listeners, unbind associated pools. Defaults to **false**.
        :param pulumi.Input[str] ipv4_address: Specifies the private IPv4 address of the load balancer.
        :param pulumi.Input[str] ipv4_subnet_id: Specifies the ID of the IPv4 subnet where the load balancer works. If it is not
               specified, the IPv4 subnet of the original load balancer is used. The subnets where the original and new load balancers
               work must be in the same VPC.
        :param pulumi.Input[str] ipv6_address: Specifies the private IPv6 address of the load balancer.
        :param pulumi.Input[str] ipv6_bandwidth_id: Specifies the ipv6 bandwidth ID. Only support shared bandwidth.
        :param pulumi.Input[str] ipv6_network_id: Specifies the ID of the IPv6 subnet where the new load balancer works. If it is
               not specified, the IPv6 subnet of the original load balancer is used. The subnets where the original and new load
               balancers work must be in the same VPC.
        :param pulumi.Input[str] l4_flavor_id: Specifies the Layer 4 specifications of the new load balancer. If it is not specified,
               the Layer 4 specifications of the original load balancer are used.
        :param pulumi.Input[str] l7_flavor_id: Specifies the Layer 7 specifications of the new load balancer. If it is not specified,
               the Layer 7 specifications of the original load balancer are used.
        :param pulumi.Input[str] loadbalancer_id: Specifies the source load balancer ID.
        :param pulumi.Input[str] name: Specifies the load balancer name.
        :param pulumi.Input[int] period: Specifies the charging period of the ELB load balancer.
               If `period_unit` is set to **month**, the value ranges from `1` to `9`.
               If `period_unit` is set to **year**, the value ranges from `1` to `3`.
               This parameter is mandatory if `charging_mode` is set to **prePaid**.
        :param pulumi.Input[str] period_unit: Specifies the charging period unit of the ELB load balancer.
               Valid values are **month** and **year**. This parameter is mandatory if `charging_mode` is set to **prePaid**.
        :param pulumi.Input[str] protection_reason: Specifies the reason for update protection. Only valid when `protection_status`
               is **consoleProtection**.
        :param pulumi.Input[str] protection_status: Specifies the protection status for update. Value options:
               + **nonProtection**: No protection.
               + **consoleProtection**: Console modification protection.
        :param pulumi.Input[str] region: The region in which to create the load balancer resource. If omitted, the
               provider-level region will be used. Changing this creates a new load balancer.
        :param pulumi.Input[str] reuse_pool: Specifies whether to reuse the backend server group and backend server
               ID of the original load balancer.
               + If it is set to **true**, the backend server group of the original load balancer will be used.
               + If no backend server group is selected, a new backend server group is created by default.
               + It is invalid when `enterprise_project_id` is set to another enterprise project.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: The key/value pairs to associate with the load balancer.
        :param pulumi.Input[str] waf_failure_action: Specifies traffic distributing policies when the WAF is faulty.
               Value options:
               + **discard**: Traffic will not be distributed.
               + **forward**: Traffic will be distributed to the default backend servers.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: LoadbalancerCopyArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Manages a Dedicated load balancer copy resource within HuaweiCloud.

        ## Example Usage

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        loadbalancer_id = config.require_object("loadbalancerId")
        ipv4_subnet_id = config.require_object("ipv4SubnetId")
        ipv6_network_id = config.require_object("ipv6NetworkId")
        backend_subnet_id = config.require_object("backendSubnetId")
        l4_flavor_id = config.require_object("l4FlavorId")
        l7_flavor_id = config.require_object("l7FlavorId")
        ipv6_bandwidth_id = config.require_object("ipv6BandwidthId")
        test = huaweicloud.dedicated_elb.LoadbalancerCopy("test",
            loadbalancer_id=loadbalancer_id,
            availability_zones=[
                "cn-north-4a",
                "cn-north-4b",
            ],
            ipv4_subnet_id=ipv4_subnet_id,
            ipv4_address="192.168.0.216",
            ipv6_network_id=ipv6_network_id,
            ipv6_address="2407:c080:1200:2a02:34e6:8059:ce7f:1add",
            backend_subnets=[backend_subnet_id],
            l4_flavor_id=l4_flavor_id,
            l7_flavor_id=l7_flavor_id,
            reuse_pool="true",
            description="test elb description",
            ipv6_bandwidth_id=ipv6_bandwidth_id,
            cross_vpc_backend="true",
            protection_status="consoleProtection",
            protection_reason="test protection reason",
            deletion_protection_enable="true",
            waf_failure_action="discard")
        ```

        ## Import

        The ELB load balancer copy can be imported using the `id`, e.g. bash

        ```sh
         $ pulumi import huaweicloud:DedicatedElb/loadbalancerCopy:LoadbalancerCopy test <id>
        ```

         Note that the imported state may not be identical to your resource definition, due to some attributes missing from the API response, security or some other reason. The missing attributes include`loadbalancer_id`, `ipv6_bandwidth_id`, `deletion_protection_enable`, `reuse_pool`,

        `period_unit`, `period`, `auto_renew` and `force_delete`. It is generally recommended running `terraform plan` after importing a load balancer copy. You can then decide if changes should be applied to the load balancer copy, or the resource definition should be updated to align with the load balancer. Also you can ignore changes as below. hcl resource "huaweicloud_elb_loadbalancer_copy" "test" {

         ...

         lifecycle {

         ignore_changes = [

         loadbalancer_id, ipv6_bandwidth_id, deletion_protection_enable, reuse_pool, period_unit, period, auto_renew,

         force_delete,

         ]

         } }

        :param str resource_name: The name of the resource.
        :param LoadbalancerCopyArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(LoadbalancerCopyArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 auto_renew: Optional[pulumi.Input[str]] = None,
                 availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 backend_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 charging_mode: Optional[pulumi.Input[str]] = None,
                 cross_vpc_backend: Optional[pulumi.Input[str]] = None,
                 deletion_protection_enable: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_force_new: Optional[pulumi.Input[str]] = None,
                 enterprise_project_id: Optional[pulumi.Input[str]] = None,
                 force_delete: Optional[pulumi.Input[bool]] = None,
                 ipv4_address: Optional[pulumi.Input[str]] = None,
                 ipv4_subnet_id: Optional[pulumi.Input[str]] = None,
                 ipv6_address: Optional[pulumi.Input[str]] = None,
                 ipv6_bandwidth_id: Optional[pulumi.Input[str]] = None,
                 ipv6_network_id: Optional[pulumi.Input[str]] = None,
                 l4_flavor_id: Optional[pulumi.Input[str]] = None,
                 l7_flavor_id: Optional[pulumi.Input[str]] = None,
                 loadbalancer_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 period_unit: Optional[pulumi.Input[str]] = None,
                 protection_reason: Optional[pulumi.Input[str]] = None,
                 protection_status: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 reuse_pool: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 waf_failure_action: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = LoadbalancerCopyArgs.__new__(LoadbalancerCopyArgs)

            __props__.__dict__["auto_renew"] = auto_renew
            __props__.__dict__["availability_zones"] = availability_zones
            __props__.__dict__["backend_subnets"] = backend_subnets
            __props__.__dict__["charging_mode"] = charging_mode
            __props__.__dict__["cross_vpc_backend"] = cross_vpc_backend
            __props__.__dict__["deletion_protection_enable"] = deletion_protection_enable
            __props__.__dict__["description"] = description
            __props__.__dict__["enable_force_new"] = enable_force_new
            __props__.__dict__["enterprise_project_id"] = enterprise_project_id
            __props__.__dict__["force_delete"] = force_delete
            __props__.__dict__["ipv4_address"] = ipv4_address
            __props__.__dict__["ipv4_subnet_id"] = ipv4_subnet_id
            __props__.__dict__["ipv6_address"] = ipv6_address
            __props__.__dict__["ipv6_bandwidth_id"] = ipv6_bandwidth_id
            __props__.__dict__["ipv6_network_id"] = ipv6_network_id
            __props__.__dict__["l4_flavor_id"] = l4_flavor_id
            __props__.__dict__["l7_flavor_id"] = l7_flavor_id
            if loadbalancer_id is None and not opts.urn:
                raise TypeError("Missing required property 'loadbalancer_id'")
            __props__.__dict__["loadbalancer_id"] = loadbalancer_id
            __props__.__dict__["name"] = name
            __props__.__dict__["period"] = period
            __props__.__dict__["period_unit"] = period_unit
            __props__.__dict__["protection_reason"] = protection_reason
            __props__.__dict__["protection_status"] = protection_status
            __props__.__dict__["region"] = region
            __props__.__dict__["reuse_pool"] = reuse_pool
            __props__.__dict__["tags"] = tags
            __props__.__dict__["waf_failure_action"] = waf_failure_action
            __props__.__dict__["charge_mode"] = None
            __props__.__dict__["created_at"] = None
            __props__.__dict__["elb_virsubnet_type"] = None
            __props__.__dict__["frozen_scene"] = None
            __props__.__dict__["gw_flavor_id"] = None
            __props__.__dict__["ipv4_port_id"] = None
            __props__.__dict__["loadbalancer_type"] = None
            __props__.__dict__["operating_status"] = None
            __props__.__dict__["public_border_group"] = None
            __props__.__dict__["updated_at"] = None
            __props__.__dict__["vpc_id"] = None
        super(LoadbalancerCopy, __self__).__init__(
            'huaweicloud:DedicatedElb/loadbalancerCopy:LoadbalancerCopy',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            auto_renew: Optional[pulumi.Input[str]] = None,
            availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            backend_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            charge_mode: Optional[pulumi.Input[str]] = None,
            charging_mode: Optional[pulumi.Input[str]] = None,
            created_at: Optional[pulumi.Input[str]] = None,
            cross_vpc_backend: Optional[pulumi.Input[str]] = None,
            deletion_protection_enable: Optional[pulumi.Input[str]] = None,
            description: Optional[pulumi.Input[str]] = None,
            elb_virsubnet_type: Optional[pulumi.Input[str]] = None,
            enable_force_new: Optional[pulumi.Input[str]] = None,
            enterprise_project_id: Optional[pulumi.Input[str]] = None,
            force_delete: Optional[pulumi.Input[bool]] = None,
            frozen_scene: Optional[pulumi.Input[str]] = None,
            gw_flavor_id: Optional[pulumi.Input[str]] = None,
            ipv4_address: Optional[pulumi.Input[str]] = None,
            ipv4_port_id: Optional[pulumi.Input[str]] = None,
            ipv4_subnet_id: Optional[pulumi.Input[str]] = None,
            ipv6_address: Optional[pulumi.Input[str]] = None,
            ipv6_bandwidth_id: Optional[pulumi.Input[str]] = None,
            ipv6_network_id: Optional[pulumi.Input[str]] = None,
            l4_flavor_id: Optional[pulumi.Input[str]] = None,
            l7_flavor_id: Optional[pulumi.Input[str]] = None,
            loadbalancer_id: Optional[pulumi.Input[str]] = None,
            loadbalancer_type: Optional[pulumi.Input[str]] = None,
            name: Optional[pulumi.Input[str]] = None,
            operating_status: Optional[pulumi.Input[str]] = None,
            period: Optional[pulumi.Input[int]] = None,
            period_unit: Optional[pulumi.Input[str]] = None,
            protection_reason: Optional[pulumi.Input[str]] = None,
            protection_status: Optional[pulumi.Input[str]] = None,
            public_border_group: Optional[pulumi.Input[str]] = None,
            region: Optional[pulumi.Input[str]] = None,
            reuse_pool: Optional[pulumi.Input[str]] = None,
            tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
            updated_at: Optional[pulumi.Input[str]] = None,
            vpc_id: Optional[pulumi.Input[str]] = None,
            waf_failure_action: Optional[pulumi.Input[str]] = None) -> 'LoadbalancerCopy':
        """
        Get an existing LoadbalancerCopy resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] auto_renew: Specifies whether auto-renew is enabled. Valid values are **true** and **false**.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] availability_zones: Specifies the list of AZ names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] backend_subnets: Specifies the ID of the backend subnet of the load balancer. If it is not specified,
               the backend subnet of the original load balancer is used. The subnets where the original and new load balancers work must
               be in the same VPC.
        :param pulumi.Input[str] charge_mode: Indicates the billing mode. The value can be:
               + **flavor**: Billed by the specifications you will select.
               + **lcu**: Billed by LCU usage.
        :param pulumi.Input[str] charging_mode: Specifies the charging mode of the ELB load balancer.
               Valid values are **prePaid** and **postPaid**, defaults to **postPaid**.
        :param pulumi.Input[str] created_at: Indicates the time when the load balancer was created, in RFC3339 format.
        :param pulumi.Input[str] cross_vpc_backend: Specifies whether to add backend servers that are not in the load balancer's
               VPC. Can only be **true** when updating. Value options: **true**, **false**.
        :param pulumi.Input[str] deletion_protection_enable: Specifies whether to enable deletion protection for the load balancer.
               Value options:
               + **true**: Enable deletion protection.
               + **false**: Disable deletion protection.
        :param pulumi.Input[str] description: Specifies the description of the load balancer.
        :param pulumi.Input[str] elb_virsubnet_type: Indicates the type of the subnet on the downstream plane. The value can be:
               + **ipv4**: IPv4 subnet
               + **dualstack**: subnet that supports IPv4/IPv6 dual stack
        :param pulumi.Input[str] enterprise_project_id: The enterprise project ID of the load balancer.
        :param pulumi.Input[bool] force_delete: Specifies whether to forcibly delete the load balancer, remove the load
               balancer, listeners, unbind associated pools. Defaults to **false**.
        :param pulumi.Input[str] frozen_scene: Indicates the scenario where the load balancer is frozen. Multiple values are separated using commas (,).
               The value can be:
               + **POLICE**: The load balancer is frozen due to security reasons.
               + **ILLEGAL**: The load balancer is frozen due to violation of laws and regulations.
               + **VERIFY**: Your account has not completed real-name authentication.
               + **PARTNER**: The load balancer is frozen by the partner.
               + **ARREAR**: Your account is in arrears.
        :param pulumi.Input[str] gw_flavor_id: Indicates the flavor ID of the gateway load balancer.
        :param pulumi.Input[str] ipv4_address: Specifies the private IPv4 address of the load balancer.
        :param pulumi.Input[str] ipv4_port_id: Indicates the ID of the port bound to the private IPv4 address of the load balancer.
        :param pulumi.Input[str] ipv4_subnet_id: Specifies the ID of the IPv4 subnet where the load balancer works. If it is not
               specified, the IPv4 subnet of the original load balancer is used. The subnets where the original and new load balancers
               work must be in the same VPC.
        :param pulumi.Input[str] ipv6_address: Specifies the private IPv6 address of the load balancer.
        :param pulumi.Input[str] ipv6_bandwidth_id: Specifies the ipv6 bandwidth ID. Only support shared bandwidth.
        :param pulumi.Input[str] ipv6_network_id: Specifies the ID of the IPv6 subnet where the new load balancer works. If it is
               not specified, the IPv6 subnet of the original load balancer is used. The subnets where the original and new load
               balancers work must be in the same VPC.
        :param pulumi.Input[str] l4_flavor_id: Specifies the Layer 4 specifications of the new load balancer. If it is not specified,
               the Layer 4 specifications of the original load balancer are used.
        :param pulumi.Input[str] l7_flavor_id: Specifies the Layer 7 specifications of the new load balancer. If it is not specified,
               the Layer 7 specifications of the original load balancer are used.
        :param pulumi.Input[str] loadbalancer_id: Specifies the source load balancer ID.
        :param pulumi.Input[str] loadbalancer_type: Indicates the type of the load balancer.
        :param pulumi.Input[str] name: Specifies the load balancer name.
        :param pulumi.Input[str] operating_status: Indicates the operating status of the load balancer. The value can be:
               + **ONLINE**: indicates that the load balancer is running normally.
               + **FROZEN**: indicates that the load balancer is frozen.
        :param pulumi.Input[int] period: Specifies the charging period of the ELB load balancer.
               If `period_unit` is set to **month**, the value ranges from `1` to `9`.
               If `period_unit` is set to **year**, the value ranges from `1` to `3`.
               This parameter is mandatory if `charging_mode` is set to **prePaid**.
        :param pulumi.Input[str] period_unit: Specifies the charging period unit of the ELB load balancer.
               Valid values are **month** and **year**. This parameter is mandatory if `charging_mode` is set to **prePaid**.
        :param pulumi.Input[str] protection_reason: Specifies the reason for update protection. Only valid when `protection_status`
               is **consoleProtection**.
        :param pulumi.Input[str] protection_status: Specifies the protection status for update. Value options:
               + **nonProtection**: No protection.
               + **consoleProtection**: Console modification protection.
        :param pulumi.Input[str] public_border_group: Indicates the AZ group to which the load balancer belongs.
        :param pulumi.Input[str] region: The region in which to create the load balancer resource. If omitted, the
               provider-level region will be used. Changing this creates a new load balancer.
        :param pulumi.Input[str] reuse_pool: Specifies whether to reuse the backend server group and backend server
               ID of the original load balancer.
               + If it is set to **true**, the backend server group of the original load balancer will be used.
               + If no backend server group is selected, a new backend server group is created by default.
               + It is invalid when `enterprise_project_id` is set to another enterprise project.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: The key/value pairs to associate with the load balancer.
        :param pulumi.Input[str] updated_at: Indicates the time when the load balancer was updated, in RFC3339 format.
        :param pulumi.Input[str] vpc_id: Indicates the ID of the VPC where the load balancer resides.
        :param pulumi.Input[str] waf_failure_action: Specifies traffic distributing policies when the WAF is faulty.
               Value options:
               + **discard**: Traffic will not be distributed.
               + **forward**: Traffic will be distributed to the default backend servers.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _LoadbalancerCopyState.__new__(_LoadbalancerCopyState)

        __props__.__dict__["auto_renew"] = auto_renew
        __props__.__dict__["availability_zones"] = availability_zones
        __props__.__dict__["backend_subnets"] = backend_subnets
        __props__.__dict__["charge_mode"] = charge_mode
        __props__.__dict__["charging_mode"] = charging_mode
        __props__.__dict__["created_at"] = created_at
        __props__.__dict__["cross_vpc_backend"] = cross_vpc_backend
        __props__.__dict__["deletion_protection_enable"] = deletion_protection_enable
        __props__.__dict__["description"] = description
        __props__.__dict__["elb_virsubnet_type"] = elb_virsubnet_type
        __props__.__dict__["enable_force_new"] = enable_force_new
        __props__.__dict__["enterprise_project_id"] = enterprise_project_id
        __props__.__dict__["force_delete"] = force_delete
        __props__.__dict__["frozen_scene"] = frozen_scene
        __props__.__dict__["gw_flavor_id"] = gw_flavor_id
        __props__.__dict__["ipv4_address"] = ipv4_address
        __props__.__dict__["ipv4_port_id"] = ipv4_port_id
        __props__.__dict__["ipv4_subnet_id"] = ipv4_subnet_id
        __props__.__dict__["ipv6_address"] = ipv6_address
        __props__.__dict__["ipv6_bandwidth_id"] = ipv6_bandwidth_id
        __props__.__dict__["ipv6_network_id"] = ipv6_network_id
        __props__.__dict__["l4_flavor_id"] = l4_flavor_id
        __props__.__dict__["l7_flavor_id"] = l7_flavor_id
        __props__.__dict__["loadbalancer_id"] = loadbalancer_id
        __props__.__dict__["loadbalancer_type"] = loadbalancer_type
        __props__.__dict__["name"] = name
        __props__.__dict__["operating_status"] = operating_status
        __props__.__dict__["period"] = period
        __props__.__dict__["period_unit"] = period_unit
        __props__.__dict__["protection_reason"] = protection_reason
        __props__.__dict__["protection_status"] = protection_status
        __props__.__dict__["public_border_group"] = public_border_group
        __props__.__dict__["region"] = region
        __props__.__dict__["reuse_pool"] = reuse_pool
        __props__.__dict__["tags"] = tags
        __props__.__dict__["updated_at"] = updated_at
        __props__.__dict__["vpc_id"] = vpc_id
        __props__.__dict__["waf_failure_action"] = waf_failure_action
        return LoadbalancerCopy(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="autoRenew")
    def auto_renew(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies whether auto-renew is enabled. Valid values are **true** and **false**.
        """
        return pulumi.get(self, "auto_renew")

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> pulumi.Output[Sequence[str]]:
        """
        Specifies the list of AZ names.
        """
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter(name="backendSubnets")
    def backend_subnets(self) -> pulumi.Output[Sequence[str]]:
        """
        Specifies the ID of the backend subnet of the load balancer. If it is not specified,
        the backend subnet of the original load balancer is used. The subnets where the original and new load balancers work must
        be in the same VPC.
        """
        return pulumi.get(self, "backend_subnets")

    @property
    @pulumi.getter(name="chargeMode")
    def charge_mode(self) -> pulumi.Output[str]:
        """
        Indicates the billing mode. The value can be:
        + **flavor**: Billed by the specifications you will select.
        + **lcu**: Billed by LCU usage.
        """
        return pulumi.get(self, "charge_mode")

    @property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> pulumi.Output[str]:
        """
        Specifies the charging mode of the ELB load balancer.
        Valid values are **prePaid** and **postPaid**, defaults to **postPaid**.
        """
        return pulumi.get(self, "charging_mode")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> pulumi.Output[str]:
        """
        Indicates the time when the load balancer was created, in RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="crossVpcBackend")
    def cross_vpc_backend(self) -> pulumi.Output[str]:
        """
        Specifies whether to add backend servers that are not in the load balancer's
        VPC. Can only be **true** when updating. Value options: **true**, **false**.
        """
        return pulumi.get(self, "cross_vpc_backend")

    @property
    @pulumi.getter(name="deletionProtectionEnable")
    def deletion_protection_enable(self) -> pulumi.Output[str]:
        """
        Specifies whether to enable deletion protection for the load balancer.
        Value options:
        + **true**: Enable deletion protection.
        + **false**: Disable deletion protection.
        """
        return pulumi.get(self, "deletion_protection_enable")

    @property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies the description of the load balancer.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="elbVirsubnetType")
    def elb_virsubnet_type(self) -> pulumi.Output[str]:
        """
        Indicates the type of the subnet on the downstream plane. The value can be:
        + **ipv4**: IPv4 subnet
        + **dualstack**: subnet that supports IPv4/IPv6 dual stack
        """
        return pulumi.get(self, "elb_virsubnet_type")

    @property
    @pulumi.getter(name="enableForceNew")
    def enable_force_new(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "enable_force_new")

    @property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> pulumi.Output[str]:
        """
        The enterprise project ID of the load balancer.
        """
        return pulumi.get(self, "enterprise_project_id")

    @property
    @pulumi.getter(name="forceDelete")
    def force_delete(self) -> pulumi.Output[Optional[bool]]:
        """
        Specifies whether to forcibly delete the load balancer, remove the load
        balancer, listeners, unbind associated pools. Defaults to **false**.
        """
        return pulumi.get(self, "force_delete")

    @property
    @pulumi.getter(name="frozenScene")
    def frozen_scene(self) -> pulumi.Output[str]:
        """
        Indicates the scenario where the load balancer is frozen. Multiple values are separated using commas (,).
        The value can be:
        + **POLICE**: The load balancer is frozen due to security reasons.
        + **ILLEGAL**: The load balancer is frozen due to violation of laws and regulations.
        + **VERIFY**: Your account has not completed real-name authentication.
        + **PARTNER**: The load balancer is frozen by the partner.
        + **ARREAR**: Your account is in arrears.
        """
        return pulumi.get(self, "frozen_scene")

    @property
    @pulumi.getter(name="gwFlavorId")
    def gw_flavor_id(self) -> pulumi.Output[str]:
        """
        Indicates the flavor ID of the gateway load balancer.
        """
        return pulumi.get(self, "gw_flavor_id")

    @property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> pulumi.Output[str]:
        """
        Specifies the private IPv4 address of the load balancer.
        """
        return pulumi.get(self, "ipv4_address")

    @property
    @pulumi.getter(name="ipv4PortId")
    def ipv4_port_id(self) -> pulumi.Output[str]:
        """
        Indicates the ID of the port bound to the private IPv4 address of the load balancer.
        """
        return pulumi.get(self, "ipv4_port_id")

    @property
    @pulumi.getter(name="ipv4SubnetId")
    def ipv4_subnet_id(self) -> pulumi.Output[str]:
        """
        Specifies the ID of the IPv4 subnet where the load balancer works. If it is not
        specified, the IPv4 subnet of the original load balancer is used. The subnets where the original and new load balancers
        work must be in the same VPC.
        """
        return pulumi.get(self, "ipv4_subnet_id")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> pulumi.Output[str]:
        """
        Specifies the private IPv6 address of the load balancer.
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="ipv6BandwidthId")
    def ipv6_bandwidth_id(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies the ipv6 bandwidth ID. Only support shared bandwidth.
        """
        return pulumi.get(self, "ipv6_bandwidth_id")

    @property
    @pulumi.getter(name="ipv6NetworkId")
    def ipv6_network_id(self) -> pulumi.Output[str]:
        """
        Specifies the ID of the IPv6 subnet where the new load balancer works. If it is
        not specified, the IPv6 subnet of the original load balancer is used. The subnets where the original and new load
        balancers work must be in the same VPC.
        """
        return pulumi.get(self, "ipv6_network_id")

    @property
    @pulumi.getter(name="l4FlavorId")
    def l4_flavor_id(self) -> pulumi.Output[str]:
        """
        Specifies the Layer 4 specifications of the new load balancer. If it is not specified,
        the Layer 4 specifications of the original load balancer are used.
        """
        return pulumi.get(self, "l4_flavor_id")

    @property
    @pulumi.getter(name="l7FlavorId")
    def l7_flavor_id(self) -> pulumi.Output[str]:
        """
        Specifies the Layer 7 specifications of the new load balancer. If it is not specified,
        the Layer 7 specifications of the original load balancer are used.
        """
        return pulumi.get(self, "l7_flavor_id")

    @property
    @pulumi.getter(name="loadbalancerId")
    def loadbalancer_id(self) -> pulumi.Output[str]:
        """
        Specifies the source load balancer ID.
        """
        return pulumi.get(self, "loadbalancer_id")

    @property
    @pulumi.getter(name="loadbalancerType")
    def loadbalancer_type(self) -> pulumi.Output[str]:
        """
        Indicates the type of the load balancer.
        """
        return pulumi.get(self, "loadbalancer_type")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        Specifies the load balancer name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operatingStatus")
    def operating_status(self) -> pulumi.Output[str]:
        """
        Indicates the operating status of the load balancer. The value can be:
        + **ONLINE**: indicates that the load balancer is running normally.
        + **FROZEN**: indicates that the load balancer is frozen.
        """
        return pulumi.get(self, "operating_status")

    @property
    @pulumi.getter
    def period(self) -> pulumi.Output[Optional[int]]:
        """
        Specifies the charging period of the ELB load balancer.
        If `period_unit` is set to **month**, the value ranges from `1` to `9`.
        If `period_unit` is set to **year**, the value ranges from `1` to `3`.
        This parameter is mandatory if `charging_mode` is set to **prePaid**.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="periodUnit")
    def period_unit(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies the charging period unit of the ELB load balancer.
        Valid values are **month** and **year**. This parameter is mandatory if `charging_mode` is set to **prePaid**.
        """
        return pulumi.get(self, "period_unit")

    @property
    @pulumi.getter(name="protectionReason")
    def protection_reason(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies the reason for update protection. Only valid when `protection_status`
        is **consoleProtection**.
        """
        return pulumi.get(self, "protection_reason")

    @property
    @pulumi.getter(name="protectionStatus")
    def protection_status(self) -> pulumi.Output[str]:
        """
        Specifies the protection status for update. Value options:
        + **nonProtection**: No protection.
        + **consoleProtection**: Console modification protection.
        """
        return pulumi.get(self, "protection_status")

    @property
    @pulumi.getter(name="publicBorderGroup")
    def public_border_group(self) -> pulumi.Output[str]:
        """
        Indicates the AZ group to which the load balancer belongs.
        """
        return pulumi.get(self, "public_border_group")

    @property
    @pulumi.getter
    def region(self) -> pulumi.Output[str]:
        """
        The region in which to create the load balancer resource. If omitted, the
        provider-level region will be used. Changing this creates a new load balancer.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="reusePool")
    def reuse_pool(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies whether to reuse the backend server group and backend server
        ID of the original load balancer.
        + If it is set to **true**, the backend server group of the original load balancer will be used.
        + If no backend server group is selected, a new backend server group is created by default.
        + It is invalid when `enterprise_project_id` is set to another enterprise project.
        """
        return pulumi.get(self, "reuse_pool")

    @property
    @pulumi.getter
    def tags(self) -> pulumi.Output[Optional[Mapping[str, str]]]:
        """
        The key/value pairs to associate with the load balancer.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> pulumi.Output[str]:
        """
        Indicates the time when the load balancer was updated, in RFC3339 format.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Output[str]:
        """
        Indicates the ID of the VPC where the load balancer resides.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="wafFailureAction")
    def waf_failure_action(self) -> pulumi.Output[str]:
        """
        Specifies traffic distributing policies when the WAF is faulty.
        Value options:
        + **discard**: Traffic will not be distributed.
        + **forward**: Traffic will be distributed to the default backend servers.
        """
        return pulumi.get(self, "waf_failure_action")

