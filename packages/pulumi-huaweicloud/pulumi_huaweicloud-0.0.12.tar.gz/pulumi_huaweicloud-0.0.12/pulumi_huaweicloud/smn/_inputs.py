# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'SubscriptionExtensionArgs',
    'SubscriptionFilterPolicyArgs',
]

@pulumi.input_type
class SubscriptionExtensionArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 keyword: Optional[pulumi.Input[str]] = None,
                 sign_secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: Specifies the client ID. This field is the tenant ID field in
               the WeLink subscription and is obtained by the tenant from WeLink. This field is mandatory when `protocol`
               is set to **welink**. Changing this parameter will create a new resource.
        :param pulumi.Input[str] client_secret: Specifies the client secret. This field is the client secret
               field obtained by the tenant from WeLink. This field is mandatory when `protocol` is set to **welink**.
               Changing this parameter will create a new resource.
        :param pulumi.Input[str] keyword: Specifies the keyword. When `protocol` is set to **feishu**,
               either `keyword` or `sign_secret` must be specified. When you use `keywords` to configure a security policy
               for the Lark or DingTalk chatbot on SMN, the keywords must have one of the keywords configured on the Lark
               or DingTalk client. Changing this parameter will create a new resource.
        :param pulumi.Input[str] sign_secret: Specifies the key including signature. When `protocol` is set
               to **feishu** or **dingding**, this field or `keyword` must be specified. The key configurations must be
               the same as those on the Lark or DingTalk client. For example, if only key is configured on the Lark client,
               enter the key field obtained from the Lark client. If only keyword is configured on the Lark client, skip this field.
               Changing this parameter will create a new resource.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if keyword is not None:
            pulumi.set(__self__, "keyword", keyword)
        if sign_secret is not None:
            pulumi.set(__self__, "sign_secret", sign_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the client ID. This field is the tenant ID field in
        the WeLink subscription and is obtained by the tenant from WeLink. This field is mandatory when `protocol`
        is set to **welink**. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the client secret. This field is the client secret
        field obtained by the tenant from WeLink. This field is mandatory when `protocol` is set to **welink**.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def keyword(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the keyword. When `protocol` is set to **feishu**,
        either `keyword` or `sign_secret` must be specified. When you use `keywords` to configure a security policy
        for the Lark or DingTalk chatbot on SMN, the keywords must have one of the keywords configured on the Lark
        or DingTalk client. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "keyword")

    @keyword.setter
    def keyword(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keyword", value)

    @property
    @pulumi.getter(name="signSecret")
    def sign_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the key including signature. When `protocol` is set
        to **feishu** or **dingding**, this field or `keyword` must be specified. The key configurations must be
        the same as those on the Lark or DingTalk client. For example, if only key is configured on the Lark client,
        enter the key field obtained from the Lark client. If only keyword is configured on the Lark client, skip this field.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "sign_secret")

    @sign_secret.setter
    def sign_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sign_secret", value)


@pulumi.input_type
class SubscriptionFilterPolicyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 string_equals: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The filter policy name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] string_equals: The string array for exact match.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if string_equals is not None:
            pulumi.set(__self__, "string_equals", string_equals)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The filter policy name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="stringEquals")
    def string_equals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The string array for exact match.
        """
        return pulumi.get(self, "string_equals")

    @string_equals.setter
    def string_equals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "string_equals", value)


