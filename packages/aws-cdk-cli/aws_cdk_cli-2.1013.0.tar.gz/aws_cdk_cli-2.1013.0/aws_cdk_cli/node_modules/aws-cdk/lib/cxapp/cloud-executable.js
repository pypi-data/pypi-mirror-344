"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudExecutable = void 0;
const cloud_assembly_1 = require("./cloud-assembly");
const borrowed_assembly_1 = require("../../../@aws-cdk/toolkit-lib/lib/api/cloud-assembly/private/borrowed-assembly");
const private_1 = require("../../../@aws-cdk/toolkit-lib/lib/api/io/private");
const api_1 = require("../api");
const singleton_plugin_host_1 = require("../cli/singleton-plugin-host");
const contextproviders = require("../context-providers");
/**
 * Represent the Cloud Executable and the synthesis we can do on it
 */
class CloudExecutable {
    constructor(props) {
        this.props = props;
    }
    async produce() {
        const synthesisResult = await this.synthesize(true);
        // We must return an `IReadableCloudAssembly` here, but this Cloud Assembly is only used in the context
        // of the CLI and `cli.ts` currently manages its own locking in the "synthesizer" callback function.
        //
        // All the lock-related functions are therefore no-ops.
        return new borrowed_assembly_1.BorrowedAssembly(synthesisResult.assembly);
    }
    /**
     * Return whether there is an app command from the configuration
     */
    get hasApp() {
        return !!this.props.configuration.settings.get(['app']);
    }
    /**
     * Synthesize a set of stacks.
     *
     * @param cacheCloudAssembly whether to cache the Cloud Assembly after it has been first synthesized.
     *   This is 'true' by default, and only set to 'false' for 'cdk watch',
     *   which needs to re-synthesize the Assembly each time it detects a change to the project files
     */
    async synthesize(cacheCloudAssembly = true) {
        if (!this._cloudAssembly || !cacheCloudAssembly) {
            this._cloudAssembly = await this.doSynthesize();
        }
        return this._cloudAssembly;
    }
    async doSynthesize() {
        // We may need to run the cloud executable multiple times in order to satisfy all missing context
        // (When the executable runs, it will tell us about context it wants to use
        // but it missing. We'll then look up the context and run the executable again, and
        // again, until it doesn't complain anymore or we've stopped making progress).
        let previouslyMissingKeys;
        while (true) {
            const assembly = await this.props.synthesizer(this.props.sdkProvider, this.props.configuration);
            if (assembly.manifest.missing && assembly.manifest.missing.length > 0) {
                const missingKeys = missingContextKeys(assembly.manifest.missing);
                if (!this.canLookup) {
                    throw new api_1.ToolkitError('Context lookups have been disabled. '
                        + 'Make sure all necessary context is already in \'cdk.context.json\' by running \'cdk synth\' on a machine with sufficient AWS credentials and committing the result. '
                        + `Missing context keys: '${Array.from(missingKeys).join(', ')}'`);
                }
                let tryLookup = true;
                if (previouslyMissingKeys && setsEqual(missingKeys, previouslyMissingKeys)) {
                    await this.props.ioHelper.notify(private_1.IO.DEFAULT_ASSEMBLY_DEBUG.msg('Not making progress trying to resolve environmental context. Giving up.'));
                    tryLookup = false;
                }
                previouslyMissingKeys = missingKeys;
                if (tryLookup) {
                    await this.props.ioHelper.notify(private_1.IO.DEFAULT_ASSEMBLY_DEBUG.msg('Some context information is missing. Fetching...'));
                    await contextproviders.provideContextValues(assembly.manifest.missing, this.props.configuration.context, this.props.sdkProvider, singleton_plugin_host_1.GLOBAL_PLUGIN_HOST, this.props.ioHelper);
                    // Cache the new context to disk
                    await this.props.configuration.saveContext();
                    // Execute again
                    continue;
                }
            }
            return new cloud_assembly_1.CloudAssembly(assembly, this.props.ioHelper);
        }
    }
    get canLookup() {
        return !!(this.props.configuration.settings.get(['lookups']) ?? true);
    }
}
exports.CloudExecutable = CloudExecutable;
/**
 * Return all keys of missing context items
 */
function missingContextKeys(missing) {
    return new Set((missing || []).map(m => m.key));
}
function setsEqual(a, b) {
    if (a.size !== b.size) {
        return false;
    }
    for (const x of a) {
        if (!b.has(x)) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWQtZXhlY3V0YWJsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNsb3VkLWV4ZWN1dGFibGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EscURBQWlEO0FBRWpELHNIQUFrSDtBQUVsSCw4RUFBc0U7QUFDdEUsZ0NBQXNDO0FBRXRDLHdFQUFrRTtBQUVsRSx5REFBeUQ7QUE2QnpEOztHQUVHO0FBQ0gsTUFBYSxlQUFlO0lBRzFCLFlBQTZCLEtBQTJCO1FBQTNCLFVBQUssR0FBTCxLQUFLLENBQXNCO0lBQ3hELENBQUM7SUFFTSxLQUFLLENBQUMsT0FBTztRQUNsQixNQUFNLGVBQWUsR0FBRyxNQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFcEQsdUdBQXVHO1FBQ3ZHLG9HQUFvRztRQUNwRyxFQUFFO1FBQ0YsdURBQXVEO1FBQ3ZELE9BQU8sSUFBSSxvQ0FBZ0IsQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBVyxNQUFNO1FBQ2YsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLEtBQUssQ0FBQyxVQUFVLENBQUMscUJBQThCLElBQUk7UUFDeEQsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1lBQ2hELElBQUksQ0FBQyxjQUFjLEdBQUcsTUFBTSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDbEQsQ0FBQztRQUNELE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQztJQUM3QixDQUFDO0lBRU8sS0FBSyxDQUFDLFlBQVk7UUFDeEIsaUdBQWlHO1FBQ2pHLDJFQUEyRTtRQUMzRSxtRkFBbUY7UUFDbkYsOEVBQThFO1FBQzlFLElBQUkscUJBQThDLENBQUM7UUFDbkQsT0FBTyxJQUFJLEVBQUUsQ0FBQztZQUNaLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUVoRyxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsT0FBTyxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztnQkFDdEUsTUFBTSxXQUFXLEdBQUcsa0JBQWtCLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFFbEUsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztvQkFDcEIsTUFBTSxJQUFJLGtCQUFZLENBQ3BCLHNDQUFzQzswQkFDcEMsc0tBQXNLOzBCQUN0SywwQkFBMEIsS0FBSyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUN2RSxDQUFDO2dCQUVELElBQUksU0FBUyxHQUFHLElBQUksQ0FBQztnQkFDckIsSUFBSSxxQkFBcUIsSUFBSSxTQUFTLENBQUMsV0FBVyxFQUFFLHFCQUFxQixDQUFDLEVBQUUsQ0FBQztvQkFDM0UsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsWUFBRSxDQUFDLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyx5RUFBeUUsQ0FBQyxDQUFDLENBQUM7b0JBQzNJLFNBQVMsR0FBRyxLQUFLLENBQUM7Z0JBQ3BCLENBQUM7Z0JBRUQscUJBQXFCLEdBQUcsV0FBVyxDQUFDO2dCQUVwQyxJQUFJLFNBQVMsRUFBRSxDQUFDO29CQUNkLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFlBQUUsQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLENBQUMsa0RBQWtELENBQUMsQ0FBQyxDQUFDO29CQUVwSCxNQUFNLGdCQUFnQixDQUFDLG9CQUFvQixDQUN6QyxRQUFRLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFDekIsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUNoQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFDdEIsMENBQWtCLEVBQ2xCLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUNwQixDQUFDO29CQUVGLGdDQUFnQztvQkFDaEMsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztvQkFFN0MsZ0JBQWdCO29CQUNoQixTQUFTO2dCQUNYLENBQUM7WUFDSCxDQUFDO1lBRUQsT0FBTyxJQUFJLDhCQUFhLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDMUQsQ0FBQztJQUNILENBQUM7SUFFRCxJQUFZLFNBQVM7UUFDbkIsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQztJQUN4RSxDQUFDO0NBQ0Y7QUExRkQsMENBMEZDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLGtCQUFrQixDQUFDLE9BQWdDO0lBQzFELE9BQU8sSUFBSSxHQUFHLENBQUMsQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDbEQsQ0FBQztBQUVELFNBQVMsU0FBUyxDQUFJLENBQVMsRUFBRSxDQUFTO0lBQ3hDLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDdEIsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBQ0QsS0FBSyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUNsQixJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ2QsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO0lBQ0gsQ0FBQztJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB7IENsb3VkQXNzZW1ibHkgfSBmcm9tICcuL2Nsb3VkLWFzc2VtYmx5JztcbmltcG9ydCB0eXBlIHsgSUNsb3VkQXNzZW1ibHlTb3VyY2UsIElSZWFkYWJsZUNsb3VkQXNzZW1ibHkgfSBmcm9tICcuLi8uLi8uLi9AYXdzLWNkay90b29sa2l0LWxpYi9saWIvYXBpL2Nsb3VkLWFzc2VtYmx5JztcbmltcG9ydCB7IEJvcnJvd2VkQXNzZW1ibHkgfSBmcm9tICcuLi8uLi8uLi9AYXdzLWNkay90b29sa2l0LWxpYi9saWIvYXBpL2Nsb3VkLWFzc2VtYmx5L3ByaXZhdGUvYm9ycm93ZWQtYXNzZW1ibHknO1xuaW1wb3J0IHR5cGUgeyBJb0hlbHBlciB9IGZyb20gJy4uLy4uLy4uL0Bhd3MtY2RrL3Rvb2xraXQtbGliL2xpYi9hcGkvaW8vcHJpdmF0ZSc7XG5pbXBvcnQgeyBJTyB9IGZyb20gJy4uLy4uLy4uL0Bhd3MtY2RrL3Rvb2xraXQtbGliL2xpYi9hcGkvaW8vcHJpdmF0ZSc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi9hcGknO1xuaW1wb3J0IHR5cGUgeyBTZGtQcm92aWRlciB9IGZyb20gJy4uL2FwaS9hd3MtYXV0aCc7XG5pbXBvcnQgeyBHTE9CQUxfUExVR0lOX0hPU1QgfSBmcm9tICcuLi9jbGkvc2luZ2xldG9uLXBsdWdpbi1ob3N0JztcbmltcG9ydCB0eXBlIHsgQ29uZmlndXJhdGlvbiB9IGZyb20gJy4uL2NsaS91c2VyLWNvbmZpZ3VyYXRpb24nO1xuaW1wb3J0ICogYXMgY29udGV4dHByb3ZpZGVycyBmcm9tICcuLi9jb250ZXh0LXByb3ZpZGVycyc7XG5cbi8qKlxuICogQHJldHVybnMgb3V0cHV0IGRpcmVjdG9yeVxuICovXG5leHBvcnQgdHlwZSBTeW50aGVzaXplciA9IChhd3M6IFNka1Byb3ZpZGVyLCBjb25maWc6IENvbmZpZ3VyYXRpb24pID0+IFByb21pc2U8Y3hhcGkuQ2xvdWRBc3NlbWJseT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xvdWRFeGVjdXRhYmxlUHJvcHMge1xuICAvKipcbiAgICogQXBwbGljYXRpb24gY29uZmlndXJhdGlvbiAoc2V0dGluZ3MgYW5kIGNvbnRleHQpXG4gICAqL1xuICBjb25maWd1cmF0aW9uOiBDb25maWd1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBBV1Mgb2JqZWN0ICh1c2VkIGJ5IHN5bnRoZXNpemVyIGFuZCBjb250ZXh0cHJvdmlkZXIpXG4gICAqL1xuICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXI7XG5cbiAgLyoqXG4gICAqIE1lc3NhZ2luZyBoZWxwZXJcbiAgICovXG4gIGlvSGVscGVyOiBJb0hlbHBlcjtcblxuICAvKipcbiAgICogQ2FsbGJhY2sgaW52b2tlZCB0byBzeW50aGVzaXplIHRoZSBhY3R1YWwgc3RhY2tzXG4gICAqL1xuICBzeW50aGVzaXplcjogU3ludGhlc2l6ZXI7XG59XG5cbi8qKlxuICogUmVwcmVzZW50IHRoZSBDbG91ZCBFeGVjdXRhYmxlIGFuZCB0aGUgc3ludGhlc2lzIHdlIGNhbiBkbyBvbiBpdFxuICovXG5leHBvcnQgY2xhc3MgQ2xvdWRFeGVjdXRhYmxlIGltcGxlbWVudHMgSUNsb3VkQXNzZW1ibHlTb3VyY2Uge1xuICBwcml2YXRlIF9jbG91ZEFzc2VtYmx5PzogQ2xvdWRBc3NlbWJseTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByb3BzOiBDbG91ZEV4ZWN1dGFibGVQcm9wcykge1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHByb2R1Y2UoKTogUHJvbWlzZTxJUmVhZGFibGVDbG91ZEFzc2VtYmx5PiB7XG4gICAgY29uc3Qgc3ludGhlc2lzUmVzdWx0ID0gYXdhaXQgdGhpcy5zeW50aGVzaXplKHRydWUpO1xuXG4gICAgLy8gV2UgbXVzdCByZXR1cm4gYW4gYElSZWFkYWJsZUNsb3VkQXNzZW1ibHlgIGhlcmUsIGJ1dCB0aGlzIENsb3VkIEFzc2VtYmx5IGlzIG9ubHkgdXNlZCBpbiB0aGUgY29udGV4dFxuICAgIC8vIG9mIHRoZSBDTEkgYW5kIGBjbGkudHNgIGN1cnJlbnRseSBtYW5hZ2VzIGl0cyBvd24gbG9ja2luZyBpbiB0aGUgXCJzeW50aGVzaXplclwiIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgIC8vXG4gICAgLy8gQWxsIHRoZSBsb2NrLXJlbGF0ZWQgZnVuY3Rpb25zIGFyZSB0aGVyZWZvcmUgbm8tb3BzLlxuICAgIHJldHVybiBuZXcgQm9ycm93ZWRBc3NlbWJseShzeW50aGVzaXNSZXN1bHQuYXNzZW1ibHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZXJlIGlzIGFuIGFwcCBjb21tYW5kIGZyb20gdGhlIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIHB1YmxpYyBnZXQgaGFzQXBwKCkge1xuICAgIHJldHVybiAhIXRoaXMucHJvcHMuY29uZmlndXJhdGlvbi5zZXR0aW5ncy5nZXQoWydhcHAnXSk7XG4gIH1cblxuICAvKipcbiAgICogU3ludGhlc2l6ZSBhIHNldCBvZiBzdGFja3MuXG4gICAqXG4gICAqIEBwYXJhbSBjYWNoZUNsb3VkQXNzZW1ibHkgd2hldGhlciB0byBjYWNoZSB0aGUgQ2xvdWQgQXNzZW1ibHkgYWZ0ZXIgaXQgaGFzIGJlZW4gZmlyc3Qgc3ludGhlc2l6ZWQuXG4gICAqICAgVGhpcyBpcyAndHJ1ZScgYnkgZGVmYXVsdCwgYW5kIG9ubHkgc2V0IHRvICdmYWxzZScgZm9yICdjZGsgd2F0Y2gnLFxuICAgKiAgIHdoaWNoIG5lZWRzIHRvIHJlLXN5bnRoZXNpemUgdGhlIEFzc2VtYmx5IGVhY2ggdGltZSBpdCBkZXRlY3RzIGEgY2hhbmdlIHRvIHRoZSBwcm9qZWN0IGZpbGVzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc3ludGhlc2l6ZShjYWNoZUNsb3VkQXNzZW1ibHk6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTxDbG91ZEFzc2VtYmx5PiB7XG4gICAgaWYgKCF0aGlzLl9jbG91ZEFzc2VtYmx5IHx8ICFjYWNoZUNsb3VkQXNzZW1ibHkpIHtcbiAgICAgIHRoaXMuX2Nsb3VkQXNzZW1ibHkgPSBhd2FpdCB0aGlzLmRvU3ludGhlc2l6ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xvdWRBc3NlbWJseTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZG9TeW50aGVzaXplKCk6IFByb21pc2U8Q2xvdWRBc3NlbWJseT4ge1xuICAgIC8vIFdlIG1heSBuZWVkIHRvIHJ1biB0aGUgY2xvdWQgZXhlY3V0YWJsZSBtdWx0aXBsZSB0aW1lcyBpbiBvcmRlciB0byBzYXRpc2Z5IGFsbCBtaXNzaW5nIGNvbnRleHRcbiAgICAvLyAoV2hlbiB0aGUgZXhlY3V0YWJsZSBydW5zLCBpdCB3aWxsIHRlbGwgdXMgYWJvdXQgY29udGV4dCBpdCB3YW50cyB0byB1c2VcbiAgICAvLyBidXQgaXQgbWlzc2luZy4gV2UnbGwgdGhlbiBsb29rIHVwIHRoZSBjb250ZXh0IGFuZCBydW4gdGhlIGV4ZWN1dGFibGUgYWdhaW4sIGFuZFxuICAgIC8vIGFnYWluLCB1bnRpbCBpdCBkb2Vzbid0IGNvbXBsYWluIGFueW1vcmUgb3Igd2UndmUgc3RvcHBlZCBtYWtpbmcgcHJvZ3Jlc3MpLlxuICAgIGxldCBwcmV2aW91c2x5TWlzc2luZ0tleXM6IFNldDxzdHJpbmc+IHwgdW5kZWZpbmVkO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IHRoaXMucHJvcHMuc3ludGhlc2l6ZXIodGhpcy5wcm9wcy5zZGtQcm92aWRlciwgdGhpcy5wcm9wcy5jb25maWd1cmF0aW9uKTtcblxuICAgICAgaWYgKGFzc2VtYmx5Lm1hbmlmZXN0Lm1pc3NpbmcgJiYgYXNzZW1ibHkubWFuaWZlc3QubWlzc2luZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdLZXlzID0gbWlzc2luZ0NvbnRleHRLZXlzKGFzc2VtYmx5Lm1hbmlmZXN0Lm1pc3NpbmcpO1xuXG4gICAgICAgIGlmICghdGhpcy5jYW5Mb29rdXApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFxuICAgICAgICAgICAgJ0NvbnRleHQgbG9va3VwcyBoYXZlIGJlZW4gZGlzYWJsZWQuICdcbiAgICAgICAgICAgICsgJ01ha2Ugc3VyZSBhbGwgbmVjZXNzYXJ5IGNvbnRleHQgaXMgYWxyZWFkeSBpbiBcXCdjZGsuY29udGV4dC5qc29uXFwnIGJ5IHJ1bm5pbmcgXFwnY2RrIHN5bnRoXFwnIG9uIGEgbWFjaGluZSB3aXRoIHN1ZmZpY2llbnQgQVdTIGNyZWRlbnRpYWxzIGFuZCBjb21taXR0aW5nIHRoZSByZXN1bHQuICdcbiAgICAgICAgICAgICsgYE1pc3NpbmcgY29udGV4dCBrZXlzOiAnJHtBcnJheS5mcm9tKG1pc3NpbmdLZXlzKS5qb2luKCcsICcpfSdgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0cnlMb29rdXAgPSB0cnVlO1xuICAgICAgICBpZiAocHJldmlvdXNseU1pc3NpbmdLZXlzICYmIHNldHNFcXVhbChtaXNzaW5nS2V5cywgcHJldmlvdXNseU1pc3NpbmdLZXlzKSkge1xuICAgICAgICAgIGF3YWl0IHRoaXMucHJvcHMuaW9IZWxwZXIubm90aWZ5KElPLkRFRkFVTFRfQVNTRU1CTFlfREVCVUcubXNnKCdOb3QgbWFraW5nIHByb2dyZXNzIHRyeWluZyB0byByZXNvbHZlIGVudmlyb25tZW50YWwgY29udGV4dC4gR2l2aW5nIHVwLicpKTtcbiAgICAgICAgICB0cnlMb29rdXAgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzbHlNaXNzaW5nS2V5cyA9IG1pc3NpbmdLZXlzO1xuXG4gICAgICAgIGlmICh0cnlMb29rdXApIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnByb3BzLmlvSGVscGVyLm5vdGlmeShJTy5ERUZBVUxUX0FTU0VNQkxZX0RFQlVHLm1zZygnU29tZSBjb250ZXh0IGluZm9ybWF0aW9uIGlzIG1pc3NpbmcuIEZldGNoaW5nLi4uJykpO1xuXG4gICAgICAgICAgYXdhaXQgY29udGV4dHByb3ZpZGVycy5wcm92aWRlQ29udGV4dFZhbHVlcyhcbiAgICAgICAgICAgIGFzc2VtYmx5Lm1hbmlmZXN0Lm1pc3NpbmcsXG4gICAgICAgICAgICB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24uY29udGV4dCxcbiAgICAgICAgICAgIHRoaXMucHJvcHMuc2RrUHJvdmlkZXIsXG4gICAgICAgICAgICBHTE9CQUxfUExVR0lOX0hPU1QsXG4gICAgICAgICAgICB0aGlzLnByb3BzLmlvSGVscGVyLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBDYWNoZSB0aGUgbmV3IGNvbnRleHQgdG8gZGlza1xuICAgICAgICAgIGF3YWl0IHRoaXMucHJvcHMuY29uZmlndXJhdGlvbi5zYXZlQ29udGV4dCgpO1xuXG4gICAgICAgICAgLy8gRXhlY3V0ZSBhZ2FpblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQ2xvdWRBc3NlbWJseShhc3NlbWJseSwgdGhpcy5wcm9wcy5pb0hlbHBlcik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXQgY2FuTG9va3VwKCkge1xuICAgIHJldHVybiAhISh0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24uc2V0dGluZ3MuZ2V0KFsnbG9va3VwcyddKSA/PyB0cnVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiBhbGwga2V5cyBvZiBtaXNzaW5nIGNvbnRleHQgaXRlbXNcbiAqL1xuZnVuY3Rpb24gbWlzc2luZ0NvbnRleHRLZXlzKG1pc3Npbmc/OiBjeGFwaS5NaXNzaW5nQ29udGV4dFtdKTogU2V0PHN0cmluZz4ge1xuICByZXR1cm4gbmV3IFNldCgobWlzc2luZyB8fCBbXSkubWFwKG0gPT4gbS5rZXkpKTtcbn1cblxuZnVuY3Rpb24gc2V0c0VxdWFsPEE+KGE6IFNldDxBPiwgYjogU2V0PEE+KSB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IHggb2YgYSkge1xuICAgIGlmICghYi5oYXMoeCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4iXX0=