# Finance Agent System - Secure Transaction Processing

This example demonstrates a realistic multi-agent system for financial operations with integrated plan validation using `plan-lint`. The system showcases how to intercept and validate potentially dangerous operations before they are executed.

## Overview

This example simulates a financial operations system where agents work together to handle:
- Customer transaction inquiries
- Fund transfers between accounts
- Data analysis for transaction history
- Security monitoring

The system uses plan-linter to validate all operational plans generated by the agents, intercepting any potentially dangerous operations or violations of security policies.

## Components

1. **Orchestrator Agent**: Coordinates requests and delegates to specialized agents
2. **Transaction Agent**: Processes fund transfers and payments 
3. **Analysis Agent**: Analyzes transaction histories and customer data
4. **Plan Validator**: Uses plan-lint to validate operation plans before execution

## Security Features

The example demonstrates several realistic security issues plan-lint can catch:
- SQL injection attempts in generated queries
- Excessive transaction amounts exceeding authorized limits
- Unnecessary privileged operations
- Sensitive data exposure in logs
- Authorization bypasses

## Running the Example

1. Install dependencies:
   ```
   pip install -e .[dev]
   pip install -r examples/finance_agent_system/requirements.txt
   ```

2. Run the example:
   ```
   python -m examples.finance_agent_system.main
   ```

3. Interactive Simulation Mode:
   ```
   python -m examples.finance_agent_system.main --simulated
   ```
   This mode provides a hyper-realistic terminal simulation of agents generating
   and validating plans in real-time, with colorized output and typing effects.

4. Fast Demo Mode (for videos/presentations):
   ```
   python -m examples.finance_agent_system.main --simulated --fast
   ```
   This mode speeds up the simulation to focus on plan validation timing,
   making it ideal for presentations, videos, and quick demonstrations.

5. Run a specific scenario:
   ```
   python -m examples.finance_agent_system.main --scenario harmful
   ```
   Available scenarios: `standard`, `harmful`, `excessive`, `sensitive_data`

6. Run a specific scenario in fast simulation mode:
   ```
   python -m examples.finance_agent_system.main --simulated --fast --scenario excessive
   ```

7. Run with Rego policy validation (instead of YAML):
   ```
   python -m examples.finance_agent_system.main --rego
   ```
   This uses the Rego policy defined in `finance_policy.rego` instead of the YAML policy.

## Scenarios

The example includes these scenarios:

1. **Standard**: A normal transaction for $100 between two accounts (passes validation)
2. **Harmful**: Transaction history query with SQL injection attack (fails validation)
3. **Excessive**: Large transfer exceeding policy limits (fails validation)
4. **Sensitive Data**: Customer update with exposed PII and credentials (fails validation)

## How Plan Validation Works

1. All agent-generated plans are intercepted by the plan validator
2. Plans are validated against security policies in `finance_policy.yaml` or `finance_policy.rego`
3. If validation fails, the agent cannot proceed with execution
4. Detailed feedback is provided about which policies were violated

This creates a secure layer between agent planning and execution, preventing potential security issues even when using powerful LLM agents.

## Using YAML vs Rego Policies

The system supports two policy formats:

### YAML Policy (Default)
- Simpler syntax for basic rules
- Easier to read and maintain for non-programmers
- No additional dependencies required
- Used by default when running the example

### Rego Policy (Advanced)
- More powerful, flexible policy language
- Support for complex logic and custom rules
- Requires OPA (Open Policy Agent) for direct evaluation
- Use the `--rego` flag to enable

To run the example with a Rego policy:
```
python -m examples.finance_agent_system.main --rego
```

To test if your OPA installation and Rego policy are working correctly:
```
python -m examples.finance_agent_system.test_opa
```

## Testing Policies

### Running with Valid Policy
```bash
# Test the default valid YAML policy
python -m examples.finance_agent_system.main --scenario standard

# Test the Rego policy
python -m examples.finance_agent_system.main --rego --scenario standard
```

### Example Policy Failure
To see how policies block harmful operations:
```bash
# Test SQL injection scenario with YAML policy
python -m examples.finance_agent_system.main --scenario harmful

# Test excessive transaction with Rego policy
python -m examples.finance_agent_system.main --rego --scenario excessive
```

## Creating Your Own Policies

### YAML Policies
Create a YAML file based on the structure in `finance_policy.yaml`:
```yaml
allow_tools:
  - db.get_account_details
  - payments.transfer
  - notify.customer
bounds:
  payments.transfer.amount: [0.01, 10000.00]
deny_tokens_regex:
  - "1=1"
  - "OR 1=1"
  - "DROP TABLE"
  - "password"
risk_weights:
  excessive_amount: 0.4
  sensitive_data: 0.5
  sql_injection: 0.6
fail_risk_threshold: 0.8
```

### Rego Policies
Create a Rego file based on the structure in `finance_policy.rego`. For detailed Rego syntax, refer to the [Open Policy Agent documentation](https://www.openpolicyagent.org/docs/latest/policy-language/).

A minimal Rego policy needs:
1. The `package planlint` declaration
2. Default rules for `allow`, `violations`, and `risk_score`
3. Logic to calculate violations and risk scores
4. An `allow` rule that determines if a plan is safe to execute

**Note**: When using Rego policies, having OPA installed is recommended but not required. If OPA is not available, plan-lint will fall back to built-in evaluation. 