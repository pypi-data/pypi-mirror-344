# example_client_cron.py
import time
import random
import string
from datetime import datetime
from pifunc import service, client, run_services


# Generator losowego ciągu znaków
def random_string(length=10):
    letters = string.ascii_lowercase
    return ''.join(random.choice(letters) for i in range(length))


# Funkcja do generowania ID produktu w określonym formacie
def generate_product_id():
    current_time = int(time.time())
    random_suffix = random.randint(1000, 9999)
    return f"PROD-{current_time}-{random_suffix}"


# Usługa tworząca produkt
@service(
    http={"path": "/api/products", "method": "POST"}
)
def create_product(product: dict) -> dict:
    """Create a new product."""
    print(f"[{datetime.now()}] Creating product: {product}")
    return {
        "id": product["id"],
        "name": product["name"],
        "price": product["price"],
        "in_stock": product.get("in_stock", True),
        "created_at": datetime.now().isoformat()
    }


# Strona główna
@service(
    http={"path": "/", "method": "GET"}
)
def hello() -> dict:
    """API information endpoint."""
    return {
        "description": "Product API with CRON automated generation",
        "endpoints": [
            {
                "path": "/api/products",
                "method": "POST",
                "description": "Create a new product"
            },
            {
                "path": "/api/products/generated",
                "method": "GET",
                "description": "View last generated product"
            }
        ],
        "cron_jobs": [
            {
                "name": "generate_product_hourly",
                "description": "Generates a new product every hour"
            },
            {
                "name": "generate_product_daily",
                "description": "Generates a premium product once a day"
            }
        ]
    }


# Przechowywanie ostatnio wygenerowanego produktu
last_generated_product = None


# Funkcja do odczytu ostatnio wygenerowanego produktu
@service(
    http={"path": "/api/products/generated", "method": "GET"}
)
def get_last_generated_product() -> dict:
    """Get the last product generated by CRON job."""
    if last_generated_product is None:
        return {"message": "No product has been generated yet"}
    return last_generated_product


# Funkcja kliencka generująca losowy produkt co godzinę
@client(
    http={"path": "/api/products", "method": "POST"}
)
@service(
    cron={"interval": "1h", "description": "Generate random product every hour"}
)
def generate_product_hourly() -> dict:
    """Generate random product data every hour and send it to create_product."""
    global last_generated_product

    product = {
        "id": generate_product_id(),
        "name": f"Auto Product {random_string(8)}",
        "price": round(random.uniform(10.0, 100.0), 2),
        "in_stock": random.choice([True, True, True, False]),  # 75% szans na dostępność
        "generated_at": datetime.now().isoformat(),
        "type": "standard"
    }

    print(f"[{datetime.now()}] Automatically generating product: {product}")
    last_generated_product = product
    return product


# Funkcja kliencka generująca ekskluzywny produkt raz dziennie
@client(
    http={"path": "/api/products", "method": "POST"}
)
@service(
    cron={"at": "12:00", "description": "Generate premium product daily at noon"}
)
def generate_product_daily() -> dict:
    """Generate premium product data daily at noon and send it to create_product."""
    global last_generated_product

    product = {
        "id": f"PREMIUM-{generate_product_id()}",
        "name": f"Premium {random_string(5).capitalize()} Collection",
        "price": round(random.uniform(100.0, 500.0), 2),
        "in_stock": True,
        "generated_at": datetime.now().isoformat(),
        "type": "premium",
        "features": [
            f"Feature {random_string(4).capitalize()}",
            f"Feature {random_string(4).capitalize()}",
            f"Feature {random_string(4).capitalize()}"
        ]
    }

    print(f"[{datetime.now()}] Automatically generating PREMIUM product: {product}")
    last_generated_product = product
    return product


# Funkcja do wykonania co 5 minut - sprawdzenie dostępności produktów
@service(
    cron={"interval": "5m", "description": "Check product availability every 5 minutes"}
)
def check_product_availability() -> None:
    """Check product availability every 5 minutes."""
    print(f"[{datetime.now()}] Running product availability check")
    # W rzeczywistej aplikacji tutaj można by sprawdzać dostępność w bazie danych
    # lub w zewnętrznym systemie i aktualizować status produktów

    # Symulujemy sprawdzenie
    if last_generated_product:
        print(f"Last product '{last_generated_product['name']}' is in stock: {last_generated_product['in_stock']}")
    else:
        print("No products to check yet")


# Uruchomienie wszystkich usług
if __name__ == "__main__":
    run_services(
        http={"port": 8080, "host": "0.0.0.0"},
        cron={"check_interval": 1},  # Sprawdzaj zadania co 1 sekundę
        watch=True  # Automatycznie przeładuj przy zmianach kodu
    )