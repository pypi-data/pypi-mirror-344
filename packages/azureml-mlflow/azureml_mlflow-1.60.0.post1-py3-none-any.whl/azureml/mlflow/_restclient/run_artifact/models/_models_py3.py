# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

import datetime
from typing import Dict, List, Optional, Union

from azure.core.exceptions import HttpResponseError
import msrest.serialization

from ._azure_machine_learning_workspaces_enums import *


class Artifact(msrest.serialization.Model):
    """Details of an Artifact.

    All required parameters must be populated in order to send to Azure.

    :param artifact_id: The identifier of an Artifact. Format of ArtifactId -
     {Origin}/{Container}/{Path}.
    :type artifact_id: str
    :param origin: Required. The origin of the Artifact creation request. Available origins are
     'ExperimentRun', 'LocalUpload', 'WebUpload', 'Dataset' and 'Unknown'.
    :type origin: str
    :param container: Required. The name of container. Artifacts can be grouped by container.
    :type container: str
    :param path: Required. The path to the Artifact in a container.
    :type path: str
    :param etag: The Etag of the Artifact.
    :type etag: str
    :param created_time: The Date and Time at which the Artifact is created. The DateTime is in
     UTC.
    :type created_time: ~datetime.datetime
    :param data_path:
    :type data_path: ~azure.mgmt.machinelearningservices.models.ArtifactDataPath
    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    """

    _validation = {
        'origin': {'required': True},
        'container': {'required': True},
        'path': {'required': True},
    }

    _attribute_map = {
        'artifact_id': {'key': 'artifactId', 'type': 'str'},
        'origin': {'key': 'origin', 'type': 'str'},
        'container': {'key': 'container', 'type': 'str'},
        'path': {'key': 'path', 'type': 'str'},
        'etag': {'key': 'etag', 'type': 'str'},
        'created_time': {'key': 'createdTime', 'type': 'iso-8601'},
        'data_path': {'key': 'dataPath', 'type': 'ArtifactDataPath'},
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        origin: str,
        container: str,
        path: str,
        artifact_id: Optional[str] = None,
        etag: Optional[str] = None,
        created_time: Optional[datetime.datetime] = None,
        data_path: Optional["ArtifactDataPath"] = None,
        tags: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(Artifact, self).__init__(**kwargs)
        self.artifact_id = artifact_id
        self.origin = origin
        self.container = container
        self.path = path
        self.etag = etag
        self.created_time = created_time
        self.data_path = data_path
        self.tags = tags


class ArtifactContentInformation(msrest.serialization.Model):
    """Details of an Artifact Content Information.

    :param content_uri: The URI of the content.
    :type content_uri: str
    :param origin: The origin of the Artifact creation request. Available origins are
     'ExperimentRun', 'LocalUpload', 'WebUpload', 'Dataset', 'ComputeRecord', 'Metric', and
     'Unknown'.
    :type origin: str
    :param container: The name of container. Artifacts can be grouped by container.
    :type container: str
    :param path: The path to the Artifact in a container.
    :type path: str
    :param tags: A set of tags. The tags on the artifact.
    :type tags: dict[str, str]
    """

    _attribute_map = {
        'content_uri': {'key': 'contentUri', 'type': 'str'},
        'origin': {'key': 'origin', 'type': 'str'},
        'container': {'key': 'container', 'type': 'str'},
        'path': {'key': 'path', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        content_uri: Optional[str] = None,
        origin: Optional[str] = None,
        container: Optional[str] = None,
        path: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(ArtifactContentInformation, self).__init__(**kwargs)
        self.content_uri = content_uri
        self.origin = origin
        self.container = container
        self.path = path
        self.tags = tags


class ArtifactDataPath(msrest.serialization.Model):
    """ArtifactDataPath.

    :param data_store_name:
    :type data_store_name: str
    :param relative_path:
    :type relative_path: str
    :param sql_data_path:
    :type sql_data_path: ~azure.mgmt.machinelearningservices.models.SqlDataPath
    """

    _attribute_map = {
        'data_store_name': {'key': 'dataStoreName', 'type': 'str'},
        'relative_path': {'key': 'relativePath', 'type': 'str'},
        'sql_data_path': {'key': 'sqlDataPath', 'type': 'SqlDataPath'},
    }

    def __init__(
        self,
        *,
        data_store_name: Optional[str] = None,
        relative_path: Optional[str] = None,
        sql_data_path: Optional["SqlDataPath"] = None,
        **kwargs
    ):
        super(ArtifactDataPath, self).__init__(**kwargs)
        self.data_store_name = data_store_name
        self.relative_path = relative_path
        self.sql_data_path = sql_data_path


class ArtifactPath(msrest.serialization.Model):
    """Details of an Artifact Path.

    All required parameters must be populated in order to send to Azure.

    :param path: Required. The path to the Artifact in a container.
    :type path: str
    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    """

    _validation = {
        'path': {'required': True},
    }

    _attribute_map = {
        'path': {'key': 'path', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        path: str,
        tags: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(ArtifactPath, self).__init__(**kwargs)
        self.path = path
        self.tags = tags


class ArtifactPathList(msrest.serialization.Model):
    """Contains list of Artifact Paths.

    All required parameters must be populated in order to send to Azure.

    :param paths: Required. List of Artifact Paths.
    :type paths: list[~azure.mgmt.machinelearningservices.models.ArtifactPath]
    """

    _validation = {
        'paths': {'required': True},
    }

    _attribute_map = {
        'paths': {'key': 'paths', 'type': '[ArtifactPath]'},
    }

    def __init__(
        self,
        *,
        paths: List["ArtifactPath"],
        **kwargs
    ):
        super(ArtifactPathList, self).__init__(**kwargs)
        self.paths = paths


class BaseEvent(msrest.serialization.Model):
    """Base event is the envelope used to post event data to the Event controller.

    :param timestamp:
    :type timestamp: ~datetime.datetime
    :param name:
    :type name: str
    :param data: Any object.
    :type data: object
    """

    _attribute_map = {
        'timestamp': {'key': 'timestamp', 'type': 'iso-8601'},
        'name': {'key': 'name', 'type': 'str'},
        'data': {'key': 'data', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        timestamp: Optional[datetime.datetime] = None,
        name: Optional[str] = None,
        data: Optional[object] = None,
        **kwargs
    ):
        super(BaseEvent, self).__init__(**kwargs)
        self.timestamp = timestamp
        self.name = name
        self.data = data


class BatchAddOrModifyRunRequest(msrest.serialization.Model):
    """BatchAddOrModifyRunRequest.

    :param runs:
    :type runs: list[~azure.mgmt.machinelearningservices.models.CreateRun]
    """

    _attribute_map = {
        'runs': {'key': 'runs', 'type': '[CreateRun]'},
    }

    def __init__(
        self,
        *,
        runs: Optional[List["CreateRun"]] = None,
        **kwargs
    ):
        super(BatchAddOrModifyRunRequest, self).__init__(**kwargs)
        self.runs = runs


class BatchArtifactContentInformationResult(msrest.serialization.Model):
    """Results of the Batch Artifact Content Information request.

    :param artifacts: Artifact details of the Artifact Ids requested.
    :type artifacts: dict[str, ~azure.mgmt.machinelearningservices.models.Artifact]
    :param artifact_content_information: Artifact Content Information details of the Artifact Ids
     requested.
    :type artifact_content_information: dict[str,
     ~azure.mgmt.machinelearningservices.models.ArtifactContentInformation]
    :param errors: Errors occurred while fetching the requested Artifact Ids.
    :type errors: dict[str, ~azure.mgmt.machinelearningservices.models.ErrorResponse]
    """

    _attribute_map = {
        'artifacts': {'key': 'artifacts', 'type': '{Artifact}'},
        'artifact_content_information': {'key': 'artifactContentInformation', 'type': '{ArtifactContentInformation}'},
        'errors': {'key': 'errors', 'type': '{ErrorResponse}'},
    }

    def __init__(
        self,
        *,
        artifacts: Optional[Dict[str, "Artifact"]] = None,
        artifact_content_information: Optional[Dict[str, "ArtifactContentInformation"]] = None,
        errors: Optional[Dict[str, "ErrorResponse"]] = None,
        **kwargs
    ):
        super(BatchArtifactContentInformationResult, self).__init__(**kwargs)
        self.artifacts = artifacts
        self.artifact_content_information = artifact_content_information
        self.errors = errors


class BatchEventCommand(msrest.serialization.Model):
    """BatchEventCommand.

    :param events:
    :type events: list[~azure.mgmt.machinelearningservices.models.BaseEvent]
    """

    _attribute_map = {
        'events': {'key': 'events', 'type': '[BaseEvent]'},
    }

    def __init__(
        self,
        *,
        events: Optional[List["BaseEvent"]] = None,
        **kwargs
    ):
        super(BatchEventCommand, self).__init__(**kwargs)
        self.events = events


class BatchEventCommandResult(msrest.serialization.Model):
    """BatchEventCommandResult.

    :param errors:
    :type errors:
     list[~azure.mgmt.machinelearningservices.models.KeyValuePairBaseEventErrorResponse]
    :param successes:
    :type successes: list[str]
    """

    _attribute_map = {
        'errors': {'key': 'errors', 'type': '[KeyValuePairBaseEventErrorResponse]'},
        'successes': {'key': 'successes', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        errors: Optional[List["KeyValuePairBaseEventErrorResponse"]] = None,
        successes: Optional[List[str]] = None,
        **kwargs
    ):
        super(BatchEventCommandResult, self).__init__(**kwargs)
        self.errors = errors
        self.successes = successes


class BatchIMetricV2(msrest.serialization.Model):
    """BatchIMetricV2.

    :param values:
    :type values: list[~azure.mgmt.machinelearningservices.models.IMetricV2]
    :param report_errors:
    :type report_errors: bool
    """

    _attribute_map = {
        'values': {'key': 'values', 'type': '[IMetricV2]'},
        'report_errors': {'key': 'reportErrors', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        values: Optional[List["IMetricV2"]] = None,
        report_errors: Optional[bool] = None,
        **kwargs
    ):
        super(BatchIMetricV2, self).__init__(**kwargs)
        self.values = values
        self.report_errors = report_errors


class BatchRequest1(msrest.serialization.Model):
    """BatchRequest1.

    :param requests: Dictionary of :code:`<GetRunDataRequest>`.
    :type requests: dict[str, ~azure.mgmt.machinelearningservices.models.GetRunDataRequest]
    """

    _attribute_map = {
        'requests': {'key': 'requests', 'type': '{GetRunDataRequest}'},
    }

    def __init__(
        self,
        *,
        requests: Optional[Dict[str, "GetRunDataRequest"]] = None,
        **kwargs
    ):
        super(BatchRequest1, self).__init__(**kwargs)
        self.requests = requests


class BatchResult1(msrest.serialization.Model):
    """BatchResult1.

    :param successful_results: Dictionary of :code:`<GetRunDataResult>`.
    :type successful_results: dict[str,
     ~azure.mgmt.machinelearningservices.models.GetRunDataResult]
    :param failed_results: Dictionary of :code:`<ErrorResponse>`.
    :type failed_results: dict[str, ~azure.mgmt.machinelearningservices.models.ErrorResponse]
    """

    _attribute_map = {
        'successful_results': {'key': 'successfulResults', 'type': '{GetRunDataResult}'},
        'failed_results': {'key': 'failedResults', 'type': '{ErrorResponse}'},
    }

    def __init__(
        self,
        *,
        successful_results: Optional[Dict[str, "GetRunDataResult"]] = None,
        failed_results: Optional[Dict[str, "ErrorResponse"]] = None,
        **kwargs
    ):
        super(BatchResult1, self).__init__(**kwargs)
        self.successful_results = successful_results
        self.failed_results = failed_results


class BatchRunResult(msrest.serialization.Model):
    """BatchRunResult.

    :param runs: Dictionary of :code:`<Run>`.
    :type runs: dict[str, ~azure.mgmt.machinelearningservices.models.Run]
    :param errors: Dictionary of :code:`<ErrorResponse>`.
    :type errors: dict[str, ~azure.mgmt.machinelearningservices.models.ErrorResponse]
    """

    _attribute_map = {
        'runs': {'key': 'runs', 'type': '{Run}'},
        'errors': {'key': 'errors', 'type': '{ErrorResponse}'},
    }

    def __init__(
        self,
        *,
        runs: Optional[Dict[str, "Run"]] = None,
        errors: Optional[Dict[str, "ErrorResponse"]] = None,
        **kwargs
    ):
        super(BatchRunResult, self).__init__(**kwargs)
        self.runs = runs
        self.errors = errors


class Compute(msrest.serialization.Model):
    """Compute.

    :param target:
    :type target: str
    :param target_type:
    :type target_type: str
    :param vm_size:
    :type vm_size: str
    :param instance_count:
    :type instance_count: int
    :param gpu_count:
    :type gpu_count: int
    :param priority:
    :type priority: str
    :param region:
    :type region: str
    """

    _attribute_map = {
        'target': {'key': 'target', 'type': 'str'},
        'target_type': {'key': 'targetType', 'type': 'str'},
        'vm_size': {'key': 'vmSize', 'type': 'str'},
        'instance_count': {'key': 'instanceCount', 'type': 'int'},
        'gpu_count': {'key': 'gpuCount', 'type': 'int'},
        'priority': {'key': 'priority', 'type': 'str'},
        'region': {'key': 'region', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        target: Optional[str] = None,
        target_type: Optional[str] = None,
        vm_size: Optional[str] = None,
        instance_count: Optional[int] = None,
        gpu_count: Optional[int] = None,
        priority: Optional[str] = None,
        region: Optional[str] = None,
        **kwargs
    ):
        super(Compute, self).__init__(**kwargs)
        self.target = target
        self.target_type = target_type
        self.vm_size = vm_size
        self.instance_count = instance_count
        self.gpu_count = gpu_count
        self.priority = priority
        self.region = region


class ComputeRequest(msrest.serialization.Model):
    """ComputeRequest.

    :param node_count:
    :type node_count: int
    :param gpu_count:
    :type gpu_count: int
    """

    _attribute_map = {
        'node_count': {'key': 'nodeCount', 'type': 'int'},
        'gpu_count': {'key': 'gpuCount', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        node_count: Optional[int] = None,
        gpu_count: Optional[int] = None,
        **kwargs
    ):
        super(ComputeRequest, self).__init__(**kwargs)
        self.node_count = node_count
        self.gpu_count = gpu_count


class CreatedFrom(msrest.serialization.Model):
    """CreatedFrom.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar type:  Default value: "Notebook".
    :vartype type: str
    :ivar location_type:  Default value: "ArtifactId".
    :vartype location_type: str
    :param location:
    :type location: str
    """

    _validation = {
        'type': {'constant': True},
        'location_type': {'constant': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'location_type': {'key': 'locationType', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
    }

    type = "Notebook"
    location_type = "ArtifactId"

    def __init__(
        self,
        *,
        location: Optional[str] = None,
        **kwargs
    ):
        super(CreatedFrom, self).__init__(**kwargs)
        self.location = location


class CreateRun(msrest.serialization.Model):
    """CreateRun.

    :param run_id: The identifier for the run. Run IDs must be less than 256 characters and contain
     only alphanumeric characters with dashes and underscores.
    :type run_id: str
    :param parent_run_id: The parent of the run if the run is hierarchical; otherwise, Null.
    :type parent_run_id: str
    :param experiment_id: The Id of the experiment that created this run.
    :type experiment_id: str
    :param status: The status of the run. The Status string value maps to the RunStatus Enum.
    :type status: str
    :param start_time_utc: The start time of the run in UTC.
    :type start_time_utc: ~datetime.datetime
    :param end_time_utc: The end time of the run in UTC.
    :type end_time_utc: ~datetime.datetime
    :param options:
    :type options: ~azure.mgmt.machinelearningservices.models.RunOptions
    :param is_virtual: A virtual run can set an active child run that will override the virtual run
     status and properties.
    :type is_virtual: bool
    :param display_name:
    :type display_name: str
    :param name:
    :type name: str
    :param data_container_id:
    :type data_container_id: str
    :param description:
    :type description: str
    :param hidden:
    :type hidden: bool
    :param run_type:
    :type run_type: str
    :param run_type_v2:
    :type run_type_v2: ~azure.mgmt.machinelearningservices.models.RunTypeV2
    :param properties: Dictionary of :code:`<string>`.
    :type properties: dict[str, str]
    :param parameters: Dictionary of :code:`<any>`.
    :type parameters: dict[str, object]
    :param action_uris: Dictionary of :code:`<string>`.
    :type action_uris: dict[str, str]
    :param script_name:
    :type script_name: str
    :param target:
    :type target: str
    :param unique_child_run_compute_targets:
    :type unique_child_run_compute_targets: list[str]
    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    :param settings: Dictionary of :code:`<string>`.
    :type settings: dict[str, str]
    :param services: Dictionary of :code:`<EndpointSetting>`.
    :type services: dict[str, ~azure.mgmt.machinelearningservices.models.EndpointSetting]
    :param input_datasets:
    :type input_datasets: list[~azure.mgmt.machinelearningservices.models.DatasetLineage]
    :param output_datasets:
    :type output_datasets: list[~azure.mgmt.machinelearningservices.models.OutputDatasetLineage]
    :param run_definition: Any object.
    :type run_definition: object
    :param job_specification: Any object.
    :type job_specification: object
    :param primary_metric_name:
    :type primary_metric_name: str
    :param created_from:
    :type created_from: ~azure.mgmt.machinelearningservices.models.CreatedFrom
    :param cancel_uri:
    :type cancel_uri: str
    :param complete_uri:
    :type complete_uri: str
    :param diagnostics_uri:
    :type diagnostics_uri: str
    :param compute_request:
    :type compute_request: ~azure.mgmt.machinelearningservices.models.ComputeRequest
    :param compute:
    :type compute: ~azure.mgmt.machinelearningservices.models.Compute
    :param retain_for_lifetime_of_workspace:
    :type retain_for_lifetime_of_workspace: bool
    :param queueing_info:
    :type queueing_info: ~azure.mgmt.machinelearningservices.models.QueueingInfo
    :param active_child_run_id: The RunId of the active child on a virtual run.
    :type active_child_run_id: str
    """

    _validation = {
        'unique_child_run_compute_targets': {'unique': True},
        'input_datasets': {'unique': True},
        'output_datasets': {'unique': True},
    }

    _attribute_map = {
        'run_id': {'key': 'runId', 'type': 'str'},
        'parent_run_id': {'key': 'parentRunId', 'type': 'str'},
        'experiment_id': {'key': 'experimentId', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'start_time_utc': {'key': 'startTimeUtc', 'type': 'iso-8601'},
        'end_time_utc': {'key': 'endTimeUtc', 'type': 'iso-8601'},
        'options': {'key': 'options', 'type': 'RunOptions'},
        'is_virtual': {'key': 'isVirtual', 'type': 'bool'},
        'display_name': {'key': 'displayName', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'data_container_id': {'key': 'dataContainerId', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'hidden': {'key': 'hidden', 'type': 'bool'},
        'run_type': {'key': 'runType', 'type': 'str'},
        'run_type_v2': {'key': 'runTypeV2', 'type': 'RunTypeV2'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'parameters': {'key': 'parameters', 'type': '{object}'},
        'action_uris': {'key': 'actionUris', 'type': '{str}'},
        'script_name': {'key': 'scriptName', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'unique_child_run_compute_targets': {'key': 'uniqueChildRunComputeTargets', 'type': '[str]'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'settings': {'key': 'settings', 'type': '{str}'},
        'services': {'key': 'services', 'type': '{EndpointSetting}'},
        'input_datasets': {'key': 'inputDatasets', 'type': '[DatasetLineage]'},
        'output_datasets': {'key': 'outputDatasets', 'type': '[OutputDatasetLineage]'},
        'run_definition': {'key': 'runDefinition', 'type': 'object'},
        'job_specification': {'key': 'jobSpecification', 'type': 'object'},
        'primary_metric_name': {'key': 'primaryMetricName', 'type': 'str'},
        'created_from': {'key': 'createdFrom', 'type': 'CreatedFrom'},
        'cancel_uri': {'key': 'cancelUri', 'type': 'str'},
        'complete_uri': {'key': 'completeUri', 'type': 'str'},
        'diagnostics_uri': {'key': 'diagnosticsUri', 'type': 'str'},
        'compute_request': {'key': 'computeRequest', 'type': 'ComputeRequest'},
        'compute': {'key': 'compute', 'type': 'Compute'},
        'retain_for_lifetime_of_workspace': {'key': 'retainForLifetimeOfWorkspace', 'type': 'bool'},
        'queueing_info': {'key': 'queueingInfo', 'type': 'QueueingInfo'},
        'active_child_run_id': {'key': 'activeChildRunId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        run_id: Optional[str] = None,
        parent_run_id: Optional[str] = None,
        experiment_id: Optional[str] = None,
        status: Optional[str] = None,
        start_time_utc: Optional[datetime.datetime] = None,
        end_time_utc: Optional[datetime.datetime] = None,
        options: Optional["RunOptions"] = None,
        is_virtual: Optional[bool] = None,
        display_name: Optional[str] = None,
        name: Optional[str] = None,
        data_container_id: Optional[str] = None,
        description: Optional[str] = None,
        hidden: Optional[bool] = None,
        run_type: Optional[str] = None,
        run_type_v2: Optional["RunTypeV2"] = None,
        properties: Optional[Dict[str, str]] = None,
        parameters: Optional[Dict[str, object]] = None,
        action_uris: Optional[Dict[str, str]] = None,
        script_name: Optional[str] = None,
        target: Optional[str] = None,
        unique_child_run_compute_targets: Optional[List[str]] = None,
        tags: Optional[Dict[str, str]] = None,
        settings: Optional[Dict[str, str]] = None,
        services: Optional[Dict[str, "EndpointSetting"]] = None,
        input_datasets: Optional[List["DatasetLineage"]] = None,
        output_datasets: Optional[List["OutputDatasetLineage"]] = None,
        run_definition: Optional[object] = None,
        job_specification: Optional[object] = None,
        primary_metric_name: Optional[str] = None,
        created_from: Optional["CreatedFrom"] = None,
        cancel_uri: Optional[str] = None,
        complete_uri: Optional[str] = None,
        diagnostics_uri: Optional[str] = None,
        compute_request: Optional["ComputeRequest"] = None,
        compute: Optional["Compute"] = None,
        retain_for_lifetime_of_workspace: Optional[bool] = None,
        queueing_info: Optional["QueueingInfo"] = None,
        active_child_run_id: Optional[str] = None,
        **kwargs
    ):
        super(CreateRun, self).__init__(**kwargs)
        self.run_id = run_id
        self.parent_run_id = parent_run_id
        self.experiment_id = experiment_id
        self.status = status
        self.start_time_utc = start_time_utc
        self.end_time_utc = end_time_utc
        self.options = options
        self.is_virtual = is_virtual
        self.display_name = display_name
        self.name = name
        self.data_container_id = data_container_id
        self.description = description
        self.hidden = hidden
        self.run_type = run_type
        self.run_type_v2 = run_type_v2
        self.properties = properties
        self.parameters = parameters
        self.action_uris = action_uris
        self.script_name = script_name
        self.target = target
        self.unique_child_run_compute_targets = unique_child_run_compute_targets
        self.tags = tags
        self.settings = settings
        self.services = services
        self.input_datasets = input_datasets
        self.output_datasets = output_datasets
        self.run_definition = run_definition
        self.job_specification = job_specification
        self.primary_metric_name = primary_metric_name
        self.created_from = created_from
        self.cancel_uri = cancel_uri
        self.complete_uri = complete_uri
        self.diagnostics_uri = diagnostics_uri
        self.compute_request = compute_request
        self.compute = compute
        self.retain_for_lifetime_of_workspace = retain_for_lifetime_of_workspace
        self.queueing_info = queueing_info
        self.active_child_run_id = active_child_run_id


class DatasetIdentifier(msrest.serialization.Model):
    """DatasetIdentifier.

    :param saved_id:
    :type saved_id: str
    :param registered_id:
    :type registered_id: str
    :param registered_version:
    :type registered_version: str
    """

    _attribute_map = {
        'saved_id': {'key': 'savedId', 'type': 'str'},
        'registered_id': {'key': 'registeredId', 'type': 'str'},
        'registered_version': {'key': 'registeredVersion', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        saved_id: Optional[str] = None,
        registered_id: Optional[str] = None,
        registered_version: Optional[str] = None,
        **kwargs
    ):
        super(DatasetIdentifier, self).__init__(**kwargs)
        self.saved_id = saved_id
        self.registered_id = registered_id
        self.registered_version = registered_version


class DatasetInputDetails(msrest.serialization.Model):
    """DatasetInputDetails.

    :param input_name:
    :type input_name: str
    :param mechanism:  Possible values include: "Direct", "Mount", "Download", "Hdfs".
    :type mechanism: str or ~azure.mgmt.machinelearningservices.models.DatasetDeliveryMechanism
    :param path_on_compute:
    :type path_on_compute: str
    """

    _attribute_map = {
        'input_name': {'key': 'inputName', 'type': 'str'},
        'mechanism': {'key': 'mechanism', 'type': 'str'},
        'path_on_compute': {'key': 'pathOnCompute', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        input_name: Optional[str] = None,
        mechanism: Optional[Union[str, "DatasetDeliveryMechanism"]] = None,
        path_on_compute: Optional[str] = None,
        **kwargs
    ):
        super(DatasetInputDetails, self).__init__(**kwargs)
        self.input_name = input_name
        self.mechanism = mechanism
        self.path_on_compute = path_on_compute


class DatasetLineage(msrest.serialization.Model):
    """DatasetLineage.

    :param identifier:
    :type identifier: ~azure.mgmt.machinelearningservices.models.DatasetIdentifier
    :param consumption_type:  Possible values include: "RunInput", "Reference".
    :type consumption_type: str or
     ~azure.mgmt.machinelearningservices.models.DatasetConsumptionType
    :param input_details:
    :type input_details: ~azure.mgmt.machinelearningservices.models.DatasetInputDetails
    """

    _attribute_map = {
        'identifier': {'key': 'identifier', 'type': 'DatasetIdentifier'},
        'consumption_type': {'key': 'consumptionType', 'type': 'str'},
        'input_details': {'key': 'inputDetails', 'type': 'DatasetInputDetails'},
    }

    def __init__(
        self,
        *,
        identifier: Optional["DatasetIdentifier"] = None,
        consumption_type: Optional[Union[str, "DatasetConsumptionType"]] = None,
        input_details: Optional["DatasetInputDetails"] = None,
        **kwargs
    ):
        super(DatasetLineage, self).__init__(**kwargs)
        self.identifier = identifier
        self.consumption_type = consumption_type
        self.input_details = input_details


class DatasetOutputDetails(msrest.serialization.Model):
    """DatasetOutputDetails.

    :param output_name:
    :type output_name: str
    """

    _attribute_map = {
        'output_name': {'key': 'outputName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        output_name: Optional[str] = None,
        **kwargs
    ):
        super(DatasetOutputDetails, self).__init__(**kwargs)
        self.output_name = output_name


class DeleteConfiguration(msrest.serialization.Model):
    """DeleteConfiguration.

    :param workspace_id:
    :type workspace_id: str
    :param is_enabled:
    :type is_enabled: bool
    :param cutoff_days:
    :type cutoff_days: int
    """

    _attribute_map = {
        'workspace_id': {'key': 'workspaceId', 'type': 'str'},
        'is_enabled': {'key': 'isEnabled', 'type': 'bool'},
        'cutoff_days': {'key': 'cutoffDays', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        workspace_id: Optional[str] = None,
        is_enabled: Optional[bool] = None,
        cutoff_days: Optional[int] = None,
        **kwargs
    ):
        super(DeleteConfiguration, self).__init__(**kwargs)
        self.workspace_id = workspace_id
        self.is_enabled = is_enabled
        self.cutoff_days = cutoff_days


class DeleteExperimentTagsResult(msrest.serialization.Model):
    """DeleteExperimentTagsResult.

    :param errors: Dictionary of :code:`<ErrorResponse>`.
    :type errors: dict[str, ~azure.mgmt.machinelearningservices.models.ErrorResponse]
    """

    _attribute_map = {
        'errors': {'key': 'errors', 'type': '{ErrorResponse}'},
    }

    def __init__(
        self,
        *,
        errors: Optional[Dict[str, "ErrorResponse"]] = None,
        **kwargs
    ):
        super(DeleteExperimentTagsResult, self).__init__(**kwargs)
        self.errors = errors


class DeleteOrModifyTags(msrest.serialization.Model):
    """The Tags to modify or delete.

    :param tags_to_modify: The KV pairs of tags to modify.
    :type tags_to_modify: dict[str, str]
    :param tags_to_delete: The list of tags to delete.
    :type tags_to_delete: list[str]
    """

    _attribute_map = {
        'tags_to_modify': {'key': 'tagsToModify', 'type': '{str}'},
        'tags_to_delete': {'key': 'tagsToDelete', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        tags_to_modify: Optional[Dict[str, str]] = None,
        tags_to_delete: Optional[List[str]] = None,
        **kwargs
    ):
        super(DeleteOrModifyTags, self).__init__(**kwargs)
        self.tags_to_modify = tags_to_modify
        self.tags_to_delete = tags_to_delete


class DeleteRunServices(msrest.serialization.Model):
    """The Services to delete.

    :param services_to_delete: The list of Services to delete.
    :type services_to_delete: list[str]
    """

    _attribute_map = {
        'services_to_delete': {'key': 'servicesToDelete', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        services_to_delete: Optional[List[str]] = None,
        **kwargs
    ):
        super(DeleteRunServices, self).__init__(**kwargs)
        self.services_to_delete = services_to_delete


class DeleteTagsCommand(msrest.serialization.Model):
    """DeleteTagsCommand.

    :param tags: A set of tags.
    :type tags: list[str]
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        tags: Optional[List[str]] = None,
        **kwargs
    ):
        super(DeleteTagsCommand, self).__init__(**kwargs)
        self.tags = tags


class DerivedMetricKey(msrest.serialization.Model):
    """DerivedMetricKey.

    :param namespace:
    :type namespace: str
    :param name:
    :type name: str
    :param labels:
    :type labels: list[str]
    :param column_names:
    :type column_names: list[str]
    """

    _validation = {
        'labels': {'unique': True},
        'column_names': {'unique': True},
    }

    _attribute_map = {
        'namespace': {'key': 'namespace', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'labels': {'key': 'labels', 'type': '[str]'},
        'column_names': {'key': 'columnNames', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        namespace: Optional[str] = None,
        name: Optional[str] = None,
        labels: Optional[List[str]] = None,
        column_names: Optional[List[str]] = None,
        **kwargs
    ):
        super(DerivedMetricKey, self).__init__(**kwargs)
        self.namespace = namespace
        self.name = name
        self.labels = labels
        self.column_names = column_names


class EndpointSetting(msrest.serialization.Model):
    """EndpointSetting.

    :param type:
    :type type: str
    :param port:
    :type port: int
    :param ssl_thumbprint:
    :type ssl_thumbprint: str
    :param endpoint:
    :type endpoint: str
    :param proxy_endpoint:
    :type proxy_endpoint: str
    :param status:
    :type status: str
    :param error_message:
    :type error_message: str
    :param enabled:
    :type enabled: bool
    :param properties: Dictionary of :code:`<string>`.
    :type properties: dict[str, str]
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'port': {'key': 'port', 'type': 'int'},
        'ssl_thumbprint': {'key': 'sslThumbprint', 'type': 'str'},
        'endpoint': {'key': 'endpoint', 'type': 'str'},
        'proxy_endpoint': {'key': 'proxyEndpoint', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'error_message': {'key': 'errorMessage', 'type': 'str'},
        'enabled': {'key': 'enabled', 'type': 'bool'},
        'properties': {'key': 'properties', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        type: Optional[str] = None,
        port: Optional[int] = None,
        ssl_thumbprint: Optional[str] = None,
        endpoint: Optional[str] = None,
        proxy_endpoint: Optional[str] = None,
        status: Optional[str] = None,
        error_message: Optional[str] = None,
        enabled: Optional[bool] = None,
        properties: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(EndpointSetting, self).__init__(**kwargs)
        self.type = type
        self.port = port
        self.ssl_thumbprint = ssl_thumbprint
        self.endpoint = endpoint
        self.proxy_endpoint = proxy_endpoint
        self.status = status
        self.error_message = error_message
        self.enabled = enabled
        self.properties = properties


class ErrorAdditionalInfo(msrest.serialization.Model):
    """The resource management error additional info.

    :param type: The additional info type.
    :type type: str
    :param info: The additional info.
    :type info: object
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'info': {'key': 'info', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        type: Optional[str] = None,
        info: Optional[object] = None,
        **kwargs
    ):
        super(ErrorAdditionalInfo, self).__init__(**kwargs)
        self.type = type
        self.info = info


class ErrorResponse(msrest.serialization.Model):
    """The error response.

    :param error: The root error.
    :type error: ~azure.mgmt.machinelearningservices.models.RootError
    :param correlation: Dictionary containing correlation details for the error.
    :type correlation: dict[str, str]
    :param environment: The hosting environment.
    :type environment: str
    :param location: The Azure region.
    :type location: str
    :param time: The time in UTC.
    :type time: ~datetime.datetime
    :param component_name: Component name where error originated/encountered.
    :type component_name: str
    """

    _attribute_map = {
        'error': {'key': 'error', 'type': 'RootError'},
        'correlation': {'key': 'correlation', 'type': '{str}'},
        'environment': {'key': 'environment', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'time': {'key': 'time', 'type': 'iso-8601'},
        'component_name': {'key': 'componentName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        error: Optional["RootError"] = None,
        correlation: Optional[Dict[str, str]] = None,
        environment: Optional[str] = None,
        location: Optional[str] = None,
        time: Optional[datetime.datetime] = None,
        component_name: Optional[str] = None,
        **kwargs
    ):
        super(ErrorResponse, self).__init__(**kwargs)
        self.error = error
        self.correlation = correlation
        self.environment = environment
        self.location = location
        self.time = time
        self.component_name = component_name


class Event(msrest.serialization.Model):
    """Event.

    :param name: Gets the Microsoft.MachineLearning.RunHistory.Contracts.Event name.
    :type name: str
    :param timestamp: Gets the Microsoft.MachineLearning.RunHistory.Contracts.Event timestamp.
    :type timestamp: ~datetime.datetime
    :param attributes: Gets the System.Collections.Generic.IDictionary`2 collection of attributes
     associated with the event.
    :type attributes: dict[str, object]
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'timestamp': {'key': 'timestamp', 'type': 'iso-8601'},
        'attributes': {'key': 'attributes', 'type': '{object}'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        timestamp: Optional[datetime.datetime] = None,
        attributes: Optional[Dict[str, object]] = None,
        **kwargs
    ):
        super(Event, self).__init__(**kwargs)
        self.name = name
        self.timestamp = timestamp
        self.attributes = attributes


class Experiment(msrest.serialization.Model):
    """Experiment.

    :param experiment_id:
    :type experiment_id: str
    :param name:
    :type name: str
    :param description:
    :type description: str
    :param created_utc:
    :type created_utc: ~datetime.datetime
    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    :param archived_time:
    :type archived_time: ~datetime.datetime
    :param retain_for_lifetime_of_workspace:
    :type retain_for_lifetime_of_workspace: bool
    :param artifact_location:
    :type artifact_location: str
    """

    _attribute_map = {
        'experiment_id': {'key': 'experimentId', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'created_utc': {'key': 'createdUtc', 'type': 'iso-8601'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'archived_time': {'key': 'archivedTime', 'type': 'iso-8601'},
        'retain_for_lifetime_of_workspace': {'key': 'retainForLifetimeOfWorkspace', 'type': 'bool'},
        'artifact_location': {'key': 'artifactLocation', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        experiment_id: Optional[str] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        created_utc: Optional[datetime.datetime] = None,
        tags: Optional[Dict[str, str]] = None,
        archived_time: Optional[datetime.datetime] = None,
        retain_for_lifetime_of_workspace: Optional[bool] = None,
        artifact_location: Optional[str] = None,
        **kwargs
    ):
        super(Experiment, self).__init__(**kwargs)
        self.experiment_id = experiment_id
        self.name = name
        self.description = description
        self.created_utc = created_utc
        self.tags = tags
        self.archived_time = archived_time
        self.retain_for_lifetime_of_workspace = retain_for_lifetime_of_workspace
        self.artifact_location = artifact_location


class ExperimentQueryParams(msrest.serialization.Model):
    """Extends Query Params DTO for ViewType.

    :param view_type: ViewType filters experiments by their archived state. Default is ActiveOnly.
     Possible values include: "Default", "All", "ActiveOnly", "ArchivedOnly".
    :type view_type: str or ~azure.mgmt.machinelearningservices.models.ExperimentViewType
    :param filter: Allows for filtering the collection of resources.
     The expression specified is evaluated for each resource in the collection, and only items
     where the expression evaluates to true are included in the response.
     See https://docs.microsoft.com/en-us/azure/search/query-odata-filter-orderby-syntax for
     details on the expression syntax.
    :type filter: str
    :param continuation_token: The continuation token to use for getting the next set of resources.
    :type continuation_token: str
    :param order_by: The comma separated list of resource properties to use for sorting the
     requested resources.
     Optionally, can be followed by either 'asc' or 'desc'.
    :type order_by: str
    :param top: The maximum number of items in the resource collection to be included in the
     result.
     If not specified, all items are returned.
    :type top: int
    """

    _attribute_map = {
        'view_type': {'key': 'viewType', 'type': 'str'},
        'filter': {'key': 'filter', 'type': 'str'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
        'order_by': {'key': 'orderBy', 'type': 'str'},
        'top': {'key': 'top', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        view_type: Optional[Union[str, "ExperimentViewType"]] = None,
        filter: Optional[str] = None,
        continuation_token: Optional[str] = None,
        order_by: Optional[str] = None,
        top: Optional[int] = None,
        **kwargs
    ):
        super(ExperimentQueryParams, self).__init__(**kwargs)
        self.view_type = view_type
        self.filter = filter
        self.continuation_token = continuation_token
        self.order_by = order_by
        self.top = top


class GetRunDataRequest(msrest.serialization.Model):
    """GetRunDataRequest.

    :param run_id:
    :type run_id: str
    :param select_run_metadata:
    :type select_run_metadata: bool
    :param select_run_definition:
    :type select_run_definition: bool
    :param select_job_specification:
    :type select_job_specification: bool
    """

    _attribute_map = {
        'run_id': {'key': 'runId', 'type': 'str'},
        'select_run_metadata': {'key': 'selectRunMetadata', 'type': 'bool'},
        'select_run_definition': {'key': 'selectRunDefinition', 'type': 'bool'},
        'select_job_specification': {'key': 'selectJobSpecification', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        run_id: Optional[str] = None,
        select_run_metadata: Optional[bool] = None,
        select_run_definition: Optional[bool] = None,
        select_job_specification: Optional[bool] = None,
        **kwargs
    ):
        super(GetRunDataRequest, self).__init__(**kwargs)
        self.run_id = run_id
        self.select_run_metadata = select_run_metadata
        self.select_run_definition = select_run_definition
        self.select_job_specification = select_job_specification


class GetRunDataResult(msrest.serialization.Model):
    """GetRunDataResult.

    :param run_metadata: The definition of a Run.
    :type run_metadata: ~azure.mgmt.machinelearningservices.models.Run
    :param run_definition: Any object.
    :type run_definition: object
    :param job_specification: Any object.
    :type job_specification: object
    """

    _attribute_map = {
        'run_metadata': {'key': 'runMetadata', 'type': 'Run'},
        'run_definition': {'key': 'runDefinition', 'type': 'object'},
        'job_specification': {'key': 'jobSpecification', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        run_metadata: Optional["Run"] = None,
        run_definition: Optional[object] = None,
        job_specification: Optional[object] = None,
        **kwargs
    ):
        super(GetRunDataResult, self).__init__(**kwargs)
        self.run_metadata = run_metadata
        self.run_definition = run_definition
        self.job_specification = job_specification


class GetRunsByIds(msrest.serialization.Model):
    """GetRunsByIds.

    :param run_ids:
    :type run_ids: list[str]
    """

    _attribute_map = {
        'run_ids': {'key': 'runIds', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        run_ids: Optional[List[str]] = None,
        **kwargs
    ):
        super(GetRunsByIds, self).__init__(**kwargs)
        self.run_ids = run_ids


class GetSampledMetricRequest(msrest.serialization.Model):
    """GetSampledMetricRequest.

    :param metric_name:
    :type metric_name: str
    :param metric_namespace:
    :type metric_namespace: str
    """

    _attribute_map = {
        'metric_name': {'key': 'metricName', 'type': 'str'},
        'metric_namespace': {'key': 'metricNamespace', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        metric_name: Optional[str] = None,
        metric_namespace: Optional[str] = None,
        **kwargs
    ):
        super(GetSampledMetricRequest, self).__init__(**kwargs)
        self.metric_name = metric_name
        self.metric_namespace = metric_namespace


class IMetricV2(msrest.serialization.Model):
    """Sequence of one or many values sharing a common  DataContainerId, Name, and Schema. Used only for Post Metrics.

    :param data_container_id: Data container to which this Metric belongs.
    :type data_container_id: str
    :param name: Name identifying this Metric within the Data Container.
    :type name: str
    :param columns: Schema shared by all values under this Metric
     Columns.Keys define the column names which are required for each MetricValue
     Columns.Values define the type of the associated object for each column.
    :type columns: dict[str, str or ~azure.mgmt.machinelearningservices.models.MetricValueType]
    :param namespace: Namespace for this Metric.
    :type namespace: str
    :param standard_schema_id:
    :type standard_schema_id: str
    :param value: The list of values.
    :type value: list[~azure.mgmt.machinelearningservices.models.MetricV2Value]
    """

    _attribute_map = {
        'data_container_id': {'key': 'dataContainerId', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'columns': {'key': 'columns', 'type': '{str}'},
        'namespace': {'key': 'namespace', 'type': 'str'},
        'standard_schema_id': {'key': 'standardSchemaId', 'type': 'str'},
        'value': {'key': 'value', 'type': '[MetricV2Value]'},
    }

    def __init__(
        self,
        *,
        data_container_id: Optional[str] = None,
        name: Optional[str] = None,
        columns: Optional[Dict[str, Union[str, "MetricValueType"]]] = None,
        namespace: Optional[str] = None,
        standard_schema_id: Optional[str] = None,
        value: Optional[List["MetricV2Value"]] = None,
        **kwargs
    ):
        super(IMetricV2, self).__init__(**kwargs)
        self.data_container_id = data_container_id
        self.name = name
        self.columns = columns
        self.namespace = namespace
        self.standard_schema_id = standard_schema_id
        self.value = value


class InnerErrorResponse(msrest.serialization.Model):
    """A nested structure of errors.

    :param code: The error code.
    :type code: str
    :param inner_error: A nested structure of errors.
    :type inner_error: ~azure.mgmt.machinelearningservices.models.InnerErrorResponse
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'inner_error': {'key': 'innerError', 'type': 'InnerErrorResponse'},
    }

    def __init__(
        self,
        *,
        code: Optional[str] = None,
        inner_error: Optional["InnerErrorResponse"] = None,
        **kwargs
    ):
        super(InnerErrorResponse, self).__init__(**kwargs)
        self.code = code
        self.inner_error = inner_error


class JobCost(msrest.serialization.Model):
    """JobCost.

    :param charged_cpu_core_seconds:
    :type charged_cpu_core_seconds: float
    :param charged_cpu_memory_megabyte_seconds:
    :type charged_cpu_memory_megabyte_seconds: float
    :param charged_gpu_seconds:
    :type charged_gpu_seconds: float
    :param charged_node_utilization_seconds:
    :type charged_node_utilization_seconds: float
    """

    _attribute_map = {
        'charged_cpu_core_seconds': {'key': 'chargedCpuCoreSeconds', 'type': 'float'},
        'charged_cpu_memory_megabyte_seconds': {'key': 'chargedCpuMemoryMegabyteSeconds', 'type': 'float'},
        'charged_gpu_seconds': {'key': 'chargedGpuSeconds', 'type': 'float'},
        'charged_node_utilization_seconds': {'key': 'chargedNodeUtilizationSeconds', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        charged_cpu_core_seconds: Optional[float] = None,
        charged_cpu_memory_megabyte_seconds: Optional[float] = None,
        charged_gpu_seconds: Optional[float] = None,
        charged_node_utilization_seconds: Optional[float] = None,
        **kwargs
    ):
        super(JobCost, self).__init__(**kwargs)
        self.charged_cpu_core_seconds = charged_cpu_core_seconds
        self.charged_cpu_memory_megabyte_seconds = charged_cpu_memory_megabyte_seconds
        self.charged_gpu_seconds = charged_gpu_seconds
        self.charged_node_utilization_seconds = charged_node_utilization_seconds


class KeyValuePairBaseEventErrorResponse(msrest.serialization.Model):
    """KeyValuePairBaseEventErrorResponse.

    :param key: Base event is the envelope used to post event data to the Event controller.
    :type key: ~azure.mgmt.machinelearningservices.models.BaseEvent
    :param value: The error response.
    :type value: ~azure.mgmt.machinelearningservices.models.ErrorResponse
    """

    _attribute_map = {
        'key': {'key': 'key', 'type': 'BaseEvent'},
        'value': {'key': 'value', 'type': 'ErrorResponse'},
    }

    def __init__(
        self,
        *,
        key: Optional["BaseEvent"] = None,
        value: Optional["ErrorResponse"] = None,
        **kwargs
    ):
        super(KeyValuePairBaseEventErrorResponse, self).__init__(**kwargs)
        self.key = key
        self.value = value


class KeyValuePairString(msrest.serialization.Model):
    """KeyValuePairString.

    :param key:
    :type key: str
    :param value:
    :type value: str
    """

    _attribute_map = {
        'key': {'key': 'key', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        key: Optional[str] = None,
        value: Optional[str] = None,
        **kwargs
    ):
        super(KeyValuePairString, self).__init__(**kwargs)
        self.key = key
        self.value = value


class KeyValuePairStringJToken(msrest.serialization.Model):
    """KeyValuePairStringJToken.

    :param key:
    :type key: str
    :param value: Any object.
    :type value: object
    """

    _attribute_map = {
        'key': {'key': 'key', 'type': 'str'},
        'value': {'key': 'value', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        key: Optional[str] = None,
        value: Optional[object] = None,
        **kwargs
    ):
        super(KeyValuePairStringJToken, self).__init__(**kwargs)
        self.key = key
        self.value = value


class Link(msrest.serialization.Model):
    """Link.

    :param context:
    :type context: ~azure.mgmt.machinelearningservices.models.SpanContext
    :param attributes: Gets the collection of attributes associated with the link.
    :type attributes: dict[str, object]
    """

    _attribute_map = {
        'context': {'key': 'context', 'type': 'SpanContext'},
        'attributes': {'key': 'attributes', 'type': '{object}'},
    }

    def __init__(
        self,
        *,
        context: Optional["SpanContext"] = None,
        attributes: Optional[Dict[str, object]] = None,
        **kwargs
    ):
        super(Link, self).__init__(**kwargs)
        self.context = context
        self.attributes = attributes


class ListGenericResourceMetrics(msrest.serialization.Model):
    """ListGenericResourceMetrics.

    :param resource_id:
    :type resource_id: str
    :param metric_names:
    :type metric_names: list[str]
    :param label_filters: Dictionary of :code:`<string>`.
    :type label_filters: dict[str, str]
    :param metric_namespace:
    :type metric_namespace: str
    :param continuation_token:
    :type continuation_token: str
    """

    _attribute_map = {
        'resource_id': {'key': 'resourceId', 'type': 'str'},
        'metric_names': {'key': 'metricNames', 'type': '[str]'},
        'label_filters': {'key': 'labelFilters', 'type': '{str}'},
        'metric_namespace': {'key': 'metricNamespace', 'type': 'str'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        resource_id: Optional[str] = None,
        metric_names: Optional[List[str]] = None,
        label_filters: Optional[Dict[str, str]] = None,
        metric_namespace: Optional[str] = None,
        continuation_token: Optional[str] = None,
        **kwargs
    ):
        super(ListGenericResourceMetrics, self).__init__(**kwargs)
        self.resource_id = resource_id
        self.metric_names = metric_names
        self.label_filters = label_filters
        self.metric_namespace = metric_namespace
        self.continuation_token = continuation_token


class ListMetrics(msrest.serialization.Model):
    """ListMetrics.

    :param metric_namespace:
    :type metric_namespace: str
    :param continuation_token:
    :type continuation_token: str
    """

    _attribute_map = {
        'metric_namespace': {'key': 'metricNamespace', 'type': 'str'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        metric_namespace: Optional[str] = None,
        continuation_token: Optional[str] = None,
        **kwargs
    ):
        super(ListMetrics, self).__init__(**kwargs)
        self.metric_namespace = metric_namespace
        self.continuation_token = continuation_token


class MetricDefinition(msrest.serialization.Model):
    """MetricDefinition.

    :param metric_key:
    :type metric_key: ~azure.mgmt.machinelearningservices.models.DerivedMetricKey
    :param columns: Dictionary of :code:`<MetricValueType>`.
    :type columns: dict[str, str or ~azure.mgmt.machinelearningservices.models.MetricValueType]
    :param properties:
    :type properties: ~azure.mgmt.machinelearningservices.models.MetricProperties
    """

    _attribute_map = {
        'metric_key': {'key': 'metricKey', 'type': 'DerivedMetricKey'},
        'columns': {'key': 'columns', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': 'MetricProperties'},
    }

    def __init__(
        self,
        *,
        metric_key: Optional["DerivedMetricKey"] = None,
        columns: Optional[Dict[str, Union[str, "MetricValueType"]]] = None,
        properties: Optional["MetricProperties"] = None,
        **kwargs
    ):
        super(MetricDefinition, self).__init__(**kwargs)
        self.metric_key = metric_key
        self.columns = columns
        self.properties = properties


class MetricProperties(msrest.serialization.Model):
    """MetricProperties.

    :param ux_metric_type: String value UX uses to decide how to render your metrics
     Ex: azureml.v1.scalar or azureml.v1.table.
    :type ux_metric_type: str
    """

    _attribute_map = {
        'ux_metric_type': {'key': 'uxMetricType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        ux_metric_type: Optional[str] = None,
        **kwargs
    ):
        super(MetricProperties, self).__init__(**kwargs)
        self.ux_metric_type = ux_metric_type


class MetricSample(msrest.serialization.Model):
    """MetricSample.

    :param derived_label_values: Dictionary of :code:`<string>`.
    :type derived_label_values: dict[str, str]
    :param is_partial_result:
    :type is_partial_result: bool
    :param num_values_logged:
    :type num_values_logged: long
    :param data_container_id: Data container to which this Metric belongs.
    :type data_container_id: str
    :param name: Name identifying this Metric within the Data Container.
    :type name: str
    :param columns: Schema shared by all values under this Metric
     Columns.Keys define the column names which are required for each MetricValue
     Columns.Values define the type of the associated object for each column.
    :type columns: dict[str, str or ~azure.mgmt.machinelearningservices.models.MetricValueType]
    :param properties:
    :type properties: ~azure.mgmt.machinelearningservices.models.MetricProperties
    :param namespace: Namespace for this Metric.
    :type namespace: str
    :param standard_schema_id:
    :type standard_schema_id: str
    :param value:
    :type value: list[~azure.mgmt.machinelearningservices.models.MetricV2Value]
    :param continuation_token: The token used in retrieving the next page. If null, there are no
     additional pages.
    :type continuation_token: str
    :param next_link: The link to the next page constructed using the continuationToken.  If null,
     there are no additional pages.
    :type next_link: str
    """

    _attribute_map = {
        'derived_label_values': {'key': 'derivedLabelValues', 'type': '{str}'},
        'is_partial_result': {'key': 'isPartialResult', 'type': 'bool'},
        'num_values_logged': {'key': 'numValuesLogged', 'type': 'long'},
        'data_container_id': {'key': 'dataContainerId', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'columns': {'key': 'columns', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': 'MetricProperties'},
        'namespace': {'key': 'namespace', 'type': 'str'},
        'standard_schema_id': {'key': 'standardSchemaId', 'type': 'str'},
        'value': {'key': 'value', 'type': '[MetricV2Value]'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        derived_label_values: Optional[Dict[str, str]] = None,
        is_partial_result: Optional[bool] = None,
        num_values_logged: Optional[int] = None,
        data_container_id: Optional[str] = None,
        name: Optional[str] = None,
        columns: Optional[Dict[str, Union[str, "MetricValueType"]]] = None,
        properties: Optional["MetricProperties"] = None,
        namespace: Optional[str] = None,
        standard_schema_id: Optional[str] = None,
        value: Optional[List["MetricV2Value"]] = None,
        continuation_token: Optional[str] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(MetricSample, self).__init__(**kwargs)
        self.derived_label_values = derived_label_values
        self.is_partial_result = is_partial_result
        self.num_values_logged = num_values_logged
        self.data_container_id = data_container_id
        self.name = name
        self.columns = columns
        self.properties = properties
        self.namespace = namespace
        self.standard_schema_id = standard_schema_id
        self.value = value
        self.continuation_token = continuation_token
        self.next_link = next_link


class MetricSchema(msrest.serialization.Model):
    """MetricSchema.

    :param num_properties:
    :type num_properties: int
    :param properties:
    :type properties: list[~azure.mgmt.machinelearningservices.models.MetricSchemaProperty]
    """

    _attribute_map = {
        'num_properties': {'key': 'numProperties', 'type': 'int'},
        'properties': {'key': 'properties', 'type': '[MetricSchemaProperty]'},
    }

    def __init__(
        self,
        *,
        num_properties: Optional[int] = None,
        properties: Optional[List["MetricSchemaProperty"]] = None,
        **kwargs
    ):
        super(MetricSchema, self).__init__(**kwargs)
        self.num_properties = num_properties
        self.properties = properties


class MetricSchemaProperty(msrest.serialization.Model):
    """MetricSchemaProperty.

    :param property_id:
    :type property_id: str
    :param name:
    :type name: str
    :param type:
    :type type: str
    """

    _attribute_map = {
        'property_id': {'key': 'propertyId', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        property_id: Optional[str] = None,
        name: Optional[str] = None,
        type: Optional[str] = None,
        **kwargs
    ):
        super(MetricSchemaProperty, self).__init__(**kwargs)
        self.property_id = property_id
        self.name = name
        self.type = type


class MetricV2(msrest.serialization.Model):
    """Sequence of one or many values sharing a common DataContainerId, Name, and Schema.

    :param data_container_id: Data container to which this Metric belongs.
    :type data_container_id: str
    :param name: Name identifying this Metric within the Data Container.
    :type name: str
    :param columns: Schema shared by all values under this Metric
     Columns.Keys define the column names which are required for each MetricValue
     Columns.Values define the type of the associated object for each column.
    :type columns: dict[str, str or ~azure.mgmt.machinelearningservices.models.MetricValueType]
    :param properties:
    :type properties: ~azure.mgmt.machinelearningservices.models.MetricProperties
    :param namespace: Namespace for this Metric.
    :type namespace: str
    :param standard_schema_id:
    :type standard_schema_id: str
    :param value:
    :type value: list[~azure.mgmt.machinelearningservices.models.MetricV2Value]
    :param continuation_token: The token used in retrieving the next page. If null, there are no
     additional pages.
    :type continuation_token: str
    :param next_link: The link to the next page constructed using the continuationToken.  If null,
     there are no additional pages.
    :type next_link: str
    """

    _attribute_map = {
        'data_container_id': {'key': 'dataContainerId', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'columns': {'key': 'columns', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': 'MetricProperties'},
        'namespace': {'key': 'namespace', 'type': 'str'},
        'standard_schema_id': {'key': 'standardSchemaId', 'type': 'str'},
        'value': {'key': 'value', 'type': '[MetricV2Value]'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        data_container_id: Optional[str] = None,
        name: Optional[str] = None,
        columns: Optional[Dict[str, Union[str, "MetricValueType"]]] = None,
        properties: Optional["MetricProperties"] = None,
        namespace: Optional[str] = None,
        standard_schema_id: Optional[str] = None,
        value: Optional[List["MetricV2Value"]] = None,
        continuation_token: Optional[str] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(MetricV2, self).__init__(**kwargs)
        self.data_container_id = data_container_id
        self.name = name
        self.columns = columns
        self.properties = properties
        self.namespace = namespace
        self.standard_schema_id = standard_schema_id
        self.value = value
        self.continuation_token = continuation_token
        self.next_link = next_link


class MetricV2Value(msrest.serialization.Model):
    """An individual value logged within a Metric.

    :param metric_id: Unique Id for this metric value
     Format is either a Guid or a Guid augmented with an additional int index for cases where
     multiple metric values shared a
       MetricId in the old schema.
    :type metric_id: str
    :param created_utc: Client specified timestamp for this metric value.
    :type created_utc: ~datetime.datetime
    :param step:
    :type step: long
    :param data: Dictionary mapping column names (specified as the keys in MetricV2Dto.Columns) to
     values expressed in type associated
     with that column in the metric's schema.
    :type data: dict[str, object]
    """

    _attribute_map = {
        'metric_id': {'key': 'metricId', 'type': 'str'},
        'created_utc': {'key': 'createdUtc', 'type': 'iso-8601'},
        'step': {'key': 'step', 'type': 'long'},
        'data': {'key': 'data', 'type': '{object}'},
    }

    def __init__(
        self,
        *,
        metric_id: Optional[str] = None,
        created_utc: Optional[datetime.datetime] = None,
        step: Optional[int] = None,
        data: Optional[Dict[str, object]] = None,
        **kwargs
    ):
        super(MetricV2Value, self).__init__(**kwargs)
        self.metric_id = metric_id
        self.created_utc = created_utc
        self.step = step
        self.data = data


class ModifyExperiment(msrest.serialization.Model):
    """ModifyExperiment.

    :param name:
    :type name: str
    :param description:
    :type description: str
    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    :param archive:
    :type archive: bool
    :param retain_for_lifetime_of_workspace:
    :type retain_for_lifetime_of_workspace: bool
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'archive': {'key': 'archive', 'type': 'bool'},
        'retain_for_lifetime_of_workspace': {'key': 'retainForLifetimeOfWorkspace', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        archive: Optional[bool] = None,
        retain_for_lifetime_of_workspace: Optional[bool] = None,
        **kwargs
    ):
        super(ModifyExperiment, self).__init__(**kwargs)
        self.name = name
        self.description = description
        self.tags = tags
        self.archive = archive
        self.retain_for_lifetime_of_workspace = retain_for_lifetime_of_workspace


class OutputDatasetLineage(msrest.serialization.Model):
    """OutputDatasetLineage.

    :param identifier:
    :type identifier: ~azure.mgmt.machinelearningservices.models.DatasetIdentifier
    :param output_type:  Possible values include: "RunOutput", "Reference".
    :type output_type: str or ~azure.mgmt.machinelearningservices.models.DatasetOutputType
    :param output_details:
    :type output_details: ~azure.mgmt.machinelearningservices.models.DatasetOutputDetails
    """

    _attribute_map = {
        'identifier': {'key': 'identifier', 'type': 'DatasetIdentifier'},
        'output_type': {'key': 'outputType', 'type': 'str'},
        'output_details': {'key': 'outputDetails', 'type': 'DatasetOutputDetails'},
    }

    def __init__(
        self,
        *,
        identifier: Optional["DatasetIdentifier"] = None,
        output_type: Optional[Union[str, "DatasetOutputType"]] = None,
        output_details: Optional["DatasetOutputDetails"] = None,
        **kwargs
    ):
        super(OutputDatasetLineage, self).__init__(**kwargs)
        self.identifier = identifier
        self.output_type = output_type
        self.output_details = output_details


class PaginatedArtifactContentInformationList(msrest.serialization.Model):
    """A paginated list of ArtifactContentInformations.

    :param value: An array of objects of type ArtifactContentInformation.
    :type value: list[~azure.mgmt.machinelearningservices.models.ArtifactContentInformation]
    :param continuation_token: The token used in retrieving the next page. If null, there are no
     additional pages.
    :type continuation_token: str
    :param next_link: The link to the next page constructed using the continuationToken.  If null,
     there are no additional pages.
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[ArtifactContentInformation]'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["ArtifactContentInformation"]] = None,
        continuation_token: Optional[str] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(PaginatedArtifactContentInformationList, self).__init__(**kwargs)
        self.value = value
        self.continuation_token = continuation_token
        self.next_link = next_link


class PaginatedArtifactList(msrest.serialization.Model):
    """A paginated list of Artifacts.

    :param value: An array of objects of type Artifact.
    :type value: list[~azure.mgmt.machinelearningservices.models.Artifact]
    :param continuation_token: The token used in retrieving the next page. If null, there are no
     additional pages.
    :type continuation_token: str
    :param next_link: The link to the next page constructed using the continuationToken.  If null,
     there are no additional pages.
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[Artifact]'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["Artifact"]] = None,
        continuation_token: Optional[str] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(PaginatedArtifactList, self).__init__(**kwargs)
        self.value = value
        self.continuation_token = continuation_token
        self.next_link = next_link


class PaginatedExperimentList(msrest.serialization.Model):
    """A paginated list of Experiments.

    :param value: An array of objects of type Experiment.
    :type value: list[~azure.mgmt.machinelearningservices.models.Experiment]
    :param continuation_token: The token used in retrieving the next page. If null, there are no
     additional pages.
    :type continuation_token: str
    :param next_link: The link to the next page constructed using the continuationToken.  If null,
     there are no additional pages.
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[Experiment]'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["Experiment"]] = None,
        continuation_token: Optional[str] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(PaginatedExperimentList, self).__init__(**kwargs)
        self.value = value
        self.continuation_token = continuation_token
        self.next_link = next_link


class PaginatedMetricDefinitionList(msrest.serialization.Model):
    """A paginated list of MetricDefinitions.

    :param value: An array of objects of type MetricDefinition.
    :type value: list[~azure.mgmt.machinelearningservices.models.MetricDefinition]
    :param continuation_token: The token used in retrieving the next page. If null, there are no
     additional pages.
    :type continuation_token: str
    :param next_link: The link to the next page constructed using the continuationToken.  If null,
     there are no additional pages.
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[MetricDefinition]'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["MetricDefinition"]] = None,
        continuation_token: Optional[str] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(PaginatedMetricDefinitionList, self).__init__(**kwargs)
        self.value = value
        self.continuation_token = continuation_token
        self.next_link = next_link


class PaginatedRunList(msrest.serialization.Model):
    """A paginated list of Runs.

    :param value: An array of objects of type Run.
    :type value: list[~azure.mgmt.machinelearningservices.models.Run]
    :param continuation_token: The token used in retrieving the next page. If null, there are no
     additional pages.
    :type continuation_token: str
    :param next_link: The link to the next page constructed using the continuationToken.  If null,
     there are no additional pages.
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[Run]'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["Run"]] = None,
        continuation_token: Optional[str] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(PaginatedRunList, self).__init__(**kwargs)
        self.value = value
        self.continuation_token = continuation_token
        self.next_link = next_link


class PaginatedSpanDefinition1List(msrest.serialization.Model):
    """A paginated list of SpanDefinition`1s.

    :param value: An array of objects of type SpanDefinition`1.
    :type value: list[~azure.mgmt.machinelearningservices.models.SpanDefinition1]
    :param continuation_token: The token used in retrieving the next page. If null, there are no
     additional pages.
    :type continuation_token: str
    :param next_link: The link to the next page constructed using the continuationToken.  If null,
     there are no additional pages.
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[SpanDefinition1]'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["SpanDefinition1"]] = None,
        continuation_token: Optional[str] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(PaginatedSpanDefinition1List, self).__init__(**kwargs)
        self.value = value
        self.continuation_token = continuation_token
        self.next_link = next_link


class PostRunMetricsError(msrest.serialization.Model):
    """PostRunMetricsError.

    :param metric: Sequence of one or many values sharing a common  DataContainerId, Name, and
     Schema. Used only for Post Metrics.
    :type metric: ~azure.mgmt.machinelearningservices.models.IMetricV2
    :param error_response: The error response.
    :type error_response: ~azure.mgmt.machinelearningservices.models.ErrorResponse
    """

    _attribute_map = {
        'metric': {'key': 'metric', 'type': 'IMetricV2'},
        'error_response': {'key': 'errorResponse', 'type': 'ErrorResponse'},
    }

    def __init__(
        self,
        *,
        metric: Optional["IMetricV2"] = None,
        error_response: Optional["ErrorResponse"] = None,
        **kwargs
    ):
        super(PostRunMetricsError, self).__init__(**kwargs)
        self.metric = metric
        self.error_response = error_response


class PostRunMetricsResult(msrest.serialization.Model):
    """PostRunMetricsResult.

    :param errors:
    :type errors: list[~azure.mgmt.machinelearningservices.models.PostRunMetricsError]
    """

    _attribute_map = {
        'errors': {'key': 'errors', 'type': '[PostRunMetricsError]'},
    }

    def __init__(
        self,
        *,
        errors: Optional[List["PostRunMetricsError"]] = None,
        **kwargs
    ):
        super(PostRunMetricsResult, self).__init__(**kwargs)
        self.errors = errors


class QueryParams(msrest.serialization.Model):
    """The set of supported filters.

    :param filter: Allows for filtering the collection of resources.
     The expression specified is evaluated for each resource in the collection, and only items
     where the expression evaluates to true are included in the response.
     See https://docs.microsoft.com/en-us/azure/search/query-odata-filter-orderby-syntax for
     details on the expression syntax.
    :type filter: str
    :param continuation_token: The continuation token to use for getting the next set of resources.
    :type continuation_token: str
    :param order_by: The comma separated list of resource properties to use for sorting the
     requested resources.
     Optionally, can be followed by either 'asc' or 'desc'.
    :type order_by: str
    :param top: The maximum number of items in the resource collection to be included in the
     result.
     If not specified, all items are returned.
    :type top: int
    """

    _attribute_map = {
        'filter': {'key': 'filter', 'type': 'str'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
        'order_by': {'key': 'orderBy', 'type': 'str'},
        'top': {'key': 'top', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        filter: Optional[str] = None,
        continuation_token: Optional[str] = None,
        order_by: Optional[str] = None,
        top: Optional[int] = None,
        **kwargs
    ):
        super(QueryParams, self).__init__(**kwargs)
        self.filter = filter
        self.continuation_token = continuation_token
        self.order_by = order_by
        self.top = top


class QueueingInfo(msrest.serialization.Model):
    """QueueingInfo.

    :param code:
    :type code: str
    :param message:
    :type message: str
    :param last_refresh_timestamp:
    :type last_refresh_timestamp: ~datetime.datetime
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'last_refresh_timestamp': {'key': 'lastRefreshTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        code: Optional[str] = None,
        message: Optional[str] = None,
        last_refresh_timestamp: Optional[datetime.datetime] = None,
        **kwargs
    ):
        super(QueueingInfo, self).__init__(**kwargs)
        self.code = code
        self.message = message
        self.last_refresh_timestamp = last_refresh_timestamp


class RetrieveFullFidelityMetricRequest(msrest.serialization.Model):
    """RetrieveFullFidelityMetricRequest.

    :param metric_name:
    :type metric_name: str
    :param continuation_token:
    :type continuation_token: str
    :param start_time:
    :type start_time: ~datetime.datetime
    :param end_time:
    :type end_time: ~datetime.datetime
    :param metric_namespace:
    :type metric_namespace: str
    """

    _attribute_map = {
        'metric_name': {'key': 'metricName', 'type': 'str'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
        'start_time': {'key': 'startTime', 'type': 'iso-8601'},
        'end_time': {'key': 'endTime', 'type': 'iso-8601'},
        'metric_namespace': {'key': 'metricNamespace', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        metric_name: Optional[str] = None,
        continuation_token: Optional[str] = None,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        metric_namespace: Optional[str] = None,
        **kwargs
    ):
        super(RetrieveFullFidelityMetricRequest, self).__init__(**kwargs)
        self.metric_name = metric_name
        self.continuation_token = continuation_token
        self.start_time = start_time
        self.end_time = end_time
        self.metric_namespace = metric_namespace


class RootError(msrest.serialization.Model):
    """The root error.

    :param code: The service-defined error code. Supported error codes: ServiceError, UserError,
     ValidationError, AzureStorageError, TransientError, RequestThrottled.
    :type code: str
    :param severity: The Severity of error.
    :type severity: int
    :param message: A human-readable representation of the error.
    :type message: str
    :param message_format: An unformatted version of the message with no variable substitution.
    :type message_format: str
    :param message_parameters: Value substitutions corresponding to the contents of MessageFormat.
    :type message_parameters: dict[str, str]
    :param reference_code: This code can optionally be set by the system generating the error.
     It should be used to classify the problem and identify the module and code area where the
     failure occured.
    :type reference_code: str
    :param details_uri: A URI which points to more details about the context of the error.
    :type details_uri: str
    :param target: The target of the error (e.g., the name of the property in error).
    :type target: str
    :param details: The related errors that occurred during the request.
    :type details: list[~azure.mgmt.machinelearningservices.models.RootError]
    :param inner_error: A nested structure of errors.
    :type inner_error: ~azure.mgmt.machinelearningservices.models.InnerErrorResponse
    :param additional_info: The error additional info.
    :type additional_info: list[~azure.mgmt.machinelearningservices.models.ErrorAdditionalInfo]
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'severity': {'key': 'severity', 'type': 'int'},
        'message': {'key': 'message', 'type': 'str'},
        'message_format': {'key': 'messageFormat', 'type': 'str'},
        'message_parameters': {'key': 'messageParameters', 'type': '{str}'},
        'reference_code': {'key': 'referenceCode', 'type': 'str'},
        'details_uri': {'key': 'detailsUri', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'details': {'key': 'details', 'type': '[RootError]'},
        'inner_error': {'key': 'innerError', 'type': 'InnerErrorResponse'},
        'additional_info': {'key': 'additionalInfo', 'type': '[ErrorAdditionalInfo]'},
    }

    def __init__(
        self,
        *,
        code: Optional[str] = None,
        severity: Optional[int] = None,
        message: Optional[str] = None,
        message_format: Optional[str] = None,
        message_parameters: Optional[Dict[str, str]] = None,
        reference_code: Optional[str] = None,
        details_uri: Optional[str] = None,
        target: Optional[str] = None,
        details: Optional[List["RootError"]] = None,
        inner_error: Optional["InnerErrorResponse"] = None,
        additional_info: Optional[List["ErrorAdditionalInfo"]] = None,
        **kwargs
    ):
        super(RootError, self).__init__(**kwargs)
        self.code = code
        self.severity = severity
        self.message = message
        self.message_format = message_format
        self.message_parameters = message_parameters
        self.reference_code = reference_code
        self.details_uri = details_uri
        self.target = target
        self.details = details
        self.inner_error = inner_error
        self.additional_info = additional_info


class Run(msrest.serialization.Model):
    """The definition of a Run.

    :param run_number:
    :type run_number: int
    :param root_run_id:
    :type root_run_id: str
    :param created_utc: The time the run was created in UTC.
    :type created_utc: ~datetime.datetime
    :param created_by:
    :type created_by: ~azure.mgmt.machinelearningservices.models.User
    :param user_id: The Id of the user that created the run.
    :type user_id: str
    :param token: A token used for authenticating a run.
    :type token: str
    :param token_expiry_time_utc: The Token expiration time in UTC.
    :type token_expiry_time_utc: ~datetime.datetime
    :param error: The error response.
    :type error: ~azure.mgmt.machinelearningservices.models.ErrorResponse
    :param warnings: A list of warnings that occurred during the run.
    :type warnings: list[~azure.mgmt.machinelearningservices.models.RunDetailsWarning]
    :param revision:
    :type revision: long
    :param status_revision:
    :type status_revision: long
    :param run_uuid: A system generated Id for the run.
    :type run_uuid: str
    :param parent_run_uuid: A system generated Id for the run's parent.
    :type parent_run_uuid: str
    :param root_run_uuid: A system generated Id for the root of the run's hierarchy.
    :type root_run_uuid: str
    :param has_virtual_parent: Indicates if this is a child of a virtual run.
    :type has_virtual_parent: bool
    :param last_start_time_utc: The last timestamp when a run transitioned from paused to running.
     Initialized when StartTimeUtc is first set.
    :type last_start_time_utc: ~datetime.datetime
    :param current_compute_time: The cumulative time spent in an active status for an active run.
    :type current_compute_time: str
    :param compute_duration: The cumulative time spent in an active status for a terminal run.
    :type compute_duration: str
    :param effective_start_time_utc: A relative start time set as LastStartTimeUtc - ComputeTime
     for active runs. This allows sorting active runs on how long they have been active, since an
     actual active duration cannot be frequently updated.
    :type effective_start_time_utc: ~datetime.datetime
    :param last_modified_by:
    :type last_modified_by: ~azure.mgmt.machinelearningservices.models.User
    :param last_modified_utc: The time the run was created in UTC.
    :type last_modified_utc: ~datetime.datetime
    :param duration: The total duration of a run.
    :type duration: str
    :param cancelation_reason: The cancelation Reason if the run was canceled.
    :type cancelation_reason: str
    :param run_id: The identifier for the run. Run IDs must be less than 256 characters and contain
     only alphanumeric characters with dashes and underscores.
    :type run_id: str
    :param parent_run_id: The parent of the run if the run is hierarchical; otherwise, Null.
    :type parent_run_id: str
    :param experiment_id: The Id of the experiment that created this run.
    :type experiment_id: str
    :param status: The status of the run. The Status string value maps to the RunStatus Enum.
    :type status: str
    :param start_time_utc: The start time of the run in UTC.
    :type start_time_utc: ~datetime.datetime
    :param end_time_utc: The end time of the run in UTC.
    :type end_time_utc: ~datetime.datetime
    :param options:
    :type options: ~azure.mgmt.machinelearningservices.models.RunOptions
    :param is_virtual: A virtual run can set an active child run that will override the virtual run
     status and properties.
    :type is_virtual: bool
    :param display_name:
    :type display_name: str
    :param name:
    :type name: str
    :param data_container_id:
    :type data_container_id: str
    :param description:
    :type description: str
    :param hidden:
    :type hidden: bool
    :param run_type:
    :type run_type: str
    :param run_type_v2:
    :type run_type_v2: ~azure.mgmt.machinelearningservices.models.RunTypeV2
    :param properties: Dictionary of :code:`<string>`.
    :type properties: dict[str, str]
    :param parameters: Dictionary of :code:`<any>`.
    :type parameters: dict[str, object]
    :param action_uris: Dictionary of :code:`<string>`.
    :type action_uris: dict[str, str]
    :param script_name:
    :type script_name: str
    :param target:
    :type target: str
    :param unique_child_run_compute_targets:
    :type unique_child_run_compute_targets: list[str]
    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    :param settings: Dictionary of :code:`<string>`.
    :type settings: dict[str, str]
    :param services: Dictionary of :code:`<EndpointSetting>`.
    :type services: dict[str, ~azure.mgmt.machinelearningservices.models.EndpointSetting]
    :param input_datasets:
    :type input_datasets: list[~azure.mgmt.machinelearningservices.models.DatasetLineage]
    :param output_datasets:
    :type output_datasets: list[~azure.mgmt.machinelearningservices.models.OutputDatasetLineage]
    :param run_definition: Any object.
    :type run_definition: object
    :param job_specification: Any object.
    :type job_specification: object
    :param primary_metric_name:
    :type primary_metric_name: str
    :param created_from:
    :type created_from: ~azure.mgmt.machinelearningservices.models.CreatedFrom
    :param cancel_uri:
    :type cancel_uri: str
    :param complete_uri:
    :type complete_uri: str
    :param diagnostics_uri:
    :type diagnostics_uri: str
    :param compute_request:
    :type compute_request: ~azure.mgmt.machinelearningservices.models.ComputeRequest
    :param compute:
    :type compute: ~azure.mgmt.machinelearningservices.models.Compute
    :param retain_for_lifetime_of_workspace:
    :type retain_for_lifetime_of_workspace: bool
    :param queueing_info:
    :type queueing_info: ~azure.mgmt.machinelearningservices.models.QueueingInfo
    :param active_child_run_id: The RunId of the active child on a virtual run.
    :type active_child_run_id: str
    """

    _validation = {
        'unique_child_run_compute_targets': {'unique': True},
        'input_datasets': {'unique': True},
        'output_datasets': {'unique': True},
    }

    _attribute_map = {
        'run_number': {'key': 'runNumber', 'type': 'int'},
        'root_run_id': {'key': 'rootRunId', 'type': 'str'},
        'created_utc': {'key': 'createdUtc', 'type': 'iso-8601'},
        'created_by': {'key': 'createdBy', 'type': 'User'},
        'user_id': {'key': 'userId', 'type': 'str'},
        'token': {'key': 'token', 'type': 'str'},
        'token_expiry_time_utc': {'key': 'tokenExpiryTimeUtc', 'type': 'iso-8601'},
        'error': {'key': 'error', 'type': 'ErrorResponse'},
        'warnings': {'key': 'warnings', 'type': '[RunDetailsWarning]'},
        'revision': {'key': 'revision', 'type': 'long'},
        'status_revision': {'key': 'statusRevision', 'type': 'long'},
        'run_uuid': {'key': 'runUuid', 'type': 'str'},
        'parent_run_uuid': {'key': 'parentRunUuid', 'type': 'str'},
        'root_run_uuid': {'key': 'rootRunUuid', 'type': 'str'},
        'has_virtual_parent': {'key': 'hasVirtualParent', 'type': 'bool'},
        'last_start_time_utc': {'key': 'lastStartTimeUtc', 'type': 'iso-8601'},
        'current_compute_time': {'key': 'currentComputeTime', 'type': 'str'},
        'compute_duration': {'key': 'computeDuration', 'type': 'str'},
        'effective_start_time_utc': {'key': 'effectiveStartTimeUtc', 'type': 'iso-8601'},
        'last_modified_by': {'key': 'lastModifiedBy', 'type': 'User'},
        'last_modified_utc': {'key': 'lastModifiedUtc', 'type': 'iso-8601'},
        'duration': {'key': 'duration', 'type': 'str'},
        'cancelation_reason': {'key': 'cancelationReason', 'type': 'str'},
        'run_id': {'key': 'runId', 'type': 'str'},
        'parent_run_id': {'key': 'parentRunId', 'type': 'str'},
        'experiment_id': {'key': 'experimentId', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'start_time_utc': {'key': 'startTimeUtc', 'type': 'iso-8601'},
        'end_time_utc': {'key': 'endTimeUtc', 'type': 'iso-8601'},
        'options': {'key': 'options', 'type': 'RunOptions'},
        'is_virtual': {'key': 'isVirtual', 'type': 'bool'},
        'display_name': {'key': 'displayName', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'data_container_id': {'key': 'dataContainerId', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'hidden': {'key': 'hidden', 'type': 'bool'},
        'run_type': {'key': 'runType', 'type': 'str'},
        'run_type_v2': {'key': 'runTypeV2', 'type': 'RunTypeV2'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'parameters': {'key': 'parameters', 'type': '{object}'},
        'action_uris': {'key': 'actionUris', 'type': '{str}'},
        'script_name': {'key': 'scriptName', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'unique_child_run_compute_targets': {'key': 'uniqueChildRunComputeTargets', 'type': '[str]'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'settings': {'key': 'settings', 'type': '{str}'},
        'services': {'key': 'services', 'type': '{EndpointSetting}'},
        'input_datasets': {'key': 'inputDatasets', 'type': '[DatasetLineage]'},
        'output_datasets': {'key': 'outputDatasets', 'type': '[OutputDatasetLineage]'},
        'run_definition': {'key': 'runDefinition', 'type': 'object'},
        'job_specification': {'key': 'jobSpecification', 'type': 'object'},
        'primary_metric_name': {'key': 'primaryMetricName', 'type': 'str'},
        'created_from': {'key': 'createdFrom', 'type': 'CreatedFrom'},
        'cancel_uri': {'key': 'cancelUri', 'type': 'str'},
        'complete_uri': {'key': 'completeUri', 'type': 'str'},
        'diagnostics_uri': {'key': 'diagnosticsUri', 'type': 'str'},
        'compute_request': {'key': 'computeRequest', 'type': 'ComputeRequest'},
        'compute': {'key': 'compute', 'type': 'Compute'},
        'retain_for_lifetime_of_workspace': {'key': 'retainForLifetimeOfWorkspace', 'type': 'bool'},
        'queueing_info': {'key': 'queueingInfo', 'type': 'QueueingInfo'},
        'active_child_run_id': {'key': 'activeChildRunId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        run_number: Optional[int] = None,
        root_run_id: Optional[str] = None,
        created_utc: Optional[datetime.datetime] = None,
        created_by: Optional["User"] = None,
        user_id: Optional[str] = None,
        token: Optional[str] = None,
        token_expiry_time_utc: Optional[datetime.datetime] = None,
        error: Optional["ErrorResponse"] = None,
        warnings: Optional[List["RunDetailsWarning"]] = None,
        revision: Optional[int] = None,
        status_revision: Optional[int] = None,
        run_uuid: Optional[str] = None,
        parent_run_uuid: Optional[str] = None,
        root_run_uuid: Optional[str] = None,
        has_virtual_parent: Optional[bool] = None,
        last_start_time_utc: Optional[datetime.datetime] = None,
        current_compute_time: Optional[str] = None,
        compute_duration: Optional[str] = None,
        effective_start_time_utc: Optional[datetime.datetime] = None,
        last_modified_by: Optional["User"] = None,
        last_modified_utc: Optional[datetime.datetime] = None,
        duration: Optional[str] = None,
        cancelation_reason: Optional[str] = None,
        run_id: Optional[str] = None,
        parent_run_id: Optional[str] = None,
        experiment_id: Optional[str] = None,
        status: Optional[str] = None,
        start_time_utc: Optional[datetime.datetime] = None,
        end_time_utc: Optional[datetime.datetime] = None,
        options: Optional["RunOptions"] = None,
        is_virtual: Optional[bool] = None,
        display_name: Optional[str] = None,
        name: Optional[str] = None,
        data_container_id: Optional[str] = None,
        description: Optional[str] = None,
        hidden: Optional[bool] = None,
        run_type: Optional[str] = None,
        run_type_v2: Optional["RunTypeV2"] = None,
        properties: Optional[Dict[str, str]] = None,
        parameters: Optional[Dict[str, object]] = None,
        action_uris: Optional[Dict[str, str]] = None,
        script_name: Optional[str] = None,
        target: Optional[str] = None,
        unique_child_run_compute_targets: Optional[List[str]] = None,
        tags: Optional[Dict[str, str]] = None,
        settings: Optional[Dict[str, str]] = None,
        services: Optional[Dict[str, "EndpointSetting"]] = None,
        input_datasets: Optional[List["DatasetLineage"]] = None,
        output_datasets: Optional[List["OutputDatasetLineage"]] = None,
        run_definition: Optional[object] = None,
        job_specification: Optional[object] = None,
        primary_metric_name: Optional[str] = None,
        created_from: Optional["CreatedFrom"] = None,
        cancel_uri: Optional[str] = None,
        complete_uri: Optional[str] = None,
        diagnostics_uri: Optional[str] = None,
        compute_request: Optional["ComputeRequest"] = None,
        compute: Optional["Compute"] = None,
        retain_for_lifetime_of_workspace: Optional[bool] = None,
        queueing_info: Optional["QueueingInfo"] = None,
        active_child_run_id: Optional[str] = None,
        **kwargs
    ):
        super(Run, self).__init__(**kwargs)
        self.run_number = run_number
        self.root_run_id = root_run_id
        self.created_utc = created_utc
        self.created_by = created_by
        self.user_id = user_id
        self.token = token
        self.token_expiry_time_utc = token_expiry_time_utc
        self.error = error
        self.warnings = warnings
        self.revision = revision
        self.status_revision = status_revision
        self.run_uuid = run_uuid
        self.parent_run_uuid = parent_run_uuid
        self.root_run_uuid = root_run_uuid
        self.has_virtual_parent = has_virtual_parent
        self.last_start_time_utc = last_start_time_utc
        self.current_compute_time = current_compute_time
        self.compute_duration = compute_duration
        self.effective_start_time_utc = effective_start_time_utc
        self.last_modified_by = last_modified_by
        self.last_modified_utc = last_modified_utc
        self.duration = duration
        self.cancelation_reason = cancelation_reason
        self.run_id = run_id
        self.parent_run_id = parent_run_id
        self.experiment_id = experiment_id
        self.status = status
        self.start_time_utc = start_time_utc
        self.end_time_utc = end_time_utc
        self.options = options
        self.is_virtual = is_virtual
        self.display_name = display_name
        self.name = name
        self.data_container_id = data_container_id
        self.description = description
        self.hidden = hidden
        self.run_type = run_type
        self.run_type_v2 = run_type_v2
        self.properties = properties
        self.parameters = parameters
        self.action_uris = action_uris
        self.script_name = script_name
        self.target = target
        self.unique_child_run_compute_targets = unique_child_run_compute_targets
        self.tags = tags
        self.settings = settings
        self.services = services
        self.input_datasets = input_datasets
        self.output_datasets = output_datasets
        self.run_definition = run_definition
        self.job_specification = job_specification
        self.primary_metric_name = primary_metric_name
        self.created_from = created_from
        self.cancel_uri = cancel_uri
        self.complete_uri = complete_uri
        self.diagnostics_uri = diagnostics_uri
        self.compute_request = compute_request
        self.compute = compute
        self.retain_for_lifetime_of_workspace = retain_for_lifetime_of_workspace
        self.queueing_info = queueing_info
        self.active_child_run_id = active_child_run_id


class RunDetails(msrest.serialization.Model):
    """The details of the run.

    :param run_id: The identifier for the run.
    :type run_id: str
    :param run_uuid: A system generated Id for the run.
    :type run_uuid: str
    :param parent_run_uuid: A system generated Id for the run's parent.
    :type parent_run_uuid: str
    :param root_run_uuid: A system generated Id for the root of the run's hierarchy.
    :type root_run_uuid: str
    :param target: The name of the compute target where the run is executed.
    :type target: str
    :param status: The status of the run. The Status string value maps to the RunStatus Enum.
    :type status: str
    :param parent_run_id: The parent of the run if the run is hierarchical.
    :type parent_run_id: str
    :param created_time_utc: The creation time of the run in UTC.
    :type created_time_utc: ~datetime.datetime
    :param start_time_utc: The start time of the run in UTC.
    :type start_time_utc: ~datetime.datetime
    :param end_time_utc: The end time of the run in UTC.
    :type end_time_utc: ~datetime.datetime
    :param error: The error response.
    :type error: ~azure.mgmt.machinelearningservices.models.ErrorResponse
    :param warnings: A list of warnings that occurred during the run.
    :type warnings: list[~azure.mgmt.machinelearningservices.models.RunDetailsWarning]
    :param tags: A set of tags. The tag dictionary for the run. Tags are mutable.
    :type tags: dict[str, str]
    :param properties: The properties dictionary for the run. Properties are immutable.
    :type properties: dict[str, str]
    :param parameters: The parameters dictionary for the run. Parameters are immutable.
    :type parameters: dict[str, object]
    :param services: The interactive run services for a run. Services are mutable.
    :type services: dict[str, ~azure.mgmt.machinelearningservices.models.EndpointSetting]
    :param input_datasets: A list of dataset used as input to the run.
    :type input_datasets: list[~azure.mgmt.machinelearningservices.models.DatasetLineage]
    :param output_datasets: A list of dataset used as output to the run.
    :type output_datasets: list[~azure.mgmt.machinelearningservices.models.OutputDatasetLineage]
    :param run_definition: The run definition specification.
    :type run_definition: object
    :param log_files: Dictionary of :code:`<string>`.
    :type log_files: dict[str, str]
    :param job_cost:
    :type job_cost: ~azure.mgmt.machinelearningservices.models.JobCost
    :param revision:
    :type revision: long
    :param run_type_v2:
    :type run_type_v2: ~azure.mgmt.machinelearningservices.models.RunTypeV2
    :param settings: The run settings.
    :type settings: dict[str, str]
    :param compute_request:
    :type compute_request: ~azure.mgmt.machinelearningservices.models.ComputeRequest
    :param compute:
    :type compute: ~azure.mgmt.machinelearningservices.models.Compute
    :param created_by:
    :type created_by: ~azure.mgmt.machinelearningservices.models.User
    :param compute_duration: Time spent in an active state for terminal runs.
    :type compute_duration: str
    :param effective_start_time_utc: Relative start time of active runs for ordering and computing
     active compute duration.
     Compute duration of an active run is now() - EffectiveStartTimeUtc.
    :type effective_start_time_utc: ~datetime.datetime
    :param run_number: Relative start time of active runs for ordering and computing active compute
     duration.
     Compute duration of an active run is now() - EffectiveStartTimeUtc.
    :type run_number: int
    :param root_run_id:
    :type root_run_id: str
    :param user_id: The Id of the user that created the run.
    :type user_id: str
    :param status_revision:
    :type status_revision: long
    :param has_virtual_parent: Indicates if this is a child of a virtual run.
    :type has_virtual_parent: bool
    :param current_compute_time: The cumulative time spent in an active status for an active run.
    :type current_compute_time: str
    :param last_start_time_utc: The last timestamp when a run transitioned from paused to running.
     Initialized when StartTimeUtc is first set.
    :type last_start_time_utc: ~datetime.datetime
    :param last_modified_by:
    :type last_modified_by: ~azure.mgmt.machinelearningservices.models.User
    :param last_modified_utc: The time the run was created in UTC.
    :type last_modified_utc: ~datetime.datetime
    :param duration: The total duration of a run.
    :type duration: str
    """

    _validation = {
        'input_datasets': {'unique': True},
        'output_datasets': {'unique': True},
    }

    _attribute_map = {
        'run_id': {'key': 'runId', 'type': 'str'},
        'run_uuid': {'key': 'runUuid', 'type': 'str'},
        'parent_run_uuid': {'key': 'parentRunUuid', 'type': 'str'},
        'root_run_uuid': {'key': 'rootRunUuid', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'parent_run_id': {'key': 'parentRunId', 'type': 'str'},
        'created_time_utc': {'key': 'createdTimeUtc', 'type': 'iso-8601'},
        'start_time_utc': {'key': 'startTimeUtc', 'type': 'iso-8601'},
        'end_time_utc': {'key': 'endTimeUtc', 'type': 'iso-8601'},
        'error': {'key': 'error', 'type': 'ErrorResponse'},
        'warnings': {'key': 'warnings', 'type': '[RunDetailsWarning]'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'parameters': {'key': 'parameters', 'type': '{object}'},
        'services': {'key': 'services', 'type': '{EndpointSetting}'},
        'input_datasets': {'key': 'inputDatasets', 'type': '[DatasetLineage]'},
        'output_datasets': {'key': 'outputDatasets', 'type': '[OutputDatasetLineage]'},
        'run_definition': {'key': 'runDefinition', 'type': 'object'},
        'log_files': {'key': 'logFiles', 'type': '{str}'},
        'job_cost': {'key': 'jobCost', 'type': 'JobCost'},
        'revision': {'key': 'revision', 'type': 'long'},
        'run_type_v2': {'key': 'runTypeV2', 'type': 'RunTypeV2'},
        'settings': {'key': 'settings', 'type': '{str}'},
        'compute_request': {'key': 'computeRequest', 'type': 'ComputeRequest'},
        'compute': {'key': 'compute', 'type': 'Compute'},
        'created_by': {'key': 'createdBy', 'type': 'User'},
        'compute_duration': {'key': 'computeDuration', 'type': 'str'},
        'effective_start_time_utc': {'key': 'effectiveStartTimeUtc', 'type': 'iso-8601'},
        'run_number': {'key': 'runNumber', 'type': 'int'},
        'root_run_id': {'key': 'rootRunId', 'type': 'str'},
        'user_id': {'key': 'userId', 'type': 'str'},
        'status_revision': {'key': 'statusRevision', 'type': 'long'},
        'has_virtual_parent': {'key': 'hasVirtualParent', 'type': 'bool'},
        'current_compute_time': {'key': 'currentComputeTime', 'type': 'str'},
        'last_start_time_utc': {'key': 'lastStartTimeUtc', 'type': 'iso-8601'},
        'last_modified_by': {'key': 'lastModifiedBy', 'type': 'User'},
        'last_modified_utc': {'key': 'lastModifiedUtc', 'type': 'iso-8601'},
        'duration': {'key': 'duration', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        run_id: Optional[str] = None,
        run_uuid: Optional[str] = None,
        parent_run_uuid: Optional[str] = None,
        root_run_uuid: Optional[str] = None,
        target: Optional[str] = None,
        status: Optional[str] = None,
        parent_run_id: Optional[str] = None,
        created_time_utc: Optional[datetime.datetime] = None,
        start_time_utc: Optional[datetime.datetime] = None,
        end_time_utc: Optional[datetime.datetime] = None,
        error: Optional["ErrorResponse"] = None,
        warnings: Optional[List["RunDetailsWarning"]] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        parameters: Optional[Dict[str, object]] = None,
        services: Optional[Dict[str, "EndpointSetting"]] = None,
        input_datasets: Optional[List["DatasetLineage"]] = None,
        output_datasets: Optional[List["OutputDatasetLineage"]] = None,
        run_definition: Optional[object] = None,
        log_files: Optional[Dict[str, str]] = None,
        job_cost: Optional["JobCost"] = None,
        revision: Optional[int] = None,
        run_type_v2: Optional["RunTypeV2"] = None,
        settings: Optional[Dict[str, str]] = None,
        compute_request: Optional["ComputeRequest"] = None,
        compute: Optional["Compute"] = None,
        created_by: Optional["User"] = None,
        compute_duration: Optional[str] = None,
        effective_start_time_utc: Optional[datetime.datetime] = None,
        run_number: Optional[int] = None,
        root_run_id: Optional[str] = None,
        user_id: Optional[str] = None,
        status_revision: Optional[int] = None,
        has_virtual_parent: Optional[bool] = None,
        current_compute_time: Optional[str] = None,
        last_start_time_utc: Optional[datetime.datetime] = None,
        last_modified_by: Optional["User"] = None,
        last_modified_utc: Optional[datetime.datetime] = None,
        duration: Optional[str] = None,
        **kwargs
    ):
        super(RunDetails, self).__init__(**kwargs)
        self.run_id = run_id
        self.run_uuid = run_uuid
        self.parent_run_uuid = parent_run_uuid
        self.root_run_uuid = root_run_uuid
        self.target = target
        self.status = status
        self.parent_run_id = parent_run_id
        self.created_time_utc = created_time_utc
        self.start_time_utc = start_time_utc
        self.end_time_utc = end_time_utc
        self.error = error
        self.warnings = warnings
        self.tags = tags
        self.properties = properties
        self.parameters = parameters
        self.services = services
        self.input_datasets = input_datasets
        self.output_datasets = output_datasets
        self.run_definition = run_definition
        self.log_files = log_files
        self.job_cost = job_cost
        self.revision = revision
        self.run_type_v2 = run_type_v2
        self.settings = settings
        self.compute_request = compute_request
        self.compute = compute
        self.created_by = created_by
        self.compute_duration = compute_duration
        self.effective_start_time_utc = effective_start_time_utc
        self.run_number = run_number
        self.root_run_id = root_run_id
        self.user_id = user_id
        self.status_revision = status_revision
        self.has_virtual_parent = has_virtual_parent
        self.current_compute_time = current_compute_time
        self.last_start_time_utc = last_start_time_utc
        self.last_modified_by = last_modified_by
        self.last_modified_utc = last_modified_utc
        self.duration = duration


class RunDetailsWarning(msrest.serialization.Model):
    """RunDetailsWarning.

    :param source:
    :type source: str
    :param message:
    :type message: str
    """

    _attribute_map = {
        'source': {'key': 'source', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        source: Optional[str] = None,
        message: Optional[str] = None,
        **kwargs
    ):
        super(RunDetailsWarning, self).__init__(**kwargs)
        self.source = source
        self.message = message


class RunMetric(msrest.serialization.Model):
    """RunMetric.

    :param run_id:
    :type run_id: str
    :param metric_id:
    :type metric_id: str
    :param data_container_id:
    :type data_container_id: str
    :param metric_type:
    :type metric_type: str
    :param created_utc:
    :type created_utc: ~datetime.datetime
    :param name:
    :type name: str
    :param description:
    :type description: str
    :param label:
    :type label: str
    :param num_cells:
    :type num_cells: int
    :param data_location:
    :type data_location: str
    :param cells:
    :type cells: list[dict[str, object]]
    :param schema:
    :type schema: ~azure.mgmt.machinelearningservices.models.MetricSchema
    """

    _attribute_map = {
        'run_id': {'key': 'runId', 'type': 'str'},
        'metric_id': {'key': 'metricId', 'type': 'str'},
        'data_container_id': {'key': 'dataContainerId', 'type': 'str'},
        'metric_type': {'key': 'metricType', 'type': 'str'},
        'created_utc': {'key': 'createdUtc', 'type': 'iso-8601'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'label': {'key': 'label', 'type': 'str'},
        'num_cells': {'key': 'numCells', 'type': 'int'},
        'data_location': {'key': 'dataLocation', 'type': 'str'},
        'cells': {'key': 'cells', 'type': '[{object}]'},
        'schema': {'key': 'schema', 'type': 'MetricSchema'},
    }

    def __init__(
        self,
        *,
        run_id: Optional[str] = None,
        metric_id: Optional[str] = None,
        data_container_id: Optional[str] = None,
        metric_type: Optional[str] = None,
        created_utc: Optional[datetime.datetime] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        label: Optional[str] = None,
        num_cells: Optional[int] = None,
        data_location: Optional[str] = None,
        cells: Optional[List[Dict[str, object]]] = None,
        schema: Optional["MetricSchema"] = None,
        **kwargs
    ):
        super(RunMetric, self).__init__(**kwargs)
        self.run_id = run_id
        self.metric_id = metric_id
        self.data_container_id = data_container_id
        self.metric_type = metric_type
        self.created_utc = created_utc
        self.name = name
        self.description = description
        self.label = label
        self.num_cells = num_cells
        self.data_location = data_location
        self.cells = cells
        self.schema = schema


class RunOptions(msrest.serialization.Model):
    """RunOptions.

    :param generate_data_container_id_if_not_specified:
    :type generate_data_container_id_if_not_specified: bool
    """

    _attribute_map = {
        'generate_data_container_id_if_not_specified': {'key': 'generateDataContainerIdIfNotSpecified', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        generate_data_container_id_if_not_specified: Optional[bool] = None,
        **kwargs
    ):
        super(RunOptions, self).__init__(**kwargs)
        self.generate_data_container_id_if_not_specified = generate_data_container_id_if_not_specified


class RunStatusSpans(msrest.serialization.Model):
    """RunStatusSpans.

    :param spans:
    :type spans: list[~azure.mgmt.machinelearningservices.models.SpanDefinition1]
    """

    _attribute_map = {
        'spans': {'key': 'spans', 'type': '[SpanDefinition1]'},
    }

    def __init__(
        self,
        *,
        spans: Optional[List["SpanDefinition1"]] = None,
        **kwargs
    ):
        super(RunStatusSpans, self).__init__(**kwargs)
        self.spans = spans


class RunTypeV2(msrest.serialization.Model):
    """RunTypeV2.

    :param orchestrator:
    :type orchestrator: str
    :param traits:
    :type traits: list[str]
    :param attribution:
    :type attribution: str
    :param compute_type:
    :type compute_type: str
    """

    _validation = {
        'traits': {'unique': True},
    }

    _attribute_map = {
        'orchestrator': {'key': 'orchestrator', 'type': 'str'},
        'traits': {'key': 'traits', 'type': '[str]'},
        'attribution': {'key': 'attribution', 'type': 'str'},
        'compute_type': {'key': 'computeType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        orchestrator: Optional[str] = None,
        traits: Optional[List[str]] = None,
        attribution: Optional[str] = None,
        compute_type: Optional[str] = None,
        **kwargs
    ):
        super(RunTypeV2, self).__init__(**kwargs)
        self.orchestrator = orchestrator
        self.traits = traits
        self.attribution = attribution
        self.compute_type = compute_type


class SpanContext(msrest.serialization.Model):
    """SpanContext.

    :param trace_id: Gets the TraceId associated with this
     Microsoft.MachineLearning.RunHistory.Contracts.SpanContext.
     TODO: In actual spec, it is ActivityTraceId type. But that causes problems in
     serialization/deserialization.
    :type trace_id: str
    :param span_id: Gets the SpanId associated with this
     Microsoft.MachineLearning.RunHistory.Contracts.SpanContext.
     TODO: In actual spec, it is ActivitySpanId type. But that causes problems in
     serialization/deserialization.
    :type span_id: str
    :param is_remote: Gets a value indicating whether this
     Microsoft.MachineLearning.RunHistory.Contracts.SpanContext
     was propagated from a remote parent.
    :type is_remote: bool
    :param is_valid: Gets a value indicating whether this
     Microsoft.MachineLearning.RunHistory.Contracts.SpanContext is valid.
    :type is_valid: bool
    :param tracestate: Gets the
     Microsoft.MachineLearning.RunHistory.Contracts.SpanContext.Tracestate associated with this
     Microsoft.MachineLearning.RunHistory.Contracts.SpanContext.
    :type tracestate: list[~azure.mgmt.machinelearningservices.models.KeyValuePairString]
    """

    _attribute_map = {
        'trace_id': {'key': 'traceId', 'type': 'str'},
        'span_id': {'key': 'spanId', 'type': 'str'},
        'is_remote': {'key': 'isRemote', 'type': 'bool'},
        'is_valid': {'key': 'isValid', 'type': 'bool'},
        'tracestate': {'key': 'tracestate', 'type': '[KeyValuePairString]'},
    }

    def __init__(
        self,
        *,
        trace_id: Optional[str] = None,
        span_id: Optional[str] = None,
        is_remote: Optional[bool] = None,
        is_valid: Optional[bool] = None,
        tracestate: Optional[List["KeyValuePairString"]] = None,
        **kwargs
    ):
        super(SpanContext, self).__init__(**kwargs)
        self.trace_id = trace_id
        self.span_id = span_id
        self.is_remote = is_remote
        self.is_valid = is_valid
        self.tracestate = tracestate


class SpanDefinition1(msrest.serialization.Model):
    """Most of the code in this class is vendored from here.
https://github.com/open-telemetry/opentelemetry-dotnet/blob/master/src/OpenTelemetry/Trace/Export/SpanData.cs
SpanData on that github link is readonly, we can't set properties on it after creation. So, just vendoring the Span
contract.
TStatus is the status enum. For runs, it is RunStatus
This is the link for span spec https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md#span.

    :param context:
    :type context: ~azure.mgmt.machinelearningservices.models.SpanContext
    :param name: Gets span name.
    :type name: str
    :param status: Gets span status.
     OpenTelemetry sets it to https://github.com/open-telemetry/opentelemetry-
     dotnet/blob/master/src/OpenTelemetry.Api/Trace/Status.cs
     That status enums are not very meaningful to us, so we customize this. Possible values
     include: "NotStarted", "Unapproved", "Pausing", "Paused", "Starting", "Preparing", "Queued",
     "Running", "Finalizing", "CancelRequested", "Completed", "Failed", "Canceled".
    :type status: str or ~azure.mgmt.machinelearningservices.models.RunStatus
    :param parent_span_id: Gets parent span id.
     TODO: In actual spec, it is ActivitySpanId type. But that causes problems in
     serialization/deserialization.
    :type parent_span_id: str
    :param attributes: Gets attributes.
    :type attributes: list[~azure.mgmt.machinelearningservices.models.KeyValuePairStringJToken]
    :param events: Gets events.
    :type events: list[~azure.mgmt.machinelearningservices.models.Event]
    :param links: Gets links.
    :type links: list[~azure.mgmt.machinelearningservices.models.Link]
    :param start_timestamp: Gets span start timestamp.
    :type start_timestamp: ~datetime.datetime
    :param end_timestamp: Gets span end timestamp.
    :type end_timestamp: ~datetime.datetime
    """

    _attribute_map = {
        'context': {'key': 'context', 'type': 'SpanContext'},
        'name': {'key': 'name', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'parent_span_id': {'key': 'parentSpanId', 'type': 'str'},
        'attributes': {'key': 'attributes', 'type': '[KeyValuePairStringJToken]'},
        'events': {'key': 'events', 'type': '[Event]'},
        'links': {'key': 'links', 'type': '[Link]'},
        'start_timestamp': {'key': 'startTimestamp', 'type': 'iso-8601'},
        'end_timestamp': {'key': 'endTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        context: Optional["SpanContext"] = None,
        name: Optional[str] = None,
        status: Optional[Union[str, "RunStatus"]] = None,
        parent_span_id: Optional[str] = None,
        attributes: Optional[List["KeyValuePairStringJToken"]] = None,
        events: Optional[List["Event"]] = None,
        links: Optional[List["Link"]] = None,
        start_timestamp: Optional[datetime.datetime] = None,
        end_timestamp: Optional[datetime.datetime] = None,
        **kwargs
    ):
        super(SpanDefinition1, self).__init__(**kwargs)
        self.context = context
        self.name = name
        self.status = status
        self.parent_span_id = parent_span_id
        self.attributes = attributes
        self.events = events
        self.links = links
        self.start_timestamp = start_timestamp
        self.end_timestamp = end_timestamp


class SqlDataPath(msrest.serialization.Model):
    """SqlDataPath.

    :param sql_table_name:
    :type sql_table_name: str
    :param sql_query:
    :type sql_query: str
    :param sql_stored_procedure_name:
    :type sql_stored_procedure_name: str
    :param sql_stored_procedure_params:
    :type sql_stored_procedure_params:
     list[~azure.mgmt.machinelearningservices.models.StoredProcedureParameter]
    """

    _attribute_map = {
        'sql_table_name': {'key': 'sqlTableName', 'type': 'str'},
        'sql_query': {'key': 'sqlQuery', 'type': 'str'},
        'sql_stored_procedure_name': {'key': 'sqlStoredProcedureName', 'type': 'str'},
        'sql_stored_procedure_params': {'key': 'sqlStoredProcedureParams', 'type': '[StoredProcedureParameter]'},
    }

    def __init__(
        self,
        *,
        sql_table_name: Optional[str] = None,
        sql_query: Optional[str] = None,
        sql_stored_procedure_name: Optional[str] = None,
        sql_stored_procedure_params: Optional[List["StoredProcedureParameter"]] = None,
        **kwargs
    ):
        super(SqlDataPath, self).__init__(**kwargs)
        self.sql_table_name = sql_table_name
        self.sql_query = sql_query
        self.sql_stored_procedure_name = sql_stored_procedure_name
        self.sql_stored_procedure_params = sql_stored_procedure_params


class StoredProcedureParameter(msrest.serialization.Model):
    """StoredProcedureParameter.

    :param name:
    :type name: str
    :param value:
    :type value: str
    :param type:  Possible values include: "String", "Int", "Decimal", "Guid", "Boolean", "Date".
    :type type: str or ~azure.mgmt.machinelearningservices.models.StoredProcedureParameterType
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        value: Optional[str] = None,
        type: Optional[Union[str, "StoredProcedureParameterType"]] = None,
        **kwargs
    ):
        super(StoredProcedureParameter, self).__init__(**kwargs)
        self.name = name
        self.value = value
        self.type = type


class User(msrest.serialization.Model):
    """User.

    :param user_object_id: A user or service principal's object ID.
     This is EUPI and may only be logged to warm path telemetry.
    :type user_object_id: str
    :param user_pu_id: A user or service principal's PuID.
     This is PII and should never be logged.
    :type user_pu_id: str
    :param user_idp: A user identity provider. Eg live.com
     This is PII and should never be logged.
    :type user_idp: str
    :param user_alt_sec_id: A user alternate sec id. This represents the user in a different
     identity provider system Eg.1:live.com:puid
     This is PII and should never be logged.
    :type user_alt_sec_id: str
    :param user_iss: The issuer which issed the token for this user.
     This is PII and should never be logged.
    :type user_iss: str
    :param user_tenant_id: A user or service principal's tenant ID.
    :type user_tenant_id: str
    :param user_name: A user's full name or a service principal's app ID.
     This is PII and should never be logged.
    :type user_name: str
    :param upn: A user's Principal name (upn)
     This is PII andshould never be logged.
    :type upn: str
    """

    _attribute_map = {
        'user_object_id': {'key': 'userObjectId', 'type': 'str'},
        'user_pu_id': {'key': 'userPuId', 'type': 'str'},
        'user_idp': {'key': 'userIdp', 'type': 'str'},
        'user_alt_sec_id': {'key': 'userAltSecId', 'type': 'str'},
        'user_iss': {'key': 'userIss', 'type': 'str'},
        'user_tenant_id': {'key': 'userTenantId', 'type': 'str'},
        'user_name': {'key': 'userName', 'type': 'str'},
        'upn': {'key': 'upn', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        user_object_id: Optional[str] = None,
        user_pu_id: Optional[str] = None,
        user_idp: Optional[str] = None,
        user_alt_sec_id: Optional[str] = None,
        user_iss: Optional[str] = None,
        user_tenant_id: Optional[str] = None,
        user_name: Optional[str] = None,
        upn: Optional[str] = None,
        **kwargs
    ):
        super(User, self).__init__(**kwargs)
        self.user_object_id = user_object_id
        self.user_pu_id = user_pu_id
        self.user_idp = user_idp
        self.user_alt_sec_id = user_alt_sec_id
        self.user_iss = user_iss
        self.user_tenant_id = user_tenant_id
        self.user_name = user_name
        self.upn = upn
