# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpRequest, HttpResponse
from azure.mgmt.core.exceptions import ARMErrorFormat

from .. import models

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, Iterable, List, Optional, TypeVar, Union

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

class ServicesOperations(object):
    """ServicesOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.mgmt.machinelearningservices.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def query_by_id(
        self,
        subscription_id,  # type: str
        resource_group,  # type: str
        workspace,  # type: str
        id,  # type: str
        expand=False,  # type: Optional[bool]
        include_health=True,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.ServiceResponseBase"
        """Get a Service.

        Get a Service by Id.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param id: The Service Id.
        :type id: str
        :param expand: Set to True to include Model details.
        :type expand: bool
        :param include_health: Set to True to include a live check of the health status of a service.
        :type include_health: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ServiceResponseBase, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.ServiceResponseBase
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.ServiceResponseBase"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.query_by_id.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str'),
            'id': self._serialize.url("id", id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if expand is not None:
            query_parameters['expand'] = self._serialize.query("expand", expand, 'bool')
        if include_health is not None:
            query_parameters['includeHealth'] = self._serialize.query("include_health", include_health, 'bool')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ModelErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('ServiceResponseBase', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    query_by_id.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/{id}'}  # type: ignore

    def create_put(
        self,
        subscription_id,  # type: str
        resource_group,  # type: str
        workspace,  # type: str
        id,  # type: str
        body,  # type: "models.CreateServiceRequest"
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Create a Service.

        Create a Service with the specified payload.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param id: The ID of the service requesting to be created.
        :type id: str
        :param body: The payload that is used to create the Service.
        :type body: ~azure.mgmt.machinelearningservices.models.CreateServiceRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_put.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str'),
            'id': self._serialize.url("id", id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'CreateServiceRequest')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ModelErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    create_put.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/{id}'}  # type: ignore

    def patch(
        self,
        subscription_id,  # type: str
        resource_group,  # type: str
        workspace,  # type: str
        id,  # type: str
        body,  # type: List["models.JsonPatchOperation"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Patch a Service.

        Patch a specific Service.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param id: The Service Id.
        :type id: str
        :param body: The payload that is used to patch the Service.
        :type body: list[~azure.mgmt.machinelearningservices.models.JsonPatchOperation]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json-patch+json")
        accept = "application/json"

        # Construct URL
        url = self.patch.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str'),
            'id': self._serialize.url("id", id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, '[JsonPatchOperation]')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ModelErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    patch.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/{id}'}  # type: ignore

    def delete(
        self,
        subscription_id,  # type: str
        resource_group,  # type: str
        workspace,  # type: str
        id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional["models.ProblemDetails"]
        """Delete a Service.

        Delete a specific Service.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param id: The Service Id.
        :type id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProblemDetails, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.ProblemDetails or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["models.ProblemDetails"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str'),
            'id': self._serialize.url("id", id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ModelErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 409:
            deserialized = self._deserialize('ProblemDetails', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/{id}'}  # type: ignore

    def name_validation(
        self,
        subscription_id,  # type: str
        resource_group,  # type: str
        workspace,  # type: str
        service_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.ServiceResponseBase"
        """Validate if a Service name exists.

        Validate if a Service name already exists.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param service_name: The Service Name.
        :type service_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ServiceResponseBase, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.ServiceResponseBase
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.ServiceResponseBase"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.name_validation.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str'),
            'serviceName': self._serialize.url("service_name", service_name, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ModelErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('ServiceResponseBase', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    name_validation.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/validate/name/{serviceName}'}  # type: ignore

    def resource_validation(
        self,
        subscription_id,  # type: str
        resource_group,  # type: str
        workspace,  # type: str
        body,  # type: "models.ServiceValidateResourceRequest"
        **kwargs  # type: Any
    ):
        # type: (...) -> Union["models.ServiceResponseBase", "models.ProblemDetails"]
        """Check if the service resouce is enough.

        Check if the resource required by the service is enough.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param body: The payload that is used to create the Service.
        :type body: ~azure.mgmt.machinelearningservices.models.ServiceValidateResourceRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ServiceResponseBase or ProblemDetails, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.ServiceResponseBase or ~azure.mgmt.machinelearningservices.models.ProblemDetails
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Union["models.ServiceResponseBase", "models.ProblemDetails"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.resource_validation.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'ServiceValidateResourceRequest')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ModelErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if response.status_code == 200:
            deserialized = self._deserialize('ServiceResponseBase', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ProblemDetails', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    resource_validation.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/validate/resource'}  # type: ignore

    def export_query_post(
        self,
        subscription_id,  # type: str
        resource_group,  # type: str
        workspace,  # type: str
        body=None,  # type: Optional["models.ExportServicesRequest"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Export all the V1 services associated with the Workspace to ARM templates. Upload templates to blob storage.

        Export all the V1 services associated with the Workspace to ARM templates. Upload templates to
        blob storage.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param body: The payload that is used to exporting services.
        :type body: ~azure.mgmt.machinelearningservices.models.ExportServicesRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.export_query_post.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ExportServicesRequest')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ModelErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    export_query_post.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/export'}  # type: ignore

    def list_query(
        self,
        subscription_id,  # type: str
        resource_group,  # type: str
        workspace,  # type: str
        image_id=None,  # type: Optional[str]
        image_digest=None,  # type: Optional[str]
        image_name=None,  # type: Optional[str]
        model_id=None,  # type: Optional[str]
        model_name=None,  # type: Optional[str]
        name=None,  # type: Optional[str]
        tag=None,  # type: Optional[str]
        count=None,  # type: Optional[int]
        compute_type=None,  # type: Optional[str]
        skip_token=None,  # type: Optional[str]
        tags=None,  # type: Optional[str]
        properties=None,  # type: Optional[str]
        run_id=None,  # type: Optional[str]
        endpoint_name=None,  # type: Optional[str]
        expand=False,  # type: Optional[bool]
        orderby=None,  # type: Optional[Union[str, "models.OrderString"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.PaginatedServiceList"]
        """Query the list of Services in a Workspace.

        If no filter is passed, the query lists all Services in the Workspace. The returned list is
        paginated and the count of item in each page is an optional parameter.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param image_id: The Image Id.
        :type image_id: str
        :param image_digest: The Image Digest.
        :type image_digest: str
        :param image_name: The Image name.
        :type image_name: str
        :param model_id: The Model Id.
        :type model_id: str
        :param model_name: The Model name.
        :type model_name: str
        :param name: The object name.
        :type name: str
        :param tag: The object tag.
        :type tag: str
        :param count: The number of items to retrieve in a page.
        :type count: int
        :param compute_type: The compute environment type.
        :type compute_type: str
        :param skip_token: The continuation token to retrieve the next page.
        :type skip_token: str
        :param tags: A set of tags with which to filter the returned models.
                     It is a comma separated string of tags key or tags key=value
                     Example: tagKey1,tagKey2,tagKey3=value3 .
        :type tags: str
        :param properties: A set of properties with which to filter the returned models.
                     It is a comma separated string of properties key and/or properties key=value
                     Example: propKey1,propKey2,propKey3=value3 .
        :type properties: str
        :param run_id: runId for model associated with service.
        :type run_id: str
        :param endpoint_name: endpointName that contains this service.
        :type endpoint_name: str
        :param expand: Set to True to include Model details.
        :type expand: bool
        :param orderby: The option to order the response.
        :type orderby: str or ~azure.mgmt.machinelearningservices.models.OrderString
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either PaginatedServiceList or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.machinelearningservices.models.PaginatedServiceList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.PaginatedServiceList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_query.metadata['url']  # type: ignore
                path_format_arguments = {
                    'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
                    'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
                    'workspace': self._serialize.url("workspace", workspace, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if image_id is not None:
                    query_parameters['imageId'] = self._serialize.query("image_id", image_id, 'str')
                if image_digest is not None:
                    query_parameters['imageDigest'] = self._serialize.query("image_digest", image_digest, 'str')
                if image_name is not None:
                    query_parameters['imageName'] = self._serialize.query("image_name", image_name, 'str')
                if model_id is not None:
                    query_parameters['modelId'] = self._serialize.query("model_id", model_id, 'str')
                if model_name is not None:
                    query_parameters['modelName'] = self._serialize.query("model_name", model_name, 'str')
                if name is not None:
                    query_parameters['name'] = self._serialize.query("name", name, 'str')
                if tag is not None:
                    query_parameters['tag'] = self._serialize.query("tag", tag, 'str')
                if count is not None:
                    query_parameters['count'] = self._serialize.query("count", count, 'int')
                if compute_type is not None:
                    query_parameters['computeType'] = self._serialize.query("compute_type", compute_type, 'str')
                if skip_token is not None:
                    query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
                if tags is not None:
                    query_parameters['tags'] = self._serialize.query("tags", tags, 'str')
                if properties is not None:
                    query_parameters['properties'] = self._serialize.query("properties", properties, 'str')
                if run_id is not None:
                    query_parameters['runId'] = self._serialize.query("run_id", run_id, 'str')
                if endpoint_name is not None:
                    query_parameters['endpointName'] = self._serialize.query("endpoint_name", endpoint_name, 'str')
                if expand is not None:
                    query_parameters['expand'] = self._serialize.query("expand", expand, 'bool')
                if orderby is not None:
                    query_parameters['orderby'] = self._serialize.query("orderby", orderby, 'str')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('PaginatedServiceList', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.ModelErrorResponse, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_query.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services'}  # type: ignore

    def create(
        self,
        subscription_id,  # type: str
        resource_group,  # type: str
        workspace,  # type: str
        body,  # type: "models.CreateServiceRequest"
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Create a Service.

        Create a Service with the specified payload.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param body: The payload that is used to create the Service.
        :type body: ~azure.mgmt.machinelearningservices.models.CreateServiceRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'CreateServiceRequest')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ModelErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))

        if cls:
            return cls(pipeline_response, None, response_headers)

    create.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services'}  # type: ignore

    def list_query_post(
        self,
        subscription_id,  # type: str
        resource_group,  # type: str
        workspace,  # type: str
        body=None,  # type: Optional["models.ListServicesRequest"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.PaginatedServiceListPost"]
        """Query the list of Services in a Workspace.

        If no filter is passed, the query lists all Services in the Workspace. The returned list is
        paginated and the count of item in each page is an optional parameter.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param body: The payload that is used to list services.
        :type body: ~azure.mgmt.machinelearningservices.models.ListServicesRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either PaginatedServiceListPost or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.machinelearningservices.models.PaginatedServiceListPost]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.PaginatedServiceListPost"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = "application/json"
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_query_post.metadata['url']  # type: ignore
                path_format_arguments = {
                    'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
                    'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
                    'workspace': self._serialize.url("workspace", workspace, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]

                body_content_kwargs = {}  # type: Dict[str, Any]
                if body is not None:
                    body_content = self._serialize.body(body, 'ListServicesRequest')
                else:
                    body_content = None
                body_content_kwargs['content'] = body_content
                request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                body_content_kwargs = {}  # type: Dict[str, Any]
                if body is not None:
                    body_content = self._serialize.body(body, 'ListServicesRequest')
                else:
                    body_content = None
                body_content_kwargs['content'] = body_content
                request = self._client.get(url, query_parameters, header_parameters, **body_content_kwargs)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('PaginatedServiceListPost', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.ModelErrorResponse, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_query_post.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/list'}  # type: ignore

    def list_service_keys(
        self,
        subscription_id,  # type: str
        resource_group,  # type: str
        workspace,  # type: str
        id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.AuthKeys"
        """Lists Service keys.

        Gets a list of Service keys.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param id: The Service Id.
        :type id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AuthKeys, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.AuthKeys
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.AuthKeys"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.list_service_keys.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str'),
            'id': self._serialize.url("id", id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ModelErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('AuthKeys', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    list_service_keys.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/{id}/listkeys'}  # type: ignore

    def regenerate_service_keys(
        self,
        subscription_id,  # type: str
        resource_group,  # type: str
        workspace,  # type: str
        id,  # type: str
        body,  # type: "models.RegenerateServiceKeysRequest"
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Regenerate Service Keys.

        Regenerate and return the Service keys.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param id: The Service Id.
        :type id: str
        :param body: The payload that is used to regenerate keys.
        :type body: ~azure.mgmt.machinelearningservices.models.RegenerateServiceKeysRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.regenerate_service_keys.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str'),
            'id': self._serialize.url("id", id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'RegenerateServiceKeysRequest')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ModelErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    regenerate_service_keys.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/{id}/regenerateKeys'}  # type: ignore

    def get_service_token(
        self,
        subscription_id,  # type: str
        resource_group,  # type: str
        workspace,  # type: str
        id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.AuthToken"
        """Generate Service Access Token.

        Gets access token that can be used for calling service.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param id: The Service Id.
        :type id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AuthToken, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.AuthToken
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.AuthToken"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_service_token.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str'),
            'id': self._serialize.url("id", id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ModelErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('AuthToken', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_service_token.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/{id}/token'}  # type: ignore

    def get_logs(
        self,
        subscription_id,  # type: str
        resource_group,  # type: str
        workspace,  # type: str
        id,  # type: str
        tail=None,  # type: Optional[int]
        init=False,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.ServiceLogs"
        """get_logs.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param id:
        :type id: str
        :param tail:
        :type tail: int
        :param init:
        :type init: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ServiceLogs, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.ServiceLogs
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.ServiceLogs"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_logs.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str'),
            'id': self._serialize.url("id", id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if tail is not None:
            query_parameters['tail'] = self._serialize.query("tail", tail, 'int')
        if init is not None:
            query_parameters['init'] = self._serialize.query("init", init, 'bool')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ModelErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('ServiceLogs', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_logs.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/{id}/logs'}  # type: ignore

    def request_validation(
        self,
        subscription_id,  # type: str
        resource_group,  # type: str
        workspace,  # type: str
        body,  # type: "models.ValidateServiceRequest"
        **kwargs  # type: Any
    ):
        # type: (...) -> Union["models.ServiceResponseBase", "models.ProblemDetails"]
        """Validate the request.

        Validate if the request is valid based on request type and compute type in creation request.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param body: The payload that is used to validate.
        :type body: ~azure.mgmt.machinelearningservices.models.ValidateServiceRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ServiceResponseBase or ProblemDetails, or the result of cls(response)
        :rtype: ~azure.mgmt.machinelearningservices.models.ServiceResponseBase or ~azure.mgmt.machinelearningservices.models.ProblemDetails
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Union["models.ServiceResponseBase", "models.ProblemDetails"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.request_validation.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'ValidateServiceRequest')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ModelErrorResponse, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if response.status_code == 200:
            deserialized = self._deserialize('ServiceResponseBase', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ProblemDetails', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    request_validation.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/validate'}  # type: ignore
