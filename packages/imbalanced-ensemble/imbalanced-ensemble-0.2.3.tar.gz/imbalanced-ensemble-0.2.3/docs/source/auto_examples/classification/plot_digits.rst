
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples\classification\plot_digits.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_classification_plot_digits.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_classification_plot_digits.py:


=========================================================
Classify class-imbalanced hand-written digits
=========================================================

This example shows how imbalanced-ensemble can be used to cooperate with 
scikit-learn base classifier and recognize images of hand-written digits, from 0-9.

This example uses:

    - :class:`imbens.ensemble.SelfPacedEnsembleClassifier`
    - :class:`imbens.visualizer.ImbalancedEnsembleVisualizer`

.. GENERATED FROM PYTHON SOURCE LINES 14-21

.. code-block:: default



    # Adapted from sklearn
    # Author: Zhining Liu <zhining.liu@outlook.com>
    #         Gael Varoquaux <gael dot varoquaux at normalesup dot org>
    # License: BSD 3 clause








.. GENERATED FROM PYTHON SOURCE LINES 22-36

.. code-block:: default

    print(__doc__)

    # Import imbalanced-ensemble
    import imbens

    # Import utilities
    import sklearn
    from sklearn.model_selection import train_test_split
    from imbens.datasets import make_imbalance
    from imbens.utils._plot import plot_2Dprojection_and_cardinality
    import matplotlib.pyplot as plt

    RANDOM_STATE = 42








.. GENERATED FROM PYTHON SOURCE LINES 37-40

Digits dataset
--------------
The digits dataset consists of 8x8 pixel images of digits. The images attribute of the dataset stores 8x8 arrays of grayscale values for each image. We will use these arrays to visualize the first 4 images. The target attribute of the dataset stores the digit each image represents and this is included in the title of the 4 plots below.

.. GENERATED FROM PYTHON SOURCE LINES 42-43

To apply a classifier on this data, we need to flatten the images, turning each 2-D array of grayscale values from shape (8, 8) into shape (64,). Subsequently, the entire dataset will be of shape (n_samples, n_features), where n_samples is the number of images and n_features is the total number of pixels in each image.

.. GENERATED FROM PYTHON SOURCE LINES 43-57

.. code-block:: default


    digits = sklearn.datasets.load_digits()

    # flatten the images
    n_samples = len(digits.images)
    X, y = digits.images.reshape((n_samples, -1)), digits.target

    _, axes = plt.subplots(nrows=3, ncols=4, figsize=(10, 9))
    for ax, image, label in zip(axes.flatten(), digits.images, digits.target):
        ax.set_axis_off()
        ax.imshow(image, cmap=plt.cm.gray_r, interpolation='nearest')
        ax.set_title('Training: %i' % label)





.. image-sg:: /auto_examples/classification/images/sphx_glr_plot_digits_001.png
   :alt: Training: 0, Training: 1, Training: 2, Training: 3, Training: 4, Training: 5, Training: 6, Training: 7, Training: 8, Training: 9, Training: 0, Training: 1
   :srcset: /auto_examples/classification/images/sphx_glr_plot_digits_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 58-59

**The original digits dataset**

.. GENERATED FROM PYTHON SOURCE LINES 59-63

.. code-block:: default


    fig = plot_2Dprojection_and_cardinality(X, y, figsize=(8, 4))





.. image-sg:: /auto_examples/classification/images/sphx_glr_plot_digits_002.png
   :alt: Dataset (2D projection by KernelPCA), Class Distribution
   :srcset: /auto_examples/classification/images/sphx_glr_plot_digits_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 64-65

**Make class-imbalanced digits dataset**

.. GENERATED FROM PYTHON SOURCE LINES 65-86

.. code-block:: default


    imbalance_distr = {
        0: 178,
        1: 120,
        2: 80,
        3: 60,
        4: 50,
        5: 44,
        6: 40,
        7: 40,
        8: 40,
        9: 40,
    }

    X, y = make_imbalance(
        X, y, sampling_strategy=imbalance_distr, random_state=RANDOM_STATE
    )

    fig = plot_2Dprojection_and_cardinality(X, y, figsize=(8, 4))





.. image-sg:: /auto_examples/classification/images/sphx_glr_plot_digits_003.png
   :alt: Dataset (2D projection by KernelPCA), Class Distribution
   :srcset: /auto_examples/classification/images/sphx_glr_plot_digits_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 87-91

Classification
--------------
We split the data into train and test subsets and fit a ``SelfPacedEnsembleClassifier`` (with support vector machine as base classifier) on the train samples.
The fitted classifier can subsequently be used to predict the value of the digit for the samples in the test subset.

.. GENERATED FROM PYTHON SOURCE LINES 91-111

.. code-block:: default


    # Split data into 50% train and 50% test subsets
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.5, shuffle=True, stratify=y, random_state=0
    )

    # Create a classifier: a SPE with support vector base classifier
    base_clf = sklearn.svm.SVC(gamma=0.001, probability=True)
    clf = imbens.ensemble.SelfPacedEnsembleClassifier(
        n_estimators=5,
        estimator=base_clf,
    )

    # Learn the digits on the train subset
    clf.fit(X_train, y_train)

    # Predict the value of the digit on the test subset
    predicted = clf.predict(X_test)









.. GENERATED FROM PYTHON SOURCE LINES 112-113

``sklearn.metrics.classification_report`` builds a text report showing the main classification metrics.

.. GENERATED FROM PYTHON SOURCE LINES 113-120

.. code-block:: default


    print(
        f"Classification report for classifier {clf}:\n"
        f"{sklearn.metrics.classification_report(y_test, predicted)}\n"
    )






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Classification report for classifier SelfPacedEnsembleClassifier(estimator=SVC(gamma=0.001, probability=True),
                                n_estimators=5,
                                random_state=RandomState(MT19937) at 0x1AB62EA1440):
                  precision    recall  f1-score   support

               0       1.00      1.00      1.00        89
               1       0.95      1.00      0.98        60
               2       1.00      0.97      0.99        40
               3       1.00      0.90      0.95        30
               4       1.00      0.96      0.98        25
               5       0.95      0.95      0.95        22
               6       1.00      1.00      1.00        20
               7       0.86      0.95      0.90        20
               8       0.90      0.95      0.93        20
               9       0.95      0.90      0.92        20

        accuracy                           0.97       346
       macro avg       0.96      0.96      0.96       346
    weighted avg       0.97      0.97      0.97       346






.. GENERATED FROM PYTHON SOURCE LINES 121-122

Below we visualize the first 4 test samples and show their predicted digit value in the title.

.. GENERATED FROM PYTHON SOURCE LINES 122-131

.. code-block:: default


    _, axes = plt.subplots(nrows=1, ncols=4, figsize=(10, 3))
    for ax, image, prediction in zip(axes, X_test, predicted):
        ax.set_axis_off()
        image = image.reshape(8, 8)
        ax.imshow(image, cmap=plt.cm.gray_r, interpolation='nearest')
        ax.set_title(f'Prediction: {prediction}')





.. image-sg:: /auto_examples/classification/images/sphx_glr_plot_digits_004.png
   :alt: Prediction: 1, Prediction: 2, Prediction: 9, Prediction: 6
   :srcset: /auto_examples/classification/images/sphx_glr_plot_digits_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 132-133

We can also plot a confusion matrix of the true digit values and the predicted digit values using the ``ImbalancedEnsembleVisualizer``.

.. GENERATED FROM PYTHON SOURCE LINES 133-144

.. code-block:: default


    visualizer = imbens.visualizer.ImbalancedEnsembleVisualizer(
        eval_datasets={
            'test': (X_test, y_test),
        },
    ).fit({'SPE': clf})

    fig, axes = visualizer.confusion_matrix_heatmap(
        sub_figsize=(8, 7),
        false_pred_only=True,
    )



.. image-sg:: /auto_examples/classification/images/sphx_glr_plot_digits_005.png
   :alt: Confusion Matrix
   :srcset: /auto_examples/classification/images/sphx_glr_plot_digits_005.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          | 0/5 [00:00<?, ?it/s]    Visualizer evaluating model SPE on dataset test ::   0%|          | 0/5 [00:00<?, ?it/s]    Visualizer evaluating model SPE on dataset test :: 100%|##########| 5/5 [00:00<00:00, 59.05it/s]
    Visualizer computing confusion matrices. Finished!





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  41.594 seconds)

**Estimated memory usage:**  35 MB


.. _sphx_glr_download_auto_examples_classification_plot_digits.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_digits.py <plot_digits.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_digits.ipynb <plot_digits.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
