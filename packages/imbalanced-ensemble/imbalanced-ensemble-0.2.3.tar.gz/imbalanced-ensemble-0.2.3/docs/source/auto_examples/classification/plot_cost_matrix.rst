
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples\classification\plot_cost_matrix.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_classification_plot_cost_matrix.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_classification_plot_cost_matrix.py:


=========================================================
Customize cost matrix
=========================================================

This example demonstrates how to customize the cost matrix of cost-sensitive ensemble methods.

This example uses:

    - :class:`imbens.ensemble.AdaCostClassifier`

.. GENERATED FROM PYTHON SOURCE LINES 12-16

.. code-block:: default


    # Authors: Zhining Liu <zhining.liu@outlook.com>
    # License: MIT








.. GENERATED FROM PYTHON SOURCE LINES 17-45

.. code-block:: default

    print(__doc__)

    # Import imbalanced-ensemble
    import imbens

    # Import utilities
    import numpy as np
    import sklearn
    from sklearn.datasets import make_classification
    from sklearn.model_selection import train_test_split
    from imbens.ensemble.base import sort_dict_by_key
    from collections import Counter

    # Import plot utilities
    import matplotlib.pyplot as plt
    import seaborn as sns

    sns.set_context('talk')

    RANDOM_STATE = 42

    init_kwargs = {
        'n_estimators': 5,
        'random_state': RANDOM_STATE,
    }

    # sphinx_gallery_thumbnail_number = -2








.. GENERATED FROM PYTHON SOURCE LINES 46-49

Prepare data
------------
Make a toy 3-class imbalanced classification task.

.. GENERATED FROM PYTHON SOURCE LINES 49-74

.. code-block:: default


    # make dataset
    X, y = make_classification(
        n_classes=3,
        class_sep=2,
        weights=[0.1, 0.3, 0.6],
        n_informative=3,
        n_redundant=1,
        flip_y=0,
        n_features=20,
        n_clusters_per_class=2,
        n_samples=2000,
        random_state=0,
    )

    # train valid split
    X_train, X_valid, y_train, y_valid = train_test_split(
        X, y, test_size=0.5, stratify=y, random_state=RANDOM_STATE
    )

    # Print class distribution
    print('Training dataset distribution    %s' % sort_dict_by_key(Counter(y_train)))
    print('Validation dataset distribution  %s' % sort_dict_by_key(Counter(y_valid)))






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Training dataset distribution    {0: 100, 1: 300, 2: 600}
    Validation dataset distribution  {0: 100, 1: 300, 2: 600}




.. GENERATED FROM PYTHON SOURCE LINES 75-76

Implement some plot utilities

.. GENERATED FROM PYTHON SOURCE LINES 76-87

.. code-block:: default


    cost_matrices = {}


    def plot_cost_matrix(cost_matrix, title: str, **kwargs):
        ax = sns.heatmap(data=cost_matrix, **kwargs)
        ax.set_ylabel("Predicted Label")
        ax.set_xlabel("Ground Truth")
        ax.set_title(title)









.. GENERATED FROM PYTHON SOURCE LINES 88-91

Default Cost Matrix
----------------------------
By default, cost-sensitive ensemble methods will set misclassification cost by inverse class frequency.

.. GENERATED FROM PYTHON SOURCE LINES 93-96

**You can access the ``clf.cost_matrix_`` attribute (``clf`` is a fitted cost-sensitive ensemble classifier) to view the cost matrix used for training.**
The rows represent the predicted class and columns represent the actual class.
Note that the order of the classes corresponds to that in the attribute ``clf.classes_``.

.. GENERATED FROM PYTHON SOURCE LINES 98-99

Take ``AdaCostClassifier`` as example

.. GENERATED FROM PYTHON SOURCE LINES 99-103

.. code-block:: default


    adacost_clf = imbens.ensemble.AdaCostClassifier(**init_kwargs)









.. GENERATED FROM PYTHON SOURCE LINES 104-105

**Train with the default cost matrix setting**

.. GENERATED FROM PYTHON SOURCE LINES 105-111

.. code-block:: default


    adacost_clf.fit(X_train, y_train)

    adacost_clf.cost_matrix_






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([[1.        , 0.33333333, 0.16666667],
           [3.        , 1.        , 0.5       ],
           [6.        , 2.        , 1.        ]])



.. GENERATED FROM PYTHON SOURCE LINES 112-113

**Visualize the default cost matrix**

.. GENERATED FROM PYTHON SOURCE LINES 113-119

.. code-block:: default


    title = "Misclassification Cost Matrix\n(by inverse class frequency)"
    cost_matrices[title] = adacost_clf.cost_matrix_
    plot_cost_matrix(adacost_clf.cost_matrix_, title, annot=True, cmap='YlOrRd', vmax=6)





.. image-sg:: /auto_examples/classification/images/sphx_glr_plot_cost_matrix_001.png
   :alt: Misclassification Cost Matrix (by inverse class frequency)
   :srcset: /auto_examples/classification/images/sphx_glr_plot_cost_matrix_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 120-124

``log1p-inverse`` Cost Matrix
-----------------------------
You can set misclassification cost by log inverse class frequency by set ``cost_matrix`` = ``'log1p-inverse'``.
This usually leads to a "softer" cost matrix, that is, less penalty for misclassification of minority class samples into the majority class.

.. GENERATED FROM PYTHON SOURCE LINES 124-134

.. code-block:: default


    adacost_clf.fit(
        X_train,
        y_train,
        cost_matrix='log1p-inverse',  # set cost matrix by log inverse class frequency
    )

    adacost_clf.cost_matrix_






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([[0.69314718, 0.28768207, 0.15415068],
           [1.38629436, 0.69314718, 0.40546511],
           [1.94591015, 1.09861229, 0.69314718]])



.. GENERATED FROM PYTHON SOURCE LINES 135-136

**Visualize the log1p-inverse cost matrix**

.. GENERATED FROM PYTHON SOURCE LINES 136-142

.. code-block:: default


    title = "Misclassification Cost Matrix\n(by log inverse class frequency)"
    cost_matrices[title] = adacost_clf.cost_matrix_
    plot_cost_matrix(adacost_clf.cost_matrix_, title, annot=True, cmap='YlOrRd', vmax=6)





.. image-sg:: /auto_examples/classification/images/sphx_glr_plot_cost_matrix_002.png
   :alt: Misclassification Cost Matrix (by log inverse class frequency)
   :srcset: /auto_examples/classification/images/sphx_glr_plot_cost_matrix_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 143-146

Use Uniform Cost Matrix
----------------------------
You can set misclassification cost by log inverse class frequency by set ``cost_matrix`` = ``'uniform'``.

.. GENERATED FROM PYTHON SOURCE LINES 146-158

.. code-block:: default


    # Note that this will set all misclassification cost to be equal, i.e., model will not be cost-sensitive.

    adacost_clf.fit(
        X_train,
        y_train,
        cost_matrix='uniform',  # set cost matrix to be uniform
    )

    adacost_clf.cost_matrix_






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([[1., 1., 1.],
           [1., 1., 1.],
           [1., 1., 1.]])



.. GENERATED FROM PYTHON SOURCE LINES 159-160

**Visualize the uniform cost matrix**

.. GENERATED FROM PYTHON SOURCE LINES 160-166

.. code-block:: default


    title = "Uniform Cost Matrix"
    cost_matrices[title] = adacost_clf.cost_matrix_
    plot_cost_matrix(adacost_clf.cost_matrix_, title, annot=True, cmap='YlOrRd', vmax=6)





.. image-sg:: /auto_examples/classification/images/sphx_glr_plot_cost_matrix_003.png
   :alt: Uniform Cost Matrix
   :srcset: /auto_examples/classification/images/sphx_glr_plot_cost_matrix_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 167-170

Use Your Own Cost Matrix
------------------------
You can also set misclassification cost by explicitly passing your cost matrix to ``cost_matrix``.

.. GENERATED FROM PYTHON SOURCE LINES 172-174

Your cost matrix must be a ``numpy.2darray`` of shape (n_classes, n_classes), the rows represent the predicted class and columns represent the actual class.
Thus the value at :math:`i`-th row :math:`j`-th column represents the cost of classifying a sample from class :math:`j` to class :math:`i`.

.. GENERATED FROM PYTHON SOURCE LINES 174-191

.. code-block:: default


    # set your own cost matrix
    my_cost_matrix = [
        [1, 1, 1],
        [2, 1, 1],
        [5, 2, 1],
    ]

    adacost_clf.fit(
        X_train,
        y_train,
        cost_matrix=my_cost_matrix,  # use your cost matrix
    )

    adacost_clf.cost_matrix_






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([[1, 1, 1],
           [2, 1, 1],
           [5, 2, 1]])



.. GENERATED FROM PYTHON SOURCE LINES 192-193

**Visualize the user-define cost matrix**

.. GENERATED FROM PYTHON SOURCE LINES 193-199

.. code-block:: default


    title = "User-define Cost Matrix"
    cost_matrices[title] = adacost_clf.cost_matrix_
    plot_cost_matrix(adacost_clf.cost_matrix_, title, annot=True, cmap='YlOrRd', vmax=6)





.. image-sg:: /auto_examples/classification/images/sphx_glr_plot_cost_matrix_004.png
   :alt: User-define Cost Matrix
   :srcset: /auto_examples/classification/images/sphx_glr_plot_cost_matrix_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 200-202

Visualize All Used Cost Matrices
--------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 202-209

.. code-block:: default


    sns.set_context('notebook')
    fig, axes = plt.subplots(1, 4, figsize=(20, 4))
    for ax, title in zip(axes, cost_matrices.keys()):
        plot_cost_matrix(
            cost_matrices[title], title, annot=True, cmap='YlOrRd', vmax=6, ax=ax
        )



.. image-sg:: /auto_examples/classification/images/sphx_glr_plot_cost_matrix_005.png
   :alt: Misclassification Cost Matrix (by inverse class frequency), Misclassification Cost Matrix (by log inverse class frequency), Uniform Cost Matrix, User-define Cost Matrix
   :srcset: /auto_examples/classification/images/sphx_glr_plot_cost_matrix_005.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 1 minutes  39.712 seconds)

**Estimated memory usage:**  19 MB


.. _sphx_glr_download_auto_examples_classification_plot_cost_matrix.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_cost_matrix.py <plot_cost_matrix.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_cost_matrix.ipynb <plot_cost_matrix.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
