#!/usr/bin/env python


""" 
I want to be able to read in text, determine if it's JSON 
and print out some of it.

The expectation is each line in the file is syntactically valid JSON.
Lines that are not valid JSON will be ignored.

getJsonObjectsFromFile(logfile) will iterate through each line in the file and return an object if the line is valid JSON.
If it is, the specified properties will be printed.
"""


from pathlib import Path 
import json 
from pprint import pprint 
## Define the command line interface
import argparse

jlidtQS_description = """ Json Iso8601 Logger Query Script.
it is used to analyze logs generated by jsonloggeriso8601datetime,
but can be used on any text file where each line is a valid JSON string.
hopefully descriptions of the options are clear enough to understand how it works.
if no options are used, all properties from each line of JSON text will be pretty printed to stdout.
"""

jsonfile_help = """ text file containinglines of strings of valid JSON """
count_help = """print all properties found and number of times each occurs """
properties_help = """ which JSON properties to print, use flag multiple times to specify multiple properties  """
submatch_help = """ use to let specified properties match as substring of properties in the file  """
insensitive_help = """ ignore case when matching properties """ 

parser = argparse.ArgumentParser(
    prog="jlidtQS",
    description=jlidtQS_description,
    formatter_class=argparse.RawTextHelpFormatter,
    epilog="Cheers!",
)
parser.add_argument("jsonfile", help=jsonfile_help)
parser.add_argument("-c", "--count", action="store_true", help=count_help)
parser.add_argument("-p", "--properties", action = "append", help=properties_help)
parser.add_argument("-s", "--submatch", action="store_true", help=submatch_help)
parser.add_argument("-i", "--insensitive", action="store_true", help= insensitive_help)
args = parser.parse_args()


def is_json(tstr: str) -> object:
    """ 
    if tstr is valid JSON, 
        return object created from the string, 
        else, return None 
    """ 
    ret = None
    try:
        ret = json.loads(tstr)
    except ValueError:
        ## print("not json")
        pass
    return ret


def get_json_object_from_log(binary_log: str) -> object:
    """ take the binary string and return an object if the string is valid JSON """ 
    log = binary_log.decode(errors='ignore')
    return is_json(log)


def get_json_objects_from_file(logfile: Path) -> object:
    """ 
    a generator that: 
    - opens the file
    - for each line that is a valid JSON string,
    -- yield an object created from that string 
    lines that are not valid JSON are ignored. 
    """ 
    with logfile.open('rb') as logs:
        for binary_log in logs:
            if (log_obj := get_json_object_from_log(binary_log)):
                yield log_obj


def count_json_properties(logfile: Path):
    """
    for each line in logfile that is valid JSON,
    for each property in that line's JSON,
    count how many times that property appears in the logfile. 
    """
    properties_count = {}
    for log_obj in get_json_objects_from_file(logfile):
        for key in log_obj.keys():
            if key in properties_count:
                properties_count[key] += 1
            else:
                properties_count[key] = 1 
    print(json.dumps(properties_count, indent=4))


def find_property_in_object(obj: object, prop: str, submatch: bool, insensitive: bool) -> object:
    """
    I was using a string to return the property from the object matching the prop parameter
    NOTE: when submatch is True, prop can match more than one property in obj
    now returning a dict of all properties matched 
    """
    ret = {}
    compareKey = ""
    compareProp = prop.lower() if  insensitive else prop  
    for key in obj.keys():
        compareKey = key.lower() if insensitive else key 
        if (submatch and (compareProp in compareKey)) or (compareProp == compareKey):
            """ 
            this conditional does an extra comparison when submatch is true 
            but compareProp is not in compareKey
            it is a nice one-liner though, not counting all these comments 
            maybe I'll change it someday.
            """
            ret[key] = obj[key]
    return ret 


def print_match_object(obj: object, matchObj: object) -> None: 
    """
    I want to print the matched properties in the same order 
    in which they appear in the original object.
    Since matched properties can be added to matchObj in any order 
    (based on the order of -p on command line, or submatch)
    I use the original object to create the print string.
    """
    printstring = "" 
    for k,v in obj.items():
        if k in matchObj.keys(): 
            printstring += f'{k} : {v}, '
    print(printstring)


def print_specified_properties(obj: object, properties: list[str], submatch: bool, insensitive: bool) -> None:
    """
    print line with each property from obj matching a string in the properties list 
    if no properties in obj are matched by any string in properties list, 
    don't print anything 
    NOTE: with submatch, it's possible for a string in properties to match multiple properties in obj
    or multiple strings in properties could match multiple properties in obj.
    keeping track of the matches in a dict addresses this multiple match problem.
    Once all the strings in properties list have been checked, the match dict can be printed as a single line 
    """
    matchObj = {}
    for prop in properties:
        if submatch or insensitive:
            # iterating through each property appears to be the only way to 
            # check if prop is a substring of a property in the object,
            # or to do a case insensitive get() 
            matchObj.update(find_property_in_object(obj, prop, submatch, insensitive))
        else: 
            # if submatch and insensitive are both False, check if the property is in the object
            # if it is, add the property and its value to the match object .
            if obj.get(prop, None) != None:
                matchObj[prop] = obj[prop]
    if len(matchObj.keys()) > 0:
        print_match_object(obj, matchObj)


def print_json_properties(logfile: Path, properties: list[str] = None, submatch: bool = False, insensitive: bool = False, print_all: bool = False):
    for log_obj in get_json_objects_from_file(logfile):
        if properties:
            print_specified_properties(log_obj, properties, submatch, insensitive)
        elif print_all:
            pprint(log_obj, indent=2, sort_dicts = False)


def run() -> None:
    """
    Json Iso8601 Logger Query Script  is kind of like grep focused on properties of JSON objects in a text file.
    if jsonfile is the only argument, all properties from lines of valid JSON are pretty printed.
    If a line in the file is not a valid JSON string, it is ignored.
    read the comments after each option to udnerstand how each is used.
    """
    jsonfile: Path = Path(args.jsonfile)
    if jsonfile.is_file():
        print(f'Querying {jsonfile}')
    else:
        print(f"jsonfile argument, {args.jsonfile}, is not a valid file")
        exit(1)

    if args.properties: 
        print(f"query for properties: {args.properties}")
        print_json_properties(jsonfile, args.properties, args.submatch, args.insensitive)
    elif args.count:
        count_json_properties(jsonfile)
    else:
        print_json_properties(jsonfile, print_all = True)


if __name__ == "__main__":
    run()

## end of file
