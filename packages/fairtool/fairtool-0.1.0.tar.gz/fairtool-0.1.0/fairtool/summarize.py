# fairtool/summarize.py

"""Handles the generation of human-readable summaries."""

import json
import logging
from pathlib import Path
import pandas as pd # Example: read analysis summary CSV
from jinja2 import Environment, FileSystemLoader, select_autoescape # For templating

log = logging.getLogger("fairtool")

DEFAULT_SUMMARY_TEMPLATE = """
# Calculation Summary Report

{% if sources %}
Based on data from:
{% for source in sources %}
- `{{ source }}`
{% endfor %}
{% endif %}

## Overview

{% if summary_stats %}
- **Total Calculations Processed**: {{ summary_stats.get('total_files', 'N/A') }}
- **Successfully Converged**: {{ summary_stats.get('converged_count', 'N/A') }}
- **Average Energy (eV)**: {{ "%.4f"|format(summary_stats.get('avg_energy', 'N/A')) if summary_stats.get('avg_energy') is not none else 'N/A' }}
- **Average Band Gap (eV)**: {{ "%.3f"|format(summary_stats.get('avg_band_gap', 'N/A')) if summary_stats.get('avg_band_gap') is not none else 'N/A' }}
{% else %}
No summary statistics available. Check analysis results.
{% endif %}

## Details

{% if detailed_data %}
{{ detailed_data }}
{% else %}
No detailed data provided (e.g., analysis summary table missing or empty).
{% endif %}

---
*Generated by FAIR Tool*
"""

def run_summarization(input_path: Path, output_dir: Path, template_path: str | None):
    """
    Generates summary reports (e.g., Markdown) from parsed or analyzed data.

    Args:
        input_path: Path to input data (e.g., analysis_summary.csv, directory).
        output_dir: Directory to save the summary report.
        template_path: Optional path to a custom Jinja2 template file.
    """
    summary_data = {}
    detailed_data_md = "No detailed data loaded."
    source_files = []

    # --- Load Data for Summarization ---
    # Prioritize loading an aggregate analysis file if present
    analysis_summary_csv = input_path / "analysis_summary.csv" if input_path.is_dir() else None
    if analysis_summary_csv and analysis_summary_csv.is_file():
        log.info(f"Loading analysis data from: {analysis_summary_csv}")
        try:
            df = pd.read_csv(analysis_summary_csv)
            summary_data = calculate_summary_stats(df)
            detailed_data_md = df.to_markdown(index=False) # Convert DataFrame to Markdown table
            source_files.append(analysis_summary_csv.name)
        except Exception as e:
            log.error(f"Failed to load or process {analysis_summary_csv}: {e}")
            # Fallback or exit? For now, continue without this data.
    else:
        # TODO: Implement fallback logic if no summary CSV is found.
        # Maybe load individual JSON/YAML files and summarize them directly?
        log.warning(f"Analysis summary file not found at {analysis_summary_csv}. Summary may be incomplete.")
        # Example: Try loading individual analysis YAMLs
        # yaml_files = sorted(list(input_path.rglob("*_analysis.yaml")))
        # if yaml_files: ... process them ...

    # --- Prepare Templating Environment ---
    if template_path:
        template_file = Path(template_path)
        if not template_file.is_file():
            log.error(f"Custom template not found: {template_path}. Using default.")
            template_str = DEFAULT_SUMMARY_TEMPLATE
            env = Environment(loader=FileSystemLoader("."), autoescape=select_autoescape()) # Dummy loader
        else:
            log.info(f"Using custom template: {template_file.name}")
            template_dir = template_file.parent
            env = Environment(loader=FileSystemLoader(template_dir), autoescape=select_autoescape())
            template_str = env.get_template(template_file.name).render(
                summary_stats=summary_data,
                detailed_data=detailed_data_md,
                sources=source_files
            )
    else:
        log.info("Using default summary template.")
        # For default template string, we don't need a file loader
        env = Environment(autoescape=select_autoescape())
        template = env.from_string(DEFAULT_SUMMARY_TEMPLATE)
        template_str = template.render(
            summary_stats=summary_data,
            detailed_data=detailed_data_md,
            sources=source_files
        )


    # --- Save Summary Report ---
    output_file = output_dir / "summary_report.md"
    log.info(f"Saving summary report to: {output_file}")
    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(template_str)
    except Exception as e:
        log.error(f"Failed to save summary report: {e}")
        raise

    log.info("Summarization process completed.")


def calculate_summary_stats(df: pd.DataFrame) -> dict:
    """
    Calculates basic statistics from an analysis DataFrame. (Example)

    Args:
        df: Pandas DataFrame containing analysis results.

    Returns:
        A dictionary with summary statistics.
    """
    if df.empty:
        return {}

    stats = {"total_files": len(df)}

    if "converged" in df.columns:
        # Ensure boolean interpretation handles potential strings/NaNs
        converged_series = pd.to_numeric(df["converged"], errors='coerce').fillna(0).astype(bool)
        stats["converged_count"] = int(converged_series.sum())

    if "total_energy_eV" in df.columns:
        stats["avg_energy"] = df["total_energy_eV"].mean() # mean() ignores NaN by default

    if "band_gap_eV" in df.columns:
        stats["avg_band_gap"] = df["band_gap_eV"].mean()

    # Add more stats as needed (min/max values, std deviations, etc.)

    return stats

