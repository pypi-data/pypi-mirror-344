# coding: utf-8

"""
    3Di API

    3Di simulation API (latest stable version: v3)   Framework release: 3.4.46   3Di core release: 3.6.7  deployed on:  10:05AM (UTC) on April 30, 2025  # noqa: E501

    The version of the OpenAPI document: v3
    Contact: info@nelen-schuurmans.nl
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from threedi_api_client.openapi.api_client import ApiClient
from threedi_api_client.openapi.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class V3Api(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def auth_profile_list(self, **kwargs):  # noqa: E501
        """auth_profile_list  # noqa: E501

        Read-only API endpoint for viewing user details for current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.auth_profile_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.auth_profile_list_with_http_info(**kwargs)  # noqa: E501

    def auth_profile_list_with_http_info(self, **kwargs):  # noqa: E501
        """auth_profile_list  # noqa: E501

        Read-only API endpoint for viewing user details for current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.auth_profile_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(User, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method auth_profile_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/auth/profile/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def auth_refresh_token_create(self, data, **kwargs):  # noqa: E501
        """Refresh API authentication token by refresh_token.  # noqa: E501

        Post \"refresh\" token as \"refresh\".  The return \"access\" token needs to be sent as HTTP authentication header with every request with 'Bearer ' prefix (case-sensitive).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.auth_refresh_token_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Refresh data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Tokens
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.auth_refresh_token_create_with_http_info(data, **kwargs)  # noqa: E501

    def auth_refresh_token_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """Refresh API authentication token by refresh_token.  # noqa: E501

        Post \"refresh\" token as \"refresh\".  The return \"access\" token needs to be sent as HTTP authentication header with every request with 'Bearer ' prefix (case-sensitive).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.auth_refresh_token_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Refresh data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Tokens, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method auth_refresh_token_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `auth_refresh_token_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/auth/refresh-token/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Tokens',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def auth_token_create(self, data, **kwargs):  # noqa: E501
        """Retrieve tokens for API authentication.  # noqa: E501

        There are two ways for retrieving a tokens. The preferred way is attaching a Personal API Key to the request and leave the request body empty. For backwards compatibility, you can also supply your username and password in the request body directly.  The response will contain an \"access\" and \"refresh\" JWT token.  The \"access\" token needs to be sent as HTTP authentication header with every request with a 'Bearer ' prefix (case-sensitive).  Note that the \"access\" token expires after some time.  The \"refresh\" token can be used to get a new access token via the \"refresh\" endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.auth_token_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Authenticate data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Tokens
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.auth_token_create_with_http_info(data, **kwargs)  # noqa: E501

    def auth_token_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """Retrieve tokens for API authentication.  # noqa: E501

        There are two ways for retrieving a tokens. The preferred way is attaching a Personal API Key to the request and leave the request body empty. For backwards compatibility, you can also supply your username and password in the request body directly.  The response will contain an \"access\" and \"refresh\" JWT token.  The \"access\" token needs to be sent as HTTP authentication header with every request with a 'Bearer ' prefix (case-sensitive).  Note that the \"access\" token expires after some time.  The \"refresh\" token can be used to get a new access token via the \"refresh\" endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.auth_token_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Authenticate data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Tokens, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method auth_token_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `auth_token_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/auth/token/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Tokens',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def auth_users_list(self, **kwargs):  # noqa: E501
        """Read-only API endpoint for viewing user details.  # noqa: E501

        - superusers and staff users might view all users - user with a manager role might view all users for the   organisations they have the manager role for - regular users might view their user details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.auth_users_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: username
        :param str username__iexact: username__iexact
        :param str username__contains: username__contains
        :param str username__icontains: username__icontains
        :param str username__in: username__in
        :param str username__startswith: username__startswith
        :param str username__istartswith: username__istartswith
        :param str username__endswith: username__endswith
        :param str username__regex: username__regex
        :param str email: email
        :param str email__iexact: email__iexact
        :param str email__contains: email__contains
        :param str email__icontains: email__icontains
        :param str email__in: email__in
        :param str email__startswith: email__startswith
        :param str email__istartswith: email__istartswith
        :param str email__endswith: email__endswith
        :param str email__regex: email__regex
        :param str remote__external_user_id: remote__external_user_id
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.auth_users_list_with_http_info(**kwargs)  # noqa: E501

    def auth_users_list_with_http_info(self, **kwargs):  # noqa: E501
        """Read-only API endpoint for viewing user details.  # noqa: E501

        - superusers and staff users might view all users - user with a manager role might view all users for the   organisations they have the manager role for - regular users might view their user details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.auth_users_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: username
        :param str username__iexact: username__iexact
        :param str username__contains: username__contains
        :param str username__icontains: username__icontains
        :param str username__in: username__in
        :param str username__startswith: username__startswith
        :param str username__istartswith: username__istartswith
        :param str username__endswith: username__endswith
        :param str username__regex: username__regex
        :param str email: email
        :param str email__iexact: email__iexact
        :param str email__contains: email__contains
        :param str email__icontains: email__icontains
        :param str email__in: email__in
        :param str email__startswith: email__startswith
        :param str email__istartswith: email__istartswith
        :param str email__endswith: email__endswith
        :param str email__regex: email__regex
        :param str remote__external_user_id: remote__external_user_id
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2007, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'username__iexact',
            'username__contains',
            'username__icontains',
            'username__in',
            'username__startswith',
            'username__istartswith',
            'username__endswith',
            'username__regex',
            'email',
            'email__iexact',
            'email__contains',
            'email__icontains',
            'email__in',
            'email__startswith',
            'email__istartswith',
            'email__endswith',
            'email__regex',
            'remote__external_user_id',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method auth_users_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'username' in local_var_params and local_var_params['username'] is not None:  # noqa: E501
            query_params.append(('username', local_var_params['username']))  # noqa: E501
        if 'username__iexact' in local_var_params and local_var_params['username__iexact'] is not None:  # noqa: E501
            query_params.append(('username__iexact', local_var_params['username__iexact']))  # noqa: E501
        if 'username__contains' in local_var_params and local_var_params['username__contains'] is not None:  # noqa: E501
            query_params.append(('username__contains', local_var_params['username__contains']))  # noqa: E501
        if 'username__icontains' in local_var_params and local_var_params['username__icontains'] is not None:  # noqa: E501
            query_params.append(('username__icontains', local_var_params['username__icontains']))  # noqa: E501
        if 'username__in' in local_var_params and local_var_params['username__in'] is not None:  # noqa: E501
            query_params.append(('username__in', local_var_params['username__in']))  # noqa: E501
        if 'username__startswith' in local_var_params and local_var_params['username__startswith'] is not None:  # noqa: E501
            query_params.append(('username__startswith', local_var_params['username__startswith']))  # noqa: E501
        if 'username__istartswith' in local_var_params and local_var_params['username__istartswith'] is not None:  # noqa: E501
            query_params.append(('username__istartswith', local_var_params['username__istartswith']))  # noqa: E501
        if 'username__endswith' in local_var_params and local_var_params['username__endswith'] is not None:  # noqa: E501
            query_params.append(('username__endswith', local_var_params['username__endswith']))  # noqa: E501
        if 'username__regex' in local_var_params and local_var_params['username__regex'] is not None:  # noqa: E501
            query_params.append(('username__regex', local_var_params['username__regex']))  # noqa: E501
        if 'email' in local_var_params and local_var_params['email'] is not None:  # noqa: E501
            query_params.append(('email', local_var_params['email']))  # noqa: E501
        if 'email__iexact' in local_var_params and local_var_params['email__iexact'] is not None:  # noqa: E501
            query_params.append(('email__iexact', local_var_params['email__iexact']))  # noqa: E501
        if 'email__contains' in local_var_params and local_var_params['email__contains'] is not None:  # noqa: E501
            query_params.append(('email__contains', local_var_params['email__contains']))  # noqa: E501
        if 'email__icontains' in local_var_params and local_var_params['email__icontains'] is not None:  # noqa: E501
            query_params.append(('email__icontains', local_var_params['email__icontains']))  # noqa: E501
        if 'email__in' in local_var_params and local_var_params['email__in'] is not None:  # noqa: E501
            query_params.append(('email__in', local_var_params['email__in']))  # noqa: E501
        if 'email__startswith' in local_var_params and local_var_params['email__startswith'] is not None:  # noqa: E501
            query_params.append(('email__startswith', local_var_params['email__startswith']))  # noqa: E501
        if 'email__istartswith' in local_var_params and local_var_params['email__istartswith'] is not None:  # noqa: E501
            query_params.append(('email__istartswith', local_var_params['email__istartswith']))  # noqa: E501
        if 'email__endswith' in local_var_params and local_var_params['email__endswith'] is not None:  # noqa: E501
            query_params.append(('email__endswith', local_var_params['email__endswith']))  # noqa: E501
        if 'email__regex' in local_var_params and local_var_params['email__regex'] is not None:  # noqa: E501
            query_params.append(('email__regex', local_var_params['email__regex']))  # noqa: E501
        if 'remote__external_user_id' in local_var_params and local_var_params['remote__external_user_id'] is not None:  # noqa: E501
            query_params.append(('remote__external_user_id', local_var_params['remote__external_user_id']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/auth/users/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2007',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def auth_users_read(self, id, **kwargs):  # noqa: E501
        """auth_users_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.auth_users_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this user. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.auth_users_read_with_http_info(id, **kwargs)  # noqa: E501

    def auth_users_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """auth_users_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.auth_users_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this user. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(User, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method auth_users_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `auth_users_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/auth/users/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def auth_users_tokens(self, id, **kwargs):  # noqa: E501
        """auth_users_tokens  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.auth_users_tokens(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this user. (required)
        :param list[str] required_scopes:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UserTokens
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.auth_users_tokens_with_http_info(id, **kwargs)  # noqa: E501

    def auth_users_tokens_with_http_info(self, id, **kwargs):  # noqa: E501
        """auth_users_tokens  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.auth_users_tokens_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this user. (required)
        :param list[str] required_scopes:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UserTokens, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'required_scopes'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method auth_users_tokens" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `auth_users_tokens`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'required_scopes' in local_var_params and local_var_params['required_scopes'] is not None:  # noqa: E501
            query_params.append(('required_scopes', local_var_params['required_scopes']))  # noqa: E501
            collection_formats['required_scopes'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/auth/users/{id}/tokens/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserTokens',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_create(self, data, **kwargs):  # noqa: E501
        """contracts_create  # noqa: E501

        API endpoint for interacting with contracts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Contract data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Contract
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.contracts_create_with_http_info(data, **kwargs)  # noqa: E501

    def contracts_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """contracts_create  # noqa: E501

        API endpoint for interacting with contracts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Contract data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Contract, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `contracts_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/contracts/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Contract',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_delete(self, id, **kwargs):  # noqa: E501
        """contracts_delete  # noqa: E501

        API endpoint for interacting with contracts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this contract. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.contracts_delete_with_http_info(id, **kwargs)  # noqa: E501

    def contracts_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """contracts_delete  # noqa: E501

        API endpoint for interacting with contracts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this contract. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `contracts_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/contracts/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_list(self, **kwargs):  # noqa: E501
        """Overview of organisations that have a valid 3Di contract.  # noqa: E501

        List all organisations that already have used some fraction of their calculation quota (for the current year - the `hours_used` property is based on the current calender year) ``` ?hours_used__gt=0 ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organisation__id: organisation__id
        :param str organisation__id__gt: organisation__id__gt
        :param str organisation__id__gte: organisation__id__gte
        :param str organisation__id__lt: organisation__id__lt
        :param str organisation__id__lte: organisation__id__lte
        :param str organisation__id__isnull: organisation__id__isnull
        :param str organisation__name: organisation__name
        :param str organisation__name__iexact: organisation__name__iexact
        :param str organisation__name__contains: organisation__name__contains
        :param str organisation__name__icontains: organisation__name__icontains
        :param str organisation__name__in: organisation__name__in
        :param str organisation__name__startswith: organisation__name__startswith
        :param str organisation__name__istartswith: organisation__name__istartswith
        :param str organisation__name__endswith: organisation__name__endswith
        :param str organisation__name__regex: organisation__name__regex
        :param str organisation__unique_id: organisation__unique_id
        :param str organisation__unique_id__iexact: organisation__unique_id__iexact
        :param str organisation__unique_id__contains: organisation__unique_id__contains
        :param str organisation__unique_id__icontains: organisation__unique_id__icontains
        :param str organisation__unique_id__in: organisation__unique_id__in
        :param str organisation__unique_id__startswith: organisation__unique_id__startswith
        :param str organisation__unique_id__istartswith: organisation__unique_id__istartswith
        :param str organisation__unique_id__endswith: organisation__unique_id__endswith
        :param str organisation__unique_id__regex: organisation__unique_id__regex
        :param str hours_used__gt: hours_used__gt
        :param str hours_used__lt: hours_used__lt
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.contracts_list_with_http_info(**kwargs)  # noqa: E501

    def contracts_list_with_http_info(self, **kwargs):  # noqa: E501
        """Overview of organisations that have a valid 3Di contract.  # noqa: E501

        List all organisations that already have used some fraction of their calculation quota (for the current year - the `hours_used` property is based on the current calender year) ``` ?hours_used__gt=0 ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organisation__id: organisation__id
        :param str organisation__id__gt: organisation__id__gt
        :param str organisation__id__gte: organisation__id__gte
        :param str organisation__id__lt: organisation__id__lt
        :param str organisation__id__lte: organisation__id__lte
        :param str organisation__id__isnull: organisation__id__isnull
        :param str organisation__name: organisation__name
        :param str organisation__name__iexact: organisation__name__iexact
        :param str organisation__name__contains: organisation__name__contains
        :param str organisation__name__icontains: organisation__name__icontains
        :param str organisation__name__in: organisation__name__in
        :param str organisation__name__startswith: organisation__name__startswith
        :param str organisation__name__istartswith: organisation__name__istartswith
        :param str organisation__name__endswith: organisation__name__endswith
        :param str organisation__name__regex: organisation__name__regex
        :param str organisation__unique_id: organisation__unique_id
        :param str organisation__unique_id__iexact: organisation__unique_id__iexact
        :param str organisation__unique_id__contains: organisation__unique_id__contains
        :param str organisation__unique_id__icontains: organisation__unique_id__icontains
        :param str organisation__unique_id__in: organisation__unique_id__in
        :param str organisation__unique_id__startswith: organisation__unique_id__startswith
        :param str organisation__unique_id__istartswith: organisation__unique_id__istartswith
        :param str organisation__unique_id__endswith: organisation__unique_id__endswith
        :param str organisation__unique_id__regex: organisation__unique_id__regex
        :param str hours_used__gt: hours_used__gt
        :param str hours_used__lt: hours_used__lt
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2008, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organisation__id',
            'organisation__id__gt',
            'organisation__id__gte',
            'organisation__id__lt',
            'organisation__id__lte',
            'organisation__id__isnull',
            'organisation__name',
            'organisation__name__iexact',
            'organisation__name__contains',
            'organisation__name__icontains',
            'organisation__name__in',
            'organisation__name__startswith',
            'organisation__name__istartswith',
            'organisation__name__endswith',
            'organisation__name__regex',
            'organisation__unique_id',
            'organisation__unique_id__iexact',
            'organisation__unique_id__contains',
            'organisation__unique_id__icontains',
            'organisation__unique_id__in',
            'organisation__unique_id__startswith',
            'organisation__unique_id__istartswith',
            'organisation__unique_id__endswith',
            'organisation__unique_id__regex',
            'hours_used__gt',
            'hours_used__lt',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'organisation__id' in local_var_params and local_var_params['organisation__id'] is not None:  # noqa: E501
            query_params.append(('organisation__id', local_var_params['organisation__id']))  # noqa: E501
        if 'organisation__id__gt' in local_var_params and local_var_params['organisation__id__gt'] is not None:  # noqa: E501
            query_params.append(('organisation__id__gt', local_var_params['organisation__id__gt']))  # noqa: E501
        if 'organisation__id__gte' in local_var_params and local_var_params['organisation__id__gte'] is not None:  # noqa: E501
            query_params.append(('organisation__id__gte', local_var_params['organisation__id__gte']))  # noqa: E501
        if 'organisation__id__lt' in local_var_params and local_var_params['organisation__id__lt'] is not None:  # noqa: E501
            query_params.append(('organisation__id__lt', local_var_params['organisation__id__lt']))  # noqa: E501
        if 'organisation__id__lte' in local_var_params and local_var_params['organisation__id__lte'] is not None:  # noqa: E501
            query_params.append(('organisation__id__lte', local_var_params['organisation__id__lte']))  # noqa: E501
        if 'organisation__id__isnull' in local_var_params and local_var_params['organisation__id__isnull'] is not None:  # noqa: E501
            query_params.append(('organisation__id__isnull', local_var_params['organisation__id__isnull']))  # noqa: E501
        if 'organisation__name' in local_var_params and local_var_params['organisation__name'] is not None:  # noqa: E501
            query_params.append(('organisation__name', local_var_params['organisation__name']))  # noqa: E501
        if 'organisation__name__iexact' in local_var_params and local_var_params['organisation__name__iexact'] is not None:  # noqa: E501
            query_params.append(('organisation__name__iexact', local_var_params['organisation__name__iexact']))  # noqa: E501
        if 'organisation__name__contains' in local_var_params and local_var_params['organisation__name__contains'] is not None:  # noqa: E501
            query_params.append(('organisation__name__contains', local_var_params['organisation__name__contains']))  # noqa: E501
        if 'organisation__name__icontains' in local_var_params and local_var_params['organisation__name__icontains'] is not None:  # noqa: E501
            query_params.append(('organisation__name__icontains', local_var_params['organisation__name__icontains']))  # noqa: E501
        if 'organisation__name__in' in local_var_params and local_var_params['organisation__name__in'] is not None:  # noqa: E501
            query_params.append(('organisation__name__in', local_var_params['organisation__name__in']))  # noqa: E501
        if 'organisation__name__startswith' in local_var_params and local_var_params['organisation__name__startswith'] is not None:  # noqa: E501
            query_params.append(('organisation__name__startswith', local_var_params['organisation__name__startswith']))  # noqa: E501
        if 'organisation__name__istartswith' in local_var_params and local_var_params['organisation__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('organisation__name__istartswith', local_var_params['organisation__name__istartswith']))  # noqa: E501
        if 'organisation__name__endswith' in local_var_params and local_var_params['organisation__name__endswith'] is not None:  # noqa: E501
            query_params.append(('organisation__name__endswith', local_var_params['organisation__name__endswith']))  # noqa: E501
        if 'organisation__name__regex' in local_var_params and local_var_params['organisation__name__regex'] is not None:  # noqa: E501
            query_params.append(('organisation__name__regex', local_var_params['organisation__name__regex']))  # noqa: E501
        if 'organisation__unique_id' in local_var_params and local_var_params['organisation__unique_id'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id', local_var_params['organisation__unique_id']))  # noqa: E501
        if 'organisation__unique_id__iexact' in local_var_params and local_var_params['organisation__unique_id__iexact'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id__iexact', local_var_params['organisation__unique_id__iexact']))  # noqa: E501
        if 'organisation__unique_id__contains' in local_var_params and local_var_params['organisation__unique_id__contains'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id__contains', local_var_params['organisation__unique_id__contains']))  # noqa: E501
        if 'organisation__unique_id__icontains' in local_var_params and local_var_params['organisation__unique_id__icontains'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id__icontains', local_var_params['organisation__unique_id__icontains']))  # noqa: E501
        if 'organisation__unique_id__in' in local_var_params and local_var_params['organisation__unique_id__in'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id__in', local_var_params['organisation__unique_id__in']))  # noqa: E501
        if 'organisation__unique_id__startswith' in local_var_params and local_var_params['organisation__unique_id__startswith'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id__startswith', local_var_params['organisation__unique_id__startswith']))  # noqa: E501
        if 'organisation__unique_id__istartswith' in local_var_params and local_var_params['organisation__unique_id__istartswith'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id__istartswith', local_var_params['organisation__unique_id__istartswith']))  # noqa: E501
        if 'organisation__unique_id__endswith' in local_var_params and local_var_params['organisation__unique_id__endswith'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id__endswith', local_var_params['organisation__unique_id__endswith']))  # noqa: E501
        if 'organisation__unique_id__regex' in local_var_params and local_var_params['organisation__unique_id__regex'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id__regex', local_var_params['organisation__unique_id__regex']))  # noqa: E501
        if 'hours_used__gt' in local_var_params and local_var_params['hours_used__gt'] is not None:  # noqa: E501
            query_params.append(('hours_used__gt', local_var_params['hours_used__gt']))  # noqa: E501
        if 'hours_used__lt' in local_var_params and local_var_params['hours_used__lt'] is not None:  # noqa: E501
            query_params.append(('hours_used__lt', local_var_params['hours_used__lt']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/contracts/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_partial_update(self, id, data, **kwargs):  # noqa: E501
        """contracts_partial_update  # noqa: E501

        API endpoint for interacting with contracts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this contract. (required)
        :param Contract data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Contract
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.contracts_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def contracts_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """contracts_partial_update  # noqa: E501

        API endpoint for interacting with contracts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this contract. (required)
        :param Contract data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Contract, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `contracts_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `contracts_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/contracts/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Contract',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_read(self, id, **kwargs):  # noqa: E501
        """contracts_read  # noqa: E501

        API endpoint for interacting with contracts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this contract. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Contract
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.contracts_read_with_http_info(id, **kwargs)  # noqa: E501

    def contracts_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """contracts_read  # noqa: E501

        API endpoint for interacting with contracts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this contract. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Contract, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `contracts_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/contracts/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Contract',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_update(self, id, data, **kwargs):  # noqa: E501
        """contracts_update  # noqa: E501

        API endpoint for interacting with contracts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this contract. (required)
        :param Contract data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Contract
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.contracts_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def contracts_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """contracts_update  # noqa: E501

        API endpoint for interacting with contracts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this contract. (required)
        :param Contract data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Contract, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `contracts_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `contracts_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/contracts/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Contract',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_delete(self, id, **kwargs):  # noqa: E501
        """files_delete  # noqa: E501

        A simple ViewSet for viewing files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.files_delete_with_http_info(id, **kwargs)  # noqa: E501

    def files_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """files_delete  # noqa: E501

        A simple ViewSet for viewing files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `files_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/files/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_destroy_file(self, id, **kwargs):  # noqa: E501
        """files_destroy_file  # noqa: E501

        A simple ViewSet for viewing files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_destroy_file(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.files_destroy_file_with_http_info(id, **kwargs)  # noqa: E501

    def files_destroy_file_with_http_info(self, id, **kwargs):  # noqa: E501
        """files_destroy_file  # noqa: E501

        A simple ViewSet for viewing files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_destroy_file_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(File, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_destroy_file" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `files_destroy_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/files/{id}/destroy_file/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='File',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_download(self, id, **kwargs):  # noqa: E501
        """files_download  # noqa: E501

        A simple ViewSet for viewing files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_download(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.files_download_with_http_info(id, **kwargs)  # noqa: E501

    def files_download_with_http_info(self, id, **kwargs):  # noqa: E501
        """files_download  # noqa: E501

        A simple ViewSet for viewing files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_download_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `files_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/files/{id}/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_list(self, **kwargs):  # noqa: E501
        """files_list  # noqa: E501

        A simple ViewSet for viewing files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: filename
        :param str filename__icontains: filename__icontains
        :param str etag: etag
        :param str expiry_date: expiry_date
        :param str expiry_date__lte: expiry_date__lte
        :param str expiry_date__lt: expiry_date__lt
        :param str expiry_date__gte: expiry_date__gte
        :param str expiry_date__gt: expiry_date__gt
        :param str state: state
        :param str state__in: state__in
        :param str type: type
        :param str type__in: type__in
        :param str meta: meta
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.files_list_with_http_info(**kwargs)  # noqa: E501

    def files_list_with_http_info(self, **kwargs):  # noqa: E501
        """files_list  # noqa: E501

        A simple ViewSet for viewing files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: filename
        :param str filename__icontains: filename__icontains
        :param str etag: etag
        :param str expiry_date: expiry_date
        :param str expiry_date__lte: expiry_date__lte
        :param str expiry_date__lt: expiry_date__lt
        :param str expiry_date__gte: expiry_date__gte
        :param str expiry_date__gt: expiry_date__gt
        :param str state: state
        :param str state__in: state__in
        :param str type: type
        :param str type__in: type__in
        :param str meta: meta
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2009, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'filename',
            'filename__icontains',
            'etag',
            'expiry_date',
            'expiry_date__lte',
            'expiry_date__lt',
            'expiry_date__gte',
            'expiry_date__gt',
            'state',
            'state__in',
            'type',
            'type__in',
            'meta',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filename' in local_var_params and local_var_params['filename'] is not None:  # noqa: E501
            query_params.append(('filename', local_var_params['filename']))  # noqa: E501
        if 'filename__icontains' in local_var_params and local_var_params['filename__icontains'] is not None:  # noqa: E501
            query_params.append(('filename__icontains', local_var_params['filename__icontains']))  # noqa: E501
        if 'etag' in local_var_params and local_var_params['etag'] is not None:  # noqa: E501
            query_params.append(('etag', local_var_params['etag']))  # noqa: E501
        if 'expiry_date' in local_var_params and local_var_params['expiry_date'] is not None:  # noqa: E501
            query_params.append(('expiry_date', local_var_params['expiry_date']))  # noqa: E501
        if 'expiry_date__lte' in local_var_params and local_var_params['expiry_date__lte'] is not None:  # noqa: E501
            query_params.append(('expiry_date__lte', local_var_params['expiry_date__lte']))  # noqa: E501
        if 'expiry_date__lt' in local_var_params and local_var_params['expiry_date__lt'] is not None:  # noqa: E501
            query_params.append(('expiry_date__lt', local_var_params['expiry_date__lt']))  # noqa: E501
        if 'expiry_date__gte' in local_var_params and local_var_params['expiry_date__gte'] is not None:  # noqa: E501
            query_params.append(('expiry_date__gte', local_var_params['expiry_date__gte']))  # noqa: E501
        if 'expiry_date__gt' in local_var_params and local_var_params['expiry_date__gt'] is not None:  # noqa: E501
            query_params.append(('expiry_date__gt', local_var_params['expiry_date__gt']))  # noqa: E501
        if 'state' in local_var_params and local_var_params['state'] is not None:  # noqa: E501
            query_params.append(('state', local_var_params['state']))  # noqa: E501
        if 'state__in' in local_var_params and local_var_params['state__in'] is not None:  # noqa: E501
            query_params.append(('state__in', local_var_params['state__in']))  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'type__in' in local_var_params and local_var_params['type__in'] is not None:  # noqa: E501
            query_params.append(('type__in', local_var_params['type__in']))  # noqa: E501
        if 'meta' in local_var_params and local_var_params['meta'] is not None:  # noqa: E501
            query_params.append(('meta', local_var_params['meta']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/files/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2009',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_partial_update(self, id, data, **kwargs):  # noqa: E501
        """files_partial_update  # noqa: E501

        A simple ViewSet for viewing files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file. (required)
        :param File data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.files_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def files_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """files_partial_update  # noqa: E501

        A simple ViewSet for viewing files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file. (required)
        :param File data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(File, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `files_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `files_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/files/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='File',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_processed(self, id, data, **kwargs):  # noqa: E501
        """Endpoint to which the upload-processor can enrich file objects (and their related objects) with metadata.  # noqa: E501

        For example the geotransform of raster files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_processed(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file. (required)
        :param FileMeta data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.files_processed_with_http_info(id, data, **kwargs)  # noqa: E501

    def files_processed_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """Endpoint to which the upload-processor can enrich file objects (and their related objects) with metadata.  # noqa: E501

        For example the geotransform of raster files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_processed_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file. (required)
        :param FileMeta data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_processed" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `files_processed`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `files_processed`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/files/{id}/processed/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_read(self, id, **kwargs):  # noqa: E501
        """files_read  # noqa: E501

        A simple ViewSet for viewing files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.files_read_with_http_info(id, **kwargs)  # noqa: E501

    def files_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """files_read  # noqa: E501

        A simple ViewSet for viewing files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(File, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `files_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/files/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='File',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_update(self, id, data, **kwargs):  # noqa: E501
        """files_update  # noqa: E501

        A simple ViewSet for viewing files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file. (required)
        :param File data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.files_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def files_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """files_update  # noqa: E501

        A simple ViewSet for viewing files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file. (required)
        :param File data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(File, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `files_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `files_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/files/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='File',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def inpy_versions_create(self, data, **kwargs):  # noqa: E501
        """inpy_versions_create  # noqa: E501

        Inpy was the service for preparing user-supplied schematisations into 3Di models (threedimodels) usable by the 3Di calculation core.  Currently, this route is pending deprecation: most newly generated 3Di models will carry an empty inpy_version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.inpy_versions_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param InpyVersion data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InpyVersion
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.inpy_versions_create_with_http_info(data, **kwargs)  # noqa: E501

    def inpy_versions_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """inpy_versions_create  # noqa: E501

        Inpy was the service for preparing user-supplied schematisations into 3Di models (threedimodels) usable by the 3Di calculation core.  Currently, this route is pending deprecation: most newly generated 3Di models will carry an empty inpy_version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.inpy_versions_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param InpyVersion data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InpyVersion, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method inpy_versions_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `inpy_versions_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/inpy-versions/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InpyVersion',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def inpy_versions_delete(self, id, **kwargs):  # noqa: E501
        """inpy_versions_delete  # noqa: E501

        Inpy was the service for preparing user-supplied schematisations into 3Di models (threedimodels) usable by the 3Di calculation core.  Currently, this route is pending deprecation: most newly generated 3Di models will carry an empty inpy_version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.inpy_versions_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this inpy version. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.inpy_versions_delete_with_http_info(id, **kwargs)  # noqa: E501

    def inpy_versions_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """inpy_versions_delete  # noqa: E501

        Inpy was the service for preparing user-supplied schematisations into 3Di models (threedimodels) usable by the 3Di calculation core.  Currently, this route is pending deprecation: most newly generated 3Di models will carry an empty inpy_version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.inpy_versions_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this inpy version. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method inpy_versions_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `inpy_versions_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/inpy-versions/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def inpy_versions_list(self, **kwargs):  # noqa: E501
        """inpy_versions_list  # noqa: E501

        Inpy was the service for preparing user-supplied schematisations into 3Di models (threedimodels) usable by the 3Di calculation core.  Currently, this route is pending deprecation: most newly generated 3Di models will carry an empty inpy_version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.inpy_versions_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedi_version: threedi_version
        :param str threedi_version__iexact: threedi_version__iexact
        :param str threedi_version__contains: threedi_version__contains
        :param str threedi_version__icontains: threedi_version__icontains
        :param str threedi_version__in: threedi_version__in
        :param str threedi_version__startswith: threedi_version__startswith
        :param str threedi_version__istartswith: threedi_version__istartswith
        :param str threedi_version__endswith: threedi_version__endswith
        :param str threedi_version__regex: threedi_version__regex
        :param str threedicore_version: threedicore_version
        :param str threedicore_version__iexact: threedicore_version__iexact
        :param str threedicore_version__contains: threedicore_version__contains
        :param str threedicore_version__icontains: threedicore_version__icontains
        :param str threedicore_version__in: threedicore_version__in
        :param str threedicore_version__startswith: threedicore_version__startswith
        :param str threedicore_version__istartswith: threedicore_version__istartswith
        :param str threedicore_version__endswith: threedicore_version__endswith
        :param str threedicore_version__regex: threedicore_version__regex
        :param str slug: slug
        :param str slug__iexact: slug__iexact
        :param str slug__contains: slug__contains
        :param str slug__icontains: slug__icontains
        :param str slug__in: slug__in
        :param str slug__startswith: slug__startswith
        :param str slug__istartswith: slug__istartswith
        :param str slug__endswith: slug__endswith
        :param str slug__regex: slug__regex
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.inpy_versions_list_with_http_info(**kwargs)  # noqa: E501

    def inpy_versions_list_with_http_info(self, **kwargs):  # noqa: E501
        """inpy_versions_list  # noqa: E501

        Inpy was the service for preparing user-supplied schematisations into 3Di models (threedimodels) usable by the 3Di calculation core.  Currently, this route is pending deprecation: most newly generated 3Di models will carry an empty inpy_version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.inpy_versions_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedi_version: threedi_version
        :param str threedi_version__iexact: threedi_version__iexact
        :param str threedi_version__contains: threedi_version__contains
        :param str threedi_version__icontains: threedi_version__icontains
        :param str threedi_version__in: threedi_version__in
        :param str threedi_version__startswith: threedi_version__startswith
        :param str threedi_version__istartswith: threedi_version__istartswith
        :param str threedi_version__endswith: threedi_version__endswith
        :param str threedi_version__regex: threedi_version__regex
        :param str threedicore_version: threedicore_version
        :param str threedicore_version__iexact: threedicore_version__iexact
        :param str threedicore_version__contains: threedicore_version__contains
        :param str threedicore_version__icontains: threedicore_version__icontains
        :param str threedicore_version__in: threedicore_version__in
        :param str threedicore_version__startswith: threedicore_version__startswith
        :param str threedicore_version__istartswith: threedicore_version__istartswith
        :param str threedicore_version__endswith: threedicore_version__endswith
        :param str threedicore_version__regex: threedicore_version__regex
        :param str slug: slug
        :param str slug__iexact: slug__iexact
        :param str slug__contains: slug__contains
        :param str slug__icontains: slug__icontains
        :param str slug__in: slug__in
        :param str slug__startswith: slug__startswith
        :param str slug__istartswith: slug__istartswith
        :param str slug__endswith: slug__endswith
        :param str slug__regex: slug__regex
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20010, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'threedi_version',
            'threedi_version__iexact',
            'threedi_version__contains',
            'threedi_version__icontains',
            'threedi_version__in',
            'threedi_version__startswith',
            'threedi_version__istartswith',
            'threedi_version__endswith',
            'threedi_version__regex',
            'threedicore_version',
            'threedicore_version__iexact',
            'threedicore_version__contains',
            'threedicore_version__icontains',
            'threedicore_version__in',
            'threedicore_version__startswith',
            'threedicore_version__istartswith',
            'threedicore_version__endswith',
            'threedicore_version__regex',
            'slug',
            'slug__iexact',
            'slug__contains',
            'slug__icontains',
            'slug__in',
            'slug__startswith',
            'slug__istartswith',
            'slug__endswith',
            'slug__regex',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method inpy_versions_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'threedi_version' in local_var_params and local_var_params['threedi_version'] is not None:  # noqa: E501
            query_params.append(('threedi_version', local_var_params['threedi_version']))  # noqa: E501
        if 'threedi_version__iexact' in local_var_params and local_var_params['threedi_version__iexact'] is not None:  # noqa: E501
            query_params.append(('threedi_version__iexact', local_var_params['threedi_version__iexact']))  # noqa: E501
        if 'threedi_version__contains' in local_var_params and local_var_params['threedi_version__contains'] is not None:  # noqa: E501
            query_params.append(('threedi_version__contains', local_var_params['threedi_version__contains']))  # noqa: E501
        if 'threedi_version__icontains' in local_var_params and local_var_params['threedi_version__icontains'] is not None:  # noqa: E501
            query_params.append(('threedi_version__icontains', local_var_params['threedi_version__icontains']))  # noqa: E501
        if 'threedi_version__in' in local_var_params and local_var_params['threedi_version__in'] is not None:  # noqa: E501
            query_params.append(('threedi_version__in', local_var_params['threedi_version__in']))  # noqa: E501
        if 'threedi_version__startswith' in local_var_params and local_var_params['threedi_version__startswith'] is not None:  # noqa: E501
            query_params.append(('threedi_version__startswith', local_var_params['threedi_version__startswith']))  # noqa: E501
        if 'threedi_version__istartswith' in local_var_params and local_var_params['threedi_version__istartswith'] is not None:  # noqa: E501
            query_params.append(('threedi_version__istartswith', local_var_params['threedi_version__istartswith']))  # noqa: E501
        if 'threedi_version__endswith' in local_var_params and local_var_params['threedi_version__endswith'] is not None:  # noqa: E501
            query_params.append(('threedi_version__endswith', local_var_params['threedi_version__endswith']))  # noqa: E501
        if 'threedi_version__regex' in local_var_params and local_var_params['threedi_version__regex'] is not None:  # noqa: E501
            query_params.append(('threedi_version__regex', local_var_params['threedi_version__regex']))  # noqa: E501
        if 'threedicore_version' in local_var_params and local_var_params['threedicore_version'] is not None:  # noqa: E501
            query_params.append(('threedicore_version', local_var_params['threedicore_version']))  # noqa: E501
        if 'threedicore_version__iexact' in local_var_params and local_var_params['threedicore_version__iexact'] is not None:  # noqa: E501
            query_params.append(('threedicore_version__iexact', local_var_params['threedicore_version__iexact']))  # noqa: E501
        if 'threedicore_version__contains' in local_var_params and local_var_params['threedicore_version__contains'] is not None:  # noqa: E501
            query_params.append(('threedicore_version__contains', local_var_params['threedicore_version__contains']))  # noqa: E501
        if 'threedicore_version__icontains' in local_var_params and local_var_params['threedicore_version__icontains'] is not None:  # noqa: E501
            query_params.append(('threedicore_version__icontains', local_var_params['threedicore_version__icontains']))  # noqa: E501
        if 'threedicore_version__in' in local_var_params and local_var_params['threedicore_version__in'] is not None:  # noqa: E501
            query_params.append(('threedicore_version__in', local_var_params['threedicore_version__in']))  # noqa: E501
        if 'threedicore_version__startswith' in local_var_params and local_var_params['threedicore_version__startswith'] is not None:  # noqa: E501
            query_params.append(('threedicore_version__startswith', local_var_params['threedicore_version__startswith']))  # noqa: E501
        if 'threedicore_version__istartswith' in local_var_params and local_var_params['threedicore_version__istartswith'] is not None:  # noqa: E501
            query_params.append(('threedicore_version__istartswith', local_var_params['threedicore_version__istartswith']))  # noqa: E501
        if 'threedicore_version__endswith' in local_var_params and local_var_params['threedicore_version__endswith'] is not None:  # noqa: E501
            query_params.append(('threedicore_version__endswith', local_var_params['threedicore_version__endswith']))  # noqa: E501
        if 'threedicore_version__regex' in local_var_params and local_var_params['threedicore_version__regex'] is not None:  # noqa: E501
            query_params.append(('threedicore_version__regex', local_var_params['threedicore_version__regex']))  # noqa: E501
        if 'slug' in local_var_params and local_var_params['slug'] is not None:  # noqa: E501
            query_params.append(('slug', local_var_params['slug']))  # noqa: E501
        if 'slug__iexact' in local_var_params and local_var_params['slug__iexact'] is not None:  # noqa: E501
            query_params.append(('slug__iexact', local_var_params['slug__iexact']))  # noqa: E501
        if 'slug__contains' in local_var_params and local_var_params['slug__contains'] is not None:  # noqa: E501
            query_params.append(('slug__contains', local_var_params['slug__contains']))  # noqa: E501
        if 'slug__icontains' in local_var_params and local_var_params['slug__icontains'] is not None:  # noqa: E501
            query_params.append(('slug__icontains', local_var_params['slug__icontains']))  # noqa: E501
        if 'slug__in' in local_var_params and local_var_params['slug__in'] is not None:  # noqa: E501
            query_params.append(('slug__in', local_var_params['slug__in']))  # noqa: E501
        if 'slug__startswith' in local_var_params and local_var_params['slug__startswith'] is not None:  # noqa: E501
            query_params.append(('slug__startswith', local_var_params['slug__startswith']))  # noqa: E501
        if 'slug__istartswith' in local_var_params and local_var_params['slug__istartswith'] is not None:  # noqa: E501
            query_params.append(('slug__istartswith', local_var_params['slug__istartswith']))  # noqa: E501
        if 'slug__endswith' in local_var_params and local_var_params['slug__endswith'] is not None:  # noqa: E501
            query_params.append(('slug__endswith', local_var_params['slug__endswith']))  # noqa: E501
        if 'slug__regex' in local_var_params and local_var_params['slug__regex'] is not None:  # noqa: E501
            query_params.append(('slug__regex', local_var_params['slug__regex']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/inpy-versions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20010',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def inpy_versions_partial_update(self, id, data, **kwargs):  # noqa: E501
        """inpy_versions_partial_update  # noqa: E501

        Inpy was the service for preparing user-supplied schematisations into 3Di models (threedimodels) usable by the 3Di calculation core.  Currently, this route is pending deprecation: most newly generated 3Di models will carry an empty inpy_version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.inpy_versions_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this inpy version. (required)
        :param InpyVersion data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InpyVersion
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.inpy_versions_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def inpy_versions_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """inpy_versions_partial_update  # noqa: E501

        Inpy was the service for preparing user-supplied schematisations into 3Di models (threedimodels) usable by the 3Di calculation core.  Currently, this route is pending deprecation: most newly generated 3Di models will carry an empty inpy_version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.inpy_versions_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this inpy version. (required)
        :param InpyVersion data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InpyVersion, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method inpy_versions_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `inpy_versions_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `inpy_versions_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/inpy-versions/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InpyVersion',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def inpy_versions_read(self, id, **kwargs):  # noqa: E501
        """inpy_versions_read  # noqa: E501

        Inpy was the service for preparing user-supplied schematisations into 3Di models (threedimodels) usable by the 3Di calculation core.  Currently, this route is pending deprecation: most newly generated 3Di models will carry an empty inpy_version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.inpy_versions_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this inpy version. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InpyVersion
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.inpy_versions_read_with_http_info(id, **kwargs)  # noqa: E501

    def inpy_versions_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """inpy_versions_read  # noqa: E501

        Inpy was the service for preparing user-supplied schematisations into 3Di models (threedimodels) usable by the 3Di calculation core.  Currently, this route is pending deprecation: most newly generated 3Di models will carry an empty inpy_version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.inpy_versions_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this inpy version. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InpyVersion, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method inpy_versions_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `inpy_versions_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/inpy-versions/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InpyVersion',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def inpy_versions_update(self, id, data, **kwargs):  # noqa: E501
        """inpy_versions_update  # noqa: E501

        Inpy was the service for preparing user-supplied schematisations into 3Di models (threedimodels) usable by the 3Di calculation core.  Currently, this route is pending deprecation: most newly generated 3Di models will carry an empty inpy_version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.inpy_versions_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this inpy version. (required)
        :param InpyVersion data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InpyVersion
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.inpy_versions_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def inpy_versions_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """inpy_versions_update  # noqa: E501

        Inpy was the service for preparing user-supplied schematisations into 3Di models (threedimodels) usable by the 3Di calculation core.  Currently, this route is pending deprecation: most newly generated 3Di models will carry an empty inpy_version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.inpy_versions_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this inpy version. (required)
        :param InpyVersion data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InpyVersion, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method inpy_versions_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `inpy_versions_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `inpy_versions_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/inpy-versions/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InpyVersion',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def organisation_settings_create(self, data, **kwargs):  # noqa: E501
        """organisation_settings_create  # noqa: E501

        API endpoint for interacting with organisation settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisation_settings_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Settings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Settings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.organisation_settings_create_with_http_info(data, **kwargs)  # noqa: E501

    def organisation_settings_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """organisation_settings_create  # noqa: E501

        API endpoint for interacting with organisation settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisation_settings_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Settings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Settings, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organisation_settings_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `organisation_settings_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/organisation-settings/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Settings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def organisation_settings_delete(self, id, **kwargs):  # noqa: E501
        """organisation_settings_delete  # noqa: E501

        API endpoint for interacting with organisation settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisation_settings_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this organisation settings. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.organisation_settings_delete_with_http_info(id, **kwargs)  # noqa: E501

    def organisation_settings_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """organisation_settings_delete  # noqa: E501

        API endpoint for interacting with organisation settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisation_settings_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this organisation settings. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organisation_settings_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `organisation_settings_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/organisation-settings/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def organisation_settings_list(self, **kwargs):  # noqa: E501
        """organisation_settings_list  # noqa: E501

        API endpoint for interacting with organisation settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisation_settings_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.organisation_settings_list_with_http_info(**kwargs)  # noqa: E501

    def organisation_settings_list_with_http_info(self, **kwargs):  # noqa: E501
        """organisation_settings_list  # noqa: E501

        API endpoint for interacting with organisation settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisation_settings_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20011, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organisation_settings_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/organisation-settings/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def organisation_settings_partial_update(self, id, data, **kwargs):  # noqa: E501
        """organisation_settings_partial_update  # noqa: E501

        API endpoint for interacting with organisation settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisation_settings_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this organisation settings. (required)
        :param Settings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Settings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.organisation_settings_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def organisation_settings_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """organisation_settings_partial_update  # noqa: E501

        API endpoint for interacting with organisation settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisation_settings_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this organisation settings. (required)
        :param Settings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Settings, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organisation_settings_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `organisation_settings_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `organisation_settings_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/organisation-settings/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Settings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def organisation_settings_read(self, id, **kwargs):  # noqa: E501
        """organisation_settings_read  # noqa: E501

        API endpoint for interacting with organisation settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisation_settings_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this organisation settings. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Settings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.organisation_settings_read_with_http_info(id, **kwargs)  # noqa: E501

    def organisation_settings_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """organisation_settings_read  # noqa: E501

        API endpoint for interacting with organisation settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisation_settings_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this organisation settings. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Settings, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organisation_settings_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `organisation_settings_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/organisation-settings/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Settings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def organisation_settings_update(self, id, data, **kwargs):  # noqa: E501
        """organisation_settings_update  # noqa: E501

        API endpoint for interacting with organisation settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisation_settings_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this organisation settings. (required)
        :param Settings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Settings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.organisation_settings_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def organisation_settings_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """organisation_settings_update  # noqa: E501

        API endpoint for interacting with organisation settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisation_settings_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this organisation settings. (required)
        :param Settings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Settings, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organisation_settings_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `organisation_settings_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `organisation_settings_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/organisation-settings/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Settings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def organisations_list(self, **kwargs):  # noqa: E501
        """organisations_list  # noqa: E501

        Read-only API endpoint for interacting with organisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisations_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: name
        :param str name__iexact: name__iexact
        :param str name__contains: name__contains
        :param str name__icontains: name__icontains
        :param str name__in: name__in
        :param str name__startswith: name__startswith
        :param str name__istartswith: name__istartswith
        :param str name__endswith: name__endswith
        :param str name__regex: name__regex
        :param str unique_id: unique_id
        :param str unique_id__iexact: unique_id__iexact
        :param str unique_id__contains: unique_id__contains
        :param str unique_id__icontains: unique_id__icontains
        :param str unique_id__in: unique_id__in
        :param str unique_id__startswith: unique_id__startswith
        :param str unique_id__istartswith: unique_id__istartswith
        :param str unique_id__endswith: unique_id__endswith
        :param str unique_id__regex: unique_id__regex
        :param str valid_contracts_only: valid_contracts_only
        :param str logged_in_user_has_role: logged_in_user_has_role
        :param str contract__scope__in: contract__scope__contains
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.organisations_list_with_http_info(**kwargs)  # noqa: E501

    def organisations_list_with_http_info(self, **kwargs):  # noqa: E501
        """organisations_list  # noqa: E501

        Read-only API endpoint for interacting with organisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisations_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: name
        :param str name__iexact: name__iexact
        :param str name__contains: name__contains
        :param str name__icontains: name__icontains
        :param str name__in: name__in
        :param str name__startswith: name__startswith
        :param str name__istartswith: name__istartswith
        :param str name__endswith: name__endswith
        :param str name__regex: name__regex
        :param str unique_id: unique_id
        :param str unique_id__iexact: unique_id__iexact
        :param str unique_id__contains: unique_id__contains
        :param str unique_id__icontains: unique_id__icontains
        :param str unique_id__in: unique_id__in
        :param str unique_id__startswith: unique_id__startswith
        :param str unique_id__istartswith: unique_id__istartswith
        :param str unique_id__endswith: unique_id__endswith
        :param str unique_id__regex: unique_id__regex
        :param str valid_contracts_only: valid_contracts_only
        :param str logged_in_user_has_role: logged_in_user_has_role
        :param str contract__scope__in: contract__scope__contains
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20012, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'name__iexact',
            'name__contains',
            'name__icontains',
            'name__in',
            'name__startswith',
            'name__istartswith',
            'name__endswith',
            'name__regex',
            'unique_id',
            'unique_id__iexact',
            'unique_id__contains',
            'unique_id__icontains',
            'unique_id__in',
            'unique_id__startswith',
            'unique_id__istartswith',
            'unique_id__endswith',
            'unique_id__regex',
            'valid_contracts_only',
            'logged_in_user_has_role',
            'contract__scope__in',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organisations_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'name__iexact' in local_var_params and local_var_params['name__iexact'] is not None:  # noqa: E501
            query_params.append(('name__iexact', local_var_params['name__iexact']))  # noqa: E501
        if 'name__contains' in local_var_params and local_var_params['name__contains'] is not None:  # noqa: E501
            query_params.append(('name__contains', local_var_params['name__contains']))  # noqa: E501
        if 'name__icontains' in local_var_params and local_var_params['name__icontains'] is not None:  # noqa: E501
            query_params.append(('name__icontains', local_var_params['name__icontains']))  # noqa: E501
        if 'name__in' in local_var_params and local_var_params['name__in'] is not None:  # noqa: E501
            query_params.append(('name__in', local_var_params['name__in']))  # noqa: E501
        if 'name__startswith' in local_var_params and local_var_params['name__startswith'] is not None:  # noqa: E501
            query_params.append(('name__startswith', local_var_params['name__startswith']))  # noqa: E501
        if 'name__istartswith' in local_var_params and local_var_params['name__istartswith'] is not None:  # noqa: E501
            query_params.append(('name__istartswith', local_var_params['name__istartswith']))  # noqa: E501
        if 'name__endswith' in local_var_params and local_var_params['name__endswith'] is not None:  # noqa: E501
            query_params.append(('name__endswith', local_var_params['name__endswith']))  # noqa: E501
        if 'name__regex' in local_var_params and local_var_params['name__regex'] is not None:  # noqa: E501
            query_params.append(('name__regex', local_var_params['name__regex']))  # noqa: E501
        if 'unique_id' in local_var_params and local_var_params['unique_id'] is not None:  # noqa: E501
            query_params.append(('unique_id', local_var_params['unique_id']))  # noqa: E501
        if 'unique_id__iexact' in local_var_params and local_var_params['unique_id__iexact'] is not None:  # noqa: E501
            query_params.append(('unique_id__iexact', local_var_params['unique_id__iexact']))  # noqa: E501
        if 'unique_id__contains' in local_var_params and local_var_params['unique_id__contains'] is not None:  # noqa: E501
            query_params.append(('unique_id__contains', local_var_params['unique_id__contains']))  # noqa: E501
        if 'unique_id__icontains' in local_var_params and local_var_params['unique_id__icontains'] is not None:  # noqa: E501
            query_params.append(('unique_id__icontains', local_var_params['unique_id__icontains']))  # noqa: E501
        if 'unique_id__in' in local_var_params and local_var_params['unique_id__in'] is not None:  # noqa: E501
            query_params.append(('unique_id__in', local_var_params['unique_id__in']))  # noqa: E501
        if 'unique_id__startswith' in local_var_params and local_var_params['unique_id__startswith'] is not None:  # noqa: E501
            query_params.append(('unique_id__startswith', local_var_params['unique_id__startswith']))  # noqa: E501
        if 'unique_id__istartswith' in local_var_params and local_var_params['unique_id__istartswith'] is not None:  # noqa: E501
            query_params.append(('unique_id__istartswith', local_var_params['unique_id__istartswith']))  # noqa: E501
        if 'unique_id__endswith' in local_var_params and local_var_params['unique_id__endswith'] is not None:  # noqa: E501
            query_params.append(('unique_id__endswith', local_var_params['unique_id__endswith']))  # noqa: E501
        if 'unique_id__regex' in local_var_params and local_var_params['unique_id__regex'] is not None:  # noqa: E501
            query_params.append(('unique_id__regex', local_var_params['unique_id__regex']))  # noqa: E501
        if 'valid_contracts_only' in local_var_params and local_var_params['valid_contracts_only'] is not None:  # noqa: E501
            query_params.append(('valid_contracts_only', local_var_params['valid_contracts_only']))  # noqa: E501
        if 'logged_in_user_has_role' in local_var_params and local_var_params['logged_in_user_has_role'] is not None:  # noqa: E501
            query_params.append(('logged_in_user_has_role', local_var_params['logged_in_user_has_role']))  # noqa: E501
        if 'contract__scope__in' in local_var_params and local_var_params['contract__scope__in'] is not None:  # noqa: E501
            query_params.append(('contract__scope__in', local_var_params['contract__scope__in']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/organisations/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20012',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def organisations_permissions(self, unique_id, **kwargs):  # noqa: E501
        """organisations_permissions  # noqa: E501

        Read-only API endpoint for interacting with organisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisations_permissions(unique_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str unique_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[OrganisationRole]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.organisations_permissions_with_http_info(unique_id, **kwargs)  # noqa: E501

    def organisations_permissions_with_http_info(self, unique_id, **kwargs):  # noqa: E501
        """organisations_permissions  # noqa: E501

        Read-only API endpoint for interacting with organisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisations_permissions_with_http_info(unique_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str unique_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[OrganisationRole], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'unique_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organisations_permissions" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'unique_id' is set
        if self.api_client.client_side_validation and ('unique_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['unique_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `unique_id` when calling `organisations_permissions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'unique_id' in local_var_params:
            path_params['unique_id'] = local_var_params['unique_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/organisations/{unique_id}/permissions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[OrganisationRole]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def organisations_read(self, unique_id, **kwargs):  # noqa: E501
        """organisations_read  # noqa: E501

        Read-only API endpoint for interacting with organisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisations_read(unique_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str unique_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Organisation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.organisations_read_with_http_info(unique_id, **kwargs)  # noqa: E501

    def organisations_read_with_http_info(self, unique_id, **kwargs):  # noqa: E501
        """organisations_read  # noqa: E501

        Read-only API endpoint for interacting with organisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisations_read_with_http_info(unique_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str unique_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Organisation, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'unique_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organisations_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'unique_id' is set
        if self.api_client.client_side_validation and ('unique_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['unique_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `unique_id` when calling `organisations_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'unique_id' in local_var_params:
            path_params['unique_id'] = local_var_params['unique_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/organisations/{unique_id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Organisation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def organisations_users_list(self, unique_id, **kwargs):  # noqa: E501
        """organisations_users_list  # noqa: E501

        Endpoint for interacting with users in an organisation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisations_users_list(unique_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str unique_id: (required)
        :param str username: username
        :param str username__iexact: username__iexact
        :param str username__contains: username__contains
        :param str username__icontains: username__icontains
        :param str username__in: username__in
        :param str username__startswith: username__startswith
        :param str username__istartswith: username__istartswith
        :param str username__endswith: username__endswith
        :param str username__regex: username__regex
        :param str email: email
        :param str email__iexact: email__iexact
        :param str email__contains: email__contains
        :param str email__icontains: email__icontains
        :param str email__in: email__in
        :param str email__startswith: email__startswith
        :param str email__istartswith: email__istartswith
        :param str email__endswith: email__endswith
        :param str email__regex: email__regex
        :param str remote__external_user_id: remote__external_user_id
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.organisations_users_list_with_http_info(unique_id, **kwargs)  # noqa: E501

    def organisations_users_list_with_http_info(self, unique_id, **kwargs):  # noqa: E501
        """organisations_users_list  # noqa: E501

        Endpoint for interacting with users in an organisation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisations_users_list_with_http_info(unique_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str unique_id: (required)
        :param str username: username
        :param str username__iexact: username__iexact
        :param str username__contains: username__contains
        :param str username__icontains: username__icontains
        :param str username__in: username__in
        :param str username__startswith: username__startswith
        :param str username__istartswith: username__istartswith
        :param str username__endswith: username__endswith
        :param str username__regex: username__regex
        :param str email: email
        :param str email__iexact: email__iexact
        :param str email__contains: email__contains
        :param str email__icontains: email__icontains
        :param str email__in: email__in
        :param str email__startswith: email__startswith
        :param str email__istartswith: email__istartswith
        :param str email__endswith: email__endswith
        :param str email__regex: email__regex
        :param str remote__external_user_id: remote__external_user_id
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20013, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'unique_id',
            'username',
            'username__iexact',
            'username__contains',
            'username__icontains',
            'username__in',
            'username__startswith',
            'username__istartswith',
            'username__endswith',
            'username__regex',
            'email',
            'email__iexact',
            'email__contains',
            'email__icontains',
            'email__in',
            'email__startswith',
            'email__istartswith',
            'email__endswith',
            'email__regex',
            'remote__external_user_id',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organisations_users_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'unique_id' is set
        if self.api_client.client_side_validation and ('unique_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['unique_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `unique_id` when calling `organisations_users_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'unique_id' in local_var_params:
            path_params['unique_id'] = local_var_params['unique_id']  # noqa: E501

        query_params = []
        if 'username' in local_var_params and local_var_params['username'] is not None:  # noqa: E501
            query_params.append(('username', local_var_params['username']))  # noqa: E501
        if 'username__iexact' in local_var_params and local_var_params['username__iexact'] is not None:  # noqa: E501
            query_params.append(('username__iexact', local_var_params['username__iexact']))  # noqa: E501
        if 'username__contains' in local_var_params and local_var_params['username__contains'] is not None:  # noqa: E501
            query_params.append(('username__contains', local_var_params['username__contains']))  # noqa: E501
        if 'username__icontains' in local_var_params and local_var_params['username__icontains'] is not None:  # noqa: E501
            query_params.append(('username__icontains', local_var_params['username__icontains']))  # noqa: E501
        if 'username__in' in local_var_params and local_var_params['username__in'] is not None:  # noqa: E501
            query_params.append(('username__in', local_var_params['username__in']))  # noqa: E501
        if 'username__startswith' in local_var_params and local_var_params['username__startswith'] is not None:  # noqa: E501
            query_params.append(('username__startswith', local_var_params['username__startswith']))  # noqa: E501
        if 'username__istartswith' in local_var_params and local_var_params['username__istartswith'] is not None:  # noqa: E501
            query_params.append(('username__istartswith', local_var_params['username__istartswith']))  # noqa: E501
        if 'username__endswith' in local_var_params and local_var_params['username__endswith'] is not None:  # noqa: E501
            query_params.append(('username__endswith', local_var_params['username__endswith']))  # noqa: E501
        if 'username__regex' in local_var_params and local_var_params['username__regex'] is not None:  # noqa: E501
            query_params.append(('username__regex', local_var_params['username__regex']))  # noqa: E501
        if 'email' in local_var_params and local_var_params['email'] is not None:  # noqa: E501
            query_params.append(('email', local_var_params['email']))  # noqa: E501
        if 'email__iexact' in local_var_params and local_var_params['email__iexact'] is not None:  # noqa: E501
            query_params.append(('email__iexact', local_var_params['email__iexact']))  # noqa: E501
        if 'email__contains' in local_var_params and local_var_params['email__contains'] is not None:  # noqa: E501
            query_params.append(('email__contains', local_var_params['email__contains']))  # noqa: E501
        if 'email__icontains' in local_var_params and local_var_params['email__icontains'] is not None:  # noqa: E501
            query_params.append(('email__icontains', local_var_params['email__icontains']))  # noqa: E501
        if 'email__in' in local_var_params and local_var_params['email__in'] is not None:  # noqa: E501
            query_params.append(('email__in', local_var_params['email__in']))  # noqa: E501
        if 'email__startswith' in local_var_params and local_var_params['email__startswith'] is not None:  # noqa: E501
            query_params.append(('email__startswith', local_var_params['email__startswith']))  # noqa: E501
        if 'email__istartswith' in local_var_params and local_var_params['email__istartswith'] is not None:  # noqa: E501
            query_params.append(('email__istartswith', local_var_params['email__istartswith']))  # noqa: E501
        if 'email__endswith' in local_var_params and local_var_params['email__endswith'] is not None:  # noqa: E501
            query_params.append(('email__endswith', local_var_params['email__endswith']))  # noqa: E501
        if 'email__regex' in local_var_params and local_var_params['email__regex'] is not None:  # noqa: E501
            query_params.append(('email__regex', local_var_params['email__regex']))  # noqa: E501
        if 'remote__external_user_id' in local_var_params and local_var_params['remote__external_user_id'] is not None:  # noqa: E501
            query_params.append(('remote__external_user_id', local_var_params['remote__external_user_id']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/organisations/{unique_id}/users/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20013',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def organisations_users_partial_update(self, id, unique_id, data, **kwargs):  # noqa: E501
        """organisations_users_partial_update  # noqa: E501

        Patch the roles of a user in this organisation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisations_users_partial_update(id, unique_id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this user. (required)
        :param str unique_id: (required)
        :param OrganisationUserRolePatch data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganisationUser
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.organisations_users_partial_update_with_http_info(id, unique_id, data, **kwargs)  # noqa: E501

    def organisations_users_partial_update_with_http_info(self, id, unique_id, data, **kwargs):  # noqa: E501
        """organisations_users_partial_update  # noqa: E501

        Patch the roles of a user in this organisation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisations_users_partial_update_with_http_info(id, unique_id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this user. (required)
        :param str unique_id: (required)
        :param OrganisationUserRolePatch data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganisationUser, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'unique_id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organisations_users_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `organisations_users_partial_update`")  # noqa: E501
        # verify the required parameter 'unique_id' is set
        if self.api_client.client_side_validation and ('unique_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['unique_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `unique_id` when calling `organisations_users_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `organisations_users_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'unique_id' in local_var_params:
            path_params['unique_id'] = local_var_params['unique_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/organisations/{unique_id}/users/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganisationUser',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def organisations_users_read(self, id, unique_id, **kwargs):  # noqa: E501
        """organisations_users_read  # noqa: E501

        Endpoint for interacting with users in an organisation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisations_users_read(id, unique_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this user. (required)
        :param str unique_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganisationUser
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.organisations_users_read_with_http_info(id, unique_id, **kwargs)  # noqa: E501

    def organisations_users_read_with_http_info(self, id, unique_id, **kwargs):  # noqa: E501
        """organisations_users_read  # noqa: E501

        Endpoint for interacting with users in an organisation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organisations_users_read_with_http_info(id, unique_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this user. (required)
        :param str unique_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganisationUser, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'unique_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organisations_users_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `organisations_users_read`")  # noqa: E501
        # verify the required parameter 'unique_id' is set
        if self.api_client.client_side_validation and ('unique_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['unique_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `unique_id` when calling `organisations_users_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'unique_id' in local_var_params:
            path_params['unique_id'] = local_var_params['unique_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/organisations/{unique_id}/users/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganisationUser',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def permissions_create(self, data, **kwargs):  # noqa: E501
        """create a role for an existing user in an existing organisation  # noqa: E501

        Example payload:      {       \"user\": \"chuck.norris\",  # user name       \"role\": \"simulation_runner\",  # role name       \"organisation\": \"48dac75bef8a42ebbb52e8f89bbdb9f2\"  # unique id     }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.permissions_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param OrganisationRole data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganisationRole
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.permissions_create_with_http_info(data, **kwargs)  # noqa: E501

    def permissions_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """create a role for an existing user in an existing organisation  # noqa: E501

        Example payload:      {       \"user\": \"chuck.norris\",  # user name       \"role\": \"simulation_runner\",  # role name       \"organisation\": \"48dac75bef8a42ebbb52e8f89bbdb9f2\"  # unique id     }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.permissions_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param OrganisationRole data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganisationRole, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method permissions_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `permissions_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/permissions/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganisationRole',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def permissions_delete(self, id, **kwargs):  # noqa: E501
        """permissions_delete  # noqa: E501

        Permissions management endpoints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.permissions_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this user organisation role. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.permissions_delete_with_http_info(id, **kwargs)  # noqa: E501

    def permissions_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """permissions_delete  # noqa: E501

        Permissions management endpoints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.permissions_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this user organisation role. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method permissions_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `permissions_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/permissions/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def permissions_list(self, **kwargs):  # noqa: E501
        """permissions_list  # noqa: E501

        Permissions management endpoints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.permissions_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user__username: user__username
        :param str user__username__iexact: user__username__iexact
        :param str user__username__contains: user__username__contains
        :param str user__username__icontains: user__username__icontains
        :param str user__username__in: user__username__in
        :param str user__username__startswith: user__username__startswith
        :param str user__username__istartswith: user__username__istartswith
        :param str user__username__endswith: user__username__endswith
        :param str user__username__regex: user__username__regex
        :param str role__name: role__name
        :param str role__name__iexact: role__name__iexact
        :param str role__name__contains: role__name__contains
        :param str role__name__icontains: role__name__icontains
        :param str role__name__in: role__name__in
        :param str role__name__startswith: role__name__startswith
        :param str role__name__istartswith: role__name__istartswith
        :param str role__name__endswith: role__name__endswith
        :param str role__name__regex: role__name__regex
        :param str organisation__name: organisation__name
        :param str organisation__name__iexact: organisation__name__iexact
        :param str organisation__name__contains: organisation__name__contains
        :param str organisation__name__icontains: organisation__name__icontains
        :param str organisation__name__in: organisation__name__in
        :param str organisation__name__startswith: organisation__name__startswith
        :param str organisation__name__istartswith: organisation__name__istartswith
        :param str organisation__name__endswith: organisation__name__endswith
        :param str organisation__name__regex: organisation__name__regex
        :param str organisation__unique_id: organisation__unique_id
        :param str user__id: user__id
        :param str user__remote__external_user_id: user__remote__external_user_id
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.permissions_list_with_http_info(**kwargs)  # noqa: E501

    def permissions_list_with_http_info(self, **kwargs):  # noqa: E501
        """permissions_list  # noqa: E501

        Permissions management endpoints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.permissions_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user__username: user__username
        :param str user__username__iexact: user__username__iexact
        :param str user__username__contains: user__username__contains
        :param str user__username__icontains: user__username__icontains
        :param str user__username__in: user__username__in
        :param str user__username__startswith: user__username__startswith
        :param str user__username__istartswith: user__username__istartswith
        :param str user__username__endswith: user__username__endswith
        :param str user__username__regex: user__username__regex
        :param str role__name: role__name
        :param str role__name__iexact: role__name__iexact
        :param str role__name__contains: role__name__contains
        :param str role__name__icontains: role__name__icontains
        :param str role__name__in: role__name__in
        :param str role__name__startswith: role__name__startswith
        :param str role__name__istartswith: role__name__istartswith
        :param str role__name__endswith: role__name__endswith
        :param str role__name__regex: role__name__regex
        :param str organisation__name: organisation__name
        :param str organisation__name__iexact: organisation__name__iexact
        :param str organisation__name__contains: organisation__name__contains
        :param str organisation__name__icontains: organisation__name__icontains
        :param str organisation__name__in: organisation__name__in
        :param str organisation__name__startswith: organisation__name__startswith
        :param str organisation__name__istartswith: organisation__name__istartswith
        :param str organisation__name__endswith: organisation__name__endswith
        :param str organisation__name__regex: organisation__name__regex
        :param str organisation__unique_id: organisation__unique_id
        :param str user__id: user__id
        :param str user__remote__external_user_id: user__remote__external_user_id
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20014, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user__username',
            'user__username__iexact',
            'user__username__contains',
            'user__username__icontains',
            'user__username__in',
            'user__username__startswith',
            'user__username__istartswith',
            'user__username__endswith',
            'user__username__regex',
            'role__name',
            'role__name__iexact',
            'role__name__contains',
            'role__name__icontains',
            'role__name__in',
            'role__name__startswith',
            'role__name__istartswith',
            'role__name__endswith',
            'role__name__regex',
            'organisation__name',
            'organisation__name__iexact',
            'organisation__name__contains',
            'organisation__name__icontains',
            'organisation__name__in',
            'organisation__name__startswith',
            'organisation__name__istartswith',
            'organisation__name__endswith',
            'organisation__name__regex',
            'organisation__unique_id',
            'user__id',
            'user__remote__external_user_id',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method permissions_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user__username' in local_var_params and local_var_params['user__username'] is not None:  # noqa: E501
            query_params.append(('user__username', local_var_params['user__username']))  # noqa: E501
        if 'user__username__iexact' in local_var_params and local_var_params['user__username__iexact'] is not None:  # noqa: E501
            query_params.append(('user__username__iexact', local_var_params['user__username__iexact']))  # noqa: E501
        if 'user__username__contains' in local_var_params and local_var_params['user__username__contains'] is not None:  # noqa: E501
            query_params.append(('user__username__contains', local_var_params['user__username__contains']))  # noqa: E501
        if 'user__username__icontains' in local_var_params and local_var_params['user__username__icontains'] is not None:  # noqa: E501
            query_params.append(('user__username__icontains', local_var_params['user__username__icontains']))  # noqa: E501
        if 'user__username__in' in local_var_params and local_var_params['user__username__in'] is not None:  # noqa: E501
            query_params.append(('user__username__in', local_var_params['user__username__in']))  # noqa: E501
        if 'user__username__startswith' in local_var_params and local_var_params['user__username__startswith'] is not None:  # noqa: E501
            query_params.append(('user__username__startswith', local_var_params['user__username__startswith']))  # noqa: E501
        if 'user__username__istartswith' in local_var_params and local_var_params['user__username__istartswith'] is not None:  # noqa: E501
            query_params.append(('user__username__istartswith', local_var_params['user__username__istartswith']))  # noqa: E501
        if 'user__username__endswith' in local_var_params and local_var_params['user__username__endswith'] is not None:  # noqa: E501
            query_params.append(('user__username__endswith', local_var_params['user__username__endswith']))  # noqa: E501
        if 'user__username__regex' in local_var_params and local_var_params['user__username__regex'] is not None:  # noqa: E501
            query_params.append(('user__username__regex', local_var_params['user__username__regex']))  # noqa: E501
        if 'role__name' in local_var_params and local_var_params['role__name'] is not None:  # noqa: E501
            query_params.append(('role__name', local_var_params['role__name']))  # noqa: E501
        if 'role__name__iexact' in local_var_params and local_var_params['role__name__iexact'] is not None:  # noqa: E501
            query_params.append(('role__name__iexact', local_var_params['role__name__iexact']))  # noqa: E501
        if 'role__name__contains' in local_var_params and local_var_params['role__name__contains'] is not None:  # noqa: E501
            query_params.append(('role__name__contains', local_var_params['role__name__contains']))  # noqa: E501
        if 'role__name__icontains' in local_var_params and local_var_params['role__name__icontains'] is not None:  # noqa: E501
            query_params.append(('role__name__icontains', local_var_params['role__name__icontains']))  # noqa: E501
        if 'role__name__in' in local_var_params and local_var_params['role__name__in'] is not None:  # noqa: E501
            query_params.append(('role__name__in', local_var_params['role__name__in']))  # noqa: E501
        if 'role__name__startswith' in local_var_params and local_var_params['role__name__startswith'] is not None:  # noqa: E501
            query_params.append(('role__name__startswith', local_var_params['role__name__startswith']))  # noqa: E501
        if 'role__name__istartswith' in local_var_params and local_var_params['role__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('role__name__istartswith', local_var_params['role__name__istartswith']))  # noqa: E501
        if 'role__name__endswith' in local_var_params and local_var_params['role__name__endswith'] is not None:  # noqa: E501
            query_params.append(('role__name__endswith', local_var_params['role__name__endswith']))  # noqa: E501
        if 'role__name__regex' in local_var_params and local_var_params['role__name__regex'] is not None:  # noqa: E501
            query_params.append(('role__name__regex', local_var_params['role__name__regex']))  # noqa: E501
        if 'organisation__name' in local_var_params and local_var_params['organisation__name'] is not None:  # noqa: E501
            query_params.append(('organisation__name', local_var_params['organisation__name']))  # noqa: E501
        if 'organisation__name__iexact' in local_var_params and local_var_params['organisation__name__iexact'] is not None:  # noqa: E501
            query_params.append(('organisation__name__iexact', local_var_params['organisation__name__iexact']))  # noqa: E501
        if 'organisation__name__contains' in local_var_params and local_var_params['organisation__name__contains'] is not None:  # noqa: E501
            query_params.append(('organisation__name__contains', local_var_params['organisation__name__contains']))  # noqa: E501
        if 'organisation__name__icontains' in local_var_params and local_var_params['organisation__name__icontains'] is not None:  # noqa: E501
            query_params.append(('organisation__name__icontains', local_var_params['organisation__name__icontains']))  # noqa: E501
        if 'organisation__name__in' in local_var_params and local_var_params['organisation__name__in'] is not None:  # noqa: E501
            query_params.append(('organisation__name__in', local_var_params['organisation__name__in']))  # noqa: E501
        if 'organisation__name__startswith' in local_var_params and local_var_params['organisation__name__startswith'] is not None:  # noqa: E501
            query_params.append(('organisation__name__startswith', local_var_params['organisation__name__startswith']))  # noqa: E501
        if 'organisation__name__istartswith' in local_var_params and local_var_params['organisation__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('organisation__name__istartswith', local_var_params['organisation__name__istartswith']))  # noqa: E501
        if 'organisation__name__endswith' in local_var_params and local_var_params['organisation__name__endswith'] is not None:  # noqa: E501
            query_params.append(('organisation__name__endswith', local_var_params['organisation__name__endswith']))  # noqa: E501
        if 'organisation__name__regex' in local_var_params and local_var_params['organisation__name__regex'] is not None:  # noqa: E501
            query_params.append(('organisation__name__regex', local_var_params['organisation__name__regex']))  # noqa: E501
        if 'organisation__unique_id' in local_var_params and local_var_params['organisation__unique_id'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id', local_var_params['organisation__unique_id']))  # noqa: E501
        if 'user__id' in local_var_params and local_var_params['user__id'] is not None:  # noqa: E501
            query_params.append(('user__id', local_var_params['user__id']))  # noqa: E501
        if 'user__remote__external_user_id' in local_var_params and local_var_params['user__remote__external_user_id'] is not None:  # noqa: E501
            query_params.append(('user__remote__external_user_id', local_var_params['user__remote__external_user_id']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/permissions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20014',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def permissions_read(self, id, **kwargs):  # noqa: E501
        """permissions_read  # noqa: E501

        Permissions management endpoints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.permissions_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this user organisation role. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganisationRole
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.permissions_read_with_http_info(id, **kwargs)  # noqa: E501

    def permissions_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """permissions_read  # noqa: E501

        Permissions management endpoints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.permissions_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this user organisation role. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganisationRole, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method permissions_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `permissions_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/permissions/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganisationRole',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_create(self, data, **kwargs):  # noqa: E501
        """repositories_create  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Repository data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Repository
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.repositories_create_with_http_info(data, **kwargs)  # noqa: E501

    def repositories_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """repositories_create  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Repository data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `repositories_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/repositories/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Repository',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_delete(self, id, **kwargs):  # noqa: E501
        """repositories_delete  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this repository. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.repositories_delete_with_http_info(id, **kwargs)  # noqa: E501

    def repositories_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """repositories_delete  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this repository. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repositories_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/repositories/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_list(self, **kwargs):  # noqa: E501
        """repositories_list  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str slug: slug
        :param str slug__iexact: slug__iexact
        :param str slug__contains: slug__contains
        :param str slug__icontains: slug__icontains
        :param str slug__in: slug__in
        :param str slug__startswith: slug__startswith
        :param str slug__istartswith: slug__istartswith
        :param str slug__endswith: slug__endswith
        :param str slug__regex: slug__regex
        :param str organisation__id: organisation__id
        :param str organisation__id__gt: organisation__id__gt
        :param str organisation__id__gte: organisation__id__gte
        :param str organisation__id__lt: organisation__id__lt
        :param str organisation__id__lte: organisation__id__lte
        :param str organisation__id__isnull: organisation__id__isnull
        :param str organisation__name: organisation__name
        :param str organisation__name__iexact: organisation__name__iexact
        :param str organisation__name__contains: organisation__name__contains
        :param str organisation__name__icontains: organisation__name__icontains
        :param str organisation__name__in: organisation__name__in
        :param str organisation__name__startswith: organisation__name__startswith
        :param str organisation__name__istartswith: organisation__name__istartswith
        :param str organisation__name__endswith: organisation__name__endswith
        :param str organisation__name__regex: organisation__name__regex
        :param str organisation__unique_id: organisation__unique_id
        :param str organisation__unique_id__iexact: organisation__unique_id__iexact
        :param str organisation__unique_id__contains: organisation__unique_id__contains
        :param str organisation__unique_id__icontains: organisation__unique_id__icontains
        :param str organisation__unique_id__in: organisation__unique_id__in
        :param str organisation__unique_id__startswith: organisation__unique_id__startswith
        :param str organisation__unique_id__istartswith: organisation__unique_id__istartswith
        :param str organisation__unique_id__endswith: organisation__unique_id__endswith
        :param str organisation__unique_id__regex: organisation__unique_id__regex
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.repositories_list_with_http_info(**kwargs)  # noqa: E501

    def repositories_list_with_http_info(self, **kwargs):  # noqa: E501
        """repositories_list  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str slug: slug
        :param str slug__iexact: slug__iexact
        :param str slug__contains: slug__contains
        :param str slug__icontains: slug__icontains
        :param str slug__in: slug__in
        :param str slug__startswith: slug__startswith
        :param str slug__istartswith: slug__istartswith
        :param str slug__endswith: slug__endswith
        :param str slug__regex: slug__regex
        :param str organisation__id: organisation__id
        :param str organisation__id__gt: organisation__id__gt
        :param str organisation__id__gte: organisation__id__gte
        :param str organisation__id__lt: organisation__id__lt
        :param str organisation__id__lte: organisation__id__lte
        :param str organisation__id__isnull: organisation__id__isnull
        :param str organisation__name: organisation__name
        :param str organisation__name__iexact: organisation__name__iexact
        :param str organisation__name__contains: organisation__name__contains
        :param str organisation__name__icontains: organisation__name__icontains
        :param str organisation__name__in: organisation__name__in
        :param str organisation__name__startswith: organisation__name__startswith
        :param str organisation__name__istartswith: organisation__name__istartswith
        :param str organisation__name__endswith: organisation__name__endswith
        :param str organisation__name__regex: organisation__name__regex
        :param str organisation__unique_id: organisation__unique_id
        :param str organisation__unique_id__iexact: organisation__unique_id__iexact
        :param str organisation__unique_id__contains: organisation__unique_id__contains
        :param str organisation__unique_id__icontains: organisation__unique_id__icontains
        :param str organisation__unique_id__in: organisation__unique_id__in
        :param str organisation__unique_id__startswith: organisation__unique_id__startswith
        :param str organisation__unique_id__istartswith: organisation__unique_id__istartswith
        :param str organisation__unique_id__endswith: organisation__unique_id__endswith
        :param str organisation__unique_id__regex: organisation__unique_id__regex
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20015, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'slug',
            'slug__iexact',
            'slug__contains',
            'slug__icontains',
            'slug__in',
            'slug__startswith',
            'slug__istartswith',
            'slug__endswith',
            'slug__regex',
            'organisation__id',
            'organisation__id__gt',
            'organisation__id__gte',
            'organisation__id__lt',
            'organisation__id__lte',
            'organisation__id__isnull',
            'organisation__name',
            'organisation__name__iexact',
            'organisation__name__contains',
            'organisation__name__icontains',
            'organisation__name__in',
            'organisation__name__startswith',
            'organisation__name__istartswith',
            'organisation__name__endswith',
            'organisation__name__regex',
            'organisation__unique_id',
            'organisation__unique_id__iexact',
            'organisation__unique_id__contains',
            'organisation__unique_id__icontains',
            'organisation__unique_id__in',
            'organisation__unique_id__startswith',
            'organisation__unique_id__istartswith',
            'organisation__unique_id__endswith',
            'organisation__unique_id__regex',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'slug' in local_var_params and local_var_params['slug'] is not None:  # noqa: E501
            query_params.append(('slug', local_var_params['slug']))  # noqa: E501
        if 'slug__iexact' in local_var_params and local_var_params['slug__iexact'] is not None:  # noqa: E501
            query_params.append(('slug__iexact', local_var_params['slug__iexact']))  # noqa: E501
        if 'slug__contains' in local_var_params and local_var_params['slug__contains'] is not None:  # noqa: E501
            query_params.append(('slug__contains', local_var_params['slug__contains']))  # noqa: E501
        if 'slug__icontains' in local_var_params and local_var_params['slug__icontains'] is not None:  # noqa: E501
            query_params.append(('slug__icontains', local_var_params['slug__icontains']))  # noqa: E501
        if 'slug__in' in local_var_params and local_var_params['slug__in'] is not None:  # noqa: E501
            query_params.append(('slug__in', local_var_params['slug__in']))  # noqa: E501
        if 'slug__startswith' in local_var_params and local_var_params['slug__startswith'] is not None:  # noqa: E501
            query_params.append(('slug__startswith', local_var_params['slug__startswith']))  # noqa: E501
        if 'slug__istartswith' in local_var_params and local_var_params['slug__istartswith'] is not None:  # noqa: E501
            query_params.append(('slug__istartswith', local_var_params['slug__istartswith']))  # noqa: E501
        if 'slug__endswith' in local_var_params and local_var_params['slug__endswith'] is not None:  # noqa: E501
            query_params.append(('slug__endswith', local_var_params['slug__endswith']))  # noqa: E501
        if 'slug__regex' in local_var_params and local_var_params['slug__regex'] is not None:  # noqa: E501
            query_params.append(('slug__regex', local_var_params['slug__regex']))  # noqa: E501
        if 'organisation__id' in local_var_params and local_var_params['organisation__id'] is not None:  # noqa: E501
            query_params.append(('organisation__id', local_var_params['organisation__id']))  # noqa: E501
        if 'organisation__id__gt' in local_var_params and local_var_params['organisation__id__gt'] is not None:  # noqa: E501
            query_params.append(('organisation__id__gt', local_var_params['organisation__id__gt']))  # noqa: E501
        if 'organisation__id__gte' in local_var_params and local_var_params['organisation__id__gte'] is not None:  # noqa: E501
            query_params.append(('organisation__id__gte', local_var_params['organisation__id__gte']))  # noqa: E501
        if 'organisation__id__lt' in local_var_params and local_var_params['organisation__id__lt'] is not None:  # noqa: E501
            query_params.append(('organisation__id__lt', local_var_params['organisation__id__lt']))  # noqa: E501
        if 'organisation__id__lte' in local_var_params and local_var_params['organisation__id__lte'] is not None:  # noqa: E501
            query_params.append(('organisation__id__lte', local_var_params['organisation__id__lte']))  # noqa: E501
        if 'organisation__id__isnull' in local_var_params and local_var_params['organisation__id__isnull'] is not None:  # noqa: E501
            query_params.append(('organisation__id__isnull', local_var_params['organisation__id__isnull']))  # noqa: E501
        if 'organisation__name' in local_var_params and local_var_params['organisation__name'] is not None:  # noqa: E501
            query_params.append(('organisation__name', local_var_params['organisation__name']))  # noqa: E501
        if 'organisation__name__iexact' in local_var_params and local_var_params['organisation__name__iexact'] is not None:  # noqa: E501
            query_params.append(('organisation__name__iexact', local_var_params['organisation__name__iexact']))  # noqa: E501
        if 'organisation__name__contains' in local_var_params and local_var_params['organisation__name__contains'] is not None:  # noqa: E501
            query_params.append(('organisation__name__contains', local_var_params['organisation__name__contains']))  # noqa: E501
        if 'organisation__name__icontains' in local_var_params and local_var_params['organisation__name__icontains'] is not None:  # noqa: E501
            query_params.append(('organisation__name__icontains', local_var_params['organisation__name__icontains']))  # noqa: E501
        if 'organisation__name__in' in local_var_params and local_var_params['organisation__name__in'] is not None:  # noqa: E501
            query_params.append(('organisation__name__in', local_var_params['organisation__name__in']))  # noqa: E501
        if 'organisation__name__startswith' in local_var_params and local_var_params['organisation__name__startswith'] is not None:  # noqa: E501
            query_params.append(('organisation__name__startswith', local_var_params['organisation__name__startswith']))  # noqa: E501
        if 'organisation__name__istartswith' in local_var_params and local_var_params['organisation__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('organisation__name__istartswith', local_var_params['organisation__name__istartswith']))  # noqa: E501
        if 'organisation__name__endswith' in local_var_params and local_var_params['organisation__name__endswith'] is not None:  # noqa: E501
            query_params.append(('organisation__name__endswith', local_var_params['organisation__name__endswith']))  # noqa: E501
        if 'organisation__name__regex' in local_var_params and local_var_params['organisation__name__regex'] is not None:  # noqa: E501
            query_params.append(('organisation__name__regex', local_var_params['organisation__name__regex']))  # noqa: E501
        if 'organisation__unique_id' in local_var_params and local_var_params['organisation__unique_id'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id', local_var_params['organisation__unique_id']))  # noqa: E501
        if 'organisation__unique_id__iexact' in local_var_params and local_var_params['organisation__unique_id__iexact'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id__iexact', local_var_params['organisation__unique_id__iexact']))  # noqa: E501
        if 'organisation__unique_id__contains' in local_var_params and local_var_params['organisation__unique_id__contains'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id__contains', local_var_params['organisation__unique_id__contains']))  # noqa: E501
        if 'organisation__unique_id__icontains' in local_var_params and local_var_params['organisation__unique_id__icontains'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id__icontains', local_var_params['organisation__unique_id__icontains']))  # noqa: E501
        if 'organisation__unique_id__in' in local_var_params and local_var_params['organisation__unique_id__in'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id__in', local_var_params['organisation__unique_id__in']))  # noqa: E501
        if 'organisation__unique_id__startswith' in local_var_params and local_var_params['organisation__unique_id__startswith'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id__startswith', local_var_params['organisation__unique_id__startswith']))  # noqa: E501
        if 'organisation__unique_id__istartswith' in local_var_params and local_var_params['organisation__unique_id__istartswith'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id__istartswith', local_var_params['organisation__unique_id__istartswith']))  # noqa: E501
        if 'organisation__unique_id__endswith' in local_var_params and local_var_params['organisation__unique_id__endswith'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id__endswith', local_var_params['organisation__unique_id__endswith']))  # noqa: E501
        if 'organisation__unique_id__regex' in local_var_params and local_var_params['organisation__unique_id__regex'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id__regex', local_var_params['organisation__unique_id__regex']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/repositories/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20015',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_partial_update(self, id, data, **kwargs):  # noqa: E501
        """repositories_partial_update  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this repository. (required)
        :param Repository data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Repository
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.repositories_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def repositories_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """repositories_partial_update  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this repository. (required)
        :param Repository data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repositories_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `repositories_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/repositories/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Repository',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_read(self, id, **kwargs):  # noqa: E501
        """repositories_read  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this repository. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Repository
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.repositories_read_with_http_info(id, **kwargs)  # noqa: E501

    def repositories_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """repositories_read  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this repository. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repositories_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/repositories/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Repository',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_revisions(self, id, **kwargs):  # noqa: E501
        """repositories_revisions  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_revisions(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this repository. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[Revision]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.repositories_revisions_with_http_info(id, **kwargs)  # noqa: E501

    def repositories_revisions_with_http_info(self, id, **kwargs):  # noqa: E501
        """repositories_revisions  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_revisions_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this repository. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[Revision], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_revisions" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repositories_revisions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/repositories/{id}/revisions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Revision]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_threedimodels(self, id, **kwargs):  # noqa: E501
        """repositories_threedimodels  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_threedimodels(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this repository. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[ThreediModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.repositories_threedimodels_with_http_info(id, **kwargs)  # noqa: E501

    def repositories_threedimodels_with_http_info(self, id, **kwargs):  # noqa: E501
        """repositories_threedimodels  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_threedimodels_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this repository. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[ThreediModel], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_threedimodels" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repositories_threedimodels`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/repositories/{id}/threedimodels/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ThreediModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_update(self, id, data, **kwargs):  # noqa: E501
        """repositories_update  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this repository. (required)
        :param Repository data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Repository
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.repositories_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def repositories_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """repositories_update  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this repository. (required)
        :param Repository data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repositories_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `repositories_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/repositories/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Repository',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revisions_create(self, data, **kwargs):  # noqa: E501
        """revisions_create  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revisions_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Revision data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Revision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.revisions_create_with_http_info(data, **kwargs)  # noqa: E501

    def revisions_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """revisions_create  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revisions_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Revision data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Revision, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revisions_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `revisions_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/revisions/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Revision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revisions_delete(self, id, **kwargs):  # noqa: E501
        """revisions_delete  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revisions_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.revisions_delete_with_http_info(id, **kwargs)  # noqa: E501

    def revisions_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """revisions_delete  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revisions_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revisions_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `revisions_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/revisions/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revisions_list(self, **kwargs):  # noqa: E501
        """revisions_list  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revisions_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str number: number
        :param str number__gt: number__gt
        :param str number__gte: number__gte
        :param str number__lt: number__lt
        :param str number__lte: number__lte
        :param str number__isnull: number__isnull
        :param str hash: hash
        :param str hash__iexact: hash__iexact
        :param str hash__contains: hash__contains
        :param str hash__icontains: hash__icontains
        :param str hash__in: hash__in
        :param str hash__startswith: hash__startswith
        :param str hash__istartswith: hash__istartswith
        :param str hash__endswith: hash__endswith
        :param str hash__regex: hash__regex
        :param str repository__id: repository__id
        :param str repository__id__gt: repository__id__gt
        :param str repository__id__gte: repository__id__gte
        :param str repository__id__lt: repository__id__lt
        :param str repository__id__lte: repository__id__lte
        :param str repository__id__isnull: repository__id__isnull
        :param str repository__slug: repository__slug
        :param str repository__slug__iexact: repository__slug__iexact
        :param str repository__slug__contains: repository__slug__contains
        :param str repository__slug__icontains: repository__slug__icontains
        :param str repository__slug__in: repository__slug__in
        :param str repository__slug__startswith: repository__slug__startswith
        :param str repository__slug__istartswith: repository__slug__istartswith
        :param str repository__slug__endswith: repository__slug__endswith
        :param str repository__slug__regex: repository__slug__regex
        :param str repository__organisation__name: repository__organisation__name
        :param str repository__organisation__name__iexact: repository__organisation__name__iexact
        :param str repository__organisation__name__contains: repository__organisation__name__contains
        :param str repository__organisation__name__icontains: repository__organisation__name__icontains
        :param str repository__organisation__name__in: repository__organisation__name__in
        :param str repository__organisation__name__startswith: repository__organisation__name__startswith
        :param str repository__organisation__name__istartswith: repository__organisation__name__istartswith
        :param str repository__organisation__name__endswith: repository__organisation__name__endswith
        :param str repository__organisation__name__regex: repository__organisation__name__regex
        :param str repository__organisation__unique_id: repository__organisation__unique_id
        :param str repository__organisation__unique_id__iexact: repository__organisation__unique_id__iexact
        :param str repository__organisation__unique_id__contains: repository__organisation__unique_id__contains
        :param str repository__organisation__unique_id__icontains: repository__organisation__unique_id__icontains
        :param str repository__organisation__unique_id__in: repository__organisation__unique_id__in
        :param str repository__organisation__unique_id__startswith: repository__organisation__unique_id__startswith
        :param str repository__organisation__unique_id__istartswith: repository__organisation__unique_id__istartswith
        :param str repository__organisation__unique_id__endswith: repository__organisation__unique_id__endswith
        :param str repository__organisation__unique_id__regex: repository__organisation__unique_id__regex
        :param str is_pinned: is_pinned
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.revisions_list_with_http_info(**kwargs)  # noqa: E501

    def revisions_list_with_http_info(self, **kwargs):  # noqa: E501
        """revisions_list  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revisions_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str number: number
        :param str number__gt: number__gt
        :param str number__gte: number__gte
        :param str number__lt: number__lt
        :param str number__lte: number__lte
        :param str number__isnull: number__isnull
        :param str hash: hash
        :param str hash__iexact: hash__iexact
        :param str hash__contains: hash__contains
        :param str hash__icontains: hash__icontains
        :param str hash__in: hash__in
        :param str hash__startswith: hash__startswith
        :param str hash__istartswith: hash__istartswith
        :param str hash__endswith: hash__endswith
        :param str hash__regex: hash__regex
        :param str repository__id: repository__id
        :param str repository__id__gt: repository__id__gt
        :param str repository__id__gte: repository__id__gte
        :param str repository__id__lt: repository__id__lt
        :param str repository__id__lte: repository__id__lte
        :param str repository__id__isnull: repository__id__isnull
        :param str repository__slug: repository__slug
        :param str repository__slug__iexact: repository__slug__iexact
        :param str repository__slug__contains: repository__slug__contains
        :param str repository__slug__icontains: repository__slug__icontains
        :param str repository__slug__in: repository__slug__in
        :param str repository__slug__startswith: repository__slug__startswith
        :param str repository__slug__istartswith: repository__slug__istartswith
        :param str repository__slug__endswith: repository__slug__endswith
        :param str repository__slug__regex: repository__slug__regex
        :param str repository__organisation__name: repository__organisation__name
        :param str repository__organisation__name__iexact: repository__organisation__name__iexact
        :param str repository__organisation__name__contains: repository__organisation__name__contains
        :param str repository__organisation__name__icontains: repository__organisation__name__icontains
        :param str repository__organisation__name__in: repository__organisation__name__in
        :param str repository__organisation__name__startswith: repository__organisation__name__startswith
        :param str repository__organisation__name__istartswith: repository__organisation__name__istartswith
        :param str repository__organisation__name__endswith: repository__organisation__name__endswith
        :param str repository__organisation__name__regex: repository__organisation__name__regex
        :param str repository__organisation__unique_id: repository__organisation__unique_id
        :param str repository__organisation__unique_id__iexact: repository__organisation__unique_id__iexact
        :param str repository__organisation__unique_id__contains: repository__organisation__unique_id__contains
        :param str repository__organisation__unique_id__icontains: repository__organisation__unique_id__icontains
        :param str repository__organisation__unique_id__in: repository__organisation__unique_id__in
        :param str repository__organisation__unique_id__startswith: repository__organisation__unique_id__startswith
        :param str repository__organisation__unique_id__istartswith: repository__organisation__unique_id__istartswith
        :param str repository__organisation__unique_id__endswith: repository__organisation__unique_id__endswith
        :param str repository__organisation__unique_id__regex: repository__organisation__unique_id__regex
        :param str is_pinned: is_pinned
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20016, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'number',
            'number__gt',
            'number__gte',
            'number__lt',
            'number__lte',
            'number__isnull',
            'hash',
            'hash__iexact',
            'hash__contains',
            'hash__icontains',
            'hash__in',
            'hash__startswith',
            'hash__istartswith',
            'hash__endswith',
            'hash__regex',
            'repository__id',
            'repository__id__gt',
            'repository__id__gte',
            'repository__id__lt',
            'repository__id__lte',
            'repository__id__isnull',
            'repository__slug',
            'repository__slug__iexact',
            'repository__slug__contains',
            'repository__slug__icontains',
            'repository__slug__in',
            'repository__slug__startswith',
            'repository__slug__istartswith',
            'repository__slug__endswith',
            'repository__slug__regex',
            'repository__organisation__name',
            'repository__organisation__name__iexact',
            'repository__organisation__name__contains',
            'repository__organisation__name__icontains',
            'repository__organisation__name__in',
            'repository__organisation__name__startswith',
            'repository__organisation__name__istartswith',
            'repository__organisation__name__endswith',
            'repository__organisation__name__regex',
            'repository__organisation__unique_id',
            'repository__organisation__unique_id__iexact',
            'repository__organisation__unique_id__contains',
            'repository__organisation__unique_id__icontains',
            'repository__organisation__unique_id__in',
            'repository__organisation__unique_id__startswith',
            'repository__organisation__unique_id__istartswith',
            'repository__organisation__unique_id__endswith',
            'repository__organisation__unique_id__regex',
            'is_pinned',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revisions_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'number' in local_var_params and local_var_params['number'] is not None:  # noqa: E501
            query_params.append(('number', local_var_params['number']))  # noqa: E501
        if 'number__gt' in local_var_params and local_var_params['number__gt'] is not None:  # noqa: E501
            query_params.append(('number__gt', local_var_params['number__gt']))  # noqa: E501
        if 'number__gte' in local_var_params and local_var_params['number__gte'] is not None:  # noqa: E501
            query_params.append(('number__gte', local_var_params['number__gte']))  # noqa: E501
        if 'number__lt' in local_var_params and local_var_params['number__lt'] is not None:  # noqa: E501
            query_params.append(('number__lt', local_var_params['number__lt']))  # noqa: E501
        if 'number__lte' in local_var_params and local_var_params['number__lte'] is not None:  # noqa: E501
            query_params.append(('number__lte', local_var_params['number__lte']))  # noqa: E501
        if 'number__isnull' in local_var_params and local_var_params['number__isnull'] is not None:  # noqa: E501
            query_params.append(('number__isnull', local_var_params['number__isnull']))  # noqa: E501
        if 'hash' in local_var_params and local_var_params['hash'] is not None:  # noqa: E501
            query_params.append(('hash', local_var_params['hash']))  # noqa: E501
        if 'hash__iexact' in local_var_params and local_var_params['hash__iexact'] is not None:  # noqa: E501
            query_params.append(('hash__iexact', local_var_params['hash__iexact']))  # noqa: E501
        if 'hash__contains' in local_var_params and local_var_params['hash__contains'] is not None:  # noqa: E501
            query_params.append(('hash__contains', local_var_params['hash__contains']))  # noqa: E501
        if 'hash__icontains' in local_var_params and local_var_params['hash__icontains'] is not None:  # noqa: E501
            query_params.append(('hash__icontains', local_var_params['hash__icontains']))  # noqa: E501
        if 'hash__in' in local_var_params and local_var_params['hash__in'] is not None:  # noqa: E501
            query_params.append(('hash__in', local_var_params['hash__in']))  # noqa: E501
        if 'hash__startswith' in local_var_params and local_var_params['hash__startswith'] is not None:  # noqa: E501
            query_params.append(('hash__startswith', local_var_params['hash__startswith']))  # noqa: E501
        if 'hash__istartswith' in local_var_params and local_var_params['hash__istartswith'] is not None:  # noqa: E501
            query_params.append(('hash__istartswith', local_var_params['hash__istartswith']))  # noqa: E501
        if 'hash__endswith' in local_var_params and local_var_params['hash__endswith'] is not None:  # noqa: E501
            query_params.append(('hash__endswith', local_var_params['hash__endswith']))  # noqa: E501
        if 'hash__regex' in local_var_params and local_var_params['hash__regex'] is not None:  # noqa: E501
            query_params.append(('hash__regex', local_var_params['hash__regex']))  # noqa: E501
        if 'repository__id' in local_var_params and local_var_params['repository__id'] is not None:  # noqa: E501
            query_params.append(('repository__id', local_var_params['repository__id']))  # noqa: E501
        if 'repository__id__gt' in local_var_params and local_var_params['repository__id__gt'] is not None:  # noqa: E501
            query_params.append(('repository__id__gt', local_var_params['repository__id__gt']))  # noqa: E501
        if 'repository__id__gte' in local_var_params and local_var_params['repository__id__gte'] is not None:  # noqa: E501
            query_params.append(('repository__id__gte', local_var_params['repository__id__gte']))  # noqa: E501
        if 'repository__id__lt' in local_var_params and local_var_params['repository__id__lt'] is not None:  # noqa: E501
            query_params.append(('repository__id__lt', local_var_params['repository__id__lt']))  # noqa: E501
        if 'repository__id__lte' in local_var_params and local_var_params['repository__id__lte'] is not None:  # noqa: E501
            query_params.append(('repository__id__lte', local_var_params['repository__id__lte']))  # noqa: E501
        if 'repository__id__isnull' in local_var_params and local_var_params['repository__id__isnull'] is not None:  # noqa: E501
            query_params.append(('repository__id__isnull', local_var_params['repository__id__isnull']))  # noqa: E501
        if 'repository__slug' in local_var_params and local_var_params['repository__slug'] is not None:  # noqa: E501
            query_params.append(('repository__slug', local_var_params['repository__slug']))  # noqa: E501
        if 'repository__slug__iexact' in local_var_params and local_var_params['repository__slug__iexact'] is not None:  # noqa: E501
            query_params.append(('repository__slug__iexact', local_var_params['repository__slug__iexact']))  # noqa: E501
        if 'repository__slug__contains' in local_var_params and local_var_params['repository__slug__contains'] is not None:  # noqa: E501
            query_params.append(('repository__slug__contains', local_var_params['repository__slug__contains']))  # noqa: E501
        if 'repository__slug__icontains' in local_var_params and local_var_params['repository__slug__icontains'] is not None:  # noqa: E501
            query_params.append(('repository__slug__icontains', local_var_params['repository__slug__icontains']))  # noqa: E501
        if 'repository__slug__in' in local_var_params and local_var_params['repository__slug__in'] is not None:  # noqa: E501
            query_params.append(('repository__slug__in', local_var_params['repository__slug__in']))  # noqa: E501
        if 'repository__slug__startswith' in local_var_params and local_var_params['repository__slug__startswith'] is not None:  # noqa: E501
            query_params.append(('repository__slug__startswith', local_var_params['repository__slug__startswith']))  # noqa: E501
        if 'repository__slug__istartswith' in local_var_params and local_var_params['repository__slug__istartswith'] is not None:  # noqa: E501
            query_params.append(('repository__slug__istartswith', local_var_params['repository__slug__istartswith']))  # noqa: E501
        if 'repository__slug__endswith' in local_var_params and local_var_params['repository__slug__endswith'] is not None:  # noqa: E501
            query_params.append(('repository__slug__endswith', local_var_params['repository__slug__endswith']))  # noqa: E501
        if 'repository__slug__regex' in local_var_params and local_var_params['repository__slug__regex'] is not None:  # noqa: E501
            query_params.append(('repository__slug__regex', local_var_params['repository__slug__regex']))  # noqa: E501
        if 'repository__organisation__name' in local_var_params and local_var_params['repository__organisation__name'] is not None:  # noqa: E501
            query_params.append(('repository__organisation__name', local_var_params['repository__organisation__name']))  # noqa: E501
        if 'repository__organisation__name__iexact' in local_var_params and local_var_params['repository__organisation__name__iexact'] is not None:  # noqa: E501
            query_params.append(('repository__organisation__name__iexact', local_var_params['repository__organisation__name__iexact']))  # noqa: E501
        if 'repository__organisation__name__contains' in local_var_params and local_var_params['repository__organisation__name__contains'] is not None:  # noqa: E501
            query_params.append(('repository__organisation__name__contains', local_var_params['repository__organisation__name__contains']))  # noqa: E501
        if 'repository__organisation__name__icontains' in local_var_params and local_var_params['repository__organisation__name__icontains'] is not None:  # noqa: E501
            query_params.append(('repository__organisation__name__icontains', local_var_params['repository__organisation__name__icontains']))  # noqa: E501
        if 'repository__organisation__name__in' in local_var_params and local_var_params['repository__organisation__name__in'] is not None:  # noqa: E501
            query_params.append(('repository__organisation__name__in', local_var_params['repository__organisation__name__in']))  # noqa: E501
        if 'repository__organisation__name__startswith' in local_var_params and local_var_params['repository__organisation__name__startswith'] is not None:  # noqa: E501
            query_params.append(('repository__organisation__name__startswith', local_var_params['repository__organisation__name__startswith']))  # noqa: E501
        if 'repository__organisation__name__istartswith' in local_var_params and local_var_params['repository__organisation__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('repository__organisation__name__istartswith', local_var_params['repository__organisation__name__istartswith']))  # noqa: E501
        if 'repository__organisation__name__endswith' in local_var_params and local_var_params['repository__organisation__name__endswith'] is not None:  # noqa: E501
            query_params.append(('repository__organisation__name__endswith', local_var_params['repository__organisation__name__endswith']))  # noqa: E501
        if 'repository__organisation__name__regex' in local_var_params and local_var_params['repository__organisation__name__regex'] is not None:  # noqa: E501
            query_params.append(('repository__organisation__name__regex', local_var_params['repository__organisation__name__regex']))  # noqa: E501
        if 'repository__organisation__unique_id' in local_var_params and local_var_params['repository__organisation__unique_id'] is not None:  # noqa: E501
            query_params.append(('repository__organisation__unique_id', local_var_params['repository__organisation__unique_id']))  # noqa: E501
        if 'repository__organisation__unique_id__iexact' in local_var_params and local_var_params['repository__organisation__unique_id__iexact'] is not None:  # noqa: E501
            query_params.append(('repository__organisation__unique_id__iexact', local_var_params['repository__organisation__unique_id__iexact']))  # noqa: E501
        if 'repository__organisation__unique_id__contains' in local_var_params and local_var_params['repository__organisation__unique_id__contains'] is not None:  # noqa: E501
            query_params.append(('repository__organisation__unique_id__contains', local_var_params['repository__organisation__unique_id__contains']))  # noqa: E501
        if 'repository__organisation__unique_id__icontains' in local_var_params and local_var_params['repository__organisation__unique_id__icontains'] is not None:  # noqa: E501
            query_params.append(('repository__organisation__unique_id__icontains', local_var_params['repository__organisation__unique_id__icontains']))  # noqa: E501
        if 'repository__organisation__unique_id__in' in local_var_params and local_var_params['repository__organisation__unique_id__in'] is not None:  # noqa: E501
            query_params.append(('repository__organisation__unique_id__in', local_var_params['repository__organisation__unique_id__in']))  # noqa: E501
        if 'repository__organisation__unique_id__startswith' in local_var_params and local_var_params['repository__organisation__unique_id__startswith'] is not None:  # noqa: E501
            query_params.append(('repository__organisation__unique_id__startswith', local_var_params['repository__organisation__unique_id__startswith']))  # noqa: E501
        if 'repository__organisation__unique_id__istartswith' in local_var_params and local_var_params['repository__organisation__unique_id__istartswith'] is not None:  # noqa: E501
            query_params.append(('repository__organisation__unique_id__istartswith', local_var_params['repository__organisation__unique_id__istartswith']))  # noqa: E501
        if 'repository__organisation__unique_id__endswith' in local_var_params and local_var_params['repository__organisation__unique_id__endswith'] is not None:  # noqa: E501
            query_params.append(('repository__organisation__unique_id__endswith', local_var_params['repository__organisation__unique_id__endswith']))  # noqa: E501
        if 'repository__organisation__unique_id__regex' in local_var_params and local_var_params['repository__organisation__unique_id__regex'] is not None:  # noqa: E501
            query_params.append(('repository__organisation__unique_id__regex', local_var_params['repository__organisation__unique_id__regex']))  # noqa: E501
        if 'is_pinned' in local_var_params and local_var_params['is_pinned'] is not None:  # noqa: E501
            query_params.append(('is_pinned', local_var_params['is_pinned']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/revisions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20016',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revisions_partial_update(self, id, data, **kwargs):  # noqa: E501
        """revisions_partial_update  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revisions_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param Revision data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Revision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.revisions_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def revisions_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """revisions_partial_update  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revisions_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param Revision data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Revision, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revisions_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `revisions_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `revisions_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/revisions/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Revision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revisions_read(self, id, **kwargs):  # noqa: E501
        """revisions_read  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revisions_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Revision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.revisions_read_with_http_info(id, **kwargs)  # noqa: E501

    def revisions_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """revisions_read  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revisions_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Revision, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revisions_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `revisions_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/revisions/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Revision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revisions_threedimodels(self, id, **kwargs):  # noqa: E501
        """revisions_threedimodels  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revisions_threedimodels(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[ThreediModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.revisions_threedimodels_with_http_info(id, **kwargs)  # noqa: E501

    def revisions_threedimodels_with_http_info(self, id, **kwargs):  # noqa: E501
        """revisions_threedimodels  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revisions_threedimodels_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[ThreediModel], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revisions_threedimodels" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `revisions_threedimodels`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/revisions/{id}/threedimodels/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ThreediModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revisions_update(self, id, data, **kwargs):  # noqa: E501
        """revisions_update  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revisions_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param Revision data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Revision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.revisions_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def revisions_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """revisions_update  # noqa: E501

        A simple ViewSet for viewing modelmeta  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revisions_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param Revision data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Revision, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revisions_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `revisions_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `revisions_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/revisions/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Revision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def roles_list(self, **kwargs):  # noqa: E501
        """roles_list  # noqa: E501

        Read-only API endpoint for viewing roles  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.roles_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.roles_list_with_http_info(**kwargs)  # noqa: E501

    def roles_list_with_http_info(self, **kwargs):  # noqa: E501
        """roles_list  # noqa: E501

        Read-only API endpoint for viewing roles  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.roles_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20017, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method roles_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/roles/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20017',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def roles_read(self, id, **kwargs):  # noqa: E501
        """roles_read  # noqa: E501

        Read-only API endpoint for viewing roles  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.roles_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this role. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.roles_read_with_http_info(id, **kwargs)  # noqa: E501

    def roles_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """roles_read  # noqa: E501

        Read-only API endpoint for viewing roles  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.roles_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this role. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Role, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method roles_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `roles_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/roles/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Role',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_create(self, data, **kwargs):  # noqa: E501
        """schematisations_create  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Schematisation data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Schematisation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_create_with_http_info(data, **kwargs)  # noqa: E501

    def schematisations_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """schematisations_create  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Schematisation data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Schematisation, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Schematisation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_delete(self, id, **kwargs):  # noqa: E501
        """schematisations_delete  # noqa: E501

        Archive schematisation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_delete_with_http_info(id, **kwargs)  # noqa: E501

    def schematisations_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """schematisations_delete  # noqa: E501

        Archive schematisation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_latest_revision(self, id, **kwargs):  # noqa: E501
        """Get the latest committed revision.  # noqa: E501

        For retrieving all revisions use: `/schematisations/{id}/revisions`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_latest_revision(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SchematisationRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_latest_revision_with_http_info(id, **kwargs)  # noqa: E501

    def schematisations_latest_revision_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the latest committed revision.  # noqa: E501

        For retrieving all revisions use: `/schematisations/{id}/revisions`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_latest_revision_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SchematisationRevision, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_latest_revision" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_latest_revision`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{id}/latest-revision/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SchematisationRevision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_list(self, **kwargs):  # noqa: E501
        """schematisations_list  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str created__range: created__range
        :param str created__date: created__date
        :param str created__date__gt: created__date__gt
        :param str created__date__gte: created__date__gte
        :param str created__date__lt: created__date__lt
        :param str created__date__lte: created__date__lte
        :param str created__year: created__year
        :param str created__year__gt: created__year__gt
        :param str created__year__gte: created__year__gte
        :param str created__year__lt: created__year__lt
        :param str created__year__lte: created__year__lte
        :param str created__month: created__month
        :param str created__month__lte: created__month__lte
        :param str created__day: created__day
        :param str created__day__lt: created__day__lt
        :param str created__week: created__week
        :param str created__week_day: created__week_day
        :param str created__quarter: created__quarter
        :param str created__time: created__time
        :param str created__hour: created__hour
        :param str created__minute: created__minute
        :param str created__second: created__second
        :param str created__isnull: created__isnull
        :param str last_updated__range: last_updated__range
        :param str last_updated__date: last_updated__date
        :param str last_updated__date__gt: last_updated__date__gt
        :param str last_updated__date__gte: last_updated__date__gte
        :param str last_updated__date__lt: last_updated__date__lt
        :param str last_updated__date__lte: last_updated__date__lte
        :param str last_updated__year: last_updated__year
        :param str last_updated__year__gt: last_updated__year__gt
        :param str last_updated__year__gte: last_updated__year__gte
        :param str last_updated__year__lt: last_updated__year__lt
        :param str last_updated__year__lte: last_updated__year__lte
        :param str last_updated__month: last_updated__month
        :param str last_updated__month__lte: last_updated__month__lte
        :param str last_updated__day: last_updated__day
        :param str last_updated__day__lt: last_updated__day__lt
        :param str last_updated__week: last_updated__week
        :param str last_updated__week_day: last_updated__week_day
        :param str last_updated__quarter: last_updated__quarter
        :param str last_updated__time: last_updated__time
        :param str last_updated__hour: last_updated__hour
        :param str last_updated__minute: last_updated__minute
        :param str last_updated__second: last_updated__second
        :param str last_updated__isnull: last_updated__isnull
        :param str created_by__username: created_by__username
        :param str created_by__username__iexact: created_by__username__iexact
        :param str created_by__username__contains: created_by__username__contains
        :param str created_by__username__icontains: created_by__username__icontains
        :param str created_by__username__in: created_by__username__in
        :param str created_by__username__startswith: created_by__username__startswith
        :param str created_by__username__istartswith: created_by__username__istartswith
        :param str created_by__username__endswith: created_by__username__endswith
        :param str created_by__username__regex: created_by__username__regex
        :param str name: name
        :param str name__iexact: name__iexact
        :param str name__contains: name__contains
        :param str name__icontains: name__icontains
        :param str name__in: name__in
        :param str name__startswith: name__startswith
        :param str name__istartswith: name__istartswith
        :param str name__endswith: name__endswith
        :param str name__regex: name__regex
        :param str slug: slug
        :param str slug__iexact: slug__iexact
        :param str slug__contains: slug__contains
        :param str slug__icontains: slug__icontains
        :param str slug__in: slug__in
        :param str slug__startswith: slug__startswith
        :param str slug__istartswith: slug__istartswith
        :param str slug__endswith: slug__endswith
        :param str slug__regex: slug__regex
        :param str owner__name: owner__name
        :param str owner__name__iexact: owner__name__iexact
        :param str owner__name__contains: owner__name__contains
        :param str owner__name__icontains: owner__name__icontains
        :param str owner__name__in: owner__name__in
        :param str owner__name__startswith: owner__name__startswith
        :param str owner__name__istartswith: owner__name__istartswith
        :param str owner__name__endswith: owner__name__endswith
        :param str owner__name__regex: owner__name__regex
        :param str owner__unique_id: owner__unique_id
        :param str owner__unique_id__iexact: owner__unique_id__iexact
        :param str owner__unique_id__contains: owner__unique_id__contains
        :param str owner__unique_id__icontains: owner__unique_id__icontains
        :param str owner__unique_id__in: owner__unique_id__in
        :param str owner__unique_id__startswith: owner__unique_id__startswith
        :param str owner__unique_id__istartswith: owner__unique_id__istartswith
        :param str owner__unique_id__endswith: owner__unique_id__endswith
        :param str owner__unique_id__regex: owner__unique_id__regex
        :param str tags__in: tags__in
        :param str archived: archived
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_list_with_http_info(**kwargs)  # noqa: E501

    def schematisations_list_with_http_info(self, **kwargs):  # noqa: E501
        """schematisations_list  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str created__range: created__range
        :param str created__date: created__date
        :param str created__date__gt: created__date__gt
        :param str created__date__gte: created__date__gte
        :param str created__date__lt: created__date__lt
        :param str created__date__lte: created__date__lte
        :param str created__year: created__year
        :param str created__year__gt: created__year__gt
        :param str created__year__gte: created__year__gte
        :param str created__year__lt: created__year__lt
        :param str created__year__lte: created__year__lte
        :param str created__month: created__month
        :param str created__month__lte: created__month__lte
        :param str created__day: created__day
        :param str created__day__lt: created__day__lt
        :param str created__week: created__week
        :param str created__week_day: created__week_day
        :param str created__quarter: created__quarter
        :param str created__time: created__time
        :param str created__hour: created__hour
        :param str created__minute: created__minute
        :param str created__second: created__second
        :param str created__isnull: created__isnull
        :param str last_updated__range: last_updated__range
        :param str last_updated__date: last_updated__date
        :param str last_updated__date__gt: last_updated__date__gt
        :param str last_updated__date__gte: last_updated__date__gte
        :param str last_updated__date__lt: last_updated__date__lt
        :param str last_updated__date__lte: last_updated__date__lte
        :param str last_updated__year: last_updated__year
        :param str last_updated__year__gt: last_updated__year__gt
        :param str last_updated__year__gte: last_updated__year__gte
        :param str last_updated__year__lt: last_updated__year__lt
        :param str last_updated__year__lte: last_updated__year__lte
        :param str last_updated__month: last_updated__month
        :param str last_updated__month__lte: last_updated__month__lte
        :param str last_updated__day: last_updated__day
        :param str last_updated__day__lt: last_updated__day__lt
        :param str last_updated__week: last_updated__week
        :param str last_updated__week_day: last_updated__week_day
        :param str last_updated__quarter: last_updated__quarter
        :param str last_updated__time: last_updated__time
        :param str last_updated__hour: last_updated__hour
        :param str last_updated__minute: last_updated__minute
        :param str last_updated__second: last_updated__second
        :param str last_updated__isnull: last_updated__isnull
        :param str created_by__username: created_by__username
        :param str created_by__username__iexact: created_by__username__iexact
        :param str created_by__username__contains: created_by__username__contains
        :param str created_by__username__icontains: created_by__username__icontains
        :param str created_by__username__in: created_by__username__in
        :param str created_by__username__startswith: created_by__username__startswith
        :param str created_by__username__istartswith: created_by__username__istartswith
        :param str created_by__username__endswith: created_by__username__endswith
        :param str created_by__username__regex: created_by__username__regex
        :param str name: name
        :param str name__iexact: name__iexact
        :param str name__contains: name__contains
        :param str name__icontains: name__icontains
        :param str name__in: name__in
        :param str name__startswith: name__startswith
        :param str name__istartswith: name__istartswith
        :param str name__endswith: name__endswith
        :param str name__regex: name__regex
        :param str slug: slug
        :param str slug__iexact: slug__iexact
        :param str slug__contains: slug__contains
        :param str slug__icontains: slug__icontains
        :param str slug__in: slug__in
        :param str slug__startswith: slug__startswith
        :param str slug__istartswith: slug__istartswith
        :param str slug__endswith: slug__endswith
        :param str slug__regex: slug__regex
        :param str owner__name: owner__name
        :param str owner__name__iexact: owner__name__iexact
        :param str owner__name__contains: owner__name__contains
        :param str owner__name__icontains: owner__name__icontains
        :param str owner__name__in: owner__name__in
        :param str owner__name__startswith: owner__name__startswith
        :param str owner__name__istartswith: owner__name__istartswith
        :param str owner__name__endswith: owner__name__endswith
        :param str owner__name__regex: owner__name__regex
        :param str owner__unique_id: owner__unique_id
        :param str owner__unique_id__iexact: owner__unique_id__iexact
        :param str owner__unique_id__contains: owner__unique_id__contains
        :param str owner__unique_id__icontains: owner__unique_id__icontains
        :param str owner__unique_id__in: owner__unique_id__in
        :param str owner__unique_id__startswith: owner__unique_id__startswith
        :param str owner__unique_id__istartswith: owner__unique_id__istartswith
        :param str owner__unique_id__endswith: owner__unique_id__endswith
        :param str owner__unique_id__regex: owner__unique_id__regex
        :param str tags__in: tags__in
        :param str archived: archived
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20018, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'created__range',
            'created__date',
            'created__date__gt',
            'created__date__gte',
            'created__date__lt',
            'created__date__lte',
            'created__year',
            'created__year__gt',
            'created__year__gte',
            'created__year__lt',
            'created__year__lte',
            'created__month',
            'created__month__lte',
            'created__day',
            'created__day__lt',
            'created__week',
            'created__week_day',
            'created__quarter',
            'created__time',
            'created__hour',
            'created__minute',
            'created__second',
            'created__isnull',
            'last_updated__range',
            'last_updated__date',
            'last_updated__date__gt',
            'last_updated__date__gte',
            'last_updated__date__lt',
            'last_updated__date__lte',
            'last_updated__year',
            'last_updated__year__gt',
            'last_updated__year__gte',
            'last_updated__year__lt',
            'last_updated__year__lte',
            'last_updated__month',
            'last_updated__month__lte',
            'last_updated__day',
            'last_updated__day__lt',
            'last_updated__week',
            'last_updated__week_day',
            'last_updated__quarter',
            'last_updated__time',
            'last_updated__hour',
            'last_updated__minute',
            'last_updated__second',
            'last_updated__isnull',
            'created_by__username',
            'created_by__username__iexact',
            'created_by__username__contains',
            'created_by__username__icontains',
            'created_by__username__in',
            'created_by__username__startswith',
            'created_by__username__istartswith',
            'created_by__username__endswith',
            'created_by__username__regex',
            'name',
            'name__iexact',
            'name__contains',
            'name__icontains',
            'name__in',
            'name__startswith',
            'name__istartswith',
            'name__endswith',
            'name__regex',
            'slug',
            'slug__iexact',
            'slug__contains',
            'slug__icontains',
            'slug__in',
            'slug__startswith',
            'slug__istartswith',
            'slug__endswith',
            'slug__regex',
            'owner__name',
            'owner__name__iexact',
            'owner__name__contains',
            'owner__name__icontains',
            'owner__name__in',
            'owner__name__startswith',
            'owner__name__istartswith',
            'owner__name__endswith',
            'owner__name__regex',
            'owner__unique_id',
            'owner__unique_id__iexact',
            'owner__unique_id__contains',
            'owner__unique_id__icontains',
            'owner__unique_id__in',
            'owner__unique_id__startswith',
            'owner__unique_id__istartswith',
            'owner__unique_id__endswith',
            'owner__unique_id__regex',
            'tags__in',
            'archived',
            'ordering',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'created__range' in local_var_params and local_var_params['created__range'] is not None:  # noqa: E501
            query_params.append(('created__range', local_var_params['created__range']))  # noqa: E501
        if 'created__date' in local_var_params and local_var_params['created__date'] is not None:  # noqa: E501
            query_params.append(('created__date', local_var_params['created__date']))  # noqa: E501
        if 'created__date__gt' in local_var_params and local_var_params['created__date__gt'] is not None:  # noqa: E501
            query_params.append(('created__date__gt', local_var_params['created__date__gt']))  # noqa: E501
        if 'created__date__gte' in local_var_params and local_var_params['created__date__gte'] is not None:  # noqa: E501
            query_params.append(('created__date__gte', local_var_params['created__date__gte']))  # noqa: E501
        if 'created__date__lt' in local_var_params and local_var_params['created__date__lt'] is not None:  # noqa: E501
            query_params.append(('created__date__lt', local_var_params['created__date__lt']))  # noqa: E501
        if 'created__date__lte' in local_var_params and local_var_params['created__date__lte'] is not None:  # noqa: E501
            query_params.append(('created__date__lte', local_var_params['created__date__lte']))  # noqa: E501
        if 'created__year' in local_var_params and local_var_params['created__year'] is not None:  # noqa: E501
            query_params.append(('created__year', local_var_params['created__year']))  # noqa: E501
        if 'created__year__gt' in local_var_params and local_var_params['created__year__gt'] is not None:  # noqa: E501
            query_params.append(('created__year__gt', local_var_params['created__year__gt']))  # noqa: E501
        if 'created__year__gte' in local_var_params and local_var_params['created__year__gte'] is not None:  # noqa: E501
            query_params.append(('created__year__gte', local_var_params['created__year__gte']))  # noqa: E501
        if 'created__year__lt' in local_var_params and local_var_params['created__year__lt'] is not None:  # noqa: E501
            query_params.append(('created__year__lt', local_var_params['created__year__lt']))  # noqa: E501
        if 'created__year__lte' in local_var_params and local_var_params['created__year__lte'] is not None:  # noqa: E501
            query_params.append(('created__year__lte', local_var_params['created__year__lte']))  # noqa: E501
        if 'created__month' in local_var_params and local_var_params['created__month'] is not None:  # noqa: E501
            query_params.append(('created__month', local_var_params['created__month']))  # noqa: E501
        if 'created__month__lte' in local_var_params and local_var_params['created__month__lte'] is not None:  # noqa: E501
            query_params.append(('created__month__lte', local_var_params['created__month__lte']))  # noqa: E501
        if 'created__day' in local_var_params and local_var_params['created__day'] is not None:  # noqa: E501
            query_params.append(('created__day', local_var_params['created__day']))  # noqa: E501
        if 'created__day__lt' in local_var_params and local_var_params['created__day__lt'] is not None:  # noqa: E501
            query_params.append(('created__day__lt', local_var_params['created__day__lt']))  # noqa: E501
        if 'created__week' in local_var_params and local_var_params['created__week'] is not None:  # noqa: E501
            query_params.append(('created__week', local_var_params['created__week']))  # noqa: E501
        if 'created__week_day' in local_var_params and local_var_params['created__week_day'] is not None:  # noqa: E501
            query_params.append(('created__week_day', local_var_params['created__week_day']))  # noqa: E501
        if 'created__quarter' in local_var_params and local_var_params['created__quarter'] is not None:  # noqa: E501
            query_params.append(('created__quarter', local_var_params['created__quarter']))  # noqa: E501
        if 'created__time' in local_var_params and local_var_params['created__time'] is not None:  # noqa: E501
            query_params.append(('created__time', local_var_params['created__time']))  # noqa: E501
        if 'created__hour' in local_var_params and local_var_params['created__hour'] is not None:  # noqa: E501
            query_params.append(('created__hour', local_var_params['created__hour']))  # noqa: E501
        if 'created__minute' in local_var_params and local_var_params['created__minute'] is not None:  # noqa: E501
            query_params.append(('created__minute', local_var_params['created__minute']))  # noqa: E501
        if 'created__second' in local_var_params and local_var_params['created__second'] is not None:  # noqa: E501
            query_params.append(('created__second', local_var_params['created__second']))  # noqa: E501
        if 'created__isnull' in local_var_params and local_var_params['created__isnull'] is not None:  # noqa: E501
            query_params.append(('created__isnull', local_var_params['created__isnull']))  # noqa: E501
        if 'last_updated__range' in local_var_params and local_var_params['last_updated__range'] is not None:  # noqa: E501
            query_params.append(('last_updated__range', local_var_params['last_updated__range']))  # noqa: E501
        if 'last_updated__date' in local_var_params and local_var_params['last_updated__date'] is not None:  # noqa: E501
            query_params.append(('last_updated__date', local_var_params['last_updated__date']))  # noqa: E501
        if 'last_updated__date__gt' in local_var_params and local_var_params['last_updated__date__gt'] is not None:  # noqa: E501
            query_params.append(('last_updated__date__gt', local_var_params['last_updated__date__gt']))  # noqa: E501
        if 'last_updated__date__gte' in local_var_params and local_var_params['last_updated__date__gte'] is not None:  # noqa: E501
            query_params.append(('last_updated__date__gte', local_var_params['last_updated__date__gte']))  # noqa: E501
        if 'last_updated__date__lt' in local_var_params and local_var_params['last_updated__date__lt'] is not None:  # noqa: E501
            query_params.append(('last_updated__date__lt', local_var_params['last_updated__date__lt']))  # noqa: E501
        if 'last_updated__date__lte' in local_var_params and local_var_params['last_updated__date__lte'] is not None:  # noqa: E501
            query_params.append(('last_updated__date__lte', local_var_params['last_updated__date__lte']))  # noqa: E501
        if 'last_updated__year' in local_var_params and local_var_params['last_updated__year'] is not None:  # noqa: E501
            query_params.append(('last_updated__year', local_var_params['last_updated__year']))  # noqa: E501
        if 'last_updated__year__gt' in local_var_params and local_var_params['last_updated__year__gt'] is not None:  # noqa: E501
            query_params.append(('last_updated__year__gt', local_var_params['last_updated__year__gt']))  # noqa: E501
        if 'last_updated__year__gte' in local_var_params and local_var_params['last_updated__year__gte'] is not None:  # noqa: E501
            query_params.append(('last_updated__year__gte', local_var_params['last_updated__year__gte']))  # noqa: E501
        if 'last_updated__year__lt' in local_var_params and local_var_params['last_updated__year__lt'] is not None:  # noqa: E501
            query_params.append(('last_updated__year__lt', local_var_params['last_updated__year__lt']))  # noqa: E501
        if 'last_updated__year__lte' in local_var_params and local_var_params['last_updated__year__lte'] is not None:  # noqa: E501
            query_params.append(('last_updated__year__lte', local_var_params['last_updated__year__lte']))  # noqa: E501
        if 'last_updated__month' in local_var_params and local_var_params['last_updated__month'] is not None:  # noqa: E501
            query_params.append(('last_updated__month', local_var_params['last_updated__month']))  # noqa: E501
        if 'last_updated__month__lte' in local_var_params and local_var_params['last_updated__month__lte'] is not None:  # noqa: E501
            query_params.append(('last_updated__month__lte', local_var_params['last_updated__month__lte']))  # noqa: E501
        if 'last_updated__day' in local_var_params and local_var_params['last_updated__day'] is not None:  # noqa: E501
            query_params.append(('last_updated__day', local_var_params['last_updated__day']))  # noqa: E501
        if 'last_updated__day__lt' in local_var_params and local_var_params['last_updated__day__lt'] is not None:  # noqa: E501
            query_params.append(('last_updated__day__lt', local_var_params['last_updated__day__lt']))  # noqa: E501
        if 'last_updated__week' in local_var_params and local_var_params['last_updated__week'] is not None:  # noqa: E501
            query_params.append(('last_updated__week', local_var_params['last_updated__week']))  # noqa: E501
        if 'last_updated__week_day' in local_var_params and local_var_params['last_updated__week_day'] is not None:  # noqa: E501
            query_params.append(('last_updated__week_day', local_var_params['last_updated__week_day']))  # noqa: E501
        if 'last_updated__quarter' in local_var_params and local_var_params['last_updated__quarter'] is not None:  # noqa: E501
            query_params.append(('last_updated__quarter', local_var_params['last_updated__quarter']))  # noqa: E501
        if 'last_updated__time' in local_var_params and local_var_params['last_updated__time'] is not None:  # noqa: E501
            query_params.append(('last_updated__time', local_var_params['last_updated__time']))  # noqa: E501
        if 'last_updated__hour' in local_var_params and local_var_params['last_updated__hour'] is not None:  # noqa: E501
            query_params.append(('last_updated__hour', local_var_params['last_updated__hour']))  # noqa: E501
        if 'last_updated__minute' in local_var_params and local_var_params['last_updated__minute'] is not None:  # noqa: E501
            query_params.append(('last_updated__minute', local_var_params['last_updated__minute']))  # noqa: E501
        if 'last_updated__second' in local_var_params and local_var_params['last_updated__second'] is not None:  # noqa: E501
            query_params.append(('last_updated__second', local_var_params['last_updated__second']))  # noqa: E501
        if 'last_updated__isnull' in local_var_params and local_var_params['last_updated__isnull'] is not None:  # noqa: E501
            query_params.append(('last_updated__isnull', local_var_params['last_updated__isnull']))  # noqa: E501
        if 'created_by__username' in local_var_params and local_var_params['created_by__username'] is not None:  # noqa: E501
            query_params.append(('created_by__username', local_var_params['created_by__username']))  # noqa: E501
        if 'created_by__username__iexact' in local_var_params and local_var_params['created_by__username__iexact'] is not None:  # noqa: E501
            query_params.append(('created_by__username__iexact', local_var_params['created_by__username__iexact']))  # noqa: E501
        if 'created_by__username__contains' in local_var_params and local_var_params['created_by__username__contains'] is not None:  # noqa: E501
            query_params.append(('created_by__username__contains', local_var_params['created_by__username__contains']))  # noqa: E501
        if 'created_by__username__icontains' in local_var_params and local_var_params['created_by__username__icontains'] is not None:  # noqa: E501
            query_params.append(('created_by__username__icontains', local_var_params['created_by__username__icontains']))  # noqa: E501
        if 'created_by__username__in' in local_var_params and local_var_params['created_by__username__in'] is not None:  # noqa: E501
            query_params.append(('created_by__username__in', local_var_params['created_by__username__in']))  # noqa: E501
        if 'created_by__username__startswith' in local_var_params and local_var_params['created_by__username__startswith'] is not None:  # noqa: E501
            query_params.append(('created_by__username__startswith', local_var_params['created_by__username__startswith']))  # noqa: E501
        if 'created_by__username__istartswith' in local_var_params and local_var_params['created_by__username__istartswith'] is not None:  # noqa: E501
            query_params.append(('created_by__username__istartswith', local_var_params['created_by__username__istartswith']))  # noqa: E501
        if 'created_by__username__endswith' in local_var_params and local_var_params['created_by__username__endswith'] is not None:  # noqa: E501
            query_params.append(('created_by__username__endswith', local_var_params['created_by__username__endswith']))  # noqa: E501
        if 'created_by__username__regex' in local_var_params and local_var_params['created_by__username__regex'] is not None:  # noqa: E501
            query_params.append(('created_by__username__regex', local_var_params['created_by__username__regex']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'name__iexact' in local_var_params and local_var_params['name__iexact'] is not None:  # noqa: E501
            query_params.append(('name__iexact', local_var_params['name__iexact']))  # noqa: E501
        if 'name__contains' in local_var_params and local_var_params['name__contains'] is not None:  # noqa: E501
            query_params.append(('name__contains', local_var_params['name__contains']))  # noqa: E501
        if 'name__icontains' in local_var_params and local_var_params['name__icontains'] is not None:  # noqa: E501
            query_params.append(('name__icontains', local_var_params['name__icontains']))  # noqa: E501
        if 'name__in' in local_var_params and local_var_params['name__in'] is not None:  # noqa: E501
            query_params.append(('name__in', local_var_params['name__in']))  # noqa: E501
        if 'name__startswith' in local_var_params and local_var_params['name__startswith'] is not None:  # noqa: E501
            query_params.append(('name__startswith', local_var_params['name__startswith']))  # noqa: E501
        if 'name__istartswith' in local_var_params and local_var_params['name__istartswith'] is not None:  # noqa: E501
            query_params.append(('name__istartswith', local_var_params['name__istartswith']))  # noqa: E501
        if 'name__endswith' in local_var_params and local_var_params['name__endswith'] is not None:  # noqa: E501
            query_params.append(('name__endswith', local_var_params['name__endswith']))  # noqa: E501
        if 'name__regex' in local_var_params and local_var_params['name__regex'] is not None:  # noqa: E501
            query_params.append(('name__regex', local_var_params['name__regex']))  # noqa: E501
        if 'slug' in local_var_params and local_var_params['slug'] is not None:  # noqa: E501
            query_params.append(('slug', local_var_params['slug']))  # noqa: E501
        if 'slug__iexact' in local_var_params and local_var_params['slug__iexact'] is not None:  # noqa: E501
            query_params.append(('slug__iexact', local_var_params['slug__iexact']))  # noqa: E501
        if 'slug__contains' in local_var_params and local_var_params['slug__contains'] is not None:  # noqa: E501
            query_params.append(('slug__contains', local_var_params['slug__contains']))  # noqa: E501
        if 'slug__icontains' in local_var_params and local_var_params['slug__icontains'] is not None:  # noqa: E501
            query_params.append(('slug__icontains', local_var_params['slug__icontains']))  # noqa: E501
        if 'slug__in' in local_var_params and local_var_params['slug__in'] is not None:  # noqa: E501
            query_params.append(('slug__in', local_var_params['slug__in']))  # noqa: E501
        if 'slug__startswith' in local_var_params and local_var_params['slug__startswith'] is not None:  # noqa: E501
            query_params.append(('slug__startswith', local_var_params['slug__startswith']))  # noqa: E501
        if 'slug__istartswith' in local_var_params and local_var_params['slug__istartswith'] is not None:  # noqa: E501
            query_params.append(('slug__istartswith', local_var_params['slug__istartswith']))  # noqa: E501
        if 'slug__endswith' in local_var_params and local_var_params['slug__endswith'] is not None:  # noqa: E501
            query_params.append(('slug__endswith', local_var_params['slug__endswith']))  # noqa: E501
        if 'slug__regex' in local_var_params and local_var_params['slug__regex'] is not None:  # noqa: E501
            query_params.append(('slug__regex', local_var_params['slug__regex']))  # noqa: E501
        if 'owner__name' in local_var_params and local_var_params['owner__name'] is not None:  # noqa: E501
            query_params.append(('owner__name', local_var_params['owner__name']))  # noqa: E501
        if 'owner__name__iexact' in local_var_params and local_var_params['owner__name__iexact'] is not None:  # noqa: E501
            query_params.append(('owner__name__iexact', local_var_params['owner__name__iexact']))  # noqa: E501
        if 'owner__name__contains' in local_var_params and local_var_params['owner__name__contains'] is not None:  # noqa: E501
            query_params.append(('owner__name__contains', local_var_params['owner__name__contains']))  # noqa: E501
        if 'owner__name__icontains' in local_var_params and local_var_params['owner__name__icontains'] is not None:  # noqa: E501
            query_params.append(('owner__name__icontains', local_var_params['owner__name__icontains']))  # noqa: E501
        if 'owner__name__in' in local_var_params and local_var_params['owner__name__in'] is not None:  # noqa: E501
            query_params.append(('owner__name__in', local_var_params['owner__name__in']))  # noqa: E501
        if 'owner__name__startswith' in local_var_params and local_var_params['owner__name__startswith'] is not None:  # noqa: E501
            query_params.append(('owner__name__startswith', local_var_params['owner__name__startswith']))  # noqa: E501
        if 'owner__name__istartswith' in local_var_params and local_var_params['owner__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('owner__name__istartswith', local_var_params['owner__name__istartswith']))  # noqa: E501
        if 'owner__name__endswith' in local_var_params and local_var_params['owner__name__endswith'] is not None:  # noqa: E501
            query_params.append(('owner__name__endswith', local_var_params['owner__name__endswith']))  # noqa: E501
        if 'owner__name__regex' in local_var_params and local_var_params['owner__name__regex'] is not None:  # noqa: E501
            query_params.append(('owner__name__regex', local_var_params['owner__name__regex']))  # noqa: E501
        if 'owner__unique_id' in local_var_params and local_var_params['owner__unique_id'] is not None:  # noqa: E501
            query_params.append(('owner__unique_id', local_var_params['owner__unique_id']))  # noqa: E501
        if 'owner__unique_id__iexact' in local_var_params and local_var_params['owner__unique_id__iexact'] is not None:  # noqa: E501
            query_params.append(('owner__unique_id__iexact', local_var_params['owner__unique_id__iexact']))  # noqa: E501
        if 'owner__unique_id__contains' in local_var_params and local_var_params['owner__unique_id__contains'] is not None:  # noqa: E501
            query_params.append(('owner__unique_id__contains', local_var_params['owner__unique_id__contains']))  # noqa: E501
        if 'owner__unique_id__icontains' in local_var_params and local_var_params['owner__unique_id__icontains'] is not None:  # noqa: E501
            query_params.append(('owner__unique_id__icontains', local_var_params['owner__unique_id__icontains']))  # noqa: E501
        if 'owner__unique_id__in' in local_var_params and local_var_params['owner__unique_id__in'] is not None:  # noqa: E501
            query_params.append(('owner__unique_id__in', local_var_params['owner__unique_id__in']))  # noqa: E501
        if 'owner__unique_id__startswith' in local_var_params and local_var_params['owner__unique_id__startswith'] is not None:  # noqa: E501
            query_params.append(('owner__unique_id__startswith', local_var_params['owner__unique_id__startswith']))  # noqa: E501
        if 'owner__unique_id__istartswith' in local_var_params and local_var_params['owner__unique_id__istartswith'] is not None:  # noqa: E501
            query_params.append(('owner__unique_id__istartswith', local_var_params['owner__unique_id__istartswith']))  # noqa: E501
        if 'owner__unique_id__endswith' in local_var_params and local_var_params['owner__unique_id__endswith'] is not None:  # noqa: E501
            query_params.append(('owner__unique_id__endswith', local_var_params['owner__unique_id__endswith']))  # noqa: E501
        if 'owner__unique_id__regex' in local_var_params and local_var_params['owner__unique_id__regex'] is not None:  # noqa: E501
            query_params.append(('owner__unique_id__regex', local_var_params['owner__unique_id__regex']))  # noqa: E501
        if 'tags__in' in local_var_params and local_var_params['tags__in'] is not None:  # noqa: E501
            query_params.append(('tags__in', local_var_params['tags__in']))  # noqa: E501
        if 'archived' in local_var_params and local_var_params['archived'] is not None:  # noqa: E501
            query_params.append(('archived', local_var_params['archived']))  # noqa: E501
        if 'ordering' in local_var_params and local_var_params['ordering'] is not None:  # noqa: E501
            query_params.append(('ordering', local_var_params['ordering']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20018',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_partial_update(self, id, data, **kwargs):  # noqa: E501
        """schematisations_partial_update  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param Schematisation data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Schematisation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def schematisations_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """schematisations_partial_update  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param Schematisation data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Schematisation, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Schematisation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_read(self, id, **kwargs):  # noqa: E501
        """schematisations_read  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Schematisation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_read_with_http_info(id, **kwargs)  # noqa: E501

    def schematisations_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """schematisations_read  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Schematisation, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Schematisation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_check(self, id, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_check  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_check(id, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevisionTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_check_with_http_info(id, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_check_with_http_info(self, id, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_check  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_check_with_http_info(id, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevisionTask, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_check" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_check`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_check`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{id}/check/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_commit(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """Commit the revision  # noqa: E501

        The `commit_message` can be used to describe the changes.  The `force_as` parameter allows to override the default behaviour of committing the revision with the already assigned revision number.  In case another user has already committed a revision with the same number, an HTTP 409 status code is returned.  In this case you can either: 1) Save the revision with a higher revision number using    `force_as` = `new_revision`, effectively overwriting changes    from the other user. 2) Save the revision under a new schematisation using    `force_as` = `new_schematisation` and specifying    a `schematisation_name`.  If you want to merge your changes with the changes from the other user, you need to download his/hers revision locally and merge it yourselves.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_commit(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param Commit data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SchematisationRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_commit_with_http_info(id, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_commit_with_http_info(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """Commit the revision  # noqa: E501

        The `commit_message` can be used to describe the changes.  The `force_as` parameter allows to override the default behaviour of committing the revision with the already assigned revision number.  In case another user has already committed a revision with the same number, an HTTP 409 status code is returned.  In this case you can either: 1) Save the revision with a higher revision number using    `force_as` = `new_revision`, effectively overwriting changes    from the other user. 2) Save the revision under a new schematisation using    `force_as` = `new_schematisation` and specifying    a `schematisation_name`.  If you want to merge your changes with the changes from the other user, you need to download his/hers revision locally and merge it yourselves.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_commit_with_http_info(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param Commit data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SchematisationRevision, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_commit" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_commit`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_commit`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_commit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{id}/commit/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SchematisationRevision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_create(self, schematisation_pk, data, **kwargs):  # noqa: E501
        """Create a new revision  # noqa: E501

        Creates a clone of the last committed revision (if present) by default except when empty=true is passed in the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_create(schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str schematisation_pk: (required)
        :param CreateRevision data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SchematisationRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_create_with_http_info(schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_create_with_http_info(self, schematisation_pk, data, **kwargs):  # noqa: E501
        """Create a new revision  # noqa: E501

        Creates a clone of the last committed revision (if present) by default except when empty=true is passed in the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_create_with_http_info(schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str schematisation_pk: (required)
        :param CreateRevision data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SchematisationRevision, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SchematisationRevision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_create_threedimodel(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_create_threedimodel  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_create_threedimodel(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param CreateThreedimodel data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ThreediModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_create_threedimodel_with_http_info(id, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_create_threedimodel_with_http_info(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_create_threedimodel  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_create_threedimodel_with_http_info(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param CreateThreedimodel data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ThreediModel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_create_threedimodel" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_create_threedimodel`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_create_threedimodel`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_create_threedimodel`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{id}/create-threedimodel/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreediModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_delete(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_delete  # noqa: E501

        Provide the revision id to delete the revision  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_delete(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param DestroyRevision data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_delete_with_http_info(id, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_delete_with_http_info(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_delete  # noqa: E501

        Provide the revision id to delete the revision  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_delete_with_http_info(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param DestroyRevision data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_delete`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_delete`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_list(self, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_list  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_list(schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str schematisation_pk: (required)
        :param str number: number
        :param str commit_message: commit_message
        :param str commit_message__iexact: commit_message__iexact
        :param str commit_message__contains: commit_message__contains
        :param str commit_message__icontains: commit_message__icontains
        :param str commit_message__in: commit_message__in
        :param str commit_message__startswith: commit_message__startswith
        :param str commit_message__istartswith: commit_message__istartswith
        :param str commit_message__endswith: commit_message__endswith
        :param str commit_message__regex: commit_message__regex
        :param str schematisation__id: schematisation__id
        :param str schematisation__slug: schematisation__slug
        :param str schematisation__slug__iexact: schematisation__slug__iexact
        :param str schematisation__slug__contains: schematisation__slug__contains
        :param str schematisation__slug__icontains: schematisation__slug__icontains
        :param str schematisation__slug__in: schematisation__slug__in
        :param str schematisation__slug__startswith: schematisation__slug__startswith
        :param str schematisation__slug__istartswith: schematisation__slug__istartswith
        :param str schematisation__slug__endswith: schematisation__slug__endswith
        :param str schematisation__slug__regex: schematisation__slug__regex
        :param str schematisation__owner__name: schematisation__owner__name
        :param str schematisation__owner__name__iexact: schematisation__owner__name__iexact
        :param str schematisation__owner__name__contains: schematisation__owner__name__contains
        :param str schematisation__owner__name__icontains: schematisation__owner__name__icontains
        :param str schematisation__owner__name__in: schematisation__owner__name__in
        :param str schematisation__owner__name__startswith: schematisation__owner__name__startswith
        :param str schematisation__owner__name__istartswith: schematisation__owner__name__istartswith
        :param str schematisation__owner__name__endswith: schematisation__owner__name__endswith
        :param str schematisation__owner__name__regex: schematisation__owner__name__regex
        :param str schematisation__owner__unique_id: schematisation__owner__unique_id
        :param str schematisation__owner__unique_id__iexact: schematisation__owner__unique_id__iexact
        :param str schematisation__owner__unique_id__contains: schematisation__owner__unique_id__contains
        :param str schematisation__owner__unique_id__icontains: schematisation__owner__unique_id__icontains
        :param str schematisation__owner__unique_id__in: schematisation__owner__unique_id__in
        :param str schematisation__owner__unique_id__startswith: schematisation__owner__unique_id__startswith
        :param str schematisation__owner__unique_id__istartswith: schematisation__owner__unique_id__istartswith
        :param str schematisation__owner__unique_id__endswith: schematisation__owner__unique_id__endswith
        :param str schematisation__owner__unique_id__regex: schematisation__owner__unique_id__regex
        :param str commit_user__username: commit_user__username
        :param str commit_user__username__iexact: commit_user__username__iexact
        :param str commit_user__username__contains: commit_user__username__contains
        :param str commit_user__username__icontains: commit_user__username__icontains
        :param str commit_user__username__in: commit_user__username__in
        :param str commit_user__username__startswith: commit_user__username__startswith
        :param str commit_user__username__istartswith: commit_user__username__istartswith
        :param str commit_user__username__endswith: commit_user__username__endswith
        :param str commit_user__username__regex: commit_user__username__regex
        :param str commit_date: commit_date
        :param str commit_date__gt: commit_date__gt
        :param str commit_date__gte: commit_date__gte
        :param str commit_date__lt: commit_date__lt
        :param str commit_date__lte: commit_date__lte
        :param str commit_date__date: commit_date__date
        :param str commit_date__date__gt: commit_date__date__gt
        :param str commit_date__date__gte: commit_date__date__gte
        :param str commit_date__date__lt: commit_date__date__lt
        :param str commit_date__date__lte: commit_date__date__lte
        :param str commit_date__year: commit_date__year
        :param str commit_date__year__gt: commit_date__year__gt
        :param str commit_date__year__gte: commit_date__year__gte
        :param str commit_date__year__lt: commit_date__year__lt
        :param str commit_date__year__lte: commit_date__year__lte
        :param str commit_date__month: commit_date__month
        :param str commit_date__month__lte: commit_date__month__lte
        :param str commit_date__day: commit_date__day
        :param str commit_date__day__lt: commit_date__day__lt
        :param str commit_date__week: commit_date__week
        :param str commit_date__week_day: commit_date__week_day
        :param str committed: committed
        :param str archived: archived
        :param str is_valid: is_valid
        :param str has_threedimodel: has_threedimodel
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_list_with_http_info(schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_list_with_http_info(self, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_list  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_list_with_http_info(schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str schematisation_pk: (required)
        :param str number: number
        :param str commit_message: commit_message
        :param str commit_message__iexact: commit_message__iexact
        :param str commit_message__contains: commit_message__contains
        :param str commit_message__icontains: commit_message__icontains
        :param str commit_message__in: commit_message__in
        :param str commit_message__startswith: commit_message__startswith
        :param str commit_message__istartswith: commit_message__istartswith
        :param str commit_message__endswith: commit_message__endswith
        :param str commit_message__regex: commit_message__regex
        :param str schematisation__id: schematisation__id
        :param str schematisation__slug: schematisation__slug
        :param str schematisation__slug__iexact: schematisation__slug__iexact
        :param str schematisation__slug__contains: schematisation__slug__contains
        :param str schematisation__slug__icontains: schematisation__slug__icontains
        :param str schematisation__slug__in: schematisation__slug__in
        :param str schematisation__slug__startswith: schematisation__slug__startswith
        :param str schematisation__slug__istartswith: schematisation__slug__istartswith
        :param str schematisation__slug__endswith: schematisation__slug__endswith
        :param str schematisation__slug__regex: schematisation__slug__regex
        :param str schematisation__owner__name: schematisation__owner__name
        :param str schematisation__owner__name__iexact: schematisation__owner__name__iexact
        :param str schematisation__owner__name__contains: schematisation__owner__name__contains
        :param str schematisation__owner__name__icontains: schematisation__owner__name__icontains
        :param str schematisation__owner__name__in: schematisation__owner__name__in
        :param str schematisation__owner__name__startswith: schematisation__owner__name__startswith
        :param str schematisation__owner__name__istartswith: schematisation__owner__name__istartswith
        :param str schematisation__owner__name__endswith: schematisation__owner__name__endswith
        :param str schematisation__owner__name__regex: schematisation__owner__name__regex
        :param str schematisation__owner__unique_id: schematisation__owner__unique_id
        :param str schematisation__owner__unique_id__iexact: schematisation__owner__unique_id__iexact
        :param str schematisation__owner__unique_id__contains: schematisation__owner__unique_id__contains
        :param str schematisation__owner__unique_id__icontains: schematisation__owner__unique_id__icontains
        :param str schematisation__owner__unique_id__in: schematisation__owner__unique_id__in
        :param str schematisation__owner__unique_id__startswith: schematisation__owner__unique_id__startswith
        :param str schematisation__owner__unique_id__istartswith: schematisation__owner__unique_id__istartswith
        :param str schematisation__owner__unique_id__endswith: schematisation__owner__unique_id__endswith
        :param str schematisation__owner__unique_id__regex: schematisation__owner__unique_id__regex
        :param str commit_user__username: commit_user__username
        :param str commit_user__username__iexact: commit_user__username__iexact
        :param str commit_user__username__contains: commit_user__username__contains
        :param str commit_user__username__icontains: commit_user__username__icontains
        :param str commit_user__username__in: commit_user__username__in
        :param str commit_user__username__startswith: commit_user__username__startswith
        :param str commit_user__username__istartswith: commit_user__username__istartswith
        :param str commit_user__username__endswith: commit_user__username__endswith
        :param str commit_user__username__regex: commit_user__username__regex
        :param str commit_date: commit_date
        :param str commit_date__gt: commit_date__gt
        :param str commit_date__gte: commit_date__gte
        :param str commit_date__lt: commit_date__lt
        :param str commit_date__lte: commit_date__lte
        :param str commit_date__date: commit_date__date
        :param str commit_date__date__gt: commit_date__date__gt
        :param str commit_date__date__gte: commit_date__date__gte
        :param str commit_date__date__lt: commit_date__date__lt
        :param str commit_date__date__lte: commit_date__date__lte
        :param str commit_date__year: commit_date__year
        :param str commit_date__year__gt: commit_date__year__gt
        :param str commit_date__year__gte: commit_date__year__gte
        :param str commit_date__year__lt: commit_date__year__lt
        :param str commit_date__year__lte: commit_date__year__lte
        :param str commit_date__month: commit_date__month
        :param str commit_date__month__lte: commit_date__month__lte
        :param str commit_date__day: commit_date__day
        :param str commit_date__day__lt: commit_date__day__lt
        :param str commit_date__week: commit_date__week
        :param str commit_date__week_day: commit_date__week_day
        :param str committed: committed
        :param str archived: archived
        :param str is_valid: is_valid
        :param str has_threedimodel: has_threedimodel
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20019, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'schematisation_pk',
            'number',
            'commit_message',
            'commit_message__iexact',
            'commit_message__contains',
            'commit_message__icontains',
            'commit_message__in',
            'commit_message__startswith',
            'commit_message__istartswith',
            'commit_message__endswith',
            'commit_message__regex',
            'schematisation__id',
            'schematisation__slug',
            'schematisation__slug__iexact',
            'schematisation__slug__contains',
            'schematisation__slug__icontains',
            'schematisation__slug__in',
            'schematisation__slug__startswith',
            'schematisation__slug__istartswith',
            'schematisation__slug__endswith',
            'schematisation__slug__regex',
            'schematisation__owner__name',
            'schematisation__owner__name__iexact',
            'schematisation__owner__name__contains',
            'schematisation__owner__name__icontains',
            'schematisation__owner__name__in',
            'schematisation__owner__name__startswith',
            'schematisation__owner__name__istartswith',
            'schematisation__owner__name__endswith',
            'schematisation__owner__name__regex',
            'schematisation__owner__unique_id',
            'schematisation__owner__unique_id__iexact',
            'schematisation__owner__unique_id__contains',
            'schematisation__owner__unique_id__icontains',
            'schematisation__owner__unique_id__in',
            'schematisation__owner__unique_id__startswith',
            'schematisation__owner__unique_id__istartswith',
            'schematisation__owner__unique_id__endswith',
            'schematisation__owner__unique_id__regex',
            'commit_user__username',
            'commit_user__username__iexact',
            'commit_user__username__contains',
            'commit_user__username__icontains',
            'commit_user__username__in',
            'commit_user__username__startswith',
            'commit_user__username__istartswith',
            'commit_user__username__endswith',
            'commit_user__username__regex',
            'commit_date',
            'commit_date__gt',
            'commit_date__gte',
            'commit_date__lt',
            'commit_date__lte',
            'commit_date__date',
            'commit_date__date__gt',
            'commit_date__date__gte',
            'commit_date__date__lt',
            'commit_date__date__lte',
            'commit_date__year',
            'commit_date__year__gt',
            'commit_date__year__gte',
            'commit_date__year__lt',
            'commit_date__year__lte',
            'commit_date__month',
            'commit_date__month__lte',
            'commit_date__day',
            'commit_date__day__lt',
            'commit_date__week',
            'commit_date__week_day',
            'committed',
            'archived',
            'is_valid',
            'has_threedimodel',
            'ordering',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []
        if 'number' in local_var_params and local_var_params['number'] is not None:  # noqa: E501
            query_params.append(('number', local_var_params['number']))  # noqa: E501
        if 'commit_message' in local_var_params and local_var_params['commit_message'] is not None:  # noqa: E501
            query_params.append(('commit_message', local_var_params['commit_message']))  # noqa: E501
        if 'commit_message__iexact' in local_var_params and local_var_params['commit_message__iexact'] is not None:  # noqa: E501
            query_params.append(('commit_message__iexact', local_var_params['commit_message__iexact']))  # noqa: E501
        if 'commit_message__contains' in local_var_params and local_var_params['commit_message__contains'] is not None:  # noqa: E501
            query_params.append(('commit_message__contains', local_var_params['commit_message__contains']))  # noqa: E501
        if 'commit_message__icontains' in local_var_params and local_var_params['commit_message__icontains'] is not None:  # noqa: E501
            query_params.append(('commit_message__icontains', local_var_params['commit_message__icontains']))  # noqa: E501
        if 'commit_message__in' in local_var_params and local_var_params['commit_message__in'] is not None:  # noqa: E501
            query_params.append(('commit_message__in', local_var_params['commit_message__in']))  # noqa: E501
        if 'commit_message__startswith' in local_var_params and local_var_params['commit_message__startswith'] is not None:  # noqa: E501
            query_params.append(('commit_message__startswith', local_var_params['commit_message__startswith']))  # noqa: E501
        if 'commit_message__istartswith' in local_var_params and local_var_params['commit_message__istartswith'] is not None:  # noqa: E501
            query_params.append(('commit_message__istartswith', local_var_params['commit_message__istartswith']))  # noqa: E501
        if 'commit_message__endswith' in local_var_params and local_var_params['commit_message__endswith'] is not None:  # noqa: E501
            query_params.append(('commit_message__endswith', local_var_params['commit_message__endswith']))  # noqa: E501
        if 'commit_message__regex' in local_var_params and local_var_params['commit_message__regex'] is not None:  # noqa: E501
            query_params.append(('commit_message__regex', local_var_params['commit_message__regex']))  # noqa: E501
        if 'schematisation__id' in local_var_params and local_var_params['schematisation__id'] is not None:  # noqa: E501
            query_params.append(('schematisation__id', local_var_params['schematisation__id']))  # noqa: E501
        if 'schematisation__slug' in local_var_params and local_var_params['schematisation__slug'] is not None:  # noqa: E501
            query_params.append(('schematisation__slug', local_var_params['schematisation__slug']))  # noqa: E501
        if 'schematisation__slug__iexact' in local_var_params and local_var_params['schematisation__slug__iexact'] is not None:  # noqa: E501
            query_params.append(('schematisation__slug__iexact', local_var_params['schematisation__slug__iexact']))  # noqa: E501
        if 'schematisation__slug__contains' in local_var_params and local_var_params['schematisation__slug__contains'] is not None:  # noqa: E501
            query_params.append(('schematisation__slug__contains', local_var_params['schematisation__slug__contains']))  # noqa: E501
        if 'schematisation__slug__icontains' in local_var_params and local_var_params['schematisation__slug__icontains'] is not None:  # noqa: E501
            query_params.append(('schematisation__slug__icontains', local_var_params['schematisation__slug__icontains']))  # noqa: E501
        if 'schematisation__slug__in' in local_var_params and local_var_params['schematisation__slug__in'] is not None:  # noqa: E501
            query_params.append(('schematisation__slug__in', local_var_params['schematisation__slug__in']))  # noqa: E501
        if 'schematisation__slug__startswith' in local_var_params and local_var_params['schematisation__slug__startswith'] is not None:  # noqa: E501
            query_params.append(('schematisation__slug__startswith', local_var_params['schematisation__slug__startswith']))  # noqa: E501
        if 'schematisation__slug__istartswith' in local_var_params and local_var_params['schematisation__slug__istartswith'] is not None:  # noqa: E501
            query_params.append(('schematisation__slug__istartswith', local_var_params['schematisation__slug__istartswith']))  # noqa: E501
        if 'schematisation__slug__endswith' in local_var_params and local_var_params['schematisation__slug__endswith'] is not None:  # noqa: E501
            query_params.append(('schematisation__slug__endswith', local_var_params['schematisation__slug__endswith']))  # noqa: E501
        if 'schematisation__slug__regex' in local_var_params and local_var_params['schematisation__slug__regex'] is not None:  # noqa: E501
            query_params.append(('schematisation__slug__regex', local_var_params['schematisation__slug__regex']))  # noqa: E501
        if 'schematisation__owner__name' in local_var_params and local_var_params['schematisation__owner__name'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__name', local_var_params['schematisation__owner__name']))  # noqa: E501
        if 'schematisation__owner__name__iexact' in local_var_params and local_var_params['schematisation__owner__name__iexact'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__name__iexact', local_var_params['schematisation__owner__name__iexact']))  # noqa: E501
        if 'schematisation__owner__name__contains' in local_var_params and local_var_params['schematisation__owner__name__contains'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__name__contains', local_var_params['schematisation__owner__name__contains']))  # noqa: E501
        if 'schematisation__owner__name__icontains' in local_var_params and local_var_params['schematisation__owner__name__icontains'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__name__icontains', local_var_params['schematisation__owner__name__icontains']))  # noqa: E501
        if 'schematisation__owner__name__in' in local_var_params and local_var_params['schematisation__owner__name__in'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__name__in', local_var_params['schematisation__owner__name__in']))  # noqa: E501
        if 'schematisation__owner__name__startswith' in local_var_params and local_var_params['schematisation__owner__name__startswith'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__name__startswith', local_var_params['schematisation__owner__name__startswith']))  # noqa: E501
        if 'schematisation__owner__name__istartswith' in local_var_params and local_var_params['schematisation__owner__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__name__istartswith', local_var_params['schematisation__owner__name__istartswith']))  # noqa: E501
        if 'schematisation__owner__name__endswith' in local_var_params and local_var_params['schematisation__owner__name__endswith'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__name__endswith', local_var_params['schematisation__owner__name__endswith']))  # noqa: E501
        if 'schematisation__owner__name__regex' in local_var_params and local_var_params['schematisation__owner__name__regex'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__name__regex', local_var_params['schematisation__owner__name__regex']))  # noqa: E501
        if 'schematisation__owner__unique_id' in local_var_params and local_var_params['schematisation__owner__unique_id'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__unique_id', local_var_params['schematisation__owner__unique_id']))  # noqa: E501
        if 'schematisation__owner__unique_id__iexact' in local_var_params and local_var_params['schematisation__owner__unique_id__iexact'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__unique_id__iexact', local_var_params['schematisation__owner__unique_id__iexact']))  # noqa: E501
        if 'schematisation__owner__unique_id__contains' in local_var_params and local_var_params['schematisation__owner__unique_id__contains'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__unique_id__contains', local_var_params['schematisation__owner__unique_id__contains']))  # noqa: E501
        if 'schematisation__owner__unique_id__icontains' in local_var_params and local_var_params['schematisation__owner__unique_id__icontains'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__unique_id__icontains', local_var_params['schematisation__owner__unique_id__icontains']))  # noqa: E501
        if 'schematisation__owner__unique_id__in' in local_var_params and local_var_params['schematisation__owner__unique_id__in'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__unique_id__in', local_var_params['schematisation__owner__unique_id__in']))  # noqa: E501
        if 'schematisation__owner__unique_id__startswith' in local_var_params and local_var_params['schematisation__owner__unique_id__startswith'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__unique_id__startswith', local_var_params['schematisation__owner__unique_id__startswith']))  # noqa: E501
        if 'schematisation__owner__unique_id__istartswith' in local_var_params and local_var_params['schematisation__owner__unique_id__istartswith'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__unique_id__istartswith', local_var_params['schematisation__owner__unique_id__istartswith']))  # noqa: E501
        if 'schematisation__owner__unique_id__endswith' in local_var_params and local_var_params['schematisation__owner__unique_id__endswith'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__unique_id__endswith', local_var_params['schematisation__owner__unique_id__endswith']))  # noqa: E501
        if 'schematisation__owner__unique_id__regex' in local_var_params and local_var_params['schematisation__owner__unique_id__regex'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__unique_id__regex', local_var_params['schematisation__owner__unique_id__regex']))  # noqa: E501
        if 'commit_user__username' in local_var_params and local_var_params['commit_user__username'] is not None:  # noqa: E501
            query_params.append(('commit_user__username', local_var_params['commit_user__username']))  # noqa: E501
        if 'commit_user__username__iexact' in local_var_params and local_var_params['commit_user__username__iexact'] is not None:  # noqa: E501
            query_params.append(('commit_user__username__iexact', local_var_params['commit_user__username__iexact']))  # noqa: E501
        if 'commit_user__username__contains' in local_var_params and local_var_params['commit_user__username__contains'] is not None:  # noqa: E501
            query_params.append(('commit_user__username__contains', local_var_params['commit_user__username__contains']))  # noqa: E501
        if 'commit_user__username__icontains' in local_var_params and local_var_params['commit_user__username__icontains'] is not None:  # noqa: E501
            query_params.append(('commit_user__username__icontains', local_var_params['commit_user__username__icontains']))  # noqa: E501
        if 'commit_user__username__in' in local_var_params and local_var_params['commit_user__username__in'] is not None:  # noqa: E501
            query_params.append(('commit_user__username__in', local_var_params['commit_user__username__in']))  # noqa: E501
        if 'commit_user__username__startswith' in local_var_params and local_var_params['commit_user__username__startswith'] is not None:  # noqa: E501
            query_params.append(('commit_user__username__startswith', local_var_params['commit_user__username__startswith']))  # noqa: E501
        if 'commit_user__username__istartswith' in local_var_params and local_var_params['commit_user__username__istartswith'] is not None:  # noqa: E501
            query_params.append(('commit_user__username__istartswith', local_var_params['commit_user__username__istartswith']))  # noqa: E501
        if 'commit_user__username__endswith' in local_var_params and local_var_params['commit_user__username__endswith'] is not None:  # noqa: E501
            query_params.append(('commit_user__username__endswith', local_var_params['commit_user__username__endswith']))  # noqa: E501
        if 'commit_user__username__regex' in local_var_params and local_var_params['commit_user__username__regex'] is not None:  # noqa: E501
            query_params.append(('commit_user__username__regex', local_var_params['commit_user__username__regex']))  # noqa: E501
        if 'commit_date' in local_var_params and local_var_params['commit_date'] is not None:  # noqa: E501
            query_params.append(('commit_date', local_var_params['commit_date']))  # noqa: E501
        if 'commit_date__gt' in local_var_params and local_var_params['commit_date__gt'] is not None:  # noqa: E501
            query_params.append(('commit_date__gt', local_var_params['commit_date__gt']))  # noqa: E501
        if 'commit_date__gte' in local_var_params and local_var_params['commit_date__gte'] is not None:  # noqa: E501
            query_params.append(('commit_date__gte', local_var_params['commit_date__gte']))  # noqa: E501
        if 'commit_date__lt' in local_var_params and local_var_params['commit_date__lt'] is not None:  # noqa: E501
            query_params.append(('commit_date__lt', local_var_params['commit_date__lt']))  # noqa: E501
        if 'commit_date__lte' in local_var_params and local_var_params['commit_date__lte'] is not None:  # noqa: E501
            query_params.append(('commit_date__lte', local_var_params['commit_date__lte']))  # noqa: E501
        if 'commit_date__date' in local_var_params and local_var_params['commit_date__date'] is not None:  # noqa: E501
            query_params.append(('commit_date__date', local_var_params['commit_date__date']))  # noqa: E501
        if 'commit_date__date__gt' in local_var_params and local_var_params['commit_date__date__gt'] is not None:  # noqa: E501
            query_params.append(('commit_date__date__gt', local_var_params['commit_date__date__gt']))  # noqa: E501
        if 'commit_date__date__gte' in local_var_params and local_var_params['commit_date__date__gte'] is not None:  # noqa: E501
            query_params.append(('commit_date__date__gte', local_var_params['commit_date__date__gte']))  # noqa: E501
        if 'commit_date__date__lt' in local_var_params and local_var_params['commit_date__date__lt'] is not None:  # noqa: E501
            query_params.append(('commit_date__date__lt', local_var_params['commit_date__date__lt']))  # noqa: E501
        if 'commit_date__date__lte' in local_var_params and local_var_params['commit_date__date__lte'] is not None:  # noqa: E501
            query_params.append(('commit_date__date__lte', local_var_params['commit_date__date__lte']))  # noqa: E501
        if 'commit_date__year' in local_var_params and local_var_params['commit_date__year'] is not None:  # noqa: E501
            query_params.append(('commit_date__year', local_var_params['commit_date__year']))  # noqa: E501
        if 'commit_date__year__gt' in local_var_params and local_var_params['commit_date__year__gt'] is not None:  # noqa: E501
            query_params.append(('commit_date__year__gt', local_var_params['commit_date__year__gt']))  # noqa: E501
        if 'commit_date__year__gte' in local_var_params and local_var_params['commit_date__year__gte'] is not None:  # noqa: E501
            query_params.append(('commit_date__year__gte', local_var_params['commit_date__year__gte']))  # noqa: E501
        if 'commit_date__year__lt' in local_var_params and local_var_params['commit_date__year__lt'] is not None:  # noqa: E501
            query_params.append(('commit_date__year__lt', local_var_params['commit_date__year__lt']))  # noqa: E501
        if 'commit_date__year__lte' in local_var_params and local_var_params['commit_date__year__lte'] is not None:  # noqa: E501
            query_params.append(('commit_date__year__lte', local_var_params['commit_date__year__lte']))  # noqa: E501
        if 'commit_date__month' in local_var_params and local_var_params['commit_date__month'] is not None:  # noqa: E501
            query_params.append(('commit_date__month', local_var_params['commit_date__month']))  # noqa: E501
        if 'commit_date__month__lte' in local_var_params and local_var_params['commit_date__month__lte'] is not None:  # noqa: E501
            query_params.append(('commit_date__month__lte', local_var_params['commit_date__month__lte']))  # noqa: E501
        if 'commit_date__day' in local_var_params and local_var_params['commit_date__day'] is not None:  # noqa: E501
            query_params.append(('commit_date__day', local_var_params['commit_date__day']))  # noqa: E501
        if 'commit_date__day__lt' in local_var_params and local_var_params['commit_date__day__lt'] is not None:  # noqa: E501
            query_params.append(('commit_date__day__lt', local_var_params['commit_date__day__lt']))  # noqa: E501
        if 'commit_date__week' in local_var_params and local_var_params['commit_date__week'] is not None:  # noqa: E501
            query_params.append(('commit_date__week', local_var_params['commit_date__week']))  # noqa: E501
        if 'commit_date__week_day' in local_var_params and local_var_params['commit_date__week_day'] is not None:  # noqa: E501
            query_params.append(('commit_date__week_day', local_var_params['commit_date__week_day']))  # noqa: E501
        if 'committed' in local_var_params and local_var_params['committed'] is not None:  # noqa: E501
            query_params.append(('committed', local_var_params['committed']))  # noqa: E501
        if 'archived' in local_var_params and local_var_params['archived'] is not None:  # noqa: E501
            query_params.append(('archived', local_var_params['archived']))  # noqa: E501
        if 'is_valid' in local_var_params and local_var_params['is_valid'] is not None:  # noqa: E501
            query_params.append(('is_valid', local_var_params['is_valid']))  # noqa: E501
        if 'has_threedimodel' in local_var_params and local_var_params['has_threedimodel'] is not None:  # noqa: E501
            query_params.append(('has_threedimodel', local_var_params['has_threedimodel']))  # noqa: E501
        if 'ordering' in local_var_params and local_var_params['ordering'] is not None:  # noqa: E501
            query_params.append(('ordering', local_var_params['ordering']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20019',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_partial_update(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_partial_update  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_partial_update(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param UpdateRevision data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UpdateRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_partial_update_with_http_info(id, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_partial_update_with_http_info(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_partial_update  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_partial_update_with_http_info(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param UpdateRevision data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UpdateRevision, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_partial_update`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UpdateRevision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_rasters_create(self, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """Endpoint for creating a raster linked to a revision.  # noqa: E501

        Every raster type can be created/uploaded only once.  Optional md5sum can be added to detect if the file already has been uploaded and automatically perform de-duplication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_create(revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RasterCreate data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevisionRaster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_rasters_create_with_http_info(revision_pk, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_rasters_create_with_http_info(self, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """Endpoint for creating a raster linked to a revision.  # noqa: E501

        Every raster type can be created/uploaded only once.  Optional md5sum can be added to detect if the file already has been uploaded and automatically perform de-duplication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_create_with_http_info(revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RasterCreate data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevisionRaster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'revision_pk',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_rasters_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_rasters_create`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_rasters_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_rasters_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{revision_pk}/rasters/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionRaster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_rasters_delete(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_delete(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_rasters_delete_with_http_info(id, revision_pk, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_rasters_delete_with_http_info(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_delete_with_http_info(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_rasters_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_rasters_delete`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_rasters_delete`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_rasters_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{revision_pk}/rasters/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_rasters_download(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_download(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_rasters_download_with_http_info(id, revision_pk, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_rasters_download_with_http_info(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_download_with_http_info(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_rasters_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_rasters_download`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_rasters_download`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_rasters_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{revision_pk}/rasters/{id}/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_rasters_list(self, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_list(revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20020
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_rasters_list_with_http_info(revision_pk, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_rasters_list_with_http_info(self, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_list_with_http_info(revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20020, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'revision_pk',
            'schematisation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_rasters_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_rasters_list`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_rasters_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{revision_pk}/rasters/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20020',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_rasters_partial_update(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_partial_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_partial_update(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionRaster data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevisionRaster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_rasters_partial_update_with_http_info(id, revision_pk, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_rasters_partial_update_with_http_info(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_partial_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_partial_update_with_http_info(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionRaster data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevisionRaster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_rasters_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_rasters_partial_update`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_rasters_partial_update`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_rasters_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_rasters_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{revision_pk}/rasters/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionRaster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_rasters_read(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_read(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevisionRaster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_rasters_read_with_http_info(id, revision_pk, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_rasters_read_with_http_info(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_read_with_http_info(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevisionRaster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_rasters_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_rasters_read`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_rasters_read`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_rasters_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{revision_pk}/rasters/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionRaster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_rasters_update(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_update(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionRaster data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevisionRaster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_rasters_update_with_http_info(id, revision_pk, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_rasters_update_with_http_info(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_update_with_http_info(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionRaster data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevisionRaster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_rasters_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_rasters_update`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_rasters_update`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_rasters_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_rasters_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{revision_pk}/rasters/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionRaster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_rasters_upload(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_upload  # noqa: E501

        Endpoint for uploading a raster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_upload(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_rasters_upload_with_http_info(id, revision_pk, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_rasters_upload_with_http_info(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_upload  # noqa: E501

        Endpoint for uploading a raster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_upload_with_http_info(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_rasters_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_rasters_upload`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_rasters_upload`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_rasters_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_rasters_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{revision_pk}/rasters/{id}/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_read(self, id, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_read  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_read(id, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SchematisationRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_read_with_http_info(id, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_read_with_http_info(self, id, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_read  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_read_with_http_info(id, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SchematisationRevision, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_read`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SchematisationRevision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_sqlite_delete(self, id, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_sqlite_delete  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_sqlite_delete(id, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_sqlite_delete_with_http_info(id, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_sqlite_delete_with_http_info(self, id, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_sqlite_delete  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_sqlite_delete_with_http_info(id, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_sqlite_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_sqlite_delete`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_sqlite_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{id}/sqlite/delete/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_sqlite_download(self, id, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_sqlite_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_sqlite_download(id, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_sqlite_download_with_http_info(id, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_sqlite_download_with_http_info(self, id, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_sqlite_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_sqlite_download_with_http_info(id, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_sqlite_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_sqlite_download`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_sqlite_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{id}/sqlite/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_sqlite_upload(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """Endpoint for uploading the sqlite file.  # noqa: E501

        The file should preferably be zipped (deflate).  Replaces the present sqlite file if there already exists one.  Optional md5sum can be added to detect if the file already has been uploaded and perform de-duplication. (md5sum of the compressed sqlite file)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_sqlite_upload(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param SqliteFileUpload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_sqlite_upload_with_http_info(id, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_sqlite_upload_with_http_info(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """Endpoint for uploading the sqlite file.  # noqa: E501

        The file should preferably be zipped (deflate).  Replaces the present sqlite file if there already exists one.  Optional md5sum can be added to detect if the file already has been uploaded and perform de-duplication. (md5sum of the compressed sqlite file)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_sqlite_upload_with_http_info(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param SqliteFileUpload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_sqlite_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_sqlite_upload`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_sqlite_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_sqlite_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{id}/sqlite/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_tasks_create(self, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_create  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_create(revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionTask data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevisionTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_tasks_create_with_http_info(revision_pk, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_tasks_create_with_http_info(self, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_create  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_create_with_http_info(revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionTask data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevisionTask, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'revision_pk',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_tasks_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_tasks_create`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_tasks_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_tasks_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{revision_pk}/tasks/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_tasks_delete(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_delete  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_delete(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision task. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_tasks_delete_with_http_info(id, revision_pk, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_tasks_delete_with_http_info(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_delete  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_delete_with_http_info(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision task. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_tasks_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_tasks_delete`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_tasks_delete`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_tasks_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{revision_pk}/tasks/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_tasks_list(self, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_list  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_list(revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_tasks_list_with_http_info(revision_pk, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_tasks_list_with_http_info(self, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_list  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_list_with_http_info(revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20021, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'revision_pk',
            'schematisation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_tasks_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_tasks_list`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_tasks_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{revision_pk}/tasks/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20021',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_tasks_partial_update(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_partial_update  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_partial_update(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision task. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionTask data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevisionTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_tasks_partial_update_with_http_info(id, revision_pk, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_tasks_partial_update_with_http_info(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_partial_update  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_partial_update_with_http_info(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision task. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionTask data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevisionTask, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_tasks_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_tasks_partial_update`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_tasks_partial_update`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_tasks_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_tasks_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{revision_pk}/tasks/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_tasks_read(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_read  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_read(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision task. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevisionTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_tasks_read_with_http_info(id, revision_pk, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_tasks_read_with_http_info(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_read  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_read_with_http_info(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision task. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevisionTask, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_tasks_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_tasks_read`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_tasks_read`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_tasks_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{revision_pk}/tasks/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_tasks_update(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_update  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_update(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision task. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionTask data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevisionTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_tasks_update_with_http_info(id, revision_pk, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_tasks_update_with_http_info(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_update  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_update_with_http_info(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision task. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionTask data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevisionTask, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_tasks_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_tasks_update`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_tasks_update`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_tasks_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_tasks_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{revision_pk}/tasks/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_threedimodels(self, id, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_threedimodels  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_threedimodels(id, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[ThreediModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_threedimodels_with_http_info(id, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_threedimodels_with_http_info(self, id, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_threedimodels  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_threedimodels_with_http_info(id, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[ThreediModel], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_threedimodels" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_threedimodels`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_threedimodels`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{schematisation_pk}/revisions/{id}/threedimodels/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ThreediModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_update(self, id, data, **kwargs):  # noqa: E501
        """schematisations_update  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param Schematisation data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Schematisation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def schematisations_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """schematisations_update  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param Schematisation data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Schematisation, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/schematisations/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Schematisation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulation_templates_create(self, data, **kwargs):  # noqa: E501
        """Create a (optionally cloned) simulation template from the given simulation.  # noqa: E501

        A simulation template is actually nothing more than a simulation with a special status. It's immutable after creation and only can be used to create new simulations.  Simulations 'upgraded' to simulations templates can't be directly run. The 'from_template' endpoint allows to create a new simulation from a template in a runnable state.  A simulation template can be changed by first creating a simulation from it with 'from_template'. Changing that simulation and use this endpoint to 'upgrade' it to a simulation template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulation_templates_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateTemplate data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Template
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulation_templates_create_with_http_info(data, **kwargs)  # noqa: E501

    def simulation_templates_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """Create a (optionally cloned) simulation template from the given simulation.  # noqa: E501

        A simulation template is actually nothing more than a simulation with a special status. It's immutable after creation and only can be used to create new simulations.  Simulations 'upgraded' to simulations templates can't be directly run. The 'from_template' endpoint allows to create a new simulation from a template in a runnable state.  A simulation template can be changed by first creating a simulation from it with 'from_template'. Changing that simulation and use this endpoint to 'upgrade' it to a simulation template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulation_templates_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateTemplate data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Template, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulation_templates_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulation_templates_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulation-templates/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Template',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulation_templates_delete(self, id, **kwargs):  # noqa: E501
        """simulation_templates_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulation_templates_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this template. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulation_templates_delete_with_http_info(id, **kwargs)  # noqa: E501

    def simulation_templates_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """simulation_templates_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulation_templates_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this template. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulation_templates_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulation_templates_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulation-templates/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulation_templates_list(self, **kwargs):  # noqa: E501
        """simulation_templates_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulation_templates_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: name
        :param str name__iexact: name__iexact
        :param str name__contains: name__contains
        :param str name__icontains: name__icontains
        :param str name__in: name__in
        :param str name__startswith: name__startswith
        :param str name__istartswith: name__istartswith
        :param str name__endswith: name__endswith
        :param str name__regex: name__regex
        :param str uuid: uuid
        :param str uuid__iexact: uuid__iexact
        :param str uuid__contains: uuid__contains
        :param str uuid__icontains: uuid__icontains
        :param str uuid__in: uuid__in
        :param str uuid__startswith: uuid__startswith
        :param str uuid__istartswith: uuid__istartswith
        :param str uuid__endswith: uuid__endswith
        :param str uuid__regex: uuid__regex
        :param str created__date: created__date
        :param str created__date__gt: created__date__gt
        :param str created__date__gte: created__date__gte
        :param str created__date__lt: created__date__lt
        :param str created__date__lte: created__date__lte
        :param str created__year: created__year
        :param str created__year__gt: created__year__gt
        :param str created__year__gte: created__year__gte
        :param str created__year__lt: created__year__lt
        :param str created__year__lte: created__year__lte
        :param str created__month: created__month
        :param str created__month__lte: created__month__lte
        :param str created__day: created__day
        :param str created__day__lt: created__day__lt
        :param str simulation__threedimodel__id: simulation__threedimodel__id
        :param str simulation__threedimodel__id__range: simulation__threedimodel__id__range
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20022
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulation_templates_list_with_http_info(**kwargs)  # noqa: E501

    def simulation_templates_list_with_http_info(self, **kwargs):  # noqa: E501
        """simulation_templates_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulation_templates_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: name
        :param str name__iexact: name__iexact
        :param str name__contains: name__contains
        :param str name__icontains: name__icontains
        :param str name__in: name__in
        :param str name__startswith: name__startswith
        :param str name__istartswith: name__istartswith
        :param str name__endswith: name__endswith
        :param str name__regex: name__regex
        :param str uuid: uuid
        :param str uuid__iexact: uuid__iexact
        :param str uuid__contains: uuid__contains
        :param str uuid__icontains: uuid__icontains
        :param str uuid__in: uuid__in
        :param str uuid__startswith: uuid__startswith
        :param str uuid__istartswith: uuid__istartswith
        :param str uuid__endswith: uuid__endswith
        :param str uuid__regex: uuid__regex
        :param str created__date: created__date
        :param str created__date__gt: created__date__gt
        :param str created__date__gte: created__date__gte
        :param str created__date__lt: created__date__lt
        :param str created__date__lte: created__date__lte
        :param str created__year: created__year
        :param str created__year__gt: created__year__gt
        :param str created__year__gte: created__year__gte
        :param str created__year__lt: created__year__lt
        :param str created__year__lte: created__year__lte
        :param str created__month: created__month
        :param str created__month__lte: created__month__lte
        :param str created__day: created__day
        :param str created__day__lt: created__day__lt
        :param str simulation__threedimodel__id: simulation__threedimodel__id
        :param str simulation__threedimodel__id__range: simulation__threedimodel__id__range
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20022, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'name__iexact',
            'name__contains',
            'name__icontains',
            'name__in',
            'name__startswith',
            'name__istartswith',
            'name__endswith',
            'name__regex',
            'uuid',
            'uuid__iexact',
            'uuid__contains',
            'uuid__icontains',
            'uuid__in',
            'uuid__startswith',
            'uuid__istartswith',
            'uuid__endswith',
            'uuid__regex',
            'created__date',
            'created__date__gt',
            'created__date__gte',
            'created__date__lt',
            'created__date__lte',
            'created__year',
            'created__year__gt',
            'created__year__gte',
            'created__year__lt',
            'created__year__lte',
            'created__month',
            'created__month__lte',
            'created__day',
            'created__day__lt',
            'simulation__threedimodel__id',
            'simulation__threedimodel__id__range',
            'ordering',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulation_templates_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'name__iexact' in local_var_params and local_var_params['name__iexact'] is not None:  # noqa: E501
            query_params.append(('name__iexact', local_var_params['name__iexact']))  # noqa: E501
        if 'name__contains' in local_var_params and local_var_params['name__contains'] is not None:  # noqa: E501
            query_params.append(('name__contains', local_var_params['name__contains']))  # noqa: E501
        if 'name__icontains' in local_var_params and local_var_params['name__icontains'] is not None:  # noqa: E501
            query_params.append(('name__icontains', local_var_params['name__icontains']))  # noqa: E501
        if 'name__in' in local_var_params and local_var_params['name__in'] is not None:  # noqa: E501
            query_params.append(('name__in', local_var_params['name__in']))  # noqa: E501
        if 'name__startswith' in local_var_params and local_var_params['name__startswith'] is not None:  # noqa: E501
            query_params.append(('name__startswith', local_var_params['name__startswith']))  # noqa: E501
        if 'name__istartswith' in local_var_params and local_var_params['name__istartswith'] is not None:  # noqa: E501
            query_params.append(('name__istartswith', local_var_params['name__istartswith']))  # noqa: E501
        if 'name__endswith' in local_var_params and local_var_params['name__endswith'] is not None:  # noqa: E501
            query_params.append(('name__endswith', local_var_params['name__endswith']))  # noqa: E501
        if 'name__regex' in local_var_params and local_var_params['name__regex'] is not None:  # noqa: E501
            query_params.append(('name__regex', local_var_params['name__regex']))  # noqa: E501
        if 'uuid' in local_var_params and local_var_params['uuid'] is not None:  # noqa: E501
            query_params.append(('uuid', local_var_params['uuid']))  # noqa: E501
        if 'uuid__iexact' in local_var_params and local_var_params['uuid__iexact'] is not None:  # noqa: E501
            query_params.append(('uuid__iexact', local_var_params['uuid__iexact']))  # noqa: E501
        if 'uuid__contains' in local_var_params and local_var_params['uuid__contains'] is not None:  # noqa: E501
            query_params.append(('uuid__contains', local_var_params['uuid__contains']))  # noqa: E501
        if 'uuid__icontains' in local_var_params and local_var_params['uuid__icontains'] is not None:  # noqa: E501
            query_params.append(('uuid__icontains', local_var_params['uuid__icontains']))  # noqa: E501
        if 'uuid__in' in local_var_params and local_var_params['uuid__in'] is not None:  # noqa: E501
            query_params.append(('uuid__in', local_var_params['uuid__in']))  # noqa: E501
        if 'uuid__startswith' in local_var_params and local_var_params['uuid__startswith'] is not None:  # noqa: E501
            query_params.append(('uuid__startswith', local_var_params['uuid__startswith']))  # noqa: E501
        if 'uuid__istartswith' in local_var_params and local_var_params['uuid__istartswith'] is not None:  # noqa: E501
            query_params.append(('uuid__istartswith', local_var_params['uuid__istartswith']))  # noqa: E501
        if 'uuid__endswith' in local_var_params and local_var_params['uuid__endswith'] is not None:  # noqa: E501
            query_params.append(('uuid__endswith', local_var_params['uuid__endswith']))  # noqa: E501
        if 'uuid__regex' in local_var_params and local_var_params['uuid__regex'] is not None:  # noqa: E501
            query_params.append(('uuid__regex', local_var_params['uuid__regex']))  # noqa: E501
        if 'created__date' in local_var_params and local_var_params['created__date'] is not None:  # noqa: E501
            query_params.append(('created__date', local_var_params['created__date']))  # noqa: E501
        if 'created__date__gt' in local_var_params and local_var_params['created__date__gt'] is not None:  # noqa: E501
            query_params.append(('created__date__gt', local_var_params['created__date__gt']))  # noqa: E501
        if 'created__date__gte' in local_var_params and local_var_params['created__date__gte'] is not None:  # noqa: E501
            query_params.append(('created__date__gte', local_var_params['created__date__gte']))  # noqa: E501
        if 'created__date__lt' in local_var_params and local_var_params['created__date__lt'] is not None:  # noqa: E501
            query_params.append(('created__date__lt', local_var_params['created__date__lt']))  # noqa: E501
        if 'created__date__lte' in local_var_params and local_var_params['created__date__lte'] is not None:  # noqa: E501
            query_params.append(('created__date__lte', local_var_params['created__date__lte']))  # noqa: E501
        if 'created__year' in local_var_params and local_var_params['created__year'] is not None:  # noqa: E501
            query_params.append(('created__year', local_var_params['created__year']))  # noqa: E501
        if 'created__year__gt' in local_var_params and local_var_params['created__year__gt'] is not None:  # noqa: E501
            query_params.append(('created__year__gt', local_var_params['created__year__gt']))  # noqa: E501
        if 'created__year__gte' in local_var_params and local_var_params['created__year__gte'] is not None:  # noqa: E501
            query_params.append(('created__year__gte', local_var_params['created__year__gte']))  # noqa: E501
        if 'created__year__lt' in local_var_params and local_var_params['created__year__lt'] is not None:  # noqa: E501
            query_params.append(('created__year__lt', local_var_params['created__year__lt']))  # noqa: E501
        if 'created__year__lte' in local_var_params and local_var_params['created__year__lte'] is not None:  # noqa: E501
            query_params.append(('created__year__lte', local_var_params['created__year__lte']))  # noqa: E501
        if 'created__month' in local_var_params and local_var_params['created__month'] is not None:  # noqa: E501
            query_params.append(('created__month', local_var_params['created__month']))  # noqa: E501
        if 'created__month__lte' in local_var_params and local_var_params['created__month__lte'] is not None:  # noqa: E501
            query_params.append(('created__month__lte', local_var_params['created__month__lte']))  # noqa: E501
        if 'created__day' in local_var_params and local_var_params['created__day'] is not None:  # noqa: E501
            query_params.append(('created__day', local_var_params['created__day']))  # noqa: E501
        if 'created__day__lt' in local_var_params and local_var_params['created__day__lt'] is not None:  # noqa: E501
            query_params.append(('created__day__lt', local_var_params['created__day__lt']))  # noqa: E501
        if 'simulation__threedimodel__id' in local_var_params and local_var_params['simulation__threedimodel__id'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__id', local_var_params['simulation__threedimodel__id']))  # noqa: E501
        if 'simulation__threedimodel__id__range' in local_var_params and local_var_params['simulation__threedimodel__id__range'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__id__range', local_var_params['simulation__threedimodel__id__range']))  # noqa: E501
        if 'ordering' in local_var_params and local_var_params['ordering'] is not None:  # noqa: E501
            query_params.append(('ordering', local_var_params['ordering']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulation-templates/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20022',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulation_templates_partial_update(self, id, data, **kwargs):  # noqa: E501
        """simulation_templates_partial_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulation_templates_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this template. (required)
        :param UpdateTemplate data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UpdateTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulation_templates_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def simulation_templates_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """simulation_templates_partial_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulation_templates_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this template. (required)
        :param UpdateTemplate data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UpdateTemplate, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulation_templates_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulation_templates_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulation_templates_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulation-templates/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UpdateTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulation_templates_read(self, id, **kwargs):  # noqa: E501
        """simulation_templates_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulation_templates_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this template. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Template
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulation_templates_read_with_http_info(id, **kwargs)  # noqa: E501

    def simulation_templates_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """simulation_templates_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulation_templates_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this template. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Template, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulation_templates_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulation_templates_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulation-templates/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Template',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_actions_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Post an action to the simulation to start, pause or end it.  # noqa: E501

        Example usage:  To initialize a simulation (and pause) ``` {\"name\": \"initialize\"} ```  To initialize and directly run a simulation ``` {\"name\": \"start\"} ``` Also use \"start\" to resume a paused simulation.  If you want to pause the simulation automatically after a given duration use the duration parameter ``` {   \"name\": \"start\",   \"duration\": 2500 } ```  To pause a simulation ``` {\"name\": \"pause\"} ``` Please note: The simulation will automatically be shut down after the default timeout of 300 seconds has been reached. You can customize this value by specifying the timeout parameter ``` {   \"name\": \"pause\",   \"timeout\": 999 } ```  To end a simulation ``` {\"name\": \"shutdown\"} ```  To queue a simulation ``` {\"name\": \"queue\"} ``` Queued simulations will be started as soon as a session spot becomes available. If a session spot is directly is available the simulation will also be started immediately. The response body will then contain `{\"name\": \"start\"}` ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_actions_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param Action data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Action
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_actions_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_actions_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Post an action to the simulation to start, pause or end it.  # noqa: E501

        Example usage:  To initialize a simulation (and pause) ``` {\"name\": \"initialize\"} ```  To initialize and directly run a simulation ``` {\"name\": \"start\"} ``` Also use \"start\" to resume a paused simulation.  If you want to pause the simulation automatically after a given duration use the duration parameter ``` {   \"name\": \"start\",   \"duration\": 2500 } ```  To pause a simulation ``` {\"name\": \"pause\"} ``` Please note: The simulation will automatically be shut down after the default timeout of 300 seconds has been reached. You can customize this value by specifying the timeout parameter ``` {   \"name\": \"pause\",   \"timeout\": 999 } ```  To end a simulation ``` {\"name\": \"shutdown\"} ```  To queue a simulation ``` {\"name\": \"queue\"} ``` Queued simulations will be started as soon as a session spot becomes available. If a session spot is directly is available the simulation will also be started immediately. The response body will then contain `{\"name\": \"start\"}` ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_actions_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param Action data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Action, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_actions_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_actions_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_actions_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/actions/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Action',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_actions_reset_pause_timeout(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Reset the pause timeout with the new specified timeout value  # noqa: E501

        You can only reset the pause timeout when the SimulationStatus.name is 'initialized' and SimulationStatus.paused is True.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_actions_reset_pause_timeout(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param Timeout data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Action
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_actions_reset_pause_timeout_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_actions_reset_pause_timeout_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Reset the pause timeout with the new specified timeout value  # noqa: E501

        You can only reset the pause timeout when the SimulationStatus.name is 'initialized' and SimulationStatus.paused is True.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_actions_reset_pause_timeout_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param Timeout data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Action, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_actions_reset_pause_timeout" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_actions_reset_pause_timeout`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_actions_reset_pause_timeout`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/actions/reset_pause_timeout/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Action',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_clone(self, id, **kwargs):  # noqa: E501
        """Clone the simulation.  # noqa: E501

        Clones the simulation in a runnable state, only events & initials.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_clone(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Simulation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_clone_with_http_info(id, **kwargs)  # noqa: E501

    def simulations_clone_with_http_info(self, id, **kwargs):  # noqa: E501
        """Clone the simulation.  # noqa: E501

        Clones the simulation in a runnable state, only events & initials.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_clone_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Simulation, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_clone" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_clone`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{id}/clone/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Simulation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_create(self, data, **kwargs):  # noqa: E501
        """Create a simulation resource  # noqa: E501

        There are two options to specify the desired duration for the simulation, either by using the ``end_datetime`` **or** the ``duration`` parameter.  ``` {   \"name\":           # give the simulation a name   \"tags\":           # add as many tags as you like: handy to find your simulation back later!   \"threedimodel\":   # The model schema to use for the simulation by                     referring to the id of the threedimodel resource   \"organisation\":   # uuid of the organisation for which the                     simulation is run   \"start_datetime\": # datetime (in ISO 8601 (UTC) format) for the                     simulation start, e.g. \"YYYY-MM-DDThh:mm:ss\"   \"end_datetime\":   # datetime (in ISO 8601 (UTC) format) for the                     simulation end, e.g. \"YYYY-MM-DDThh:mm:ss\"   \"duration\":       # in seconds, can be used instead of end_datetime } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Simulation data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Simulation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_create_with_http_info(data, **kwargs)  # noqa: E501

    def simulations_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """Create a simulation resource  # noqa: E501

        There are two options to specify the desired duration for the simulation, either by using the ``end_datetime`` **or** the ``duration`` parameter.  ``` {   \"name\":           # give the simulation a name   \"tags\":           # add as many tags as you like: handy to find your simulation back later!   \"threedimodel\":   # The model schema to use for the simulation by                     referring to the id of the threedimodel resource   \"organisation\":   # uuid of the organisation for which the                     simulation is run   \"start_datetime\": # datetime (in ISO 8601 (UTC) format) for the                     simulation start, e.g. \"YYYY-MM-DDThh:mm:ss\"   \"end_datetime\":   # datetime (in ISO 8601 (UTC) format) for the                     simulation end, e.g. \"YYYY-MM-DDThh:mm:ss\"   \"duration\":       # in seconds, can be used instead of end_datetime } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Simulation data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Simulation, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Simulation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_create_saved_states_stable_threshold_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Save the state of the simulation to file when a given (set of) variable(s) becomes stable  # noqa: E501

        Example ``` {   \"expiry\": \"2020-08-15T13:02:30.317Z\",   \"thresholds\": [     {       \"variable\": \"s1\",       \"value\": 0.005     }   ] } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_stable_threshold_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param StableThresholdSavedState data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: StableThresholdSavedState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_create_saved_states_stable_threshold_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_create_saved_states_stable_threshold_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Save the state of the simulation to file when a given (set of) variable(s) becomes stable  # noqa: E501

        Example ``` {   \"expiry\": \"2020-08-15T13:02:30.317Z\",   \"thresholds\": [     {       \"variable\": \"s1\",       \"value\": 0.005     }   ] } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_stable_threshold_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param StableThresholdSavedState data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(StableThresholdSavedState, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_create_saved_states_stable_threshold_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_create_saved_states_stable_threshold_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_create_saved_states_stable_threshold_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/create-saved-states/stable-threshold/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StableThresholdSavedState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_create_saved_states_stable_threshold_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_create_saved_states_stable_threshold_delete  # noqa: E501

        Stable threshold SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_stable_threshold_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_create_saved_states_stable_threshold_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_create_saved_states_stable_threshold_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_create_saved_states_stable_threshold_delete  # noqa: E501

        Stable threshold SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_stable_threshold_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_create_saved_states_stable_threshold_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_create_saved_states_stable_threshold_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_create_saved_states_stable_threshold_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/create-saved-states/stable-threshold/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_create_saved_states_stable_threshold_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_create_saved_states_stable_threshold_list  # noqa: E501

        Stable threshold SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_stable_threshold_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20025
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_create_saved_states_stable_threshold_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_create_saved_states_stable_threshold_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_create_saved_states_stable_threshold_list  # noqa: E501

        Stable threshold SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_stable_threshold_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20025, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_create_saved_states_stable_threshold_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_create_saved_states_stable_threshold_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/create-saved-states/stable-threshold/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20025',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_create_saved_states_stable_threshold_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_create_saved_states_stable_threshold_partial_update  # noqa: E501

        When the simulation has started this resource can not be patched.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_stable_threshold_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param StableThresholdSavedState data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_create_saved_states_stable_threshold_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_create_saved_states_stable_threshold_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_create_saved_states_stable_threshold_partial_update  # noqa: E501

        When the simulation has started this resource can not be patched.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_stable_threshold_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param StableThresholdSavedState data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_create_saved_states_stable_threshold_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_create_saved_states_stable_threshold_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_create_saved_states_stable_threshold_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_create_saved_states_stable_threshold_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/create-saved-states/stable-threshold/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_create_saved_states_stable_threshold_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_create_saved_states_stable_threshold_read  # noqa: E501

        Stable threshold SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_stable_threshold_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: StableThresholdSavedState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_create_saved_states_stable_threshold_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_create_saved_states_stable_threshold_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_create_saved_states_stable_threshold_read  # noqa: E501

        Stable threshold SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_stable_threshold_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(StableThresholdSavedState, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_create_saved_states_stable_threshold_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_create_saved_states_stable_threshold_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_create_saved_states_stable_threshold_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/create-saved-states/stable-threshold/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StableThresholdSavedState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_create_saved_states_stable_threshold_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_create_saved_states_stable_threshold_update  # noqa: E501

        Stable threshold SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_stable_threshold_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param StableThresholdSavedState data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: StableThresholdSavedState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_create_saved_states_stable_threshold_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_create_saved_states_stable_threshold_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_create_saved_states_stable_threshold_update  # noqa: E501

        Stable threshold SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_stable_threshold_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param StableThresholdSavedState data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(StableThresholdSavedState, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_create_saved_states_stable_threshold_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_create_saved_states_stable_threshold_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_create_saved_states_stable_threshold_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_create_saved_states_stable_threshold_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/create-saved-states/stable-threshold/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StableThresholdSavedState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_create_saved_states_stable_threshold_upload(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_create_saved_states_stable_threshold_upload  # noqa: E501

        Stable threshold SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_stable_threshold_upload(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_create_saved_states_stable_threshold_upload_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_create_saved_states_stable_threshold_upload_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_create_saved_states_stable_threshold_upload  # noqa: E501

        Stable threshold SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_stable_threshold_upload_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_create_saved_states_stable_threshold_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_create_saved_states_stable_threshold_upload`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_create_saved_states_stable_threshold_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_create_saved_states_stable_threshold_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/create-saved-states/stable-threshold/{id}/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_create_saved_states_timed_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Save the state at a given time of the simulation to file  # noqa: E501

        ```     {       \"name\":   # custom name for the saved state (optional)       \"tags\":   # add tags to the resource. Either space or comma                 separated (optional)       \"expiry\": # datetime (in ISO 8601 (UTC) format) until the saved                 state file will be kept       \"time\":   # the state at this given time of the simulation will                  be saved to file     } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_timed_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimedSavedStateUpdate data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimedSavedStateUpdate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_create_saved_states_timed_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_create_saved_states_timed_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Save the state at a given time of the simulation to file  # noqa: E501

        ```     {       \"name\":   # custom name for the saved state (optional)       \"tags\":   # add tags to the resource. Either space or comma                 separated (optional)       \"expiry\": # datetime (in ISO 8601 (UTC) format) until the saved                 state file will be kept       \"time\":   # the state at this given time of the simulation will                  be saved to file     } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_timed_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimedSavedStateUpdate data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimedSavedStateUpdate, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_create_saved_states_timed_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_create_saved_states_timed_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_create_saved_states_timed_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/create-saved-states/timed/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimedSavedStateUpdate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_create_saved_states_timed_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_create_saved_states_timed_delete  # noqa: E501

        Timed SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_timed_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_create_saved_states_timed_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_create_saved_states_timed_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_create_saved_states_timed_delete  # noqa: E501

        Timed SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_timed_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_create_saved_states_timed_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_create_saved_states_timed_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_create_saved_states_timed_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/create-saved-states/timed/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_create_saved_states_timed_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_create_saved_states_timed_list  # noqa: E501

        Timed SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_timed_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20026
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_create_saved_states_timed_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_create_saved_states_timed_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_create_saved_states_timed_list  # noqa: E501

        Timed SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_timed_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20026, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_create_saved_states_timed_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_create_saved_states_timed_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/create-saved-states/timed/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20026',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_create_saved_states_timed_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_create_saved_states_timed_partial_update  # noqa: E501

        Timed SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_timed_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param TimedSavedStateUpdate data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_create_saved_states_timed_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_create_saved_states_timed_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_create_saved_states_timed_partial_update  # noqa: E501

        Timed SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_timed_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param TimedSavedStateUpdate data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_create_saved_states_timed_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_create_saved_states_timed_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_create_saved_states_timed_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_create_saved_states_timed_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/create-saved-states/timed/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_create_saved_states_timed_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_create_saved_states_timed_read  # noqa: E501

        Timed SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_timed_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimedSavedStateUpdate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_create_saved_states_timed_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_create_saved_states_timed_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_create_saved_states_timed_read  # noqa: E501

        Timed SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_timed_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimedSavedStateUpdate, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_create_saved_states_timed_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_create_saved_states_timed_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_create_saved_states_timed_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/create-saved-states/timed/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimedSavedStateUpdate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_create_saved_states_timed_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_create_saved_states_timed_update  # noqa: E501

        Timed SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_timed_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param TimedSavedStateUpdate data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimedSavedStateUpdate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_create_saved_states_timed_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_create_saved_states_timed_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_create_saved_states_timed_update  # noqa: E501

        Timed SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_timed_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param TimedSavedStateUpdate data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimedSavedStateUpdate, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_create_saved_states_timed_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_create_saved_states_timed_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_create_saved_states_timed_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_create_saved_states_timed_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/create-saved-states/timed/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimedSavedStateUpdate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_create_saved_states_timed_upload(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_create_saved_states_timed_upload  # noqa: E501

        Timed SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_timed_upload(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_create_saved_states_timed_upload_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_create_saved_states_timed_upload_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_create_saved_states_timed_upload  # noqa: E501

        Timed SavedState  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_create_saved_states_timed_upload_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str simulation_pk: (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_create_saved_states_timed_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_create_saved_states_timed_upload`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_create_saved_states_timed_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_create_saved_states_timed_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/create-saved-states/timed/{id}/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_delete(self, id, **kwargs):  # noqa: E501
        """simulations_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_delete_with_http_info(id, **kwargs)  # noqa: E501

    def simulations_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """simulations_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events(self, id, **kwargs):  # noqa: E501
        """simulations_events  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Event
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_with_http_info(id, **kwargs)  # noqa: E501

    def simulations_events_with_http_info(self, id, **kwargs):  # noqa: E501
        """simulations_events  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Event, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{id}/events/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Event',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_boundaryconditions_file_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Endpoint for uploading a boundary-conditions file.  # noqa: E501

        The format of the filename should be <filename>.<extension>, e.g.  `boundary_conditions_bergermeer.json`  Every leading and trailing spaces will be removed. Other spaces are converted to underscores and anything that is not an alphanumeric, dash, underscore, or dot will be removed as well.  The response provides a put_url which allows you to upload a file containing one or more boundary-conditions.  The uploaded file should be a JSON-file containing an array of boundary-conditions timeseries.  The file must contain a timeseries for each boundary condition in the threedimodel. This is validated after upload.  Boundary-conditions need to be added before initializing/starting the simulation and cannot be changed once the simulation is initialized.  Example -------  **Notes** The ordering of the boundaries does not matter.  ``` [     {         \"id\": 1,   # sqlite boundary_1d table id         \"type\": \"1D\",  # \"1D\" for 1d boundaries         \"interpolate\": false,         \"values\": [             [0, 0.5],             [500, 0,8],             [1000, 0]         ]     },     {         \"id\": 2,  # sqlite boundary_2d table id         \"type\": \"2D\", # \"2D\" for 2d boundaries         \"interpolate\": false,         \"values\": [             [0, 0,3],             [400, 0.1]         ]     },     {         \"id\": 3,         \"type\": \"2D\",         \"interpolate\": false,         \"values\": [             [0, -2.4],             [1300, 0,3],             [3000, 1.2],             [3600, 0]         ]     } ] ```  Example with (water quality) substances. **Note**, the substance concentrations timesteps need to exactly match the boundary values timesteps (0, 500, 1000 in example below). ``` [     {         \"id\": 1,   # sqlite boundary_1d table id         \"type\": \"1D\",  # \"1D\" for 1d boundaries         \"interpolate\": false,         \"values\": [             [0, 0.5],             [500, 0,8],             [1000, 0]         ]         \"substances\": [             {                 \"substance\": 1,                 \"interpolate\": false,                 \"concentrations\": [                     [0, 0.1],                     [500, 0.2],                     [1000, 0]                 ]             }         ]     } ] ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_boundaryconditions_file_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_boundaryconditions_file_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_boundaryconditions_file_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Endpoint for uploading a boundary-conditions file.  # noqa: E501

        The format of the filename should be <filename>.<extension>, e.g.  `boundary_conditions_bergermeer.json`  Every leading and trailing spaces will be removed. Other spaces are converted to underscores and anything that is not an alphanumeric, dash, underscore, or dot will be removed as well.  The response provides a put_url which allows you to upload a file containing one or more boundary-conditions.  The uploaded file should be a JSON-file containing an array of boundary-conditions timeseries.  The file must contain a timeseries for each boundary condition in the threedimodel. This is validated after upload.  Boundary-conditions need to be added before initializing/starting the simulation and cannot be changed once the simulation is initialized.  Example -------  **Notes** The ordering of the boundaries does not matter.  ``` [     {         \"id\": 1,   # sqlite boundary_1d table id         \"type\": \"1D\",  # \"1D\" for 1d boundaries         \"interpolate\": false,         \"values\": [             [0, 0.5],             [500, 0,8],             [1000, 0]         ]     },     {         \"id\": 2,  # sqlite boundary_2d table id         \"type\": \"2D\", # \"2D\" for 2d boundaries         \"interpolate\": false,         \"values\": [             [0, 0,3],             [400, 0.1]         ]     },     {         \"id\": 3,         \"type\": \"2D\",         \"interpolate\": false,         \"values\": [             [0, -2.4],             [1300, 0,3],             [3000, 1.2],             [3600, 0]         ]     } ] ```  Example with (water quality) substances. **Note**, the substance concentrations timesteps need to exactly match the boundary values timesteps (0, 500, 1000 in example below). ``` [     {         \"id\": 1,   # sqlite boundary_1d table id         \"type\": \"1D\",  # \"1D\" for 1d boundaries         \"interpolate\": false,         \"values\": [             [0, 0.5],             [500, 0,8],             [1000, 0]         ]         \"substances\": [             {                 \"substance\": 1,                 \"interpolate\": false,                 \"concentrations\": [                     [0, 0.1],                     [500, 0.2],                     [1000, 0]                 ]             }         ]     } ] ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_boundaryconditions_file_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_boundaryconditions_file_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_boundaryconditions_file_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_boundaryconditions_file_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/boundaryconditions/file/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_boundaryconditions_file_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_boundaryconditions_file_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_boundaryconditions_file_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk boundary condition. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_boundaryconditions_file_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_boundaryconditions_file_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_boundaryconditions_file_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_boundaryconditions_file_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk boundary condition. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_boundaryconditions_file_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_boundaryconditions_file_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_boundaryconditions_file_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/boundaryconditions/file/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_boundaryconditions_file_download(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_boundaryconditions_file_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_boundaryconditions_file_download(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk boundary condition. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_boundaryconditions_file_download_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_boundaryconditions_file_download_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_boundaryconditions_file_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_boundaryconditions_file_download_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk boundary condition. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_boundaryconditions_file_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_boundaryconditions_file_download`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_boundaryconditions_file_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/boundaryconditions/file/{id}/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_boundaryconditions_file_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_boundaryconditions_file_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_boundaryconditions_file_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20027
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_boundaryconditions_file_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_boundaryconditions_file_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_boundaryconditions_file_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_boundaryconditions_file_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20027, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_boundaryconditions_file_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_boundaryconditions_file_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/boundaryconditions/file/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20027',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_boundaryconditions_file_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_boundaryconditions_file_partial_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_boundaryconditions_file_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk boundary condition. (required)
        :param str simulation_pk: (required)
        :param FileBoundaryCondition data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FileBoundaryCondition
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_boundaryconditions_file_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_boundaryconditions_file_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_boundaryconditions_file_partial_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_boundaryconditions_file_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk boundary condition. (required)
        :param str simulation_pk: (required)
        :param FileBoundaryCondition data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FileBoundaryCondition, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_boundaryconditions_file_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_boundaryconditions_file_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_boundaryconditions_file_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_boundaryconditions_file_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/boundaryconditions/file/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileBoundaryCondition',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_boundaryconditions_file_processed(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_boundaryconditions_file_processed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_boundaryconditions_file_processed(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk boundary condition. (required)
        :param str simulation_pk: (required)
        :param BaseEventState data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_boundaryconditions_file_processed_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_boundaryconditions_file_processed_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_boundaryconditions_file_processed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_boundaryconditions_file_processed_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk boundary condition. (required)
        :param str simulation_pk: (required)
        :param BaseEventState data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_boundaryconditions_file_processed" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_boundaryconditions_file_processed`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_boundaryconditions_file_processed`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_boundaryconditions_file_processed`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/boundaryconditions/file/{id}/processed/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_boundaryconditions_file_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_boundaryconditions_file_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_boundaryconditions_file_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk boundary condition. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FileBoundaryCondition
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_boundaryconditions_file_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_boundaryconditions_file_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_boundaryconditions_file_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_boundaryconditions_file_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk boundary condition. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FileBoundaryCondition, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_boundaryconditions_file_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_boundaryconditions_file_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_boundaryconditions_file_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/boundaryconditions/file/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileBoundaryCondition',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_boundaryconditions_file_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_boundaryconditions_file_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_boundaryconditions_file_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk boundary condition. (required)
        :param str simulation_pk: (required)
        :param FileBoundaryCondition data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FileBoundaryCondition
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_boundaryconditions_file_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_boundaryconditions_file_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_boundaryconditions_file_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_boundaryconditions_file_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk boundary condition. (required)
        :param str simulation_pk: (required)
        :param FileBoundaryCondition data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FileBoundaryCondition, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_boundaryconditions_file_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_boundaryconditions_file_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_boundaryconditions_file_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_boundaryconditions_file_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/boundaryconditions/file/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileBoundaryCondition',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_breaches_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_breaches_create  # noqa: E501

        Create a breach during a given simulation. The `potential_breach` parameter refers to the id of a potential location associated with the threedimodel. A list of these locations can be retrieved at the uri `/threedimodels/{id}/potentialbreaches/`  The `duration_till_max_depth` parameter describes the time it takes until the deepest point of the breach is reached. [seconds]  `maximum_breach_depth` specifies the maximum depth of the breach relative to the top of the levee [meters]  `initial_width` of the breach [meters]  `discharge_coefficient_positive` and `discharge_coefficient_negative` are dimensionless parameters to deal with behaviour of energy loss around a breach.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_breaches_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param Breach data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Breach
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_breaches_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_breaches_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_breaches_create  # noqa: E501

        Create a breach during a given simulation. The `potential_breach` parameter refers to the id of a potential location associated with the threedimodel. A list of these locations can be retrieved at the uri `/threedimodels/{id}/potentialbreaches/`  The `duration_till_max_depth` parameter describes the time it takes until the deepest point of the breach is reached. [seconds]  `maximum_breach_depth` specifies the maximum depth of the breach relative to the top of the levee [meters]  `initial_width` of the breach [meters]  `discharge_coefficient_positive` and `discharge_coefficient_negative` are dimensionless parameters to deal with behaviour of energy loss around a breach.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_breaches_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param Breach data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Breach, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_breaches_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_breaches_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_breaches_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/breaches/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Breach',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_breaches_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_breaches_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_breaches_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this breach. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_breaches_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_breaches_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_breaches_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_breaches_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this breach. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_breaches_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_breaches_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_breaches_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/breaches/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_breaches_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_breaches_list  # noqa: E501

        A simple ViewSet for viewing Breaches  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_breaches_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20028
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_breaches_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_breaches_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_breaches_list  # noqa: E501

        A simple ViewSet for viewing Breaches  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_breaches_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20028, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_breaches_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_breaches_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/breaches/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20028',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_breaches_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_breaches_partial_update  # noqa: E501

        Please note: **Breach resources are not allowed to be patched after the simulation has started**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_breaches_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this breach. (required)
        :param str simulation_pk: (required)
        :param Breach data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_breaches_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_breaches_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_breaches_partial_update  # noqa: E501

        Please note: **Breach resources are not allowed to be patched after the simulation has started**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_breaches_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this breach. (required)
        :param str simulation_pk: (required)
        :param Breach data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_breaches_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_breaches_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_breaches_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_breaches_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/breaches/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_breaches_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_breaches_read  # noqa: E501

        A simple ViewSet for viewing Breaches  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_breaches_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this breach. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Breach
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_breaches_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_breaches_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_breaches_read  # noqa: E501

        A simple ViewSet for viewing Breaches  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_breaches_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this breach. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Breach, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_breaches_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_breaches_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_breaches_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/breaches/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Breach',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_breaches_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_breaches_update  # noqa: E501

        A simple ViewSet for viewing Breaches  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_breaches_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this breach. (required)
        :param str simulation_pk: (required)
        :param Breach data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Breach
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_breaches_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_breaches_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_breaches_update  # noqa: E501

        A simple ViewSet for viewing Breaches  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_breaches_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this breach. (required)
        :param str simulation_pk: (required)
        :param Breach data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Breach, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_breaches_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_breaches_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_breaches_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_breaches_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/breaches/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Breach',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_constant_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_constant_create  # noqa: E501

        A simple ViewSet for viewing ConstantLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_constant_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param ConstantLateral data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantLateral
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_constant_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_lateral_constant_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_constant_create  # noqa: E501

        A simple ViewSet for viewing ConstantLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_constant_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param ConstantLateral data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantLateral, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_constant_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_constant_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_lateral_constant_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/constant/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantLateral',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_constant_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_constant_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_constant_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_constant_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_lateral_constant_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_constant_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_constant_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_constant_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_lateral_constant_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_constant_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/constant/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_constant_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_constant_list  # noqa: E501

        A simple ViewSet for viewing ConstantLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_constant_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_constant_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_lateral_constant_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_constant_list  # noqa: E501

        A simple ViewSet for viewing ConstantLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_constant_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20029, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_constant_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_constant_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/constant/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20029',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_constant_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_constant_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_constant_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param ConstantLateral data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_constant_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_lateral_constant_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_constant_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_constant_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param ConstantLateral data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_constant_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_lateral_constant_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_constant_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_lateral_constant_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/constant/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_constant_processed(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_constant_processed  # noqa: E501

        A simple ViewSet for viewing ConstantLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_constant_processed(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param GridEventState data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_constant_processed_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_lateral_constant_processed_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_constant_processed  # noqa: E501

        A simple ViewSet for viewing ConstantLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_constant_processed_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param GridEventState data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_constant_processed" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_lateral_constant_processed`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_constant_processed`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_lateral_constant_processed`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/constant/{id}/processed/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_constant_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_constant_read  # noqa: E501

        A simple ViewSet for viewing ConstantLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_constant_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantLateral
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_constant_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_lateral_constant_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_constant_read  # noqa: E501

        A simple ViewSet for viewing ConstantLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_constant_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantLateral, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_constant_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_lateral_constant_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_constant_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/constant/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantLateral',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_constant_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_constant_update  # noqa: E501

        A simple ViewSet for viewing ConstantLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_constant_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param ConstantLateral data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantLateral
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_constant_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_lateral_constant_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_constant_update  # noqa: E501

        A simple ViewSet for viewing ConstantLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_constant_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param ConstantLateral data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantLateral, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_constant_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_lateral_constant_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_constant_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_lateral_constant_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/constant/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantLateral',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_file_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Endpoint for uploading a file with one or more laterals.  # noqa: E501

        The format of the filename should be <filename>.<extension>, e.g.  `laterals_bergermeer.json`  Every leading and trailing spaces will be removed. Other spaces are converted to underscores and anything that is not an alphanumeric, dash, underscore, or dot will be removed as well.  The response provides a put_url which allows you to upload a file containing one or more laterals. These laterals should either be a constant- or a timeseries-lateral, or a combination of both. See their respective endpoint for the required fields of these laterals.  The uploaded file should be a JSON-file containing an array of laterals. Example of the content of such a file: ``` [   {     \"offset\": 100,     \"value\": 0.05,     \"duration\": 300,     \"units\": \"m3/s\",     \"connection_node\": 5   },   {     \"offset\": 180,     \"interpolate\": false,     \"values\": [       [0.0, 0.0002],       [900.0, 0.0],       [1200.0, 0.0001],       [1620.0, 0.0]     ],     \"units\": \"m3/s\",     \"connection_node\": 4   },   {     \"offset\": 0,     \"value\": 0.03,     \"duration\": 500,     \"units\": \"m3/s\",     \"point\": {       \"type\": \"Point\",       \"coordinates\": [4.70184629, 52.62586862]   #  longitude, latitude     }   } ] ```  The `offset` of this file-lateral-event will be applied to each individual lateral offset in the uploaded file  If the `periodic` field is set to `daily` the values given are used for every hour of every day in the simulation. Exactly 25 (0-24) timeseries per entry are required like such:       \"values\": [         [0.0, 0.0002],         [3600, 0.01],         .....         <SNIP>         .....         [82800, 0.15]  # 3600.0 * 23         [86400, 0.0]   # 3600.0 * 24       ]  Only laterals with 'values' are allowed in this case.  The **hour** (not minutes or seconds) of the simulation `start_datetime` (UTC) is taken into consideration for the first timeseries value to use. Periodic laterals are intended for dry weather flow.  Example with (water quality) substances. **Note**: the substance concentrations timesteps need to exactly match the lateral values timesteps (0, 300 in example below). ``` [   {     \"offset\": 100,     \"values\": [[0, 0.05], [300, 0]],     \"units\": \"m3/s\",     \"connection_node\": 5,     \"substances\": [         {\"substance\": 1, \"concentrations\": [[0, 0.1], [300, 0]]}     ]   } ] ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_file_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param UploadEventFile data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UploadEventFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_file_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_lateral_file_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Endpoint for uploading a file with one or more laterals.  # noqa: E501

        The format of the filename should be <filename>.<extension>, e.g.  `laterals_bergermeer.json`  Every leading and trailing spaces will be removed. Other spaces are converted to underscores and anything that is not an alphanumeric, dash, underscore, or dot will be removed as well.  The response provides a put_url which allows you to upload a file containing one or more laterals. These laterals should either be a constant- or a timeseries-lateral, or a combination of both. See their respective endpoint for the required fields of these laterals.  The uploaded file should be a JSON-file containing an array of laterals. Example of the content of such a file: ``` [   {     \"offset\": 100,     \"value\": 0.05,     \"duration\": 300,     \"units\": \"m3/s\",     \"connection_node\": 5   },   {     \"offset\": 180,     \"interpolate\": false,     \"values\": [       [0.0, 0.0002],       [900.0, 0.0],       [1200.0, 0.0001],       [1620.0, 0.0]     ],     \"units\": \"m3/s\",     \"connection_node\": 4   },   {     \"offset\": 0,     \"value\": 0.03,     \"duration\": 500,     \"units\": \"m3/s\",     \"point\": {       \"type\": \"Point\",       \"coordinates\": [4.70184629, 52.62586862]   #  longitude, latitude     }   } ] ```  The `offset` of this file-lateral-event will be applied to each individual lateral offset in the uploaded file  If the `periodic` field is set to `daily` the values given are used for every hour of every day in the simulation. Exactly 25 (0-24) timeseries per entry are required like such:       \"values\": [         [0.0, 0.0002],         [3600, 0.01],         .....         <SNIP>         .....         [82800, 0.15]  # 3600.0 * 23         [86400, 0.0]   # 3600.0 * 24       ]  Only laterals with 'values' are allowed in this case.  The **hour** (not minutes or seconds) of the simulation `start_datetime` (UTC) is taken into consideration for the first timeseries value to use. Periodic laterals are intended for dry weather flow.  Example with (water quality) substances. **Note**: the substance concentrations timesteps need to exactly match the lateral values timesteps (0, 300 in example below). ``` [   {     \"offset\": 100,     \"values\": [[0, 0.05], [300, 0]],     \"units\": \"m3/s\",     \"connection_node\": 5,     \"substances\": [         {\"substance\": 1, \"concentrations\": [[0, 0.1], [300, 0]]}     ]   } ] ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_file_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param UploadEventFile data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UploadEventFile, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_file_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_file_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_lateral_file_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/file/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UploadEventFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_file_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_file_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_file_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk lateral. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_file_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_lateral_file_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_file_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_file_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk lateral. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_file_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_lateral_file_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_file_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/file/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_file_download(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_file_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_file_download(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk lateral. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_file_download_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_lateral_file_download_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_file_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_file_download_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk lateral. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_file_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_lateral_file_download`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_file_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/file/{id}/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_file_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_file_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_file_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_file_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_lateral_file_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_file_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_file_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20030, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_file_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_file_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/file/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20030',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_file_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_file_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_file_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk lateral. (required)
        :param str simulation_pk: (required)
        :param FileLateral data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_file_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_lateral_file_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_file_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_file_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk lateral. (required)
        :param str simulation_pk: (required)
        :param FileLateral data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_file_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_lateral_file_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_file_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_lateral_file_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/file/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_file_processed(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_file_processed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_file_processed(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk lateral. (required)
        :param str simulation_pk: (required)
        :param BaseEventState data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_file_processed_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_lateral_file_processed_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_file_processed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_file_processed_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk lateral. (required)
        :param str simulation_pk: (required)
        :param BaseEventState data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_file_processed" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_lateral_file_processed`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_file_processed`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_lateral_file_processed`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/file/{id}/processed/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_file_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_file_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_file_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk lateral. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FileLateral
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_file_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_lateral_file_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_file_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_file_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk lateral. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FileLateral, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_file_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_lateral_file_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_file_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/file/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileLateral',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_file_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_file_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_file_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk lateral. (required)
        :param str simulation_pk: (required)
        :param FileLateral data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FileLateral
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_file_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_lateral_file_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_file_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_file_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk lateral. (required)
        :param str simulation_pk: (required)
        :param FileLateral data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FileLateral, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_file_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_lateral_file_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_file_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_lateral_file_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/file/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileLateral',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_timeseries_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_timeseries_create  # noqa: E501

        A simple ViewSet for viewing TimeseriesLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_timeseries_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimeseriesLateral data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesLateral
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_timeseries_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_lateral_timeseries_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_timeseries_create  # noqa: E501

        A simple ViewSet for viewing TimeseriesLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_timeseries_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimeseriesLateral data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesLateral, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_timeseries_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_timeseries_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_lateral_timeseries_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/timeseries/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesLateral',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_timeseries_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_timeseries_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_timeseries_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_timeseries_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_lateral_timeseries_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_timeseries_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_timeseries_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_timeseries_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_lateral_timeseries_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_timeseries_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/timeseries/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_timeseries_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_timeseries_list  # noqa: E501

        A simple ViewSet for viewing TimeseriesLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_timeseries_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_timeseries_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_lateral_timeseries_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_timeseries_list  # noqa: E501

        A simple ViewSet for viewing TimeseriesLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_timeseries_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20031, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_timeseries_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_timeseries_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/timeseries/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20031',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_timeseries_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_timeseries_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_timeseries_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param TimeseriesLateral data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_timeseries_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_lateral_timeseries_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_timeseries_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_timeseries_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param TimeseriesLateral data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_timeseries_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_lateral_timeseries_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_timeseries_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_lateral_timeseries_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/timeseries/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_timeseries_processed(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_timeseries_processed  # noqa: E501

        A simple ViewSet for viewing TimeseriesLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_timeseries_processed(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param GridEventState data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_timeseries_processed_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_lateral_timeseries_processed_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_timeseries_processed  # noqa: E501

        A simple ViewSet for viewing TimeseriesLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_timeseries_processed_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param GridEventState data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_timeseries_processed" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_lateral_timeseries_processed`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_timeseries_processed`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_lateral_timeseries_processed`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/timeseries/{id}/processed/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_timeseries_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_timeseries_read  # noqa: E501

        A simple ViewSet for viewing TimeseriesLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_timeseries_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesLateral
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_timeseries_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_lateral_timeseries_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_lateral_timeseries_read  # noqa: E501

        A simple ViewSet for viewing TimeseriesLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_timeseries_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesLateral, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_timeseries_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_lateral_timeseries_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_timeseries_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/timeseries/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesLateral',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_lateral_timeseries_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_timeseries_update  # noqa: E501

        A simple ViewSet for viewing TimeseriesLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_timeseries_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param TimeseriesLateral data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesLateral
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_lateral_timeseries_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_lateral_timeseries_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_lateral_timeseries_update  # noqa: E501

        A simple ViewSet for viewing TimeseriesLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_lateral_timeseries_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lateral. (required)
        :param str simulation_pk: (required)
        :param TimeseriesLateral data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesLateral, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_lateral_timeseries_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_lateral_timeseries_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_lateral_timeseries_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_lateral_timeseries_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/lateral/timeseries/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesLateral',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_constant_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_leakage_constant_create  # noqa: E501

        A simple ViewSet for viewing ConstantLeakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_constant_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param ConstantLeakage data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantLeakage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_constant_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_leakage_constant_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_leakage_constant_create  # noqa: E501

        A simple ViewSet for viewing ConstantLeakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_constant_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param ConstantLeakage data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantLeakage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_constant_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_constant_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_leakage_constant_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/constant/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantLeakage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_constant_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_constant_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_constant_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_constant_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_leakage_constant_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_constant_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_constant_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_constant_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_leakage_constant_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_constant_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/constant/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_constant_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_constant_list  # noqa: E501

        A simple ViewSet for viewing ConstantLeakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_constant_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_constant_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_leakage_constant_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_constant_list  # noqa: E501

        A simple ViewSet for viewing ConstantLeakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_constant_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20032, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_constant_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_constant_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/constant/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20032',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_constant_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_leakage_constant_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_constant_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param ConstantLeakage data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_constant_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_leakage_constant_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_leakage_constant_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_constant_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param ConstantLeakage data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_constant_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_leakage_constant_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_constant_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_leakage_constant_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/constant/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_constant_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_constant_read  # noqa: E501

        A simple ViewSet for viewing ConstantLeakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_constant_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantLeakage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_constant_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_leakage_constant_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_constant_read  # noqa: E501

        A simple ViewSet for viewing ConstantLeakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_constant_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantLeakage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_constant_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_leakage_constant_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_constant_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/constant/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantLeakage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_constant_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_leakage_constant_update  # noqa: E501

        A simple ViewSet for viewing ConstantLeakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_constant_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param ConstantLeakage data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantLeakage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_constant_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_leakage_constant_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_leakage_constant_update  # noqa: E501

        A simple ViewSet for viewing ConstantLeakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_constant_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param ConstantLeakage data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantLeakage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_constant_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_leakage_constant_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_constant_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_leakage_constant_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/constant/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantLeakage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_rasters_netcdf_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_leakage_rasters_netcdf_create  # noqa: E501

        NetCDF 4 raster leakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_rasters_netcdf_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param UploadWithSubstances data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UploadWithSubstances
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_rasters_netcdf_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_leakage_rasters_netcdf_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_leakage_rasters_netcdf_create  # noqa: E501

        NetCDF 4 raster leakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_rasters_netcdf_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param UploadWithSubstances data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UploadWithSubstances, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_rasters_netcdf_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_rasters_netcdf_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_leakage_rasters_netcdf_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/rasters/netcdf/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UploadWithSubstances',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_rasters_netcdf_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_rasters_netcdf_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_rasters_netcdf_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster leakage. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_rasters_netcdf_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_leakage_rasters_netcdf_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_rasters_netcdf_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_rasters_netcdf_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster leakage. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_rasters_netcdf_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_leakage_rasters_netcdf_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_rasters_netcdf_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/rasters/netcdf/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_rasters_netcdf_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_rasters_netcdf_list  # noqa: E501

        NetCDF 4 raster leakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_rasters_netcdf_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20033
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_rasters_netcdf_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_leakage_rasters_netcdf_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_rasters_netcdf_list  # noqa: E501

        NetCDF 4 raster leakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_rasters_netcdf_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20033, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_rasters_netcdf_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_rasters_netcdf_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/rasters/netcdf/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20033',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_rasters_netcdf_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_rasters_netcdf_read  # noqa: E501

        NetCDF 4 raster leakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_rasters_netcdf_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster leakage. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: NetCDFRasterLeakage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_rasters_netcdf_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_leakage_rasters_netcdf_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_rasters_netcdf_read  # noqa: E501

        NetCDF 4 raster leakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_rasters_netcdf_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster leakage. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(NetCDFRasterLeakage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_rasters_netcdf_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_leakage_rasters_netcdf_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_rasters_netcdf_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/rasters/netcdf/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetCDFRasterLeakage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_timeseries_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_create  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimeseriesLeakage data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesLeakage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_timeseries_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_leakage_timeseries_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_create  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimeseriesLeakage data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesLeakage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_timeseries_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_timeseries_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_leakage_timeseries_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/timeseries/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesLeakage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_timeseries_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_timeseries_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_leakage_timeseries_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_timeseries_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_leakage_timeseries_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_timeseries_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/timeseries/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_timeseries_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_list  # noqa: E501

        A simple ViewSet for viewing TimeseriesLeakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20034
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_timeseries_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_leakage_timeseries_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_list  # noqa: E501

        A simple ViewSet for viewing TimeseriesLeakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20034, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_timeseries_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_timeseries_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/timeseries/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20034',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_timeseries_netcdf_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_netcdf_create  # noqa: E501

        NetCDF 4 timeseries leakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_netcdf_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param UploadWithSubstances data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UploadWithSubstances
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_timeseries_netcdf_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_leakage_timeseries_netcdf_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_netcdf_create  # noqa: E501

        NetCDF 4 timeseries leakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_netcdf_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param UploadWithSubstances data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UploadWithSubstances, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_timeseries_netcdf_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_timeseries_netcdf_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_leakage_timeseries_netcdf_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/timeseries/netcdf/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UploadWithSubstances',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_timeseries_netcdf_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_netcdf_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_netcdf_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_timeseries_netcdf_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_leakage_timeseries_netcdf_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_netcdf_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_netcdf_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_timeseries_netcdf_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_leakage_timeseries_netcdf_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_timeseries_netcdf_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/timeseries/netcdf/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_timeseries_netcdf_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_netcdf_list  # noqa: E501

        NetCDF 4 timeseries leakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_netcdf_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20035
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_timeseries_netcdf_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_leakage_timeseries_netcdf_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_netcdf_list  # noqa: E501

        NetCDF 4 timeseries leakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_netcdf_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20035, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_timeseries_netcdf_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_timeseries_netcdf_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/timeseries/netcdf/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20035',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_timeseries_netcdf_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_netcdf_read  # noqa: E501

        NetCDF 4 timeseries leakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_netcdf_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: NetCDFTimeseriesLeakage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_timeseries_netcdf_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_leakage_timeseries_netcdf_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_netcdf_read  # noqa: E501

        NetCDF 4 timeseries leakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_netcdf_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(NetCDFTimeseriesLeakage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_timeseries_netcdf_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_leakage_timeseries_netcdf_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_timeseries_netcdf_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/timeseries/netcdf/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetCDFTimeseriesLeakage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_timeseries_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param TimeseriesLeakage data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_timeseries_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_leakage_timeseries_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param TimeseriesLeakage data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_timeseries_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_leakage_timeseries_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_timeseries_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_leakage_timeseries_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/timeseries/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_timeseries_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_read  # noqa: E501

        A simple ViewSet for viewing TimeseriesLeakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesLeakage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_timeseries_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_leakage_timeseries_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_read  # noqa: E501

        A simple ViewSet for viewing TimeseriesLeakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesLeakage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_timeseries_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_leakage_timeseries_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_timeseries_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/timeseries/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesLeakage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_leakage_timeseries_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_update  # noqa: E501

        A simple ViewSet for viewing TimeseriesLeakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param TimeseriesLeakage data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesLeakage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_leakage_timeseries_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_leakage_timeseries_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_leakage_timeseries_update  # noqa: E501

        A simple ViewSet for viewing TimeseriesLeakage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_leakage_timeseries_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries leakage. (required)
        :param str simulation_pk: (required)
        :param TimeseriesLeakage data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesLeakage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_leakage_timeseries_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_leakage_timeseries_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_leakage_timeseries_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_leakage_timeseries_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/leakage/timeseries/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesLeakage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_constant_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_constant_create  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_constant_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param ConstantRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_constant_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_constant_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_constant_create  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_constant_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param ConstantRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_constant_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_constant_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_constant_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/constant/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_constant_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_constant_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_constant_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries rain. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_constant_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_constant_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_constant_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_constant_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries rain. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_constant_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_constant_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_constant_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/constant/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_constant_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_constant_list  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_constant_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20036
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_constant_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_constant_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_constant_list  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_constant_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20036, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_constant_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_constant_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/constant/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20036',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_constant_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_constant_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_constant_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries rain. (required)
        :param str simulation_pk: (required)
        :param ConstantRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_constant_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_constant_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_constant_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_constant_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries rain. (required)
        :param str simulation_pk: (required)
        :param ConstantRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_constant_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_constant_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_constant_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_constant_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/constant/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_constant_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_constant_read  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_constant_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries rain. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_constant_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_constant_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_constant_read  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_constant_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries rain. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_constant_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_constant_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_constant_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/constant/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_constant_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_constant_update  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_constant_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries rain. (required)
        :param str simulation_pk: (required)
        :param ConstantRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_constant_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_constant_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_constant_update  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_constant_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries rain. (required)
        :param str simulation_pk: (required)
        :param ConstantRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_constant_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_constant_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_constant_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_constant_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/constant/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_local_constant_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_local_constant_create  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_constant_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param ConstantLocalRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantLocalRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_local_constant_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_local_constant_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_local_constant_create  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_constant_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param ConstantLocalRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantLocalRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_local_constant_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_local_constant_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_local_constant_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/local/constant/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantLocalRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_local_constant_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_local_constant_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_constant_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this local rain. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_local_constant_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_local_constant_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_local_constant_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_constant_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this local rain. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_local_constant_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_local_constant_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_local_constant_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/local/constant/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_local_constant_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_local_constant_list  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_constant_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20037
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_local_constant_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_local_constant_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_local_constant_list  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_constant_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20037, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_local_constant_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_local_constant_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/local/constant/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20037',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_local_constant_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_local_constant_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_constant_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this local rain. (required)
        :param str simulation_pk: (required)
        :param ConstantLocalRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_local_constant_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_local_constant_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_local_constant_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_constant_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this local rain. (required)
        :param str simulation_pk: (required)
        :param ConstantLocalRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_local_constant_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_local_constant_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_local_constant_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_local_constant_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/local/constant/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_local_constant_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_local_constant_read  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_constant_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this local rain. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantLocalRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_local_constant_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_local_constant_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_local_constant_read  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_constant_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this local rain. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantLocalRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_local_constant_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_local_constant_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_local_constant_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/local/constant/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantLocalRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_local_constant_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_local_constant_update  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_constant_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this local rain. (required)
        :param str simulation_pk: (required)
        :param ConstantLocalRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantLocalRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_local_constant_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_local_constant_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_local_constant_update  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_constant_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this local rain. (required)
        :param str simulation_pk: (required)
        :param ConstantLocalRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantLocalRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_local_constant_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_local_constant_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_local_constant_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_local_constant_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/local/constant/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantLocalRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_local_timeseries_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_local_timeseries_create  # noqa: E501

        A simple ViewSet for viewing TimeseriesLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_timeseries_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimeseriesLocalRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesLocalRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_local_timeseries_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_local_timeseries_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_local_timeseries_create  # noqa: E501

        A simple ViewSet for viewing TimeseriesLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_timeseries_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimeseriesLocalRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesLocalRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_local_timeseries_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_local_timeseries_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_local_timeseries_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/local/timeseries/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesLocalRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_local_timeseries_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_local_timeseries_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_timeseries_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this local rain. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_local_timeseries_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_local_timeseries_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_local_timeseries_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_timeseries_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this local rain. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_local_timeseries_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_local_timeseries_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_local_timeseries_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/local/timeseries/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_local_timeseries_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_local_timeseries_list  # noqa: E501

        A simple ViewSet for viewing TimeseriesLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_timeseries_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20038
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_local_timeseries_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_local_timeseries_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_local_timeseries_list  # noqa: E501

        A simple ViewSet for viewing TimeseriesLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_timeseries_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20038, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_local_timeseries_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_local_timeseries_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/local/timeseries/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20038',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_local_timeseries_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_local_timeseries_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_timeseries_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this local rain. (required)
        :param str simulation_pk: (required)
        :param TimeseriesLocalRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_local_timeseries_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_local_timeseries_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_local_timeseries_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_timeseries_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this local rain. (required)
        :param str simulation_pk: (required)
        :param TimeseriesLocalRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_local_timeseries_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_local_timeseries_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_local_timeseries_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_local_timeseries_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/local/timeseries/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_local_timeseries_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_local_timeseries_read  # noqa: E501

        A simple ViewSet for viewing TimeseriesLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_timeseries_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this local rain. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesLocalRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_local_timeseries_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_local_timeseries_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_local_timeseries_read  # noqa: E501

        A simple ViewSet for viewing TimeseriesLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_timeseries_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this local rain. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesLocalRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_local_timeseries_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_local_timeseries_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_local_timeseries_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/local/timeseries/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesLocalRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_local_timeseries_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_local_timeseries_update  # noqa: E501

        A simple ViewSet for viewing TimeseriesLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_timeseries_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this local rain. (required)
        :param str simulation_pk: (required)
        :param TimeseriesLocalRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesLocalRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_local_timeseries_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_local_timeseries_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_local_timeseries_update  # noqa: E501

        A simple ViewSet for viewing TimeseriesLateral  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_local_timeseries_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this local rain. (required)
        :param str simulation_pk: (required)
        :param TimeseriesLocalRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesLocalRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_local_timeseries_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_local_timeseries_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_local_timeseries_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_local_timeseries_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/local/timeseries/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesLocalRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_rasters_lizard_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_lizard_create  # noqa: E501

        A simple ViewSet for viewing lizardRasterRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_lizard_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param LizardRasterRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LizardRasterRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_rasters_lizard_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_rasters_lizard_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_lizard_create  # noqa: E501

        A simple ViewSet for viewing lizardRasterRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_lizard_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param LizardRasterRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LizardRasterRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_rasters_lizard_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_rasters_lizard_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_rasters_lizard_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/rasters/lizard/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LizardRasterRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_rasters_lizard_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_lizard_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_lizard_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard raster rain. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_rasters_lizard_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_rasters_lizard_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_lizard_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_lizard_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard raster rain. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_rasters_lizard_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_rasters_lizard_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_rasters_lizard_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/rasters/lizard/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_rasters_lizard_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_lizard_list  # noqa: E501

        A simple ViewSet for viewing lizardRasterRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_lizard_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20039
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_rasters_lizard_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_rasters_lizard_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_lizard_list  # noqa: E501

        A simple ViewSet for viewing lizardRasterRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_lizard_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20039, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_rasters_lizard_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_rasters_lizard_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/rasters/lizard/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20039',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_rasters_lizard_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_lizard_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_lizard_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard raster rain. (required)
        :param str simulation_pk: (required)
        :param LizardRasterRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_rasters_lizard_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_rasters_lizard_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_lizard_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_lizard_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard raster rain. (required)
        :param str simulation_pk: (required)
        :param LizardRasterRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_rasters_lizard_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_rasters_lizard_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_rasters_lizard_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_rasters_lizard_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/rasters/lizard/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_rasters_lizard_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_lizard_read  # noqa: E501

        A simple ViewSet for viewing lizardRasterRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_lizard_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard raster rain. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LizardRasterRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_rasters_lizard_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_rasters_lizard_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_lizard_read  # noqa: E501

        A simple ViewSet for viewing lizardRasterRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_lizard_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard raster rain. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LizardRasterRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_rasters_lizard_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_rasters_lizard_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_rasters_lizard_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/rasters/lizard/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LizardRasterRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_rasters_lizard_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_lizard_update  # noqa: E501

        A simple ViewSet for viewing lizardRasterRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_lizard_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard raster rain. (required)
        :param str simulation_pk: (required)
        :param LizardRasterRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LizardRasterRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_rasters_lizard_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_rasters_lizard_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_lizard_update  # noqa: E501

        A simple ViewSet for viewing lizardRasterRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_lizard_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard raster rain. (required)
        :param str simulation_pk: (required)
        :param LizardRasterRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LizardRasterRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_rasters_lizard_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_rasters_lizard_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_rasters_lizard_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_rasters_lizard_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/rasters/lizard/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LizardRasterRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_rasters_netcdf_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_netcdf_create  # noqa: E501

        NetCDF 4 raster rain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_netcdf_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param UploadWithSubstances data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UploadWithSubstances
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_rasters_netcdf_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_rasters_netcdf_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_netcdf_create  # noqa: E501

        NetCDF 4 raster rain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_netcdf_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param UploadWithSubstances data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UploadWithSubstances, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_rasters_netcdf_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_rasters_netcdf_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_rasters_netcdf_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/rasters/netcdf/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UploadWithSubstances',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_rasters_netcdf_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_netcdf_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_netcdf_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster rain. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_rasters_netcdf_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_rasters_netcdf_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_netcdf_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_netcdf_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster rain. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_rasters_netcdf_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_rasters_netcdf_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_rasters_netcdf_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/rasters/netcdf/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_rasters_netcdf_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_netcdf_list  # noqa: E501

        NetCDF 4 raster rain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_netcdf_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20040
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_rasters_netcdf_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_rasters_netcdf_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_netcdf_list  # noqa: E501

        NetCDF 4 raster rain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_netcdf_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20040, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_rasters_netcdf_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_rasters_netcdf_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/rasters/netcdf/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20040',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_rasters_netcdf_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_netcdf_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_netcdf_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster rain. (required)
        :param str simulation_pk: (required)
        :param NetCDFRasterRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_rasters_netcdf_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_rasters_netcdf_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_netcdf_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_netcdf_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster rain. (required)
        :param str simulation_pk: (required)
        :param NetCDFRasterRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_rasters_netcdf_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_rasters_netcdf_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_rasters_netcdf_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_rasters_netcdf_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/rasters/netcdf/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_rasters_netcdf_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_netcdf_read  # noqa: E501

        NetCDF 4 raster rain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_netcdf_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster rain. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: NetCDFRasterRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_rasters_netcdf_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_rasters_netcdf_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_netcdf_read  # noqa: E501

        NetCDF 4 raster rain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_netcdf_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster rain. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(NetCDFRasterRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_rasters_netcdf_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_rasters_netcdf_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_rasters_netcdf_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/rasters/netcdf/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetCDFRasterRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_rasters_netcdf_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_netcdf_update  # noqa: E501

        NetCDF 4 raster rain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_netcdf_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster rain. (required)
        :param str simulation_pk: (required)
        :param NetCDFRasterRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: NetCDFRasterRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_rasters_netcdf_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_rasters_netcdf_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_rasters_netcdf_update  # noqa: E501

        NetCDF 4 raster rain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_rasters_netcdf_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster rain. (required)
        :param str simulation_pk: (required)
        :param NetCDFRasterRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(NetCDFRasterRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_rasters_netcdf_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_rasters_netcdf_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_rasters_netcdf_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_rasters_netcdf_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/rasters/netcdf/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetCDFRasterRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_timeseries_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_create  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimeseriesRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_timeseries_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_timeseries_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_create  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimeseriesRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_timeseries_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_timeseries_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_timeseries_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/timeseries/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_timeseries_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries rain. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_timeseries_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_timeseries_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries rain. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_timeseries_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_timeseries_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_timeseries_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/timeseries/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_timeseries_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_list  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20041
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_timeseries_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_timeseries_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_list  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20041, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_timeseries_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_timeseries_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/timeseries/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20041',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_timeseries_lizard_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_lizard_create  # noqa: E501

        A simple ViewSet for viewing LizardTimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_lizard_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param LizardTimeseriesRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LizardTimeseriesRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_timeseries_lizard_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_timeseries_lizard_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_lizard_create  # noqa: E501

        A simple ViewSet for viewing LizardTimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_lizard_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param LizardTimeseriesRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LizardTimeseriesRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_timeseries_lizard_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_timeseries_lizard_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_timeseries_lizard_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/timeseries/lizard/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LizardTimeseriesRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_timeseries_lizard_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_lizard_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_lizard_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard timeseries rain. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_timeseries_lizard_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_timeseries_lizard_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_lizard_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_lizard_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard timeseries rain. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_timeseries_lizard_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_timeseries_lizard_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_timeseries_lizard_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/timeseries/lizard/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_timeseries_lizard_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_lizard_list  # noqa: E501

        A simple ViewSet for viewing LizardTimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_lizard_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20042
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_timeseries_lizard_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_timeseries_lizard_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_lizard_list  # noqa: E501

        A simple ViewSet for viewing LizardTimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_lizard_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20042, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_timeseries_lizard_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_timeseries_lizard_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/timeseries/lizard/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20042',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_timeseries_lizard_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_lizard_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_lizard_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard timeseries rain. (required)
        :param str simulation_pk: (required)
        :param LizardTimeseriesRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_timeseries_lizard_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_timeseries_lizard_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_lizard_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_lizard_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard timeseries rain. (required)
        :param str simulation_pk: (required)
        :param LizardTimeseriesRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_timeseries_lizard_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_timeseries_lizard_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_timeseries_lizard_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_timeseries_lizard_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/timeseries/lizard/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_timeseries_lizard_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_lizard_read  # noqa: E501

        A simple ViewSet for viewing LizardTimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_lizard_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard timeseries rain. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LizardTimeseriesRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_timeseries_lizard_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_timeseries_lizard_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_lizard_read  # noqa: E501

        A simple ViewSet for viewing LizardTimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_lizard_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard timeseries rain. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LizardTimeseriesRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_timeseries_lizard_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_timeseries_lizard_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_timeseries_lizard_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/timeseries/lizard/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LizardTimeseriesRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_timeseries_lizard_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_lizard_update  # noqa: E501

        A simple ViewSet for viewing LizardTimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_lizard_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard timeseries rain. (required)
        :param str simulation_pk: (required)
        :param LizardTimeseriesRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LizardTimeseriesRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_timeseries_lizard_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_timeseries_lizard_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_lizard_update  # noqa: E501

        A simple ViewSet for viewing LizardTimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_lizard_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard timeseries rain. (required)
        :param str simulation_pk: (required)
        :param LizardTimeseriesRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LizardTimeseriesRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_timeseries_lizard_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_timeseries_lizard_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_timeseries_lizard_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_timeseries_lizard_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/timeseries/lizard/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LizardTimeseriesRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_timeseries_netcdf_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_netcdf_create  # noqa: E501

        NetCDF 4 timeseries rain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_netcdf_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param UploadWithSubstances data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UploadWithSubstances
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_timeseries_netcdf_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_timeseries_netcdf_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_netcdf_create  # noqa: E501

        NetCDF 4 timeseries rain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_netcdf_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param UploadWithSubstances data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UploadWithSubstances, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_timeseries_netcdf_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_timeseries_netcdf_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_timeseries_netcdf_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/timeseries/netcdf/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UploadWithSubstances',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_timeseries_netcdf_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_netcdf_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_netcdf_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file timeseries rain. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_timeseries_netcdf_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_timeseries_netcdf_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_netcdf_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_netcdf_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file timeseries rain. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_timeseries_netcdf_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_timeseries_netcdf_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_timeseries_netcdf_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/timeseries/netcdf/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_timeseries_netcdf_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_netcdf_list  # noqa: E501

        NetCDF 4 timeseries rain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_netcdf_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20043
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_timeseries_netcdf_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_timeseries_netcdf_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_netcdf_list  # noqa: E501

        NetCDF 4 timeseries rain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_netcdf_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20043, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_timeseries_netcdf_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_timeseries_netcdf_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/timeseries/netcdf/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20043',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_timeseries_netcdf_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_netcdf_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_netcdf_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file timeseries rain. (required)
        :param str simulation_pk: (required)
        :param NetCDFTimeseriesRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_timeseries_netcdf_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_timeseries_netcdf_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_netcdf_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_netcdf_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file timeseries rain. (required)
        :param str simulation_pk: (required)
        :param NetCDFTimeseriesRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_timeseries_netcdf_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_timeseries_netcdf_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_timeseries_netcdf_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_timeseries_netcdf_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/timeseries/netcdf/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_timeseries_netcdf_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_netcdf_read  # noqa: E501

        NetCDF 4 timeseries rain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_netcdf_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file timeseries rain. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: NetCDFTimeseriesRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_timeseries_netcdf_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_timeseries_netcdf_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_netcdf_read  # noqa: E501

        NetCDF 4 timeseries rain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_netcdf_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file timeseries rain. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(NetCDFTimeseriesRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_timeseries_netcdf_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_timeseries_netcdf_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_timeseries_netcdf_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/timeseries/netcdf/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetCDFTimeseriesRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_timeseries_netcdf_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_netcdf_update  # noqa: E501

        NetCDF 4 timeseries rain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_netcdf_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file timeseries rain. (required)
        :param str simulation_pk: (required)
        :param NetCDFTimeseriesRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: NetCDFTimeseriesRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_timeseries_netcdf_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_timeseries_netcdf_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_netcdf_update  # noqa: E501

        NetCDF 4 timeseries rain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_netcdf_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file timeseries rain. (required)
        :param str simulation_pk: (required)
        :param NetCDFTimeseriesRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(NetCDFTimeseriesRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_timeseries_netcdf_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_timeseries_netcdf_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_timeseries_netcdf_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_timeseries_netcdf_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/timeseries/netcdf/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetCDFTimeseriesRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_timeseries_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries rain. (required)
        :param str simulation_pk: (required)
        :param TimeseriesRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_timeseries_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_timeseries_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries rain. (required)
        :param str simulation_pk: (required)
        :param TimeseriesRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_timeseries_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_timeseries_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_timeseries_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_timeseries_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/timeseries/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_timeseries_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_read  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries rain. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_timeseries_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_rain_timeseries_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_read  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries rain. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_timeseries_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_timeseries_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_timeseries_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/timeseries/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_rain_timeseries_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_update  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries rain. (required)
        :param str simulation_pk: (required)
        :param TimeseriesRain data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesRain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_rain_timeseries_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_rain_timeseries_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_rain_timeseries_update  # noqa: E501

        A simple ViewSet for viewing TimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_rain_timeseries_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries rain. (required)
        :param str simulation_pk: (required)
        :param TimeseriesRain data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesRain, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_rain_timeseries_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_rain_timeseries_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_rain_timeseries_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_rain_timeseries_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/rain/timeseries/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesRain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_raster_edits_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_raster_edits_create  # noqa: E501

        A simple ViewSet for viewing raster edits  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_raster_edits_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param RasterEdit data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RasterEdit
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_raster_edits_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_raster_edits_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_raster_edits_create  # noqa: E501

        A simple ViewSet for viewing raster edits  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_raster_edits_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param RasterEdit data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RasterEdit, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_raster_edits_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_raster_edits_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_raster_edits_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/raster-edits/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RasterEdit',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_raster_edits_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_raster_edits_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_raster_edits_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster edit. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_raster_edits_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_raster_edits_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_raster_edits_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_raster_edits_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster edit. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_raster_edits_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_raster_edits_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_raster_edits_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/raster-edits/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_raster_edits_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_raster_edits_list  # noqa: E501

        A simple ViewSet for viewing raster edits  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_raster_edits_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20044
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_raster_edits_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_raster_edits_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_raster_edits_list  # noqa: E501

        A simple ViewSet for viewing raster edits  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_raster_edits_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20044, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_raster_edits_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_raster_edits_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/raster-edits/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20044',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_raster_edits_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_raster_edits_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_raster_edits_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster edit. (required)
        :param str simulation_pk: (required)
        :param RasterEdit data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_raster_edits_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_raster_edits_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_raster_edits_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_raster_edits_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster edit. (required)
        :param str simulation_pk: (required)
        :param RasterEdit data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_raster_edits_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_raster_edits_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_raster_edits_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_raster_edits_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/raster-edits/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_raster_edits_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_raster_edits_read  # noqa: E501

        A simple ViewSet for viewing raster edits  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_raster_edits_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster edit. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RasterEdit
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_raster_edits_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_raster_edits_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_raster_edits_read  # noqa: E501

        A simple ViewSet for viewing raster edits  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_raster_edits_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster edit. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RasterEdit, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_raster_edits_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_raster_edits_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_raster_edits_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/raster-edits/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RasterEdit',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_raster_edits_register_related_rasters(self, id, simulation_pk, **kwargs):  # noqa: E501
        """Register all related rasters in the results-api and return read_bbox urls of the registered rasters  # noqa: E501

        Skips registering of related rasters when the simulation is not in the state 'starting' or 'initialized'. In this case the urls will be empty  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_raster_edits_register_related_rasters(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster edit. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[RasterEditUrls]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_raster_edits_register_related_rasters_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_raster_edits_register_related_rasters_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """Register all related rasters in the results-api and return read_bbox urls of the registered rasters  # noqa: E501

        Skips registering of related rasters when the simulation is not in the state 'starting' or 'initialized'. In this case the urls will be empty  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_raster_edits_register_related_rasters_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster edit. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[RasterEditUrls], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_raster_edits_register_related_rasters" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_raster_edits_register_related_rasters`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_raster_edits_register_related_rasters`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/raster-edits/{id}/register_related_rasters/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RasterEditUrls]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_raster_edits_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_raster_edits_update  # noqa: E501

        A simple ViewSet for viewing raster edits  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_raster_edits_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster edit. (required)
        :param str simulation_pk: (required)
        :param RasterEdit data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RasterEdit
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_raster_edits_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_raster_edits_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_raster_edits_update  # noqa: E501

        A simple ViewSet for viewing raster edits  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_raster_edits_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster edit. (required)
        :param str simulation_pk: (required)
        :param RasterEdit data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RasterEdit, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_raster_edits_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_raster_edits_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_raster_edits_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_raster_edits_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/raster-edits/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RasterEdit',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_constant_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_constant_create  # noqa: E501

        A simple ViewSet for viewing ConstantSourcesSinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_constant_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param ConstantSourcesSinks data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantSourcesSinks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_constant_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_constant_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_constant_create  # noqa: E501

        A simple ViewSet for viewing ConstantSourcesSinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_constant_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param ConstantSourcesSinks data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantSourcesSinks, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_constant_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_constant_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_sources_sinks_constant_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/constant/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantSourcesSinks',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_constant_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_constant_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_constant_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_constant_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_constant_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_constant_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_constant_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_constant_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_constant_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_constant_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/constant/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_constant_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_constant_list  # noqa: E501

        A simple ViewSet for viewing ConstantSourcesSinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_constant_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20045
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_constant_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_constant_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_constant_list  # noqa: E501

        A simple ViewSet for viewing ConstantSourcesSinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_constant_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20045, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_constant_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_constant_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/constant/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20045',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_constant_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_constant_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_constant_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param ConstantSourcesSinks data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_constant_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_constant_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_constant_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_constant_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param ConstantSourcesSinks data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_constant_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_constant_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_constant_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_sources_sinks_constant_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/constant/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_constant_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_constant_read  # noqa: E501

        A simple ViewSet for viewing ConstantSourcesSinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_constant_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantSourcesSinks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_constant_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_constant_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_constant_read  # noqa: E501

        A simple ViewSet for viewing ConstantSourcesSinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_constant_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantSourcesSinks, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_constant_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_constant_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_constant_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/constant/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantSourcesSinks',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_constant_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_constant_update  # noqa: E501

        A simple ViewSet for viewing ConstantSourcesSinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_constant_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param ConstantSourcesSinks data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantSourcesSinks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_constant_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_constant_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_constant_update  # noqa: E501

        A simple ViewSet for viewing ConstantSourcesSinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_constant_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param ConstantSourcesSinks data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantSourcesSinks, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_constant_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_constant_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_constant_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_sources_sinks_constant_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/constant/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantSourcesSinks',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_rasters_lizard_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_lizard_create  # noqa: E501

        A simple ViewSet for viewing lizardRasterRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_lizard_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param LizardRasterSourcesSinks data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LizardRasterSourcesSinks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_rasters_lizard_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_rasters_lizard_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_lizard_create  # noqa: E501

        A simple ViewSet for viewing lizardRasterRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_lizard_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param LizardRasterSourcesSinks data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LizardRasterSourcesSinks, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_rasters_lizard_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_rasters_lizard_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_sources_sinks_rasters_lizard_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/rasters/lizard/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LizardRasterSourcesSinks',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_rasters_lizard_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_lizard_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_lizard_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard raster sources sinks. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_rasters_lizard_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_rasters_lizard_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_lizard_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_lizard_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard raster sources sinks. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_rasters_lizard_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_rasters_lizard_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_rasters_lizard_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/rasters/lizard/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_rasters_lizard_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_lizard_list  # noqa: E501

        A simple ViewSet for viewing lizardRasterRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_lizard_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20046
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_rasters_lizard_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_rasters_lizard_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_lizard_list  # noqa: E501

        A simple ViewSet for viewing lizardRasterRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_lizard_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20046, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_rasters_lizard_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_rasters_lizard_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/rasters/lizard/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20046',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_rasters_lizard_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_lizard_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_lizard_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard raster sources sinks. (required)
        :param str simulation_pk: (required)
        :param LizardRasterSourcesSinks data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_rasters_lizard_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_rasters_lizard_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_lizard_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_lizard_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard raster sources sinks. (required)
        :param str simulation_pk: (required)
        :param LizardRasterSourcesSinks data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_rasters_lizard_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_rasters_lizard_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_rasters_lizard_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_sources_sinks_rasters_lizard_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/rasters/lizard/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_rasters_lizard_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_lizard_read  # noqa: E501

        A simple ViewSet for viewing lizardRasterRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_lizard_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard raster sources sinks. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LizardRasterSourcesSinks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_rasters_lizard_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_rasters_lizard_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_lizard_read  # noqa: E501

        A simple ViewSet for viewing lizardRasterRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_lizard_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard raster sources sinks. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LizardRasterSourcesSinks, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_rasters_lizard_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_rasters_lizard_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_rasters_lizard_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/rasters/lizard/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LizardRasterSourcesSinks',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_rasters_lizard_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_lizard_update  # noqa: E501

        A simple ViewSet for viewing lizardRasterRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_lizard_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard raster sources sinks. (required)
        :param str simulation_pk: (required)
        :param LizardRasterSourcesSinks data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LizardRasterSourcesSinks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_rasters_lizard_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_rasters_lizard_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_lizard_update  # noqa: E501

        A simple ViewSet for viewing lizardRasterRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_lizard_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard raster sources sinks. (required)
        :param str simulation_pk: (required)
        :param LizardRasterSourcesSinks data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LizardRasterSourcesSinks, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_rasters_lizard_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_rasters_lizard_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_rasters_lizard_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_sources_sinks_rasters_lizard_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/rasters/lizard/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LizardRasterSourcesSinks',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_rasters_netcdf_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_netcdf_create  # noqa: E501

        NetCDF 4 raster sources & sinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_netcdf_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param UploadWithSubstances data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UploadWithSubstances
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_rasters_netcdf_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_rasters_netcdf_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_netcdf_create  # noqa: E501

        NetCDF 4 raster sources & sinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_netcdf_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param UploadWithSubstances data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UploadWithSubstances, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_rasters_netcdf_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_rasters_netcdf_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_sources_sinks_rasters_netcdf_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/rasters/netcdf/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UploadWithSubstances',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_rasters_netcdf_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_netcdf_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_netcdf_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster sources sinks. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_rasters_netcdf_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_rasters_netcdf_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_netcdf_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_netcdf_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster sources sinks. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_rasters_netcdf_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_rasters_netcdf_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_rasters_netcdf_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/rasters/netcdf/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_rasters_netcdf_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_netcdf_list  # noqa: E501

        NetCDF 4 raster sources & sinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_netcdf_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20047
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_rasters_netcdf_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_rasters_netcdf_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_netcdf_list  # noqa: E501

        NetCDF 4 raster sources & sinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_netcdf_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20047, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_rasters_netcdf_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_rasters_netcdf_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/rasters/netcdf/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20047',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_rasters_netcdf_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_netcdf_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_netcdf_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster sources sinks. (required)
        :param str simulation_pk: (required)
        :param NetCDFRasterSourcesSinks data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_rasters_netcdf_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_rasters_netcdf_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_netcdf_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_netcdf_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster sources sinks. (required)
        :param str simulation_pk: (required)
        :param NetCDFRasterSourcesSinks data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_rasters_netcdf_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_rasters_netcdf_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_rasters_netcdf_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_sources_sinks_rasters_netcdf_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/rasters/netcdf/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_rasters_netcdf_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_netcdf_read  # noqa: E501

        NetCDF 4 raster sources & sinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_netcdf_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster sources sinks. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: NetCDFRasterSourcesSinks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_rasters_netcdf_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_rasters_netcdf_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_netcdf_read  # noqa: E501

        NetCDF 4 raster sources & sinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_netcdf_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster sources sinks. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(NetCDFRasterSourcesSinks, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_rasters_netcdf_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_rasters_netcdf_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_rasters_netcdf_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/rasters/netcdf/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetCDFRasterSourcesSinks',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_rasters_netcdf_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_netcdf_update  # noqa: E501

        NetCDF 4 raster sources & sinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_netcdf_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster sources sinks. (required)
        :param str simulation_pk: (required)
        :param NetCDFRasterSourcesSinks data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: NetCDFRasterSourcesSinks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_rasters_netcdf_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_rasters_netcdf_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_rasters_netcdf_update  # noqa: E501

        NetCDF 4 raster sources & sinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_rasters_netcdf_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file raster sources sinks. (required)
        :param str simulation_pk: (required)
        :param NetCDFRasterSourcesSinks data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(NetCDFRasterSourcesSinks, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_rasters_netcdf_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_rasters_netcdf_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_rasters_netcdf_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_sources_sinks_rasters_netcdf_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/rasters/netcdf/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetCDFRasterSourcesSinks',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_timeseries_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_create  # noqa: E501

        Example payload: ```     {       \"offset\": 0,       \"values\": [         [           0,           0.0005         ],         [           300,           0.0002         ]       ],       \"units\": \"m/s\"     } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimeseriesSourcesSinks data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesSourcesSinks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_timeseries_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_timeseries_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_create  # noqa: E501

        Example payload: ```     {       \"offset\": 0,       \"values\": [         [           0,           0.0005         ],         [           300,           0.0002         ]       ],       \"units\": \"m/s\"     } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimeseriesSourcesSinks data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesSourcesSinks, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_timeseries_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_timeseries_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_sources_sinks_timeseries_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/timeseries/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesSourcesSinks',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_timeseries_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_timeseries_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_timeseries_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_timeseries_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_timeseries_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_timeseries_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/timeseries/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_timeseries_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_list  # noqa: E501

        A simple ViewSet for viewing TimeseriesSourcesSinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20048
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_timeseries_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_timeseries_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_list  # noqa: E501

        A simple ViewSet for viewing TimeseriesSourcesSinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20048, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_timeseries_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_timeseries_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/timeseries/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20048',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_timeseries_lizard_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_lizard_create  # noqa: E501

        A simple ViewSet for viewing LizardTimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_lizard_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param LizardTimeseriesSourcesSinks data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LizardTimeseriesSourcesSinks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_timeseries_lizard_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_timeseries_lizard_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_lizard_create  # noqa: E501

        A simple ViewSet for viewing LizardTimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_lizard_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param LizardTimeseriesSourcesSinks data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LizardTimeseriesSourcesSinks, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_timeseries_lizard_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_timeseries_lizard_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_sources_sinks_timeseries_lizard_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/timeseries/lizard/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LizardTimeseriesSourcesSinks',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_timeseries_lizard_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_lizard_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_lizard_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_timeseries_lizard_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_timeseries_lizard_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_lizard_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_lizard_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_timeseries_lizard_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_timeseries_lizard_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_timeseries_lizard_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/timeseries/lizard/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_timeseries_lizard_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_lizard_list  # noqa: E501

        A simple ViewSet for viewing LizardTimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_lizard_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20049
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_timeseries_lizard_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_timeseries_lizard_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_lizard_list  # noqa: E501

        A simple ViewSet for viewing LizardTimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_lizard_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20049, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_timeseries_lizard_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_timeseries_lizard_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/timeseries/lizard/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20049',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_timeseries_lizard_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_lizard_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_lizard_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param LizardTimeseriesSourcesSinks data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_timeseries_lizard_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_timeseries_lizard_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_lizard_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_lizard_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param LizardTimeseriesSourcesSinks data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_timeseries_lizard_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_timeseries_lizard_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_timeseries_lizard_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_sources_sinks_timeseries_lizard_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/timeseries/lizard/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_timeseries_lizard_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_lizard_read  # noqa: E501

        A simple ViewSet for viewing LizardTimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_lizard_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LizardTimeseriesSourcesSinks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_timeseries_lizard_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_timeseries_lizard_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_lizard_read  # noqa: E501

        A simple ViewSet for viewing LizardTimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_lizard_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LizardTimeseriesSourcesSinks, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_timeseries_lizard_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_timeseries_lizard_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_timeseries_lizard_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/timeseries/lizard/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LizardTimeseriesSourcesSinks',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_timeseries_lizard_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_lizard_update  # noqa: E501

        A simple ViewSet for viewing LizardTimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_lizard_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param LizardTimeseriesSourcesSinks data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LizardTimeseriesSourcesSinks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_timeseries_lizard_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_timeseries_lizard_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_lizard_update  # noqa: E501

        A simple ViewSet for viewing LizardTimeseriesRain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_lizard_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this lizard timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param LizardTimeseriesSourcesSinks data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LizardTimeseriesSourcesSinks, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_timeseries_lizard_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_timeseries_lizard_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_timeseries_lizard_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_sources_sinks_timeseries_lizard_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/timeseries/lizard/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LizardTimeseriesSourcesSinks',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_timeseries_netcdf_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_netcdf_create  # noqa: E501

        NetCDF 4 timeseries sources & sinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_netcdf_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param UploadWithSubstances data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UploadWithSubstances
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_timeseries_netcdf_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_timeseries_netcdf_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_netcdf_create  # noqa: E501

        NetCDF 4 timeseries sources & sinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_netcdf_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param UploadWithSubstances data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UploadWithSubstances, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_timeseries_netcdf_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_timeseries_netcdf_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_sources_sinks_timeseries_netcdf_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/timeseries/netcdf/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UploadWithSubstances',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_timeseries_netcdf_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_netcdf_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_netcdf_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_timeseries_netcdf_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_timeseries_netcdf_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_netcdf_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_netcdf_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_timeseries_netcdf_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_timeseries_netcdf_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_timeseries_netcdf_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/timeseries/netcdf/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_timeseries_netcdf_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_netcdf_list  # noqa: E501

        NetCDF 4 timeseries sources & sinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_netcdf_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20050
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_timeseries_netcdf_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_timeseries_netcdf_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_netcdf_list  # noqa: E501

        NetCDF 4 timeseries sources & sinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_netcdf_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20050, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_timeseries_netcdf_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_timeseries_netcdf_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/timeseries/netcdf/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20050',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_timeseries_netcdf_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_netcdf_read  # noqa: E501

        NetCDF 4 timeseries sources & sinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_netcdf_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: NetCDFTimeseriesSourcesSinks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_timeseries_netcdf_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_timeseries_netcdf_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_netcdf_read  # noqa: E501

        NetCDF 4 timeseries sources & sinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_netcdf_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this file timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(NetCDFTimeseriesSourcesSinks, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_timeseries_netcdf_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_timeseries_netcdf_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_timeseries_netcdf_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/timeseries/netcdf/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetCDFTimeseriesSourcesSinks',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_timeseries_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param TimeseriesSourcesSinks data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_timeseries_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_timeseries_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param TimeseriesSourcesSinks data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_timeseries_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_timeseries_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_timeseries_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_sources_sinks_timeseries_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/timeseries/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_timeseries_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_read  # noqa: E501

        A simple ViewSet for viewing TimeseriesSourcesSinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesSourcesSinks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_timeseries_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_timeseries_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_read  # noqa: E501

        A simple ViewSet for viewing TimeseriesSourcesSinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesSourcesSinks, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_timeseries_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_timeseries_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_timeseries_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/timeseries/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesSourcesSinks',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_sources_sinks_timeseries_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_update  # noqa: E501

        A simple ViewSet for viewing TimeseriesSourcesSinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param TimeseriesSourcesSinks data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesSourcesSinks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_sources_sinks_timeseries_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_sources_sinks_timeseries_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_sources_sinks_timeseries_update  # noqa: E501

        A simple ViewSet for viewing TimeseriesSourcesSinks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_sources_sinks_timeseries_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timeseries sources sinks. (required)
        :param str simulation_pk: (required)
        :param TimeseriesSourcesSinks data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesSourcesSinks, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_sources_sinks_timeseries_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_sources_sinks_timeseries_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_sources_sinks_timeseries_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_sources_sinks_timeseries_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/sources-sinks/timeseries/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesSourcesSinks',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_file_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Endpoint for uploading a file with one or more structure controls.  # noqa: E501

        The supplied filename should be include the extension, for example \"bergermeer_controls.json\".  `bergermeer_controls.json`  The response provides a put_url which may be used to upload a file containing one or more controls. These controls are divided in memory, table and timed structure controls. See the respective endpoints for the required fields of these controls.  The uploaded file should be a JSON-file containing an array of controls per control type. Example of the content of such a file: ``` {     \"timed\": [         {             \"offset\": 0,             \"duration\": 100,             \"value\": [                 0.4, 0.8             ],             \"type\": \"set_discharge_coefficients\",             \"structure_id\": 21,             \"structure_type\": \"v2_weir\"         }     ],     \"memory\": [         {             \"offset\": 0,             \"duration\": 3600,             \"measure_specification\": {                 \"name\": \"Measurement location\",                 \"locations\": [                     {                         \"weight\": \"1.00\",                         \"content_type\": \"v2_connection_node\",                         \"content_pk\": 356,                     }                 ],                 \"variable\": \"s1\",                 \"operator\": \"<\"             },             \"structure_id\": 10250,             \"structure_type\": \"v2_weir\",             \"type\": \"set_crest_level\",             \"value\": [                 9.05             ],             \"upper_threshold\": 0.3,             \"lower_threshold\": 0.1,             \"is_active\": false,             \"is_inverse\": false         }     ],     \"table\": [         {             \"offset\": 0,             \"duration\": 3600,             \"measure_specification\": {                 \"name\": \"Measurement location\",                 \"locations\": [                     {                         \"weight\": \"1.00\",                         \"content_type\": \"v2_connection_node\",                         \"content_pk\": 356,                     }                 ],                 \"variable\": \"s1\",                 \"operator\": \"<\"             },             \"structure_id\": 10249,             \"structure_type\": \"v2_weir\",             \"type\": \"set_crest_level\",             \"values\": [                 [                     9.05,                     -1.45                 ],             ]         }     ] } ```  If there are only controls of one category, the other arrays can be omitted, like for example: ``` {     \"timed\": [         {             \"offset\": 0,             \"duration\": 100,             \"value\": [                 0.4, 0.8             ],             \"type\": \"set_discharge_coefficients\",             \"structure_id\": 21,             \"structure_type\": \"v2_weir\"         }     ] } ```  The `offset` supplied in the request body will be applied on top of each individual structure control offset in the uploaded file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_file_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param UploadEventFile data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UploadEventFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_file_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_structure_control_file_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Endpoint for uploading a file with one or more structure controls.  # noqa: E501

        The supplied filename should be include the extension, for example \"bergermeer_controls.json\".  `bergermeer_controls.json`  The response provides a put_url which may be used to upload a file containing one or more controls. These controls are divided in memory, table and timed structure controls. See the respective endpoints for the required fields of these controls.  The uploaded file should be a JSON-file containing an array of controls per control type. Example of the content of such a file: ``` {     \"timed\": [         {             \"offset\": 0,             \"duration\": 100,             \"value\": [                 0.4, 0.8             ],             \"type\": \"set_discharge_coefficients\",             \"structure_id\": 21,             \"structure_type\": \"v2_weir\"         }     ],     \"memory\": [         {             \"offset\": 0,             \"duration\": 3600,             \"measure_specification\": {                 \"name\": \"Measurement location\",                 \"locations\": [                     {                         \"weight\": \"1.00\",                         \"content_type\": \"v2_connection_node\",                         \"content_pk\": 356,                     }                 ],                 \"variable\": \"s1\",                 \"operator\": \"<\"             },             \"structure_id\": 10250,             \"structure_type\": \"v2_weir\",             \"type\": \"set_crest_level\",             \"value\": [                 9.05             ],             \"upper_threshold\": 0.3,             \"lower_threshold\": 0.1,             \"is_active\": false,             \"is_inverse\": false         }     ],     \"table\": [         {             \"offset\": 0,             \"duration\": 3600,             \"measure_specification\": {                 \"name\": \"Measurement location\",                 \"locations\": [                     {                         \"weight\": \"1.00\",                         \"content_type\": \"v2_connection_node\",                         \"content_pk\": 356,                     }                 ],                 \"variable\": \"s1\",                 \"operator\": \"<\"             },             \"structure_id\": 10249,             \"structure_type\": \"v2_weir\",             \"type\": \"set_crest_level\",             \"values\": [                 [                     9.05,                     -1.45                 ],             ]         }     ] } ```  If there are only controls of one category, the other arrays can be omitted, like for example: ``` {     \"timed\": [         {             \"offset\": 0,             \"duration\": 100,             \"value\": [                 0.4, 0.8             ],             \"type\": \"set_discharge_coefficients\",             \"structure_id\": 21,             \"structure_type\": \"v2_weir\"         }     ] } ```  The `offset` supplied in the request body will be applied on top of each individual structure control offset in the uploaded file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_file_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param UploadEventFile data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UploadEventFile, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_file_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_file_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_structure_control_file_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/file/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UploadEventFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_file_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_file_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_file_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk control. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_file_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_structure_control_file_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_file_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_file_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk control. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_file_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_file_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_file_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/file/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_file_download(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_file_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_file_download(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk control. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_file_download_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_structure_control_file_download_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_file_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_file_download_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk control. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_file_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_file_download`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_file_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/file/{id}/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_file_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_file_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_file_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20051
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_file_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_structure_control_file_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_file_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_file_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20051, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_file_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_file_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/file/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20051',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_file_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_file_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_file_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk control. (required)
        :param str simulation_pk: (required)
        :param FileStructureControl data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_file_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_structure_control_file_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_file_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_file_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk control. (required)
        :param str simulation_pk: (required)
        :param FileStructureControl data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_file_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_file_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_file_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_structure_control_file_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/file/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_file_processed(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_file_processed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_file_processed(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk control. (required)
        :param str simulation_pk: (required)
        :param BaseEventState data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_file_processed_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_structure_control_file_processed_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_file_processed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_file_processed_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk control. (required)
        :param str simulation_pk: (required)
        :param BaseEventState data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_file_processed" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_file_processed`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_file_processed`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_structure_control_file_processed`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/file/{id}/processed/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_file_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_file_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_file_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk control. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FileStructureControl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_file_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_structure_control_file_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_file_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_file_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk control. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FileStructureControl, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_file_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_file_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_file_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/file/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileStructureControl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_file_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_file_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_file_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk control. (required)
        :param str simulation_pk: (required)
        :param FileStructureControl data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FileStructureControl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_file_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_structure_control_file_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_file_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_file_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this bulk control. (required)
        :param str simulation_pk: (required)
        :param FileStructureControl data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FileStructureControl, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_file_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_file_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_file_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_structure_control_file_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/file/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileStructureControl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_memory_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_memory_create  # noqa: E501

        See tables structure endpoint for more information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_memory_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param MemoryStructureControl data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MemoryStructureControl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_memory_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_structure_control_memory_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_memory_create  # noqa: E501

        See tables structure endpoint for more information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_memory_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param MemoryStructureControl data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MemoryStructureControl, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_memory_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_memory_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_structure_control_memory_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/memory/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MemoryStructureControl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_memory_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_memory_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_memory_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this memory structure control. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_memory_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_structure_control_memory_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_memory_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_memory_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this memory structure control. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_memory_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_memory_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_memory_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/memory/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_memory_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_memory_list  # noqa: E501

        ViewSet for viewing MemoryStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_memory_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20052
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_memory_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_structure_control_memory_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_memory_list  # noqa: E501

        ViewSet for viewing MemoryStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_memory_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20052, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_memory_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_memory_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/memory/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20052',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_memory_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_memory_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_memory_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this memory structure control. (required)
        :param str simulation_pk: (required)
        :param MemoryStructureControl data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_memory_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_structure_control_memory_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_memory_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_memory_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this memory structure control. (required)
        :param str simulation_pk: (required)
        :param MemoryStructureControl data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_memory_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_memory_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_memory_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_structure_control_memory_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/memory/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_memory_processed(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_memory_processed  # noqa: E501

        ViewSet for viewing MemoryStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_memory_processed(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this memory structure control. (required)
        :param str simulation_pk: (required)
        :param MeasureLocationGridEventState data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_memory_processed_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_structure_control_memory_processed_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_memory_processed  # noqa: E501

        ViewSet for viewing MemoryStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_memory_processed_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this memory structure control. (required)
        :param str simulation_pk: (required)
        :param MeasureLocationGridEventState data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_memory_processed" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_memory_processed`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_memory_processed`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_structure_control_memory_processed`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/memory/{id}/processed/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_memory_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_memory_read  # noqa: E501

        ViewSet for viewing MemoryStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_memory_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this memory structure control. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MemoryStructureControl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_memory_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_structure_control_memory_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_memory_read  # noqa: E501

        ViewSet for viewing MemoryStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_memory_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this memory structure control. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MemoryStructureControl, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_memory_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_memory_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_memory_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/memory/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MemoryStructureControl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_memory_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_memory_update  # noqa: E501

        ViewSet for viewing MemoryStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_memory_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this memory structure control. (required)
        :param str simulation_pk: (required)
        :param MemoryStructureControl data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MemoryStructureControl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_memory_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_structure_control_memory_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_memory_update  # noqa: E501

        ViewSet for viewing MemoryStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_memory_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this memory structure control. (required)
        :param str simulation_pk: (required)
        :param MemoryStructureControl data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MemoryStructureControl, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_memory_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_memory_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_memory_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_structure_control_memory_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/memory/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MemoryStructureControl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_table_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_table_create  # noqa: E501

        A table structure control can used to apply a certain action, e.g increase the pump capacity of a pump station, based on the measured values of one or more locations.  **type**  *for weirs and orifices*  - set_crest_level - set_discharge_coefficients  *for culverts, channels and pipes*  - set_discharge_coefficients  *for pumps*  - set_pump_capacity (m3/s)  **values**  The action table consists of one or more value pairs (threshold, action_value)  To close/open or partially close/open a structure using the `set_discharge_coefficients` type the values must contain **three** values. For example `[[1.2, 0.5, 0.7]]`,  where     1.2 is the threshold value     0.5 the action value for the left flow direction     0.7 action value for the right flow direction  Please note: action values for `set_discharge_coefficients` type must be > 0.  For ALL operators threshold values must be ascending,  In most cases the measure location will be of type `v2_connection_node`. For this location type only the variables `s1` and `vol1` apply. If your measure location, however, is of any other type the variable must either be `q` or `u1`.  Note that the `v2_` prefixes are no longer used in the schematisations, but are required in the API.  For both the target structure as well as for the measure location it is allowed to use a grid id as input directly. In this case we will check if the structure type associated with the given id matches with the grid administration data.  Nonetheless, we encourage you to use the structure id (that is the id of the structure in the model sqlite database) as input data. We will look up the corresponding grid id for you. If the validation holds, the state of the resource will be updated from `processing` to `valid`. Using the structure id will enable you to re-use the structure control resource after a model revision as a grid id will most likely change with every new grid generation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_table_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TableStructureControl data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TableStructureControl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_table_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_structure_control_table_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_table_create  # noqa: E501

        A table structure control can used to apply a certain action, e.g increase the pump capacity of a pump station, based on the measured values of one or more locations.  **type**  *for weirs and orifices*  - set_crest_level - set_discharge_coefficients  *for culverts, channels and pipes*  - set_discharge_coefficients  *for pumps*  - set_pump_capacity (m3/s)  **values**  The action table consists of one or more value pairs (threshold, action_value)  To close/open or partially close/open a structure using the `set_discharge_coefficients` type the values must contain **three** values. For example `[[1.2, 0.5, 0.7]]`,  where     1.2 is the threshold value     0.5 the action value for the left flow direction     0.7 action value for the right flow direction  Please note: action values for `set_discharge_coefficients` type must be > 0.  For ALL operators threshold values must be ascending,  In most cases the measure location will be of type `v2_connection_node`. For this location type only the variables `s1` and `vol1` apply. If your measure location, however, is of any other type the variable must either be `q` or `u1`.  Note that the `v2_` prefixes are no longer used in the schematisations, but are required in the API.  For both the target structure as well as for the measure location it is allowed to use a grid id as input directly. In this case we will check if the structure type associated with the given id matches with the grid administration data.  Nonetheless, we encourage you to use the structure id (that is the id of the structure in the model sqlite database) as input data. We will look up the corresponding grid id for you. If the validation holds, the state of the resource will be updated from `processing` to `valid`. Using the structure id will enable you to re-use the structure control resource after a model revision as a grid id will most likely change with every new grid generation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_table_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TableStructureControl data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TableStructureControl, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_table_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_table_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_structure_control_table_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/table/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TableStructureControl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_table_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_table_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_table_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this table structure control. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_table_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_structure_control_table_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_table_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_table_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this table structure control. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_table_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_table_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_table_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/table/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_table_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_table_list  # noqa: E501

        ViewSet for viewing TableStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_table_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20053
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_table_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_structure_control_table_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_table_list  # noqa: E501

        ViewSet for viewing TableStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_table_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20053, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_table_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_table_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/table/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20053',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_table_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_table_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_table_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this table structure control. (required)
        :param str simulation_pk: (required)
        :param TableStructureControl data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_table_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_structure_control_table_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_table_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_table_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this table structure control. (required)
        :param str simulation_pk: (required)
        :param TableStructureControl data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_table_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_table_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_table_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_structure_control_table_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/table/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_table_processed(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_table_processed  # noqa: E501

        ViewSet for viewing TableStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_table_processed(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this table structure control. (required)
        :param str simulation_pk: (required)
        :param MeasureLocationGridEventState data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_table_processed_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_structure_control_table_processed_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_table_processed  # noqa: E501

        ViewSet for viewing TableStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_table_processed_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this table structure control. (required)
        :param str simulation_pk: (required)
        :param MeasureLocationGridEventState data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_table_processed" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_table_processed`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_table_processed`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_structure_control_table_processed`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/table/{id}/processed/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_table_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_table_read  # noqa: E501

        ViewSet for viewing TableStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_table_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this table structure control. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TableStructureControl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_table_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_structure_control_table_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_table_read  # noqa: E501

        ViewSet for viewing TableStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_table_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this table structure control. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TableStructureControl, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_table_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_table_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_table_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/table/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TableStructureControl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_table_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_table_update  # noqa: E501

        ViewSet for viewing TableStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_table_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this table structure control. (required)
        :param str simulation_pk: (required)
        :param TableStructureControl data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TableStructureControl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_table_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_structure_control_table_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_table_update  # noqa: E501

        ViewSet for viewing TableStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_table_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this table structure control. (required)
        :param str simulation_pk: (required)
        :param TableStructureControl data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TableStructureControl, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_table_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_table_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_table_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_structure_control_table_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/table/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TableStructureControl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_timed_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_timed_create  # noqa: E501

        A timed structure control allows for actively altering parameters of structures at a given point in time of the simulation for a given period of time. The ``type`` parameter specifies which action should be applied to the structure. Not all valid action types can be applied to every structure. An overview of valid combinations:     set_discharge_coefficients: v2_orifice, v2_weir, v2_pipe,                                v2_channel, v2_culvert    set_crest_level: v2_orifice, v2_weir    set_pump_capacity: v2_pumpstation  The value parameter must contain 1 value, except for the ``set_discharge_coefficients``action that expects a value for both flow directions.  Example payload:  ```     {       \"offset\": 0,       \"duration\": 100,       \"value\": [         0.4, 0.8       ],       \"type\": \"set_discharge_coefficients\",       \"structure_id\": 21,       \"structure_type\": \"v2_weir\"     } ```  **v2_channel and v2_pipe are for internal use only. They expect a grid_id instead of a structure_id!**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_timed_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimedStructureControl data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimedStructureControl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_timed_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_structure_control_timed_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_timed_create  # noqa: E501

        A timed structure control allows for actively altering parameters of structures at a given point in time of the simulation for a given period of time. The ``type`` parameter specifies which action should be applied to the structure. Not all valid action types can be applied to every structure. An overview of valid combinations:     set_discharge_coefficients: v2_orifice, v2_weir, v2_pipe,                                v2_channel, v2_culvert    set_crest_level: v2_orifice, v2_weir    set_pump_capacity: v2_pumpstation  The value parameter must contain 1 value, except for the ``set_discharge_coefficients``action that expects a value for both flow directions.  Example payload:  ```     {       \"offset\": 0,       \"duration\": 100,       \"value\": [         0.4, 0.8       ],       \"type\": \"set_discharge_coefficients\",       \"structure_id\": 21,       \"structure_type\": \"v2_weir\"     } ```  **v2_channel and v2_pipe are for internal use only. They expect a grid_id instead of a structure_id!**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_timed_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimedStructureControl data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimedStructureControl, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_timed_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_timed_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_structure_control_timed_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/timed/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimedStructureControl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_timed_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_timed_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_timed_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timed structure control. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_timed_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_structure_control_timed_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_timed_delete  # noqa: E501

        destroy resource only if the event has not yet been applied to the associated simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_timed_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timed structure control. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_timed_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_timed_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_timed_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/timed/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_timed_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_timed_list  # noqa: E501

        A simple ViewSet for viewing TimedStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_timed_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20054
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_timed_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_structure_control_timed_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_timed_list  # noqa: E501

        A simple ViewSet for viewing TimedStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_timed_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20054, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_timed_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_timed_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/timed/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20054',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_timed_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_timed_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_timed_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timed structure control. (required)
        :param str simulation_pk: (required)
        :param TimedStructureControl data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_timed_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_structure_control_timed_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_timed_partial_update  # noqa: E501

        when the simulation has started only the duration parameter might be patched  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_timed_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timed structure control. (required)
        :param str simulation_pk: (required)
        :param TimedStructureControl data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_timed_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_timed_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_timed_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_structure_control_timed_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/timed/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_timed_processed(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_timed_processed  # noqa: E501

        A simple ViewSet for viewing TimedStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_timed_processed(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timed structure control. (required)
        :param str simulation_pk: (required)
        :param GridEventState data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_timed_processed_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_structure_control_timed_processed_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_timed_processed  # noqa: E501

        A simple ViewSet for viewing TimedStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_timed_processed_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timed structure control. (required)
        :param str simulation_pk: (required)
        :param GridEventState data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_timed_processed" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_timed_processed`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_timed_processed`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_structure_control_timed_processed`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/timed/{id}/processed/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_timed_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_timed_read  # noqa: E501

        A simple ViewSet for viewing TimedStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_timed_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timed structure control. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimedStructureControl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_timed_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_structure_control_timed_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_structure_control_timed_read  # noqa: E501

        A simple ViewSet for viewing TimedStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_timed_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timed structure control. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimedStructureControl, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_timed_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_timed_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_timed_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/timed/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimedStructureControl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_structure_control_timed_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_timed_update  # noqa: E501

        A simple ViewSet for viewing TimedStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_timed_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timed structure control. (required)
        :param str simulation_pk: (required)
        :param TimedStructureControl data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimedStructureControl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_structure_control_timed_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_structure_control_timed_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_structure_control_timed_update  # noqa: E501

        A simple ViewSet for viewing TimedStructureControls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_structure_control_timed_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this timed structure control. (required)
        :param str simulation_pk: (required)
        :param TimedStructureControl data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimedStructureControl, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_structure_control_timed_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_structure_control_timed_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_structure_control_timed_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_structure_control_timed_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/structure-control/timed/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimedStructureControl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_wind_constant_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_wind_constant_create  # noqa: E501

        A constant wind event allows for wind forcing at a given point in time of the simulation for a given period of time. No distinction is made (yet) between the 1D and 2D model domain.  The ``units`` parameter is the wind speed unit ('m/s' or 'km/h').  The ``direction_value`` parameter is the wind direction in degrees (0-360) from the north - meteorological standard. Thus, a direction_value of 180 represents a south wind (which comes from the south and blows your hat towards the north.  The ``speed_value`` parameter as well as the ``direction_value`` must contain 1 value. Behind the the scenes these are converted into nested array [time, speed_value, direction_value]. This means that this payload (example):  ``` {     \"offset\": 100,     \"duration\": 400,     \"units\": \"m/s\",     \"speed_value\": 80,     \"direction_value\": 220 } ```  becomes an Timeseries object with values:  ``` {     \"values\": [         [ 0, 80, 220],    # time, speed, direction         [ 400, 0, 0]      # time, speed, direction     ], } ```  Note that the (dimensionless) ``drag-coefficient`` is not part of a simulation event, but part of simulation initial condition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_constant_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param ConstantWind data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantWind
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_wind_constant_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_wind_constant_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_wind_constant_create  # noqa: E501

        A constant wind event allows for wind forcing at a given point in time of the simulation for a given period of time. No distinction is made (yet) between the 1D and 2D model domain.  The ``units`` parameter is the wind speed unit ('m/s' or 'km/h').  The ``direction_value`` parameter is the wind direction in degrees (0-360) from the north - meteorological standard. Thus, a direction_value of 180 represents a south wind (which comes from the south and blows your hat towards the north.  The ``speed_value`` parameter as well as the ``direction_value`` must contain 1 value. Behind the the scenes these are converted into nested array [time, speed_value, direction_value]. This means that this payload (example):  ``` {     \"offset\": 100,     \"duration\": 400,     \"units\": \"m/s\",     \"speed_value\": 80,     \"direction_value\": 220 } ```  becomes an Timeseries object with values:  ``` {     \"values\": [         [ 0, 80, 220],    # time, speed, direction         [ 400, 0, 0]      # time, speed, direction     ], } ```  Note that the (dimensionless) ``drag-coefficient`` is not part of a simulation event, but part of simulation initial condition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_constant_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param ConstantWind data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantWind, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_wind_constant_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_wind_constant_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_wind_constant_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/wind/constant/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantWind',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_wind_constant_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_wind_constant_delete  # noqa: E501

        A simple ViewSet for viewing Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_constant_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_wind_constant_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_wind_constant_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_wind_constant_delete  # noqa: E501

        A simple ViewSet for viewing Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_constant_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_wind_constant_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_wind_constant_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_wind_constant_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/wind/constant/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_wind_constant_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_wind_constant_list  # noqa: E501

        A simple ViewSet for viewing Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_constant_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20055
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_wind_constant_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_wind_constant_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_wind_constant_list  # noqa: E501

        A simple ViewSet for viewing Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_constant_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20055, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_wind_constant_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_wind_constant_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/wind/constant/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20055',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_wind_constant_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_wind_constant_partial_update  # noqa: E501

        A simple ViewSet for viewing Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_constant_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind. (required)
        :param str simulation_pk: (required)
        :param ConstantWind data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantWind
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_wind_constant_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_wind_constant_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_wind_constant_partial_update  # noqa: E501

        A simple ViewSet for viewing Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_constant_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind. (required)
        :param str simulation_pk: (required)
        :param ConstantWind data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantWind, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_wind_constant_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_wind_constant_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_wind_constant_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_wind_constant_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/wind/constant/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantWind',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_wind_constant_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_wind_constant_read  # noqa: E501

        A simple ViewSet for viewing Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_constant_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantWind
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_wind_constant_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_wind_constant_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_wind_constant_read  # noqa: E501

        A simple ViewSet for viewing Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_constant_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantWind, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_wind_constant_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_wind_constant_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_wind_constant_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/wind/constant/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantWind',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_wind_constant_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_wind_constant_update  # noqa: E501

        A simple ViewSet for viewing Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_constant_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind. (required)
        :param str simulation_pk: (required)
        :param ConstantWind data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ConstantWind
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_wind_constant_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_wind_constant_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_wind_constant_update  # noqa: E501

        A simple ViewSet for viewing Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_constant_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind. (required)
        :param str simulation_pk: (required)
        :param ConstantWind data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ConstantWind, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_wind_constant_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_wind_constant_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_wind_constant_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_wind_constant_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/wind/constant/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantWind',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_wind_timeseries_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_wind_timeseries_create  # noqa: E501

        Same as constant wind event but now without separate fields for ``speed_value`` and ``direction_value``. Instead - to avoid time-mapping issues - the field ``values`` holds the speed and direction values: ``` [     [time, speed1, direction1],     [time, speed2, direction2], ] ```  example payload: ``` {     \"offset\": 2,     \"values\": [         [0, 40, 180],         [60, 35, 181]     ],     \"units\": \"m/s\", } ```  becomes an Timeseries object with values: ``` {     \"values\": [         [ 0, 40, 180 ],         [60, 35, 181 ]     ] } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_timeseries_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimeseriesWind data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesWind
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_wind_timeseries_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_wind_timeseries_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_wind_timeseries_create  # noqa: E501

        Same as constant wind event but now without separate fields for ``speed_value`` and ``direction_value``. Instead - to avoid time-mapping issues - the field ``values`` holds the speed and direction values: ``` [     [time, speed1, direction1],     [time, speed2, direction2], ] ```  example payload: ``` {     \"offset\": 2,     \"values\": [         [0, 40, 180],         [60, 35, 181]     ],     \"units\": \"m/s\", } ```  becomes an Timeseries object with values: ``` {     \"values\": [         [ 0, 40, 180 ],         [60, 35, 181 ]     ] } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_timeseries_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimeseriesWind data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesWind, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_wind_timeseries_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_wind_timeseries_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_wind_timeseries_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/wind/timeseries/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesWind',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_wind_timeseries_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_wind_timeseries_delete  # noqa: E501

        A simple ViewSet for viewig Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_timeseries_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_wind_timeseries_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_wind_timeseries_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_wind_timeseries_delete  # noqa: E501

        A simple ViewSet for viewig Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_timeseries_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_wind_timeseries_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_wind_timeseries_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_wind_timeseries_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/wind/timeseries/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_wind_timeseries_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_wind_timeseries_list  # noqa: E501

        A simple ViewSet for viewig Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_timeseries_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20056
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_wind_timeseries_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_wind_timeseries_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_wind_timeseries_list  # noqa: E501

        A simple ViewSet for viewig Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_timeseries_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20056, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_wind_timeseries_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_wind_timeseries_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/wind/timeseries/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20056',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_wind_timeseries_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_wind_timeseries_partial_update  # noqa: E501

        A simple ViewSet for viewig Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_timeseries_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind. (required)
        :param str simulation_pk: (required)
        :param TimeseriesWind data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesWind
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_wind_timeseries_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_wind_timeseries_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_wind_timeseries_partial_update  # noqa: E501

        A simple ViewSet for viewig Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_timeseries_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind. (required)
        :param str simulation_pk: (required)
        :param TimeseriesWind data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesWind, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_wind_timeseries_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_wind_timeseries_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_wind_timeseries_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_wind_timeseries_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/wind/timeseries/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesWind',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_wind_timeseries_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_wind_timeseries_read  # noqa: E501

        A simple ViewSet for viewig Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_timeseries_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesWind
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_wind_timeseries_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_events_wind_timeseries_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_events_wind_timeseries_read  # noqa: E501

        A simple ViewSet for viewig Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_timeseries_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesWind, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_wind_timeseries_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_wind_timeseries_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_wind_timeseries_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/wind/timeseries/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesWind',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_events_wind_timeseries_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_wind_timeseries_update  # noqa: E501

        A simple ViewSet for viewig Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_timeseries_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind. (required)
        :param str simulation_pk: (required)
        :param TimeseriesWind data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimeseriesWind
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_events_wind_timeseries_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_events_wind_timeseries_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_events_wind_timeseries_update  # noqa: E501

        A simple ViewSet for viewig Wind.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_events_wind_timeseries_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind. (required)
        :param str simulation_pk: (required)
        :param TimeseriesWind data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimeseriesWind, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_events_wind_timeseries_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_events_wind_timeseries_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_events_wind_timeseries_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_events_wind_timeseries_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/events/wind/timeseries/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeseriesWind',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_from_template(self, data, **kwargs):  # noqa: E501
        """Create a (new/cloned) simulation from a simulation template.  # noqa: E501

        There are two options to specify the desired duration for the new simulation, either by using the ``end_datetime`` **or** the ``duration`` parameter.  {   \"template\":                  # source simulation template resource id   \"name\":                      # name for the new simulation.   \"tags\":                      # extra tags, added to existing simulation template tags.   \"organisation\":              # uuid of the organisation for which the                                  simulation is run   \"start_datetime\":            # datetime (in ISO 8601 (UTC) format) for the                                  simulation start, e.g. \"YYYY-MM-DDThh:mm:ss\"   \"end_datetime\":              # datetime (in ISO 8601 (UTC) format) for the                                  simulation end, e.g. \"YYYY-MM-DDThh:mm:ss\"   \"duration\":                  # in seconds, can be used instead of end_datetime   \"clone_events\":              # if true, clone events like rain/sources & sinks etc.   \"clone_initials\":            # if true, clone initial waterlevels   \"clone_settings\":            # if true, clone simulation settings, like physical settings etc.   \"threedimodel_id\":           # copy simulation template to threedimodel   \"started_from\":              # platform from which the simulation was started }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_from_template(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param FromTemplate data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Simulation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_from_template_with_http_info(data, **kwargs)  # noqa: E501

    def simulations_from_template_with_http_info(self, data, **kwargs):  # noqa: E501
        """Create a (new/cloned) simulation from a simulation template.  # noqa: E501

        There are two options to specify the desired duration for the new simulation, either by using the ``end_datetime`` **or** the ``duration`` parameter.  {   \"template\":                  # source simulation template resource id   \"name\":                      # name for the new simulation.   \"tags\":                      # extra tags, added to existing simulation template tags.   \"organisation\":              # uuid of the organisation for which the                                  simulation is run   \"start_datetime\":            # datetime (in ISO 8601 (UTC) format) for the                                  simulation start, e.g. \"YYYY-MM-DDThh:mm:ss\"   \"end_datetime\":              # datetime (in ISO 8601 (UTC) format) for the                                  simulation end, e.g. \"YYYY-MM-DDThh:mm:ss\"   \"duration\":                  # in seconds, can be used instead of end_datetime   \"clone_events\":              # if true, clone events like rain/sources & sinks etc.   \"clone_initials\":            # if true, clone initial waterlevels   \"clone_settings\":            # if true, clone simulation settings, like physical settings etc.   \"threedimodel_id\":           # copy simulation template to threedimodel   \"started_from\":              # platform from which the simulation was started }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_from_template_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param FromTemplate data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Simulation, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_from_template" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_from_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/from-template/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Simulation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial1d_water_level_constant_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_constant_create  # noqa: E501

        Start the simulation with a global 1D water level  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_constant_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param OneDWaterLevel data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OneDWaterLevel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial1d_water_level_constant_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial1d_water_level_constant_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_constant_create  # noqa: E501

        Start the simulation with a global 1D water level  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_constant_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param OneDWaterLevel data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OneDWaterLevel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial1d_water_level_constant_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial1d_water_level_constant_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial1d_water_level_constant_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/1d_water_level/constant/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OneDWaterLevel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial1d_water_level_constant_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_constant_delete  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_constant_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial1d_water_level_constant_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial1d_water_level_constant_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_constant_delete  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_constant_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial1d_water_level_constant_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial1d_water_level_constant_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial1d_water_level_constant_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/1d_water_level/constant/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial1d_water_level_constant_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_constant_list  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_constant_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20057
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial1d_water_level_constant_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial1d_water_level_constant_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_constant_list  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_constant_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20057, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial1d_water_level_constant_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial1d_water_level_constant_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/1d_water_level/constant/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20057',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial1d_water_level_constant_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_constant_partial_update  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_constant_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level. (required)
        :param str simulation_pk: (required)
        :param OneDWaterLevel data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OneDWaterLevel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial1d_water_level_constant_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial1d_water_level_constant_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_constant_partial_update  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_constant_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level. (required)
        :param str simulation_pk: (required)
        :param OneDWaterLevel data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OneDWaterLevel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial1d_water_level_constant_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial1d_water_level_constant_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial1d_water_level_constant_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial1d_water_level_constant_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/1d_water_level/constant/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OneDWaterLevel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial1d_water_level_constant_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_constant_read  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_constant_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OneDWaterLevel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial1d_water_level_constant_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial1d_water_level_constant_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_constant_read  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_constant_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OneDWaterLevel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial1d_water_level_constant_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial1d_water_level_constant_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial1d_water_level_constant_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/1d_water_level/constant/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OneDWaterLevel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial1d_water_level_constant_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_constant_update  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_constant_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level. (required)
        :param str simulation_pk: (required)
        :param OneDWaterLevel data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OneDWaterLevel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial1d_water_level_constant_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial1d_water_level_constant_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_constant_update  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_constant_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level. (required)
        :param str simulation_pk: (required)
        :param OneDWaterLevel data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OneDWaterLevel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial1d_water_level_constant_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial1d_water_level_constant_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial1d_water_level_constant_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial1d_water_level_constant_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/1d_water_level/constant/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OneDWaterLevel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial1d_water_level_file_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_file_create  # noqa: E501

        Start the simulation with a 1D water levels from a file. Applies the given values to the predefined nodes subset \"1D\" as described in the [threedigrid documentation] [ref]  [ref]: https://threedigrid.readthedocs.io/en/latest/api.html#subsets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_file_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param OneDWaterLevelFile data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OneDWaterLevelFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial1d_water_level_file_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial1d_water_level_file_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_file_create  # noqa: E501

        Start the simulation with a 1D water levels from a file. Applies the given values to the predefined nodes subset \"1D\" as described in the [threedigrid documentation] [ref]  [ref]: https://threedigrid.readthedocs.io/en/latest/api.html#subsets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_file_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param OneDWaterLevelFile data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OneDWaterLevelFile, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial1d_water_level_file_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial1d_water_level_file_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial1d_water_level_file_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/1d_water_level/file/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OneDWaterLevelFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial1d_water_level_file_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_file_delete  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_file_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level file. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial1d_water_level_file_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial1d_water_level_file_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_file_delete  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_file_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level file. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial1d_water_level_file_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial1d_water_level_file_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial1d_water_level_file_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/1d_water_level/file/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial1d_water_level_file_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_file_list  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_file_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20058
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial1d_water_level_file_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial1d_water_level_file_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_file_list  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_file_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20058, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial1d_water_level_file_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial1d_water_level_file_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/1d_water_level/file/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20058',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial1d_water_level_file_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_file_partial_update  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_file_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level file. (required)
        :param str simulation_pk: (required)
        :param OneDWaterLevelFile data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OneDWaterLevelFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial1d_water_level_file_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial1d_water_level_file_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_file_partial_update  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_file_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level file. (required)
        :param str simulation_pk: (required)
        :param OneDWaterLevelFile data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OneDWaterLevelFile, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial1d_water_level_file_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial1d_water_level_file_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial1d_water_level_file_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial1d_water_level_file_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/1d_water_level/file/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OneDWaterLevelFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial1d_water_level_file_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_file_read  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_file_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level file. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OneDWaterLevelFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial1d_water_level_file_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial1d_water_level_file_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_file_read  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_file_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level file. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OneDWaterLevelFile, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial1d_water_level_file_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial1d_water_level_file_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial1d_water_level_file_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/1d_water_level/file/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OneDWaterLevelFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial1d_water_level_file_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_file_update  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_file_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level file. (required)
        :param str simulation_pk: (required)
        :param OneDWaterLevelFile data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OneDWaterLevelFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial1d_water_level_file_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial1d_water_level_file_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_file_update  # noqa: E501

        Initial 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_file_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level file. (required)
        :param str simulation_pk: (required)
        :param OneDWaterLevelFile data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OneDWaterLevelFile, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial1d_water_level_file_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial1d_water_level_file_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial1d_water_level_file_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial1d_water_level_file_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/1d_water_level/file/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OneDWaterLevelFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial1d_water_level_predefined_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """This endpoint is pending deprecation.  # noqa: E501

        For threedimodels that came from a repository on models.lizard.net: Start the simulation with predefined 1D water levels. That is, use the initial water levels that have been specified in the ``connection_nodes`` schema.  For threedimodels that came from a schematisation in this API, there might be a threedimodels/{}/initial_waterlevels 1D resource. If such a resource exists, there will also be a /file initial condition created. The /predefined resource will still be created but is ignored by the simulation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_predefined_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param OneDWaterLevelPredefined data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OneDWaterLevelPredefined
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial1d_water_level_predefined_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial1d_water_level_predefined_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """This endpoint is pending deprecation.  # noqa: E501

        For threedimodels that came from a repository on models.lizard.net: Start the simulation with predefined 1D water levels. That is, use the initial water levels that have been specified in the ``connection_nodes`` schema.  For threedimodels that came from a schematisation in this API, there might be a threedimodels/{}/initial_waterlevels 1D resource. If such a resource exists, there will also be a /file initial condition created. The /predefined resource will still be created but is ignored by the simulation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_predefined_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param OneDWaterLevelPredefined data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OneDWaterLevelPredefined, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial1d_water_level_predefined_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial1d_water_level_predefined_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial1d_water_level_predefined_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/1d_water_level/predefined/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OneDWaterLevelPredefined',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial1d_water_level_predefined_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_predefined_delete  # noqa: E501

        initial predefined 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_predefined_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level predefined. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial1d_water_level_predefined_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial1d_water_level_predefined_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_predefined_delete  # noqa: E501

        initial predefined 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_predefined_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level predefined. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial1d_water_level_predefined_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial1d_water_level_predefined_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial1d_water_level_predefined_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/1d_water_level/predefined/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial1d_water_level_predefined_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_predefined_list  # noqa: E501

        initial predefined 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_predefined_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20059
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial1d_water_level_predefined_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial1d_water_level_predefined_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_predefined_list  # noqa: E501

        initial predefined 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_predefined_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20059, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial1d_water_level_predefined_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial1d_water_level_predefined_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/1d_water_level/predefined/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20059',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial1d_water_level_predefined_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_predefined_partial_update  # noqa: E501

        initial predefined 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_predefined_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level predefined. (required)
        :param str simulation_pk: (required)
        :param OneDWaterLevelPredefined data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OneDWaterLevelPredefined
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial1d_water_level_predefined_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial1d_water_level_predefined_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_predefined_partial_update  # noqa: E501

        initial predefined 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_predefined_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level predefined. (required)
        :param str simulation_pk: (required)
        :param OneDWaterLevelPredefined data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OneDWaterLevelPredefined, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial1d_water_level_predefined_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial1d_water_level_predefined_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial1d_water_level_predefined_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial1d_water_level_predefined_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/1d_water_level/predefined/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OneDWaterLevelPredefined',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial1d_water_level_predefined_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_predefined_read  # noqa: E501

        initial predefined 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_predefined_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level predefined. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OneDWaterLevelPredefined
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial1d_water_level_predefined_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial1d_water_level_predefined_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_predefined_read  # noqa: E501

        initial predefined 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_predefined_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level predefined. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OneDWaterLevelPredefined, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial1d_water_level_predefined_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial1d_water_level_predefined_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial1d_water_level_predefined_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/1d_water_level/predefined/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OneDWaterLevelPredefined',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial1d_water_level_predefined_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_predefined_update  # noqa: E501

        initial predefined 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_predefined_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level predefined. (required)
        :param str simulation_pk: (required)
        :param OneDWaterLevelPredefined data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OneDWaterLevelPredefined
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial1d_water_level_predefined_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial1d_water_level_predefined_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial1d_water_level_predefined_update  # noqa: E501

        initial predefined 1D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial1d_water_level_predefined_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this one d water level predefined. (required)
        :param str simulation_pk: (required)
        :param OneDWaterLevelPredefined data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OneDWaterLevelPredefined, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial1d_water_level_predefined_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial1d_water_level_predefined_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial1d_water_level_predefined_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial1d_water_level_predefined_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/1d_water_level/predefined/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OneDWaterLevelPredefined',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial2d_water_level_constant_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_constant_create  # noqa: E501

        Start the simulation with a global 2D water level. Applies the given value to the predefined nodes subset \"2D_OPEN_WATER\" as described in the [threedigrid documentation] [ref]  [ref]: https://threedigrid.readthedocs.io/en/latest/api.html#subsets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_constant_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TwoDWaterLevel data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TwoDWaterLevel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial2d_water_level_constant_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial2d_water_level_constant_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_constant_create  # noqa: E501

        Start the simulation with a global 2D water level. Applies the given value to the predefined nodes subset \"2D_OPEN_WATER\" as described in the [threedigrid documentation] [ref]  [ref]: https://threedigrid.readthedocs.io/en/latest/api.html#subsets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_constant_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TwoDWaterLevel data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TwoDWaterLevel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial2d_water_level_constant_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial2d_water_level_constant_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial2d_water_level_constant_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/2d_water_level/constant/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TwoDWaterLevel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial2d_water_level_constant_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_constant_delete  # noqa: E501

        Initial 2D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_constant_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this two d water level. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial2d_water_level_constant_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial2d_water_level_constant_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_constant_delete  # noqa: E501

        Initial 2D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_constant_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this two d water level. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial2d_water_level_constant_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial2d_water_level_constant_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial2d_water_level_constant_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/2d_water_level/constant/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial2d_water_level_constant_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_constant_list  # noqa: E501

        Initial 2D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_constant_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20060
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial2d_water_level_constant_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial2d_water_level_constant_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_constant_list  # noqa: E501

        Initial 2D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_constant_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20060, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial2d_water_level_constant_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial2d_water_level_constant_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/2d_water_level/constant/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20060',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial2d_water_level_constant_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_constant_partial_update  # noqa: E501

        Initial 2D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_constant_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this two d water level. (required)
        :param str simulation_pk: (required)
        :param TwoDWaterLevel data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TwoDWaterLevel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial2d_water_level_constant_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial2d_water_level_constant_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_constant_partial_update  # noqa: E501

        Initial 2D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_constant_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this two d water level. (required)
        :param str simulation_pk: (required)
        :param TwoDWaterLevel data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TwoDWaterLevel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial2d_water_level_constant_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial2d_water_level_constant_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial2d_water_level_constant_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial2d_water_level_constant_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/2d_water_level/constant/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TwoDWaterLevel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial2d_water_level_constant_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_constant_read  # noqa: E501

        Initial 2D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_constant_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this two d water level. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TwoDWaterLevel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial2d_water_level_constant_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial2d_water_level_constant_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_constant_read  # noqa: E501

        Initial 2D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_constant_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this two d water level. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TwoDWaterLevel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial2d_water_level_constant_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial2d_water_level_constant_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial2d_water_level_constant_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/2d_water_level/constant/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TwoDWaterLevel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial2d_water_level_constant_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_constant_update  # noqa: E501

        Initial 2D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_constant_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this two d water level. (required)
        :param str simulation_pk: (required)
        :param TwoDWaterLevel data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TwoDWaterLevel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial2d_water_level_constant_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial2d_water_level_constant_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_constant_update  # noqa: E501

        Initial 2D water levels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_constant_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this two d water level. (required)
        :param str simulation_pk: (required)
        :param TwoDWaterLevel data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TwoDWaterLevel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial2d_water_level_constant_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial2d_water_level_constant_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial2d_water_level_constant_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial2d_water_level_constant_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/2d_water_level/constant/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TwoDWaterLevel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial2d_water_level_raster_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_raster_create  # noqa: E501

        Start the simulation with 2D water levels derived from the raster by using the aggregation method. Applies the resulting levels to the predefined nodes subset \"2D_OPEN_WATER\" as described in the [threedigrid documentation] [ref]  [ref]: https://threedigrid.readthedocs.io/en/latest/api.html#subsets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_raster_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TwoDWaterRaster data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TwoDWaterRaster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial2d_water_level_raster_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial2d_water_level_raster_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_raster_create  # noqa: E501

        Start the simulation with 2D water levels derived from the raster by using the aggregation method. Applies the resulting levels to the predefined nodes subset \"2D_OPEN_WATER\" as described in the [threedigrid documentation] [ref]  [ref]: https://threedigrid.readthedocs.io/en/latest/api.html#subsets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_raster_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TwoDWaterRaster data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TwoDWaterRaster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial2d_water_level_raster_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial2d_water_level_raster_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial2d_water_level_raster_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/2d_water_level/raster/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TwoDWaterRaster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial2d_water_level_raster_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_raster_delete  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_raster_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this two d water raster. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial2d_water_level_raster_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial2d_water_level_raster_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_raster_delete  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_raster_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this two d water raster. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial2d_water_level_raster_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial2d_water_level_raster_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial2d_water_level_raster_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/2d_water_level/raster/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial2d_water_level_raster_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_raster_list  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_raster_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20061
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial2d_water_level_raster_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial2d_water_level_raster_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_raster_list  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_raster_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20061, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial2d_water_level_raster_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial2d_water_level_raster_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/2d_water_level/raster/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20061',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial2d_water_level_raster_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_raster_partial_update  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_raster_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this two d water raster. (required)
        :param str simulation_pk: (required)
        :param TwoDWaterRaster data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TwoDWaterRaster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial2d_water_level_raster_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial2d_water_level_raster_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_raster_partial_update  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_raster_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this two d water raster. (required)
        :param str simulation_pk: (required)
        :param TwoDWaterRaster data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TwoDWaterRaster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial2d_water_level_raster_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial2d_water_level_raster_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial2d_water_level_raster_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial2d_water_level_raster_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/2d_water_level/raster/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TwoDWaterRaster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial2d_water_level_raster_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_raster_read  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_raster_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this two d water raster. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TwoDWaterRaster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial2d_water_level_raster_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial2d_water_level_raster_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_raster_read  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_raster_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this two d water raster. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TwoDWaterRaster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial2d_water_level_raster_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial2d_water_level_raster_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial2d_water_level_raster_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/2d_water_level/raster/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TwoDWaterRaster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial2d_water_level_raster_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_raster_update  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_raster_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this two d water raster. (required)
        :param str simulation_pk: (required)
        :param TwoDWaterRaster data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TwoDWaterRaster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial2d_water_level_raster_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial2d_water_level_raster_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial2d_water_level_raster_update  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial2d_water_level_raster_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this two d water raster. (required)
        :param str simulation_pk: (required)
        :param TwoDWaterRaster data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TwoDWaterRaster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial2d_water_level_raster_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial2d_water_level_raster_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial2d_water_level_raster_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial2d_water_level_raster_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/2d_water_level/raster/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TwoDWaterRaster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_groundwater_level_constant_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_constant_create  # noqa: E501

        Start the simulation with a global 2D groundwater level. Applies the given value to the predefined nodes subset \"2D_GROUNDWATER\" as described in the [threedigrid documentation] [ref]  [ref]: https://threedigrid.readthedocs.io/en/latest/api.html#subsets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_constant_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param GroundWaterLevel data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GroundWaterLevel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_groundwater_level_constant_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial_groundwater_level_constant_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_constant_create  # noqa: E501

        Start the simulation with a global 2D groundwater level. Applies the given value to the predefined nodes subset \"2D_GROUNDWATER\" as described in the [threedigrid documentation] [ref]  [ref]: https://threedigrid.readthedocs.io/en/latest/api.html#subsets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_constant_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param GroundWaterLevel data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GroundWaterLevel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_groundwater_level_constant_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_groundwater_level_constant_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial_groundwater_level_constant_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/groundwater_level/constant/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GroundWaterLevel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_groundwater_level_constant_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_constant_delete  # noqa: E501

        Initial groundwater levels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_constant_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this ground water level. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_groundwater_level_constant_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial_groundwater_level_constant_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_constant_delete  # noqa: E501

        Initial groundwater levels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_constant_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this ground water level. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_groundwater_level_constant_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial_groundwater_level_constant_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_groundwater_level_constant_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/groundwater_level/constant/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_groundwater_level_constant_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_constant_list  # noqa: E501

        Initial groundwater levels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_constant_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20062
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_groundwater_level_constant_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial_groundwater_level_constant_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_constant_list  # noqa: E501

        Initial groundwater levels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_constant_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20062, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_groundwater_level_constant_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_groundwater_level_constant_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/groundwater_level/constant/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20062',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_groundwater_level_constant_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_constant_partial_update  # noqa: E501

        Initial groundwater levels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_constant_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this ground water level. (required)
        :param str simulation_pk: (required)
        :param GroundWaterLevel data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GroundWaterLevel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_groundwater_level_constant_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial_groundwater_level_constant_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_constant_partial_update  # noqa: E501

        Initial groundwater levels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_constant_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this ground water level. (required)
        :param str simulation_pk: (required)
        :param GroundWaterLevel data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GroundWaterLevel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_groundwater_level_constant_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial_groundwater_level_constant_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_groundwater_level_constant_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial_groundwater_level_constant_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/groundwater_level/constant/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GroundWaterLevel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_groundwater_level_constant_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_constant_read  # noqa: E501

        Initial groundwater levels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_constant_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this ground water level. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GroundWaterLevel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_groundwater_level_constant_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial_groundwater_level_constant_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_constant_read  # noqa: E501

        Initial groundwater levels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_constant_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this ground water level. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GroundWaterLevel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_groundwater_level_constant_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial_groundwater_level_constant_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_groundwater_level_constant_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/groundwater_level/constant/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GroundWaterLevel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_groundwater_level_constant_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_constant_update  # noqa: E501

        Initial groundwater levels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_constant_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this ground water level. (required)
        :param str simulation_pk: (required)
        :param GroundWaterLevel data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GroundWaterLevel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_groundwater_level_constant_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial_groundwater_level_constant_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_constant_update  # noqa: E501

        Initial groundwater levels.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_constant_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this ground water level. (required)
        :param str simulation_pk: (required)
        :param GroundWaterLevel data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GroundWaterLevel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_groundwater_level_constant_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial_groundwater_level_constant_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_groundwater_level_constant_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial_groundwater_level_constant_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/groundwater_level/constant/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GroundWaterLevel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_groundwater_level_raster_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_raster_create  # noqa: E501

        Start the simulation with groundwaterlevels derived from the raster by using the aggregation method. Applies the given value to the predefined nodes subset \"2D_GROUNDWATER\" as described in the [threedigrid documentation] [ref]  [ref]: https://threedigrid.readthedocs.io/en/latest/api.html#subsets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_raster_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param GroundWaterRaster data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GroundWaterRaster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_groundwater_level_raster_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial_groundwater_level_raster_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_raster_create  # noqa: E501

        Start the simulation with groundwaterlevels derived from the raster by using the aggregation method. Applies the given value to the predefined nodes subset \"2D_GROUNDWATER\" as described in the [threedigrid documentation] [ref]  [ref]: https://threedigrid.readthedocs.io/en/latest/api.html#subsets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_raster_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param GroundWaterRaster data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GroundWaterRaster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_groundwater_level_raster_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_groundwater_level_raster_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial_groundwater_level_raster_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/groundwater_level/raster/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GroundWaterRaster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_groundwater_level_raster_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_raster_delete  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_raster_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this ground water raster. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_groundwater_level_raster_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial_groundwater_level_raster_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_raster_delete  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_raster_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this ground water raster. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_groundwater_level_raster_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial_groundwater_level_raster_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_groundwater_level_raster_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/groundwater_level/raster/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_groundwater_level_raster_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_raster_list  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_raster_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20063
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_groundwater_level_raster_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial_groundwater_level_raster_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_raster_list  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_raster_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20063, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_groundwater_level_raster_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_groundwater_level_raster_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/groundwater_level/raster/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20063',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_groundwater_level_raster_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_raster_partial_update  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_raster_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this ground water raster. (required)
        :param str simulation_pk: (required)
        :param GroundWaterRaster data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GroundWaterRaster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_groundwater_level_raster_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial_groundwater_level_raster_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_raster_partial_update  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_raster_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this ground water raster. (required)
        :param str simulation_pk: (required)
        :param GroundWaterRaster data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GroundWaterRaster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_groundwater_level_raster_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial_groundwater_level_raster_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_groundwater_level_raster_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial_groundwater_level_raster_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/groundwater_level/raster/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GroundWaterRaster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_groundwater_level_raster_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_raster_read  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_raster_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this ground water raster. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GroundWaterRaster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_groundwater_level_raster_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial_groundwater_level_raster_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_raster_read  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_raster_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this ground water raster. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GroundWaterRaster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_groundwater_level_raster_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial_groundwater_level_raster_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_groundwater_level_raster_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/groundwater_level/raster/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GroundWaterRaster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_groundwater_level_raster_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_raster_update  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_raster_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this ground water raster. (required)
        :param str simulation_pk: (required)
        :param GroundWaterRaster data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GroundWaterRaster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_groundwater_level_raster_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial_groundwater_level_raster_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_groundwater_level_raster_update  # noqa: E501

        Initial 2D water raster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_groundwater_level_raster_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this ground water raster. (required)
        :param str simulation_pk: (required)
        :param GroundWaterRaster data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GroundWaterRaster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_groundwater_level_raster_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial_groundwater_level_raster_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_groundwater_level_raster_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial_groundwater_level_raster_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/groundwater_level/raster/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GroundWaterRaster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_saved_state_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_saved_state_create  # noqa: E501

        A simple ViewSet for initial SavedState's  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_saved_state_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param InitialSavedState data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InitialSavedState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_saved_state_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial_saved_state_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_saved_state_create  # noqa: E501

        A simple ViewSet for initial SavedState's  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_saved_state_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param InitialSavedState data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InitialSavedState, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_saved_state_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_saved_state_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial_saved_state_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/saved_state/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InitialSavedState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_saved_state_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_saved_state_delete  # noqa: E501

        A simple ViewSet for initial SavedState's  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_saved_state_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial saved state. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_saved_state_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial_saved_state_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_saved_state_delete  # noqa: E501

        A simple ViewSet for initial SavedState's  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_saved_state_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial saved state. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_saved_state_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial_saved_state_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_saved_state_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/saved_state/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_saved_state_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_saved_state_list  # noqa: E501

        A simple ViewSet for initial SavedState's  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_saved_state_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20064
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_saved_state_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial_saved_state_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_saved_state_list  # noqa: E501

        A simple ViewSet for initial SavedState's  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_saved_state_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20064, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_saved_state_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_saved_state_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/saved_state/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20064',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_saved_state_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_saved_state_partial_update  # noqa: E501

        A simple ViewSet for initial SavedState's  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_saved_state_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial saved state. (required)
        :param str simulation_pk: (required)
        :param InitialSavedState data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InitialSavedState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_saved_state_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial_saved_state_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_saved_state_partial_update  # noqa: E501

        A simple ViewSet for initial SavedState's  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_saved_state_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial saved state. (required)
        :param str simulation_pk: (required)
        :param InitialSavedState data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InitialSavedState, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_saved_state_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial_saved_state_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_saved_state_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial_saved_state_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/saved_state/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InitialSavedState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_saved_state_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_saved_state_read  # noqa: E501

        A simple ViewSet for initial SavedState's  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_saved_state_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial saved state. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InitialSavedState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_saved_state_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial_saved_state_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_saved_state_read  # noqa: E501

        A simple ViewSet for initial SavedState's  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_saved_state_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial saved state. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InitialSavedState, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_saved_state_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial_saved_state_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_saved_state_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/saved_state/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InitialSavedState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_saved_state_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_saved_state_update  # noqa: E501

        A simple ViewSet for initial SavedState's  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_saved_state_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial saved state. (required)
        :param str simulation_pk: (required)
        :param InitialSavedState data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InitialSavedState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_saved_state_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial_saved_state_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_saved_state_update  # noqa: E501

        A simple ViewSet for initial SavedState's  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_saved_state_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial saved state. (required)
        :param str simulation_pk: (required)
        :param InitialSavedState data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InitialSavedState, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_saved_state_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial_saved_state_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_saved_state_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial_saved_state_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/saved_state/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InitialSavedState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_wind_drag_coefficient_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_wind_drag_coefficient_create  # noqa: E501

        Start the simulation with a global wind drag-coefficient. This (dimensionless) ``drag-coefficient`` translates the wind speed on a 10 m elevation to the speed on the ground (default=0.005). Currently the drag-coefficient works as a global factor for the entire model: 1D lines and 2D lines if exists  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_wind_drag_coefficient_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WindDragCoefficient data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WindDragCoefficient
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_wind_drag_coefficient_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial_wind_drag_coefficient_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_wind_drag_coefficient_create  # noqa: E501

        Start the simulation with a global wind drag-coefficient. This (dimensionless) ``drag-coefficient`` translates the wind speed on a 10 m elevation to the speed on the ground (default=0.005). Currently the drag-coefficient works as a global factor for the entire model: 1D lines and 2D lines if exists  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_wind_drag_coefficient_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WindDragCoefficient data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WindDragCoefficient, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_wind_drag_coefficient_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_wind_drag_coefficient_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial_wind_drag_coefficient_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/wind_drag-coefficient/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WindDragCoefficient',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_wind_drag_coefficient_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_wind_drag_coefficient_delete  # noqa: E501

        A simple ViewSet for initial Wind drag coefficient  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_wind_drag_coefficient_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind drag coefficient. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_wind_drag_coefficient_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial_wind_drag_coefficient_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_wind_drag_coefficient_delete  # noqa: E501

        A simple ViewSet for initial Wind drag coefficient  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_wind_drag_coefficient_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind drag coefficient. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_wind_drag_coefficient_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial_wind_drag_coefficient_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_wind_drag_coefficient_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/wind_drag-coefficient/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_wind_drag_coefficient_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_wind_drag_coefficient_list  # noqa: E501

        A simple ViewSet for initial Wind drag coefficient  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_wind_drag_coefficient_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20065
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_wind_drag_coefficient_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial_wind_drag_coefficient_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_wind_drag_coefficient_list  # noqa: E501

        A simple ViewSet for initial Wind drag coefficient  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_wind_drag_coefficient_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20065, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_wind_drag_coefficient_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_wind_drag_coefficient_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/wind_drag-coefficient/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20065',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_wind_drag_coefficient_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_wind_drag_coefficient_partial_update  # noqa: E501

        A simple ViewSet for initial Wind drag coefficient  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_wind_drag_coefficient_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind drag coefficient. (required)
        :param str simulation_pk: (required)
        :param WindDragCoefficient data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WindDragCoefficient
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_wind_drag_coefficient_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial_wind_drag_coefficient_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_wind_drag_coefficient_partial_update  # noqa: E501

        A simple ViewSet for initial Wind drag coefficient  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_wind_drag_coefficient_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind drag coefficient. (required)
        :param str simulation_pk: (required)
        :param WindDragCoefficient data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WindDragCoefficient, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_wind_drag_coefficient_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial_wind_drag_coefficient_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_wind_drag_coefficient_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial_wind_drag_coefficient_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/wind_drag-coefficient/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WindDragCoefficient',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_wind_drag_coefficient_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_wind_drag_coefficient_read  # noqa: E501

        A simple ViewSet for initial Wind drag coefficient  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_wind_drag_coefficient_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind drag coefficient. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WindDragCoefficient
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_wind_drag_coefficient_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_initial_wind_drag_coefficient_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_initial_wind_drag_coefficient_read  # noqa: E501

        A simple ViewSet for initial Wind drag coefficient  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_wind_drag_coefficient_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind drag coefficient. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WindDragCoefficient, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_wind_drag_coefficient_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial_wind_drag_coefficient_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_wind_drag_coefficient_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/wind_drag-coefficient/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WindDragCoefficient',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_initial_wind_drag_coefficient_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_wind_drag_coefficient_update  # noqa: E501

        A simple ViewSet for initial Wind drag coefficient  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_wind_drag_coefficient_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind drag coefficient. (required)
        :param str simulation_pk: (required)
        :param WindDragCoefficient data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WindDragCoefficient
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_initial_wind_drag_coefficient_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_initial_wind_drag_coefficient_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_initial_wind_drag_coefficient_update  # noqa: E501

        A simple ViewSet for initial Wind drag coefficient  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_initial_wind_drag_coefficient_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this wind drag coefficient. (required)
        :param str simulation_pk: (required)
        :param WindDragCoefficient data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WindDragCoefficient, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_initial_wind_drag_coefficient_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_initial_wind_drag_coefficient_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_initial_wind_drag_coefficient_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_initial_wind_drag_coefficient_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/initial/wind_drag-coefficient/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WindDragCoefficient',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_list(self, **kwargs):  # noqa: E501
        """List all simulations resources. By default the results are sorted from newest to oldest.  # noqa: E501

        The reverse this order  ```     ?created ``` In general it is possible to specify reverse orderings by prefixing the field name with '-', like so:  ```     ?-id ``` Other fields that can be used to order the results are `name` and `id`.  Several filter are available, for instance the creation date of the resource. Some usage examples:  To get all simulation resources that have been created on Guido van Rossum's birthday  ```     ?created__date=1956-01-31 ```  To get all simulation resources that have been created during the 1988 UEFA European Football Championship ```    ?created__date__gte=1988-06-10&created__date__lte=1988-06-25 ```  To get all simulation resources that have been created in the month of the Carnation Revolution ```     ?created__year=1974&created__month=04 ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str id__contains: id__contains
        :param str name: name
        :param str name__iexact: name__iexact
        :param str name__contains: name__contains
        :param str name__icontains: name__icontains
        :param str name__in: name__in
        :param str name__startswith: name__startswith
        :param str name__istartswith: name__istartswith
        :param str name__endswith: name__endswith
        :param str name__regex: name__regex
        :param str uuid: uuid
        :param str uuid__iexact: uuid__iexact
        :param str uuid__contains: uuid__contains
        :param str uuid__icontains: uuid__icontains
        :param str uuid__in: uuid__in
        :param str uuid__startswith: uuid__startswith
        :param str uuid__istartswith: uuid__istartswith
        :param str uuid__endswith: uuid__endswith
        :param str uuid__regex: uuid__regex
        :param str created__date: created__date
        :param str created__date__gt: created__date__gt
        :param str created__date__gte: created__date__gte
        :param str created__date__lt: created__date__lt
        :param str created__date__lte: created__date__lte
        :param str created__year: created__year
        :param str created__year__gt: created__year__gt
        :param str created__year__gte: created__year__gte
        :param str created__year__lt: created__year__lt
        :param str created__year__lte: created__year__lte
        :param str created__month: created__month
        :param str created__month__lte: created__month__lte
        :param str created__day: created__day
        :param str created__day__lt: created__day__lt
        :param str started_from: started_from
        :param str user__username: user__username
        :param str user__username__istartswith: user__username__istartswith
        :param str threedimodel__id: threedimodel__id
        :param str threedimodel__revision__id: threedimodel__revision__id
        :param str organisation__unique_id: organisation__unique_id
        :param str tags__in: tags__in
        :param str is_template: is_template
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20023
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_list_with_http_info(**kwargs)  # noqa: E501

    def simulations_list_with_http_info(self, **kwargs):  # noqa: E501
        """List all simulations resources. By default the results are sorted from newest to oldest.  # noqa: E501

        The reverse this order  ```     ?created ``` In general it is possible to specify reverse orderings by prefixing the field name with '-', like so:  ```     ?-id ``` Other fields that can be used to order the results are `name` and `id`.  Several filter are available, for instance the creation date of the resource. Some usage examples:  To get all simulation resources that have been created on Guido van Rossum's birthday  ```     ?created__date=1956-01-31 ```  To get all simulation resources that have been created during the 1988 UEFA European Football Championship ```    ?created__date__gte=1988-06-10&created__date__lte=1988-06-25 ```  To get all simulation resources that have been created in the month of the Carnation Revolution ```     ?created__year=1974&created__month=04 ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str id__contains: id__contains
        :param str name: name
        :param str name__iexact: name__iexact
        :param str name__contains: name__contains
        :param str name__icontains: name__icontains
        :param str name__in: name__in
        :param str name__startswith: name__startswith
        :param str name__istartswith: name__istartswith
        :param str name__endswith: name__endswith
        :param str name__regex: name__regex
        :param str uuid: uuid
        :param str uuid__iexact: uuid__iexact
        :param str uuid__contains: uuid__contains
        :param str uuid__icontains: uuid__icontains
        :param str uuid__in: uuid__in
        :param str uuid__startswith: uuid__startswith
        :param str uuid__istartswith: uuid__istartswith
        :param str uuid__endswith: uuid__endswith
        :param str uuid__regex: uuid__regex
        :param str created__date: created__date
        :param str created__date__gt: created__date__gt
        :param str created__date__gte: created__date__gte
        :param str created__date__lt: created__date__lt
        :param str created__date__lte: created__date__lte
        :param str created__year: created__year
        :param str created__year__gt: created__year__gt
        :param str created__year__gte: created__year__gte
        :param str created__year__lt: created__year__lt
        :param str created__year__lte: created__year__lte
        :param str created__month: created__month
        :param str created__month__lte: created__month__lte
        :param str created__day: created__day
        :param str created__day__lt: created__day__lt
        :param str started_from: started_from
        :param str user__username: user__username
        :param str user__username__istartswith: user__username__istartswith
        :param str threedimodel__id: threedimodel__id
        :param str threedimodel__revision__id: threedimodel__revision__id
        :param str organisation__unique_id: organisation__unique_id
        :param str tags__in: tags__in
        :param str is_template: is_template
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20023, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id__contains',
            'name',
            'name__iexact',
            'name__contains',
            'name__icontains',
            'name__in',
            'name__startswith',
            'name__istartswith',
            'name__endswith',
            'name__regex',
            'uuid',
            'uuid__iexact',
            'uuid__contains',
            'uuid__icontains',
            'uuid__in',
            'uuid__startswith',
            'uuid__istartswith',
            'uuid__endswith',
            'uuid__regex',
            'created__date',
            'created__date__gt',
            'created__date__gte',
            'created__date__lt',
            'created__date__lte',
            'created__year',
            'created__year__gt',
            'created__year__gte',
            'created__year__lt',
            'created__year__lte',
            'created__month',
            'created__month__lte',
            'created__day',
            'created__day__lt',
            'started_from',
            'user__username',
            'user__username__istartswith',
            'threedimodel__id',
            'threedimodel__revision__id',
            'organisation__unique_id',
            'tags__in',
            'is_template',
            'ordering',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id__contains' in local_var_params and local_var_params['id__contains'] is not None:  # noqa: E501
            query_params.append(('id__contains', local_var_params['id__contains']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'name__iexact' in local_var_params and local_var_params['name__iexact'] is not None:  # noqa: E501
            query_params.append(('name__iexact', local_var_params['name__iexact']))  # noqa: E501
        if 'name__contains' in local_var_params and local_var_params['name__contains'] is not None:  # noqa: E501
            query_params.append(('name__contains', local_var_params['name__contains']))  # noqa: E501
        if 'name__icontains' in local_var_params and local_var_params['name__icontains'] is not None:  # noqa: E501
            query_params.append(('name__icontains', local_var_params['name__icontains']))  # noqa: E501
        if 'name__in' in local_var_params and local_var_params['name__in'] is not None:  # noqa: E501
            query_params.append(('name__in', local_var_params['name__in']))  # noqa: E501
        if 'name__startswith' in local_var_params and local_var_params['name__startswith'] is not None:  # noqa: E501
            query_params.append(('name__startswith', local_var_params['name__startswith']))  # noqa: E501
        if 'name__istartswith' in local_var_params and local_var_params['name__istartswith'] is not None:  # noqa: E501
            query_params.append(('name__istartswith', local_var_params['name__istartswith']))  # noqa: E501
        if 'name__endswith' in local_var_params and local_var_params['name__endswith'] is not None:  # noqa: E501
            query_params.append(('name__endswith', local_var_params['name__endswith']))  # noqa: E501
        if 'name__regex' in local_var_params and local_var_params['name__regex'] is not None:  # noqa: E501
            query_params.append(('name__regex', local_var_params['name__regex']))  # noqa: E501
        if 'uuid' in local_var_params and local_var_params['uuid'] is not None:  # noqa: E501
            query_params.append(('uuid', local_var_params['uuid']))  # noqa: E501
        if 'uuid__iexact' in local_var_params and local_var_params['uuid__iexact'] is not None:  # noqa: E501
            query_params.append(('uuid__iexact', local_var_params['uuid__iexact']))  # noqa: E501
        if 'uuid__contains' in local_var_params and local_var_params['uuid__contains'] is not None:  # noqa: E501
            query_params.append(('uuid__contains', local_var_params['uuid__contains']))  # noqa: E501
        if 'uuid__icontains' in local_var_params and local_var_params['uuid__icontains'] is not None:  # noqa: E501
            query_params.append(('uuid__icontains', local_var_params['uuid__icontains']))  # noqa: E501
        if 'uuid__in' in local_var_params and local_var_params['uuid__in'] is not None:  # noqa: E501
            query_params.append(('uuid__in', local_var_params['uuid__in']))  # noqa: E501
        if 'uuid__startswith' in local_var_params and local_var_params['uuid__startswith'] is not None:  # noqa: E501
            query_params.append(('uuid__startswith', local_var_params['uuid__startswith']))  # noqa: E501
        if 'uuid__istartswith' in local_var_params and local_var_params['uuid__istartswith'] is not None:  # noqa: E501
            query_params.append(('uuid__istartswith', local_var_params['uuid__istartswith']))  # noqa: E501
        if 'uuid__endswith' in local_var_params and local_var_params['uuid__endswith'] is not None:  # noqa: E501
            query_params.append(('uuid__endswith', local_var_params['uuid__endswith']))  # noqa: E501
        if 'uuid__regex' in local_var_params and local_var_params['uuid__regex'] is not None:  # noqa: E501
            query_params.append(('uuid__regex', local_var_params['uuid__regex']))  # noqa: E501
        if 'created__date' in local_var_params and local_var_params['created__date'] is not None:  # noqa: E501
            query_params.append(('created__date', local_var_params['created__date']))  # noqa: E501
        if 'created__date__gt' in local_var_params and local_var_params['created__date__gt'] is not None:  # noqa: E501
            query_params.append(('created__date__gt', local_var_params['created__date__gt']))  # noqa: E501
        if 'created__date__gte' in local_var_params and local_var_params['created__date__gte'] is not None:  # noqa: E501
            query_params.append(('created__date__gte', local_var_params['created__date__gte']))  # noqa: E501
        if 'created__date__lt' in local_var_params and local_var_params['created__date__lt'] is not None:  # noqa: E501
            query_params.append(('created__date__lt', local_var_params['created__date__lt']))  # noqa: E501
        if 'created__date__lte' in local_var_params and local_var_params['created__date__lte'] is not None:  # noqa: E501
            query_params.append(('created__date__lte', local_var_params['created__date__lte']))  # noqa: E501
        if 'created__year' in local_var_params and local_var_params['created__year'] is not None:  # noqa: E501
            query_params.append(('created__year', local_var_params['created__year']))  # noqa: E501
        if 'created__year__gt' in local_var_params and local_var_params['created__year__gt'] is not None:  # noqa: E501
            query_params.append(('created__year__gt', local_var_params['created__year__gt']))  # noqa: E501
        if 'created__year__gte' in local_var_params and local_var_params['created__year__gte'] is not None:  # noqa: E501
            query_params.append(('created__year__gte', local_var_params['created__year__gte']))  # noqa: E501
        if 'created__year__lt' in local_var_params and local_var_params['created__year__lt'] is not None:  # noqa: E501
            query_params.append(('created__year__lt', local_var_params['created__year__lt']))  # noqa: E501
        if 'created__year__lte' in local_var_params and local_var_params['created__year__lte'] is not None:  # noqa: E501
            query_params.append(('created__year__lte', local_var_params['created__year__lte']))  # noqa: E501
        if 'created__month' in local_var_params and local_var_params['created__month'] is not None:  # noqa: E501
            query_params.append(('created__month', local_var_params['created__month']))  # noqa: E501
        if 'created__month__lte' in local_var_params and local_var_params['created__month__lte'] is not None:  # noqa: E501
            query_params.append(('created__month__lte', local_var_params['created__month__lte']))  # noqa: E501
        if 'created__day' in local_var_params and local_var_params['created__day'] is not None:  # noqa: E501
            query_params.append(('created__day', local_var_params['created__day']))  # noqa: E501
        if 'created__day__lt' in local_var_params and local_var_params['created__day__lt'] is not None:  # noqa: E501
            query_params.append(('created__day__lt', local_var_params['created__day__lt']))  # noqa: E501
        if 'started_from' in local_var_params and local_var_params['started_from'] is not None:  # noqa: E501
            query_params.append(('started_from', local_var_params['started_from']))  # noqa: E501
        if 'user__username' in local_var_params and local_var_params['user__username'] is not None:  # noqa: E501
            query_params.append(('user__username', local_var_params['user__username']))  # noqa: E501
        if 'user__username__istartswith' in local_var_params and local_var_params['user__username__istartswith'] is not None:  # noqa: E501
            query_params.append(('user__username__istartswith', local_var_params['user__username__istartswith']))  # noqa: E501
        if 'threedimodel__id' in local_var_params and local_var_params['threedimodel__id'] is not None:  # noqa: E501
            query_params.append(('threedimodel__id', local_var_params['threedimodel__id']))  # noqa: E501
        if 'threedimodel__revision__id' in local_var_params and local_var_params['threedimodel__revision__id'] is not None:  # noqa: E501
            query_params.append(('threedimodel__revision__id', local_var_params['threedimodel__revision__id']))  # noqa: E501
        if 'organisation__unique_id' in local_var_params and local_var_params['organisation__unique_id'] is not None:  # noqa: E501
            query_params.append(('organisation__unique_id', local_var_params['organisation__unique_id']))  # noqa: E501
        if 'tags__in' in local_var_params and local_var_params['tags__in'] is not None:  # noqa: E501
            query_params.append(('tags__in', local_var_params['tags__in']))  # noqa: E501
        if 'is_template' in local_var_params and local_var_params['is_template'] is not None:  # noqa: E501
            query_params.append(('is_template', local_var_params['is_template']))  # noqa: E501
        if 'ordering' in local_var_params and local_var_params['ordering'] is not None:  # noqa: E501
            query_params.append(('ordering', local_var_params['ordering']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20023',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_partial_update(self, id, data, **kwargs):  # noqa: E501
        """simulations_partial_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation. (required)
        :param SimulationUpdate data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SimulationUpdate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def simulations_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """simulations_partial_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation. (required)
        :param SimulationUpdate data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SimulationUpdate, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SimulationUpdate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_post_processing_lizard_queue_list(self, **kwargs):  # noqa: E501
        """simulations_post_processing_lizard_queue_list  # noqa: E501

        Read-only API endpoint for viewing simulations that need to be post-processed by Lizard (post-processing status is 'requested').  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_post_processing_lizard_queue_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_post_processing_lizard_queue_list_with_http_info(**kwargs)  # noqa: E501

    def simulations_post_processing_lizard_queue_list_with_http_info(self, **kwargs):  # noqa: E501
        """simulations_post_processing_lizard_queue_list  # noqa: E501

        Read-only API endpoint for viewing simulations that need to be post-processed by Lizard (post-processing status is 'requested').  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_post_processing_lizard_queue_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20024, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_post_processing_lizard_queue_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/post_processing/lizard/queue/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20024',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_progress_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_progress_list  # noqa: E501

        A simple ViewSet for viewing simulations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_progress_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Progress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_progress_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_progress_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_progress_list  # noqa: E501

        A simple ViewSet for viewing simulations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_progress_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Progress, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_progress_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_progress_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/progress/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Progress',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_read(self, id, **kwargs):  # noqa: E501
        """simulations_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Simulation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_read_with_http_info(id, **kwargs)  # noqa: E501

    def simulations_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """simulations_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Simulation, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Simulation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_files_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_results_files_create  # noqa: E501

        Retrieve simulation results  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_files_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param ResultFile data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResultFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_files_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_results_files_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_results_files_create  # noqa: E501

        Retrieve simulation results  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_files_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param ResultFile data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResultFile, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_files_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_files_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_results_files_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/files/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_files_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_files_delete  # noqa: E501

        Retrieve simulation results  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_files_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this result file. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_files_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_results_files_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_files_delete  # noqa: E501

        Retrieve simulation results  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_files_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this result file. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_files_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_results_files_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_files_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/files/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_files_download(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_files_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_files_download(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this result file. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_files_download_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_results_files_download_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_files_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_files_download_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this result file. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_files_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_results_files_download`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_files_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/files/{id}/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_files_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_files_list  # noqa: E501

        Retrieve simulation results  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_files_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20066
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_files_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_results_files_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_files_list  # noqa: E501

        Retrieve simulation results  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_files_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20066, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_files_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_files_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/files/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20066',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_files_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_results_files_partial_update  # noqa: E501

        Retrieve simulation results  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_files_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this result file. (required)
        :param str simulation_pk: (required)
        :param ResultFile data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResultFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_files_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_results_files_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_results_files_partial_update  # noqa: E501

        Retrieve simulation results  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_files_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this result file. (required)
        :param str simulation_pk: (required)
        :param ResultFile data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResultFile, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_files_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_results_files_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_files_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_results_files_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/files/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_files_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_files_read  # noqa: E501

        Retrieve simulation results  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_files_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this result file. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResultFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_files_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_results_files_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_files_read  # noqa: E501

        Retrieve simulation results  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_files_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this result file. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResultFile, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_files_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_results_files_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_files_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/files/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_files_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_results_files_update  # noqa: E501

        Retrieve simulation results  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_files_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this result file. (required)
        :param str simulation_pk: (required)
        :param ResultFile data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResultFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_files_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_results_files_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_results_files_update  # noqa: E501

        Retrieve simulation results  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_files_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this result file. (required)
        :param str simulation_pk: (required)
        :param ResultFile data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResultFile, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_files_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_results_files_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_files_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_results_files_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/files/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_files_upload(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_results_files_upload  # noqa: E501

        Endpoint for uploading a result file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_files_upload(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this result file. (required)
        :param str simulation_pk: (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_files_upload_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_results_files_upload_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_results_files_upload  # noqa: E501

        Endpoint for uploading a result file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_files_upload_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this result file. (required)
        :param str simulation_pk: (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_files_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_results_files_upload`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_files_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_results_files_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/files/{id}/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_post_processing_lizard_arrival_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_arrival_create  # noqa: E501

        A Custom ViewSet for creating, listing or deleting an ArrivalTimePostProcessing resource. It includes a custom destroy action (with detail=False) as a BasicPostProcessing object can have only one ArrivalTimePostProcessing object. An ArrivalTimePostProcessing resource is created with an empty POST.  Three conditions are validated when creating an resource: - The simulation may not already have an ArrivalTimePostProcessing resource. - The simulation must have a BasicPostProcessing resource with 'process_basic_results'=True. - Lizard may not already have been triggered to processing this simulation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_arrival_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param ArrivalTimePostProcessing data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ArrivalTimePostProcessing
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_post_processing_lizard_arrival_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_results_post_processing_lizard_arrival_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_arrival_create  # noqa: E501

        A Custom ViewSet for creating, listing or deleting an ArrivalTimePostProcessing resource. It includes a custom destroy action (with detail=False) as a BasicPostProcessing object can have only one ArrivalTimePostProcessing object. An ArrivalTimePostProcessing resource is created with an empty POST.  Three conditions are validated when creating an resource: - The simulation may not already have an ArrivalTimePostProcessing resource. - The simulation must have a BasicPostProcessing resource with 'process_basic_results'=True. - Lizard may not already have been triggered to processing this simulation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_arrival_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param ArrivalTimePostProcessing data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ArrivalTimePostProcessing, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_post_processing_lizard_arrival_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_post_processing_lizard_arrival_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_results_post_processing_lizard_arrival_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/post_processing/lizard/arrival/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ArrivalTimePostProcessing',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_post_processing_lizard_arrival_delete(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_arrival_delete  # noqa: E501

        A Custom ViewSet for creating, listing or deleting an ArrivalTimePostProcessing resource. It includes a custom destroy action (with detail=False) as a BasicPostProcessing object can have only one ArrivalTimePostProcessing object. An ArrivalTimePostProcessing resource is created with an empty POST.  Three conditions are validated when creating an resource: - The simulation may not already have an ArrivalTimePostProcessing resource. - The simulation must have a BasicPostProcessing resource with 'process_basic_results'=True. - Lizard may not already have been triggered to processing this simulation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_arrival_delete(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_post_processing_lizard_arrival_delete_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_results_post_processing_lizard_arrival_delete_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_arrival_delete  # noqa: E501

        A Custom ViewSet for creating, listing or deleting an ArrivalTimePostProcessing resource. It includes a custom destroy action (with detail=False) as a BasicPostProcessing object can have only one ArrivalTimePostProcessing object. An ArrivalTimePostProcessing resource is created with an empty POST.  Three conditions are validated when creating an resource: - The simulation may not already have an ArrivalTimePostProcessing resource. - The simulation must have a BasicPostProcessing resource with 'process_basic_results'=True. - Lizard may not already have been triggered to processing this simulation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_arrival_delete_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_post_processing_lizard_arrival_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_post_processing_lizard_arrival_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/post_processing/lizard/arrival/delete/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_post_processing_lizard_arrival_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_arrival_list  # noqa: E501

        A Custom ViewSet for creating, listing or deleting an ArrivalTimePostProcessing resource. It includes a custom destroy action (with detail=False) as a BasicPostProcessing object can have only one ArrivalTimePostProcessing object. An ArrivalTimePostProcessing resource is created with an empty POST.  Three conditions are validated when creating an resource: - The simulation may not already have an ArrivalTimePostProcessing resource. - The simulation must have a BasicPostProcessing resource with 'process_basic_results'=True. - Lizard may not already have been triggered to processing this simulation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_arrival_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ArrivalTimePostProcessing
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_post_processing_lizard_arrival_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_results_post_processing_lizard_arrival_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_arrival_list  # noqa: E501

        A Custom ViewSet for creating, listing or deleting an ArrivalTimePostProcessing resource. It includes a custom destroy action (with detail=False) as a BasicPostProcessing object can have only one ArrivalTimePostProcessing object. An ArrivalTimePostProcessing resource is created with an empty POST.  Three conditions are validated when creating an resource: - The simulation may not already have an ArrivalTimePostProcessing resource. - The simulation must have a BasicPostProcessing resource with 'process_basic_results'=True. - Lizard may not already have been triggered to processing this simulation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_arrival_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ArrivalTimePostProcessing, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_post_processing_lizard_arrival_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_post_processing_lizard_arrival_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/post_processing/lizard/arrival/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ArrivalTimePostProcessing',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_post_processing_lizard_basic_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_basic_create  # noqa: E501

        A Custom ViewSet for creating, listing or deleting a BasicPostProcessing resource. It includes a custom destroy action (with detail=False) as a BasicPostProcessing object can have only one DamagePostProcessing object.  Three conditions are validated when creating an resource: - The simulation may not already have a BasicPostProcessing resource. - Lizard may not already have been triggered to processing this simulation. - The Simulation must hold a 'dem_raw_file' in case parameter 'process_basic_results' is True.  The ``scenario_name`` parameter is optional (max 50 chars). If not provided it becomes an empty string.  THe ``result_uuid`` can be defined for e.g. operational models. Defaults to an uuid4 if not provided.  If ``process_basic_results`` (boolean) is False then: - It is not possible to have ArrivalTimePostProcessing and DamagePostProcessing. - Only raw_results (.nc, .log, etc) are uploaded to Lizard.  If ``process_basic_results`` (boolean) is True then: - It is possible to have ArrivalTimePostProcessing and DamagePostProcessing. - raw_results are uploaded to Lizard and additional WMS layers are available on Lizard.  Payload example ``` {     \"scenario_name\": \"my_scenario_name\",     \"process_basic_results\": True, } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_basic_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param BasicPostProcessing data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BasicPostProcessing
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_post_processing_lizard_basic_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_results_post_processing_lizard_basic_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_basic_create  # noqa: E501

        A Custom ViewSet for creating, listing or deleting a BasicPostProcessing resource. It includes a custom destroy action (with detail=False) as a BasicPostProcessing object can have only one DamagePostProcessing object.  Three conditions are validated when creating an resource: - The simulation may not already have a BasicPostProcessing resource. - Lizard may not already have been triggered to processing this simulation. - The Simulation must hold a 'dem_raw_file' in case parameter 'process_basic_results' is True.  The ``scenario_name`` parameter is optional (max 50 chars). If not provided it becomes an empty string.  THe ``result_uuid`` can be defined for e.g. operational models. Defaults to an uuid4 if not provided.  If ``process_basic_results`` (boolean) is False then: - It is not possible to have ArrivalTimePostProcessing and DamagePostProcessing. - Only raw_results (.nc, .log, etc) are uploaded to Lizard.  If ``process_basic_results`` (boolean) is True then: - It is possible to have ArrivalTimePostProcessing and DamagePostProcessing. - raw_results are uploaded to Lizard and additional WMS layers are available on Lizard.  Payload example ``` {     \"scenario_name\": \"my_scenario_name\",     \"process_basic_results\": True, } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_basic_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param BasicPostProcessing data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BasicPostProcessing, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_post_processing_lizard_basic_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_post_processing_lizard_basic_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_results_post_processing_lizard_basic_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/post_processing/lizard/basic/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BasicPostProcessing',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_post_processing_lizard_basic_delete(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_basic_delete  # noqa: E501

        A Custom ViewSet for creating, listing or deleting a BasicPostProcessing resource. It includes a custom destroy action (with detail=False) as a BasicPostProcessing object can have only one DamagePostProcessing object.  Three conditions are validated when creating an resource: - The simulation may not already have a BasicPostProcessing resource. - Lizard may not already have been triggered to processing this simulation. - The Simulation must hold a 'dem_raw_file' in case parameter 'process_basic_results' is True.  The ``scenario_name`` parameter is optional (max 50 chars). If not provided it becomes an empty string.  THe ``result_uuid`` can be defined for e.g. operational models. Defaults to an uuid4 if not provided.  If ``process_basic_results`` (boolean) is False then: - It is not possible to have ArrivalTimePostProcessing and DamagePostProcessing. - Only raw_results (.nc, .log, etc) are uploaded to Lizard.  If ``process_basic_results`` (boolean) is True then: - It is possible to have ArrivalTimePostProcessing and DamagePostProcessing. - raw_results are uploaded to Lizard and additional WMS layers are available on Lizard.  Payload example ``` {     \"scenario_name\": \"my_scenario_name\",     \"process_basic_results\": True, } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_basic_delete(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_post_processing_lizard_basic_delete_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_results_post_processing_lizard_basic_delete_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_basic_delete  # noqa: E501

        A Custom ViewSet for creating, listing or deleting a BasicPostProcessing resource. It includes a custom destroy action (with detail=False) as a BasicPostProcessing object can have only one DamagePostProcessing object.  Three conditions are validated when creating an resource: - The simulation may not already have a BasicPostProcessing resource. - Lizard may not already have been triggered to processing this simulation. - The Simulation must hold a 'dem_raw_file' in case parameter 'process_basic_results' is True.  The ``scenario_name`` parameter is optional (max 50 chars). If not provided it becomes an empty string.  THe ``result_uuid`` can be defined for e.g. operational models. Defaults to an uuid4 if not provided.  If ``process_basic_results`` (boolean) is False then: - It is not possible to have ArrivalTimePostProcessing and DamagePostProcessing. - Only raw_results (.nc, .log, etc) are uploaded to Lizard.  If ``process_basic_results`` (boolean) is True then: - It is possible to have ArrivalTimePostProcessing and DamagePostProcessing. - raw_results are uploaded to Lizard and additional WMS layers are available on Lizard.  Payload example ``` {     \"scenario_name\": \"my_scenario_name\",     \"process_basic_results\": True, } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_basic_delete_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_post_processing_lizard_basic_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_post_processing_lizard_basic_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/post_processing/lizard/basic/delete/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_post_processing_lizard_basic_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_basic_list  # noqa: E501

        A Custom ViewSet for creating, listing or deleting a BasicPostProcessing resource. It includes a custom destroy action (with detail=False) as a BasicPostProcessing object can have only one DamagePostProcessing object.  Three conditions are validated when creating an resource: - The simulation may not already have a BasicPostProcessing resource. - Lizard may not already have been triggered to processing this simulation. - The Simulation must hold a 'dem_raw_file' in case parameter 'process_basic_results' is True.  The ``scenario_name`` parameter is optional (max 50 chars). If not provided it becomes an empty string.  THe ``result_uuid`` can be defined for e.g. operational models. Defaults to an uuid4 if not provided.  If ``process_basic_results`` (boolean) is False then: - It is not possible to have ArrivalTimePostProcessing and DamagePostProcessing. - Only raw_results (.nc, .log, etc) are uploaded to Lizard.  If ``process_basic_results`` (boolean) is True then: - It is possible to have ArrivalTimePostProcessing and DamagePostProcessing. - raw_results are uploaded to Lizard and additional WMS layers are available on Lizard.  Payload example ``` {     \"scenario_name\": \"my_scenario_name\",     \"process_basic_results\": True, } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_basic_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BasicPostProcessing
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_post_processing_lizard_basic_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_results_post_processing_lizard_basic_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_basic_list  # noqa: E501

        A Custom ViewSet for creating, listing or deleting a BasicPostProcessing resource. It includes a custom destroy action (with detail=False) as a BasicPostProcessing object can have only one DamagePostProcessing object.  Three conditions are validated when creating an resource: - The simulation may not already have a BasicPostProcessing resource. - Lizard may not already have been triggered to processing this simulation. - The Simulation must hold a 'dem_raw_file' in case parameter 'process_basic_results' is True.  The ``scenario_name`` parameter is optional (max 50 chars). If not provided it becomes an empty string.  THe ``result_uuid`` can be defined for e.g. operational models. Defaults to an uuid4 if not provided.  If ``process_basic_results`` (boolean) is False then: - It is not possible to have ArrivalTimePostProcessing and DamagePostProcessing. - Only raw_results (.nc, .log, etc) are uploaded to Lizard.  If ``process_basic_results`` (boolean) is True then: - It is possible to have ArrivalTimePostProcessing and DamagePostProcessing. - raw_results are uploaded to Lizard and additional WMS layers are available on Lizard.  Payload example ``` {     \"scenario_name\": \"my_scenario_name\",     \"process_basic_results\": True, } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_basic_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BasicPostProcessing, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_post_processing_lizard_basic_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_post_processing_lizard_basic_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/post_processing/lizard/basic/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BasicPostProcessing',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_post_processing_lizard_damage_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_damage_create  # noqa: E501

        A Custom ViewSet for creating, listing or deleting a DamagePostProcessing resource. It includes a custom destroy action (with detail=False) as a BasicPostProcessing object can have only one DamagePostProcessing object.  Three conditions are validated when creating an resource: - The simulation may not already have a DamagePostProcessing resource. - The simulation must have a BasicPostProcessing resource with 'process_basic_results'=True. - Lizard may not already have been triggered to processing this simulation.  The ``cost_type`` parameter choices are: 'min', 'avg', 'max'.  The ``flood_month`` parameter choices are: 'jan', 'feb', etc  The ``inundation_period`` parameter is ime in hours (float), min_value=1.0  The ``repair_time_infrastructure`` parameter is time in hours (integer), min_value=1, max_value=240  The ``repair_time_buildings`` parameter is time in hours (integer), min_value=1, max_value=240  Payload example ``` {     \"cost_type\": \"min\",     \"flood_month\": \"jan\",     \"inundation_period\": 12.0,     \"repair_time_infrastructure\": 120,     \"repair_time_buildings\": 240 } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_damage_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param DamagePostProcessing data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DamagePostProcessing
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_post_processing_lizard_damage_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_results_post_processing_lizard_damage_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_damage_create  # noqa: E501

        A Custom ViewSet for creating, listing or deleting a DamagePostProcessing resource. It includes a custom destroy action (with detail=False) as a BasicPostProcessing object can have only one DamagePostProcessing object.  Three conditions are validated when creating an resource: - The simulation may not already have a DamagePostProcessing resource. - The simulation must have a BasicPostProcessing resource with 'process_basic_results'=True. - Lizard may not already have been triggered to processing this simulation.  The ``cost_type`` parameter choices are: 'min', 'avg', 'max'.  The ``flood_month`` parameter choices are: 'jan', 'feb', etc  The ``inundation_period`` parameter is ime in hours (float), min_value=1.0  The ``repair_time_infrastructure`` parameter is time in hours (integer), min_value=1, max_value=240  The ``repair_time_buildings`` parameter is time in hours (integer), min_value=1, max_value=240  Payload example ``` {     \"cost_type\": \"min\",     \"flood_month\": \"jan\",     \"inundation_period\": 12.0,     \"repair_time_infrastructure\": 120,     \"repair_time_buildings\": 240 } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_damage_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param DamagePostProcessing data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DamagePostProcessing, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_post_processing_lizard_damage_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_post_processing_lizard_damage_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_results_post_processing_lizard_damage_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/post_processing/lizard/damage/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DamagePostProcessing',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_post_processing_lizard_damage_delete(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_damage_delete  # noqa: E501

        A Custom ViewSet for creating, listing or deleting a DamagePostProcessing resource. It includes a custom destroy action (with detail=False) as a BasicPostProcessing object can have only one DamagePostProcessing object.  Three conditions are validated when creating an resource: - The simulation may not already have a DamagePostProcessing resource. - The simulation must have a BasicPostProcessing resource with 'process_basic_results'=True. - Lizard may not already have been triggered to processing this simulation.  The ``cost_type`` parameter choices are: 'min', 'avg', 'max'.  The ``flood_month`` parameter choices are: 'jan', 'feb', etc  The ``inundation_period`` parameter is ime in hours (float), min_value=1.0  The ``repair_time_infrastructure`` parameter is time in hours (integer), min_value=1, max_value=240  The ``repair_time_buildings`` parameter is time in hours (integer), min_value=1, max_value=240  Payload example ``` {     \"cost_type\": \"min\",     \"flood_month\": \"jan\",     \"inundation_period\": 12.0,     \"repair_time_infrastructure\": 120,     \"repair_time_buildings\": 240 } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_damage_delete(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_post_processing_lizard_damage_delete_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_results_post_processing_lizard_damage_delete_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_damage_delete  # noqa: E501

        A Custom ViewSet for creating, listing or deleting a DamagePostProcessing resource. It includes a custom destroy action (with detail=False) as a BasicPostProcessing object can have only one DamagePostProcessing object.  Three conditions are validated when creating an resource: - The simulation may not already have a DamagePostProcessing resource. - The simulation must have a BasicPostProcessing resource with 'process_basic_results'=True. - Lizard may not already have been triggered to processing this simulation.  The ``cost_type`` parameter choices are: 'min', 'avg', 'max'.  The ``flood_month`` parameter choices are: 'jan', 'feb', etc  The ``inundation_period`` parameter is ime in hours (float), min_value=1.0  The ``repair_time_infrastructure`` parameter is time in hours (integer), min_value=1, max_value=240  The ``repair_time_buildings`` parameter is time in hours (integer), min_value=1, max_value=240  Payload example ``` {     \"cost_type\": \"min\",     \"flood_month\": \"jan\",     \"inundation_period\": 12.0,     \"repair_time_infrastructure\": 120,     \"repair_time_buildings\": 240 } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_damage_delete_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_post_processing_lizard_damage_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_post_processing_lizard_damage_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/post_processing/lizard/damage/delete/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_post_processing_lizard_damage_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_damage_list  # noqa: E501

        A Custom ViewSet for creating, listing or deleting a DamagePostProcessing resource. It includes a custom destroy action (with detail=False) as a BasicPostProcessing object can have only one DamagePostProcessing object.  Three conditions are validated when creating an resource: - The simulation may not already have a DamagePostProcessing resource. - The simulation must have a BasicPostProcessing resource with 'process_basic_results'=True. - Lizard may not already have been triggered to processing this simulation.  The ``cost_type`` parameter choices are: 'min', 'avg', 'max'.  The ``flood_month`` parameter choices are: 'jan', 'feb', etc  The ``inundation_period`` parameter is ime in hours (float), min_value=1.0  The ``repair_time_infrastructure`` parameter is time in hours (integer), min_value=1, max_value=240  The ``repair_time_buildings`` parameter is time in hours (integer), min_value=1, max_value=240  Payload example ``` {     \"cost_type\": \"min\",     \"flood_month\": \"jan\",     \"inundation_period\": 12.0,     \"repair_time_infrastructure\": 120,     \"repair_time_buildings\": 240 } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_damage_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DamagePostProcessing
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_post_processing_lizard_damage_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_results_post_processing_lizard_damage_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_damage_list  # noqa: E501

        A Custom ViewSet for creating, listing or deleting a DamagePostProcessing resource. It includes a custom destroy action (with detail=False) as a BasicPostProcessing object can have only one DamagePostProcessing object.  Three conditions are validated when creating an resource: - The simulation may not already have a DamagePostProcessing resource. - The simulation must have a BasicPostProcessing resource with 'process_basic_results'=True. - Lizard may not already have been triggered to processing this simulation.  The ``cost_type`` parameter choices are: 'min', 'avg', 'max'.  The ``flood_month`` parameter choices are: 'jan', 'feb', etc  The ``inundation_period`` parameter is ime in hours (float), min_value=1.0  The ``repair_time_infrastructure`` parameter is time in hours (integer), min_value=1, max_value=240  The ``repair_time_buildings`` parameter is time in hours (integer), min_value=1, max_value=240  Payload example ``` {     \"cost_type\": \"min\",     \"flood_month\": \"jan\",     \"inundation_period\": 12.0,     \"repair_time_infrastructure\": 120,     \"repair_time_buildings\": 240 } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_damage_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DamagePostProcessing, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_post_processing_lizard_damage_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_post_processing_lizard_damage_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/post_processing/lizard/damage/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DamagePostProcessing',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_post_processing_lizard_overview_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_overview_list  # noqa: E501

        Custom list that provides overview of post-processing configuration. Below a format specification is provided. All keys always exists, regardless post-processing config:  ``` {   \"username\": str,   \"external_user_id\": Optional[str],   \"metadata_version\": float,   \"start_time_sim\": datetime (UTC),   \"end_time_sim\": datetime (UTC),   \"results\": {     \"basic\": bool,     \"damage_estimation\": bool,     \"arrival_time\": bool   },   \"settings\": {     \"damage_estimation\": {         \"damage_table\": str,         \"elevation_raster_uuid\": str,         \"landcover_raster_uuid\": str,         \"road_rail_raster_uuid\": str,         \"cost_type\": int,         \"flood_month\": int,         \"inundation_period\": int,         \"repair_time_infrastructure\": int,         \"repair_time_buildings\": int         },   },   \"model_name\": str, (=threedimodel_slug)   \"simulation_name\": str, (=simulation_slug)   \"scenario_name\": str,   \"model_id\": int,   \"model_revision_id\": str,   \"email\": str,   \"result_uuid\": str,   \"organisation_uuid\": str,   \"simulation\": int } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_overview_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PostProcessingOverview
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_post_processing_lizard_overview_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_results_post_processing_lizard_overview_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_overview_list  # noqa: E501

        Custom list that provides overview of post-processing configuration. Below a format specification is provided. All keys always exists, regardless post-processing config:  ``` {   \"username\": str,   \"external_user_id\": Optional[str],   \"metadata_version\": float,   \"start_time_sim\": datetime (UTC),   \"end_time_sim\": datetime (UTC),   \"results\": {     \"basic\": bool,     \"damage_estimation\": bool,     \"arrival_time\": bool   },   \"settings\": {     \"damage_estimation\": {         \"damage_table\": str,         \"elevation_raster_uuid\": str,         \"landcover_raster_uuid\": str,         \"road_rail_raster_uuid\": str,         \"cost_type\": int,         \"flood_month\": int,         \"inundation_period\": int,         \"repair_time_infrastructure\": int,         \"repair_time_buildings\": int         },   },   \"model_name\": str, (=threedimodel_slug)   \"simulation_name\": str, (=simulation_slug)   \"scenario_name\": str,   \"model_id\": int,   \"model_revision_id\": str,   \"email\": str,   \"result_uuid\": str,   \"organisation_uuid\": str,   \"simulation\": int } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_overview_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PostProcessingOverview, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_post_processing_lizard_overview_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_post_processing_lizard_overview_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/post_processing/lizard/overview/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PostProcessingOverview',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_post_processing_lizard_start_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_start_create  # noqa: E501

        Empty post to start Lizard post-processing for one Simulation result.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_start_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param object data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_post_processing_lizard_start_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_results_post_processing_lizard_start_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_start_create  # noqa: E501

        Empty post to start Lizard post-processing for one Simulation result.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_start_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param object data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_post_processing_lizard_start_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_post_processing_lizard_start_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_results_post_processing_lizard_start_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/post_processing/lizard/start/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_post_processing_lizard_start_retry(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Retry the Lizard post-processing  # noqa: E501

        Will only re-trigger the post-processing if the post-processing status is in `archiving_failed`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_start_retry(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param object data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_post_processing_lizard_start_retry_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_results_post_processing_lizard_start_retry_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Retry the Lizard post-processing  # noqa: E501

        Will only re-trigger the post-processing if the post-processing status is in `archiving_failed`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_start_retry_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param object data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_post_processing_lizard_start_retry" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_post_processing_lizard_start_retry`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_results_post_processing_lizard_start_retry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/post_processing/lizard/start/retry/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_post_processing_lizard_status_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_status_create  # noqa: E501

        Endpoint to keep track of post-processing status (done by Lizard) per Simulation result. Status is updated internal by 3Di, and once processing starts it is updated by Lizard backend.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_status_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param PostProcessingStatus data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PostProcessingStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_post_processing_lizard_status_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_results_post_processing_lizard_status_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_status_create  # noqa: E501

        Endpoint to keep track of post-processing status (done by Lizard) per Simulation result. Status is updated internal by 3Di, and once processing starts it is updated by Lizard backend.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_status_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param PostProcessingStatus data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PostProcessingStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_post_processing_lizard_status_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_post_processing_lizard_status_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_results_post_processing_lizard_status_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/post_processing/lizard/status/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PostProcessingStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_post_processing_lizard_status_delete(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_status_delete  # noqa: E501

        Endpoint to keep track of post-processing status (done by Lizard) per Simulation result. Status is updated internal by 3Di, and once processing starts it is updated by Lizard backend.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_status_delete(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_post_processing_lizard_status_delete_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_results_post_processing_lizard_status_delete_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_status_delete  # noqa: E501

        Endpoint to keep track of post-processing status (done by Lizard) per Simulation result. Status is updated internal by 3Di, and once processing starts it is updated by Lizard backend.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_status_delete_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_post_processing_lizard_status_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_post_processing_lizard_status_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/post_processing/lizard/status/delete/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_post_processing_lizard_status_history_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_status_history_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_status_history_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20067
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_post_processing_lizard_status_history_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_results_post_processing_lizard_status_history_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_status_history_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_status_history_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20067, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_post_processing_lizard_status_history_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_post_processing_lizard_status_history_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/post_processing/lizard/status/history/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20067',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_results_post_processing_lizard_status_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_status_list  # noqa: E501

        Show the latest post-processing status of one simulation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_status_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PostProcessingStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_results_post_processing_lizard_status_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_results_post_processing_lizard_status_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_results_post_processing_lizard_status_list  # noqa: E501

        Show the latest post-processing status of one simulation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_results_post_processing_lizard_status_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PostProcessingStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_results_post_processing_lizard_status_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_results_post_processing_lizard_status_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/results/post_processing/lizard/status/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PostProcessingStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_aggregation_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Simulation aggregation settings.  # noqa: E501

        For a consistent water balance often the results of various snap shots - as provided by the results_3di.nc file - are not enough. Especially in case of an time step setting that is larger than the computational time step. For this purpose, an aggregated results file is available called aggregate_results_3di.nc. The structure of the file is very similar to the other result file. Each Mesh variable (s1, u1, etc.) described in the results section can be aggregated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_aggregation_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param AggregationSettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AggregationSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_aggregation_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_aggregation_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Simulation aggregation settings.  # noqa: E501

        For a consistent water balance often the results of various snap shots - as provided by the results_3di.nc file - are not enough. Especially in case of an time step setting that is larger than the computational time step. For this purpose, an aggregated results file is available called aggregate_results_3di.nc. The structure of the file is very similar to the other result file. Each Mesh variable (s1, u1, etc.) described in the results section can be aggregated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_aggregation_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param AggregationSettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AggregationSettings, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_aggregation_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_aggregation_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_aggregation_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/aggregation/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AggregationSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_aggregation_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """Simulation aggregation settings.  # noqa: E501

        For a consistent water balance often the results of various snap shots - as provided by the results_3di.nc file - are not enough. Especially in case of an time step setting that is larger than the computational time step. For this purpose, an aggregated results file is available called aggregate_results_3di.nc. The structure of the file is very similar to the other result file. Each Mesh variable (s1, u1, etc.) described in the results section can be aggregated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_aggregation_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this aggregation settings. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_aggregation_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_settings_aggregation_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """Simulation aggregation settings.  # noqa: E501

        For a consistent water balance often the results of various snap shots - as provided by the results_3di.nc file - are not enough. Especially in case of an time step setting that is larger than the computational time step. For this purpose, an aggregated results file is available called aggregate_results_3di.nc. The structure of the file is very similar to the other result file. Each Mesh variable (s1, u1, etc.) described in the results section can be aggregated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_aggregation_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this aggregation settings. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_aggregation_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_settings_aggregation_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_aggregation_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/aggregation/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_aggregation_list(self, simulation_pk, **kwargs):  # noqa: E501
        """Simulation aggregation settings.  # noqa: E501

        For a consistent water balance often the results of various snap shots - as provided by the results_3di.nc file - are not enough. Especially in case of an time step setting that is larger than the computational time step. For this purpose, an aggregated results file is available called aggregate_results_3di.nc. The structure of the file is very similar to the other result file. Each Mesh variable (s1, u1, etc.) described in the results section can be aggregated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_aggregation_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20068
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_aggregation_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_settings_aggregation_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """Simulation aggregation settings.  # noqa: E501

        For a consistent water balance often the results of various snap shots - as provided by the results_3di.nc file - are not enough. Especially in case of an time step setting that is larger than the computational time step. For this purpose, an aggregated results file is available called aggregate_results_3di.nc. The structure of the file is very similar to the other result file. Each Mesh variable (s1, u1, etc.) described in the results section can be aggregated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_aggregation_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20068, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_aggregation_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_aggregation_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/aggregation/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20068',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_aggregation_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """Simulation aggregation settings.  # noqa: E501

        For a consistent water balance often the results of various snap shots - as provided by the results_3di.nc file - are not enough. Especially in case of an time step setting that is larger than the computational time step. For this purpose, an aggregated results file is available called aggregate_results_3di.nc. The structure of the file is very similar to the other result file. Each Mesh variable (s1, u1, etc.) described in the results section can be aggregated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_aggregation_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this aggregation settings. (required)
        :param str simulation_pk: (required)
        :param AggregationSettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AggregationSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_aggregation_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_aggregation_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """Simulation aggregation settings.  # noqa: E501

        For a consistent water balance often the results of various snap shots - as provided by the results_3di.nc file - are not enough. Especially in case of an time step setting that is larger than the computational time step. For this purpose, an aggregated results file is available called aggregate_results_3di.nc. The structure of the file is very similar to the other result file. Each Mesh variable (s1, u1, etc.) described in the results section can be aggregated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_aggregation_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this aggregation settings. (required)
        :param str simulation_pk: (required)
        :param AggregationSettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AggregationSettings, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_aggregation_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_settings_aggregation_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_aggregation_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_aggregation_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/aggregation/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AggregationSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_aggregation_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """Simulation aggregation settings.  # noqa: E501

        For a consistent water balance often the results of various snap shots - as provided by the results_3di.nc file - are not enough. Especially in case of an time step setting that is larger than the computational time step. For this purpose, an aggregated results file is available called aggregate_results_3di.nc. The structure of the file is very similar to the other result file. Each Mesh variable (s1, u1, etc.) described in the results section can be aggregated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_aggregation_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this aggregation settings. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AggregationSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_aggregation_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_settings_aggregation_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """Simulation aggregation settings.  # noqa: E501

        For a consistent water balance often the results of various snap shots - as provided by the results_3di.nc file - are not enough. Especially in case of an time step setting that is larger than the computational time step. For this purpose, an aggregated results file is available called aggregate_results_3di.nc. The structure of the file is very similar to the other result file. Each Mesh variable (s1, u1, etc.) described in the results section can be aggregated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_aggregation_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this aggregation settings. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AggregationSettings, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_aggregation_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_settings_aggregation_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_aggregation_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/aggregation/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AggregationSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_aggregation_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """Simulation aggregation settings.  # noqa: E501

        For a consistent water balance often the results of various snap shots - as provided by the results_3di.nc file - are not enough. Especially in case of an time step setting that is larger than the computational time step. For this purpose, an aggregated results file is available called aggregate_results_3di.nc. The structure of the file is very similar to the other result file. Each Mesh variable (s1, u1, etc.) described in the results section can be aggregated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_aggregation_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this aggregation settings. (required)
        :param str simulation_pk: (required)
        :param AggregationSettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AggregationSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_aggregation_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_aggregation_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """Simulation aggregation settings.  # noqa: E501

        For a consistent water balance often the results of various snap shots - as provided by the results_3di.nc file - are not enough. Especially in case of an time step setting that is larger than the computational time step. For this purpose, an aggregated results file is available called aggregate_results_3di.nc. The structure of the file is very similar to the other result file. Each Mesh variable (s1, u1, etc.) described in the results section can be aggregated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_aggregation_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this aggregation settings. (required)
        :param str simulation_pk: (required)
        :param AggregationSettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AggregationSettings, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_aggregation_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_settings_aggregation_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_aggregation_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_aggregation_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/aggregation/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AggregationSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_customized_result_areas_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_customized_result_areas_create  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_customized_result_areas_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param CustomizedResultArea data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CustomizedResultArea
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_customized_result_areas_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_customized_result_areas_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_customized_result_areas_create  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_customized_result_areas_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param CustomizedResultArea data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CustomizedResultArea, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_customized_result_areas_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_customized_result_areas_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_customized_result_areas_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/customized_result_areas/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CustomizedResultArea',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_customized_result_areas_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_customized_result_areas_delete  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_customized_result_areas_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this customized result area. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_customized_result_areas_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_settings_customized_result_areas_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_customized_result_areas_delete  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_customized_result_areas_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this customized result area. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_customized_result_areas_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_settings_customized_result_areas_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_customized_result_areas_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/customized_result_areas/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_customized_result_areas_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_customized_result_areas_list  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_customized_result_areas_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20069
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_customized_result_areas_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_settings_customized_result_areas_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_customized_result_areas_list  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_customized_result_areas_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20069, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_customized_result_areas_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_customized_result_areas_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/customized_result_areas/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20069',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_customized_result_areas_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_customized_result_areas_partial_update  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_customized_result_areas_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this customized result area. (required)
        :param str simulation_pk: (required)
        :param CustomizedResultArea data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CustomizedResultArea
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_customized_result_areas_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_customized_result_areas_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_customized_result_areas_partial_update  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_customized_result_areas_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this customized result area. (required)
        :param str simulation_pk: (required)
        :param CustomizedResultArea data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CustomizedResultArea, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_customized_result_areas_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_settings_customized_result_areas_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_customized_result_areas_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_customized_result_areas_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/customized_result_areas/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CustomizedResultArea',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_customized_result_areas_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_customized_result_areas_read  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_customized_result_areas_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this customized result area. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CustomizedResultArea
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_customized_result_areas_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_settings_customized_result_areas_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_customized_result_areas_read  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_customized_result_areas_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this customized result area. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CustomizedResultArea, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_customized_result_areas_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_settings_customized_result_areas_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_customized_result_areas_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/customized_result_areas/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CustomizedResultArea',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_customized_result_areas_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_customized_result_areas_update  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_customized_result_areas_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this customized result area. (required)
        :param str simulation_pk: (required)
        :param CustomizedResultArea data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CustomizedResultArea
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_customized_result_areas_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_customized_result_areas_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_customized_result_areas_update  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_customized_result_areas_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this customized result area. (required)
        :param str simulation_pk: (required)
        :param CustomizedResultArea data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CustomizedResultArea, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_customized_result_areas_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_settings_customized_result_areas_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_customized_result_areas_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_customized_result_areas_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/customized_result_areas/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CustomizedResultArea',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_numerical_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_numerical_create  # noqa: E501

        create a numerical settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_numerical_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param NumericalSettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_numerical_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_numerical_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_numerical_create  # noqa: E501

        create a numerical settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_numerical_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param NumericalSettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_numerical_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_numerical_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_numerical_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/numerical/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_numerical_delete(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_numerical_delete  # noqa: E501

        delete the numerical settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_numerical_delete(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_numerical_delete_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_settings_numerical_delete_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_numerical_delete  # noqa: E501

        delete the numerical settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_numerical_delete_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_numerical_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_numerical_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/numerical/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_numerical_partial_update(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_numerical_partial_update  # noqa: E501

        update the numerical settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_numerical_partial_update(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param NumericalSettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_numerical_partial_update_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_numerical_partial_update_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_numerical_partial_update  # noqa: E501

        update the numerical settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_numerical_partial_update_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param NumericalSettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_numerical_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_numerical_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_numerical_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/numerical/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_numerical_update(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_numerical_update  # noqa: E501

        update the numerical settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_numerical_update(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param NumericalSettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_numerical_update_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_numerical_update_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_numerical_update  # noqa: E501

        update the numerical settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_numerical_update_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param NumericalSettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_numerical_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_numerical_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_numerical_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/numerical/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_output_settings_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_output_settings_create  # noqa: E501

        create a output settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_output_settings_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param OutputSettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_output_settings_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_output_settings_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_output_settings_create  # noqa: E501

        create a output settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_output_settings_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param OutputSettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_output_settings_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_output_settings_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_output_settings_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/output_settings/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_output_settings_delete(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_output_settings_delete  # noqa: E501

        delete the output settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_output_settings_delete(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_output_settings_delete_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_settings_output_settings_delete_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_output_settings_delete  # noqa: E501

        delete the output settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_output_settings_delete_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_output_settings_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_output_settings_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/output_settings/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_output_settings_partial_update(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_output_settings_partial_update  # noqa: E501

        update the output settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_output_settings_partial_update(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param OutputSettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_output_settings_partial_update_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_output_settings_partial_update_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_output_settings_partial_update  # noqa: E501

        update the output settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_output_settings_partial_update_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param OutputSettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_output_settings_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_output_settings_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_output_settings_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/output_settings/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_output_settings_update(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_output_settings_update  # noqa: E501

        update the output settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_output_settings_update(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param OutputSettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_output_settings_update_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_output_settings_update_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_output_settings_update  # noqa: E501

        update the output settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_output_settings_update_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param OutputSettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_output_settings_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_output_settings_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_output_settings_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/output_settings/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_overview(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_overview  # noqa: E501

        Overview of the the simulation settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_overview(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SimulationSettingsOverview
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_overview_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_settings_overview_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_overview  # noqa: E501

        Overview of the the simulation settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_overview_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SimulationSettingsOverview, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_overview" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_overview`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/overview/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SimulationSettingsOverview',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_physical_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_physical_create  # noqa: E501

        Create a general settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_physical_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param PhysicalSettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_physical_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_physical_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_physical_create  # noqa: E501

        Create a general settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_physical_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param PhysicalSettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_physical_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_physical_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_physical_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/physical/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_physical_delete(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_physical_delete  # noqa: E501

        Delete the general settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_physical_delete(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_physical_delete_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_settings_physical_delete_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_physical_delete  # noqa: E501

        Delete the general settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_physical_delete_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_physical_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_physical_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/physical/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_physical_partial_update(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_physical_partial_update  # noqa: E501

        Update the general settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_physical_partial_update(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param PhysicalSettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_physical_partial_update_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_physical_partial_update_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_physical_partial_update  # noqa: E501

        Update the general settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_physical_partial_update_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param PhysicalSettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_physical_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_physical_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_physical_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/physical/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_physical_update(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_physical_update  # noqa: E501

        Update the general settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_physical_update(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param PhysicalSettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_physical_update_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_physical_update_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_physical_update  # noqa: E501

        Update the general settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_physical_update_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param PhysicalSettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_physical_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_physical_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_physical_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/physical/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_time_step_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_time_step_create  # noqa: E501

        create a time step settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_time_step_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimeStepSettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_time_step_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_time_step_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_time_step_create  # noqa: E501

        create a time step settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_time_step_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimeStepSettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_time_step_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_time_step_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_time_step_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/time_step/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_time_step_delete(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_time_step_delete  # noqa: E501

        delete the time step settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_time_step_delete(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_time_step_delete_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_settings_time_step_delete_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_time_step_delete  # noqa: E501

        delete the time step settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_time_step_delete_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_time_step_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_time_step_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/time_step/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_time_step_partial_update(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_time_step_partial_update  # noqa: E501

        update the time step settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_time_step_partial_update(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimeStepSettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_time_step_partial_update_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_time_step_partial_update_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_time_step_partial_update  # noqa: E501

        update the time step settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_time_step_partial_update_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimeStepSettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_time_step_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_time_step_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_time_step_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/time_step/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_time_step_update(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_time_step_update  # noqa: E501

        update the time step settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_time_step_update(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimeStepSettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_time_step_update_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_time_step_update_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_time_step_update  # noqa: E501

        update the time step settings resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_time_step_update_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param TimeStepSettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_time_step_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_time_step_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_time_step_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/time_step/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_water_quality_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_create  # noqa: E501

        Create a water quality settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterQualitySettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_water_quality_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_water_quality_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_create  # noqa: E501

        Create a water quality settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterQualitySettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_water_quality_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_water_quality_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_water_quality_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/water_quality/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_water_quality_customized_result_areas_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_customized_result_areas_create  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_customized_result_areas_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterQualityCustomizedResultArea data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WaterQualityCustomizedResultArea
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_water_quality_customized_result_areas_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_water_quality_customized_result_areas_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_customized_result_areas_create  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_customized_result_areas_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterQualityCustomizedResultArea data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WaterQualityCustomizedResultArea, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_water_quality_customized_result_areas_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_water_quality_customized_result_areas_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_water_quality_customized_result_areas_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/water_quality_customized_result_areas/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WaterQualityCustomizedResultArea',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_water_quality_customized_result_areas_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_customized_result_areas_delete  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_customized_result_areas_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this water quality customized result area. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_water_quality_customized_result_areas_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_settings_water_quality_customized_result_areas_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_customized_result_areas_delete  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_customized_result_areas_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this water quality customized result area. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_water_quality_customized_result_areas_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_settings_water_quality_customized_result_areas_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_water_quality_customized_result_areas_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/water_quality_customized_result_areas/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_water_quality_customized_result_areas_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_customized_result_areas_list  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_customized_result_areas_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20070
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_water_quality_customized_result_areas_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_settings_water_quality_customized_result_areas_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_customized_result_areas_list  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_customized_result_areas_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20070, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_water_quality_customized_result_areas_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_water_quality_customized_result_areas_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/water_quality_customized_result_areas/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20070',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_water_quality_customized_result_areas_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_customized_result_areas_partial_update  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_customized_result_areas_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this water quality customized result area. (required)
        :param str simulation_pk: (required)
        :param WaterQualityCustomizedResultArea data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WaterQualityCustomizedResultArea
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_water_quality_customized_result_areas_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_water_quality_customized_result_areas_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_customized_result_areas_partial_update  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_customized_result_areas_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this water quality customized result area. (required)
        :param str simulation_pk: (required)
        :param WaterQualityCustomizedResultArea data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WaterQualityCustomizedResultArea, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_water_quality_customized_result_areas_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_settings_water_quality_customized_result_areas_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_water_quality_customized_result_areas_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_water_quality_customized_result_areas_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/water_quality_customized_result_areas/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WaterQualityCustomizedResultArea',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_water_quality_customized_result_areas_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_customized_result_areas_read  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_customized_result_areas_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this water quality customized result area. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WaterQualityCustomizedResultArea
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_water_quality_customized_result_areas_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_settings_water_quality_customized_result_areas_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_customized_result_areas_read  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_customized_result_areas_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this water quality customized result area. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WaterQualityCustomizedResultArea, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_water_quality_customized_result_areas_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_settings_water_quality_customized_result_areas_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_water_quality_customized_result_areas_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/water_quality_customized_result_areas/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WaterQualityCustomizedResultArea',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_water_quality_customized_result_areas_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_customized_result_areas_update  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_customized_result_areas_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this water quality customized result area. (required)
        :param str simulation_pk: (required)
        :param WaterQualityCustomizedResultArea data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WaterQualityCustomizedResultArea
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_water_quality_customized_result_areas_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_water_quality_customized_result_areas_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_customized_result_areas_update  # noqa: E501

        Water quality customized result area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_customized_result_areas_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this water quality customized result area. (required)
        :param str simulation_pk: (required)
        :param WaterQualityCustomizedResultArea data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WaterQualityCustomizedResultArea, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_water_quality_customized_result_areas_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_settings_water_quality_customized_result_areas_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_water_quality_customized_result_areas_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_water_quality_customized_result_areas_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/water_quality_customized_result_areas/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WaterQualityCustomizedResultArea',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_water_quality_delete(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_delete  # noqa: E501

        Delete the water quality settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_delete(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_water_quality_delete_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_settings_water_quality_delete_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_delete  # noqa: E501

        Delete the water quality settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_delete_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_water_quality_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_water_quality_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/water_quality/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_water_quality_output_settings_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_output_settings_create  # noqa: E501

        Create a water quality output settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_output_settings_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterQualityOutputSettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_water_quality_output_settings_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_water_quality_output_settings_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_output_settings_create  # noqa: E501

        Create a water quality output settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_output_settings_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterQualityOutputSettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_water_quality_output_settings_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_water_quality_output_settings_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_water_quality_output_settings_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/water_quality_output_settings/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_water_quality_output_settings_delete(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_output_settings_delete  # noqa: E501

        Delete the water quality output settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_output_settings_delete(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_water_quality_output_settings_delete_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_settings_water_quality_output_settings_delete_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_output_settings_delete  # noqa: E501

        Delete the water quality output settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_output_settings_delete_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_water_quality_output_settings_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_water_quality_output_settings_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/water_quality_output_settings/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_water_quality_output_settings_partial_update(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_output_settings_partial_update  # noqa: E501

        Update the water quality output settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_output_settings_partial_update(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterQualityOutputSettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_water_quality_output_settings_partial_update_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_water_quality_output_settings_partial_update_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_output_settings_partial_update  # noqa: E501

        Update the water quality output settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_output_settings_partial_update_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterQualityOutputSettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_water_quality_output_settings_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_water_quality_output_settings_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_water_quality_output_settings_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/water_quality_output_settings/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_water_quality_output_settings_update(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_output_settings_update  # noqa: E501

        Update the water quality output settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_output_settings_update(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterQualityOutputSettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_water_quality_output_settings_update_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_water_quality_output_settings_update_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_output_settings_update  # noqa: E501

        Update the water quality output settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_output_settings_update_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterQualityOutputSettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_water_quality_output_settings_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_water_quality_output_settings_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_water_quality_output_settings_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/water_quality_output_settings/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_water_quality_partial_update(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_partial_update  # noqa: E501

        Update the water quality settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_partial_update(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterQualitySettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_water_quality_partial_update_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_water_quality_partial_update_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_partial_update  # noqa: E501

        Update the water quality settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_partial_update_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterQualitySettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_water_quality_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_water_quality_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_water_quality_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/water_quality/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_settings_water_quality_update(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_update  # noqa: E501

        Update the water quality settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_update(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterQualitySettings data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_settings_water_quality_update_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_settings_water_quality_update_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_settings_water_quality_update  # noqa: E501

        Update the water quality settings resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_settings_water_quality_update_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterQualitySettings data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_settings_water_quality_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_settings_water_quality_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_settings_water_quality_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/settings/water_quality/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_status_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_status_create  # noqa: E501

        A simple ViewSet for viewing simulations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_status_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param SimulationStatus data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SimulationStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_status_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_status_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_status_create  # noqa: E501

        A simple ViewSet for viewing simulations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_status_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param SimulationStatus data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SimulationStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_status_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_status_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_status_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/status/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SimulationStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_status_delete(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_status_delete  # noqa: E501

        A simple ViewSet for viewing simulations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_status_delete(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation status. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_status_delete_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_status_delete_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_status_delete  # noqa: E501

        A simple ViewSet for viewing simulations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_status_delete_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation status. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_status_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_status_delete`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_status_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/status/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_status_history_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_status_history_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_status_history_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20071
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_status_history_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_status_history_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_status_history_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_status_history_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20071, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_status_history_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_status_history_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/status/history/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20071',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_status_history_read(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_status_history_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_status_history_read(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation status. (required)
        :param str simulation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SimulationStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_status_history_read_with_http_info(id, simulation_pk, **kwargs)  # noqa: E501

    def simulations_status_history_read_with_http_info(self, id, simulation_pk, **kwargs):  # noqa: E501
        """simulations_status_history_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_status_history_read_with_http_info(id, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation status. (required)
        :param str simulation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SimulationStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_status_history_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_status_history_read`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_status_history_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/status/history/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SimulationStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_status_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_status_list  # noqa: E501

        A simple ViewSet for viewing simulations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_status_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CurrentStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_status_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_status_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_status_list  # noqa: E501

        A simple ViewSet for viewing simulations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_status_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CurrentStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'ordering',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_status_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_status_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'ordering' in local_var_params and local_var_params['ordering'] is not None:  # noqa: E501
            query_params.append(('ordering', local_var_params['ordering']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/status/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CurrentStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_status_partial_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_status_partial_update  # noqa: E501

        A simple ViewSet for viewing simulations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_status_partial_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation status. (required)
        :param str simulation_pk: (required)
        :param SimulationStatus data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SimulationStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_status_partial_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_status_partial_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_status_partial_update  # noqa: E501

        A simple ViewSet for viewing simulations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_status_partial_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation status. (required)
        :param str simulation_pk: (required)
        :param SimulationStatus data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SimulationStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_status_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_status_partial_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_status_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_status_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/status/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SimulationStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_status_patch(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_status_patch  # noqa: E501

        A simple ViewSet for viewing simulations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_status_patch(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param SimulationStatus data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SimulationStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_status_patch_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_status_patch_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_status_patch  # noqa: E501

        A simple ViewSet for viewing simulations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_status_patch_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param SimulationStatus data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SimulationStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_status_patch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_status_patch`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_status_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/status/patch/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SimulationStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_status_update(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_status_update  # noqa: E501

        A simple ViewSet for viewing simulations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_status_update(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation status. (required)
        :param str simulation_pk: (required)
        :param SimulationStatus data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SimulationStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_status_update_with_http_info(id, simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_status_update_with_http_info(self, id, simulation_pk, data, **kwargs):  # noqa: E501
        """simulations_status_update  # noqa: E501

        A simple ViewSet for viewing simulations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_status_update_with_http_info(id, simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation status. (required)
        :param str simulation_pk: (required)
        :param SimulationStatus data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SimulationStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_status_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_status_update`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_status_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_status_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/status/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SimulationStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_update(self, id, data, **kwargs):  # noqa: E501
        """simulations_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation. (required)
        :param SimulationUpdate data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SimulationUpdate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def simulations_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """simulations_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation. (required)
        :param SimulationUpdate data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SimulationUpdate, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SimulationUpdate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_visualisations_breach_graph_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Get a websocket URL returning breaches (graph) data  # noqa: E501

        The websocket-url in the response returns binary data messages consisting of timestamp, breach_width, breach_depth, q (discharge), au (wet cross-sectional area) as float32 data.  The values are alternated like: [timestamp, breach_width, breach_depth, q, au ...  timestamp_N, breach_width_N, breach_depth_N, q_N, au_N]  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_visualisations_breach_graph_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param BreachGraphRequest data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BreachGraph
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_visualisations_breach_graph_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_visualisations_breach_graph_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Get a websocket URL returning breaches (graph) data  # noqa: E501

        The websocket-url in the response returns binary data messages consisting of timestamp, breach_width, breach_depth, q (discharge), au (wet cross-sectional area) as float32 data.  The values are alternated like: [timestamp, breach_width, breach_depth, q, au ...  timestamp_N, breach_width_N, breach_depth_N, q_N, au_N]  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_visualisations_breach_graph_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param BreachGraphRequest data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BreachGraph, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_visualisations_breach_graph_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_visualisations_breach_graph_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_visualisations_breach_graph_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/visualisations/breach_graph/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BreachGraph',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_visualisations_profile_list(self, layer, simulation_pk, **kwargs):  # noqa: E501
        """simulations_visualisations_profile_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_visualisations_profile_list(layer, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str layer: (required)
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Profile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_visualisations_profile_list_with_http_info(layer, simulation_pk, **kwargs)  # noqa: E501

    def simulations_visualisations_profile_list_with_http_info(self, layer, simulation_pk, **kwargs):  # noqa: E501
        """simulations_visualisations_profile_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_visualisations_profile_list_with_http_info(layer, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str layer: (required)
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Profile, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'layer',
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_visualisations_profile_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'layer' is set
        if self.api_client.client_side_validation and ('layer' not in local_var_params or  # noqa: E501
                                                        local_var_params['layer'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `layer` when calling `simulations_visualisations_profile_list`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_visualisations_profile_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'layer' in local_var_params:
            path_params['layer'] = local_var_params['layer']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/visualisations/{layer}/profile/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Profile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_visualisations_pump_discharge_graph_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Get a websocket URL returning pump discharge (graph) data  # noqa: E501

        The websocket-url in the response returns binary data messages consisting of timestamp, q_pump (discharge) float32 data. The values are alternated like: [timestamp, q_pump, timestamp_2, q_pump_2... timestamp_N, q_pump_N]  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_visualisations_pump_discharge_graph_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param PumpDischargeGraphRequest data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PumpDischargeGraph
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_visualisations_pump_discharge_graph_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_visualisations_pump_discharge_graph_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Get a websocket URL returning pump discharge (graph) data  # noqa: E501

        The websocket-url in the response returns binary data messages consisting of timestamp, q_pump (discharge) float32 data. The values are alternated like: [timestamp, q_pump, timestamp_2, q_pump_2... timestamp_N, q_pump_N]  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_visualisations_pump_discharge_graph_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param PumpDischargeGraphRequest data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PumpDischargeGraph, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_visualisations_pump_discharge_graph_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_visualisations_pump_discharge_graph_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_visualisations_pump_discharge_graph_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/visualisations/pump_discharge_graph/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PumpDischargeGraph',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_visualisations_rain_graph_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Get a websocket URL returning node rain (graph) data.  # noqa: E501

        The websocket-url in the response returns binary data messages consisting of timestamp and rain float32 data. The values are alternated like: [timestamp, rain, timestamp_2, rain_2... timestamp_N, rain_N]  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_visualisations_rain_graph_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param RainGraphRequest data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RainGraph
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_visualisations_rain_graph_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_visualisations_rain_graph_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Get a websocket URL returning node rain (graph) data.  # noqa: E501

        The websocket-url in the response returns binary data messages consisting of timestamp and rain float32 data. The values are alternated like: [timestamp, rain, timestamp_2, rain_2... timestamp_N, rain_N]  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_visualisations_rain_graph_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param RainGraphRequest data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RainGraph, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_visualisations_rain_graph_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_visualisations_rain_graph_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_visualisations_rain_graph_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/visualisations/rain_graph/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RainGraph',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_visualisations_tms_list(self, layer, simulation_pk, **kwargs):  # noqa: E501
        """simulations_visualisations_tms_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_visualisations_tms_list(layer, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str layer: (required)
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TMS
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_visualisations_tms_list_with_http_info(layer, simulation_pk, **kwargs)  # noqa: E501

    def simulations_visualisations_tms_list_with_http_info(self, layer, simulation_pk, **kwargs):  # noqa: E501
        """simulations_visualisations_tms_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_visualisations_tms_list_with_http_info(layer, simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str layer: (required)
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TMS, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'layer',
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_visualisations_tms_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'layer' is set
        if self.api_client.client_side_validation and ('layer' not in local_var_params or  # noqa: E501
                                                        local_var_params['layer'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `layer` when calling `simulations_visualisations_tms_list`")  # noqa: E501
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_visualisations_tms_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'layer' in local_var_params:
            path_params['layer'] = local_var_params['layer']  # noqa: E501
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/visualisations/{layer}/tms/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TMS',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_visualisations_water_flow_graph_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Get a websocket URL returning line flow (graph) data.  # noqa: E501

        The websocket-url in the response returns binary data messages consisting of timestamp, u1 (velocity), q (discharge) float32 data. The values are alternated like: [timestamp, u1, q, timestamp_2, u1_2, q_2... timestamp_N, u1_N, q_N]  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_visualisations_water_flow_graph_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterFlowGraphRequest data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WaterGraph
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_visualisations_water_flow_graph_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_visualisations_water_flow_graph_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Get a websocket URL returning line flow (graph) data.  # noqa: E501

        The websocket-url in the response returns binary data messages consisting of timestamp, u1 (velocity), q (discharge) float32 data. The values are alternated like: [timestamp, u1, q, timestamp_2, u1_2, q_2... timestamp_N, u1_N, q_N]  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_visualisations_water_flow_graph_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterFlowGraphRequest data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WaterGraph, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_visualisations_water_flow_graph_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_visualisations_water_flow_graph_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_visualisations_water_flow_graph_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/visualisations/water_flow_graph/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WaterGraph',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_visualisations_water_level_graph_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Get a websocket URL returning node waterlevel (graph) data.  # noqa: E501

        The websocket-url in the response returns binary data messages consisting of timestamp and waterlevel float32 data. The values are alternated like: [timestamp, s1, timestamp_2, s1_2... timestamp_N, s1_N]  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_visualisations_water_level_graph_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterLevelGraphRequest data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WaterGraph
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_visualisations_water_level_graph_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_visualisations_water_level_graph_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Get a websocket URL returning node waterlevel (graph) data.  # noqa: E501

        The websocket-url in the response returns binary data messages consisting of timestamp and waterlevel float32 data. The values are alternated like: [timestamp, s1, timestamp_2, s1_2... timestamp_N, s1_N]  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_visualisations_water_level_graph_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterLevelGraphRequest data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WaterGraph, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_visualisations_water_level_graph_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_visualisations_water_level_graph_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_visualisations_water_level_graph_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/visualisations/water_level_graph/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WaterGraph',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_visualisations_water_level_profile_create(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Get a websocket URL returning waterlevel profile data.  # noqa: E501

        The websocket returns binary data messages consisting of timestep and waterlevel float32 values in one message like: timestep, waterlevel, waterlevel, waterlevel, waterlevel  Groundwater waterlevel values are automatically added (after open water) if groundwater is present. The returned waterlevel values have length 'points_limit' * 2 in this case.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_visualisations_water_level_profile_create(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterLevelProfileRequest data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WaterLevelProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_visualisations_water_level_profile_create_with_http_info(simulation_pk, data, **kwargs)  # noqa: E501

    def simulations_visualisations_water_level_profile_create_with_http_info(self, simulation_pk, data, **kwargs):  # noqa: E501
        """Get a websocket URL returning waterlevel profile data.  # noqa: E501

        The websocket returns binary data messages consisting of timestep and waterlevel float32 values in one message like: timestep, waterlevel, waterlevel, waterlevel, waterlevel  Groundwater waterlevel values are automatically added (after open water) if groundwater is present. The returned waterlevel values have length 'points_limit' * 2 in this case.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_visualisations_water_level_profile_create_with_http_info(simulation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param WaterLevelProfileRequest data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WaterLevelProfile, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_visualisations_water_level_profile_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_visualisations_water_level_profile_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_visualisations_water_level_profile_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/visualisations/water_level_profile/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WaterLevelProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_visualisations_waterdepth_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_visualisations_waterdepth_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_visualisations_waterdepth_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Waterdepth
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_visualisations_waterdepth_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_visualisations_waterdepth_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_visualisations_waterdepth_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_visualisations_waterdepth_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Waterdepth, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_visualisations_waterdepth_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_visualisations_waterdepth_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/visualisations/waterdepth/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Waterdepth',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_websockets_list(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_websockets_list  # noqa: E501

        List active websocket connections for a given simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_websockets_list(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20072
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_websockets_list_with_http_info(simulation_pk, **kwargs)  # noqa: E501

    def simulations_websockets_list_with_http_info(self, simulation_pk, **kwargs):  # noqa: E501
        """simulations_websockets_list  # noqa: E501

        List active websocket connections for a given simulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_websockets_list_with_http_info(simulation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str simulation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20072, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'simulation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_websockets_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'simulation_pk' is set
        if self.api_client.client_side_validation and ('simulation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['simulation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `simulation_pk` when calling `simulations_websockets_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'simulation_pk' in local_var_params:
            path_params['simulation_pk'] = local_var_params['simulation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/simulations/{simulation_pk}/websockets/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20072',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def statuses_list(self, **kwargs):  # noqa: E501
        """Show the latest status off all simulations.  # noqa: E501

        List all simulations that ever have finished successfully  ``` ?name=finished ```  List all simulations that have finished successfully during the week of the 1988 UEFA European Football Championship ``` ?name=finished&created__date__gte=1988-06-10&created__date__lte=1988-06-25 ```  The `created` field is of type date-time in ISO 8601 (UTC) format. To get all crashed simulations since St Nicolas 2018  ``` ?name=crashed&created__gte=2018-12-05T00:00:00Z ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.statuses_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: name
        :param str name__iexact: name__iexact
        :param str name__contains: name__contains
        :param str name__icontains: name__icontains
        :param str name__in: name__in
        :param str name__startswith: name__startswith
        :param str name__istartswith: name__istartswith
        :param str name__endswith: name__endswith
        :param str name__regex: name__regex
        :param str simulation__name: simulation__name
        :param str simulation__name__iexact: simulation__name__iexact
        :param str simulation__name__contains: simulation__name__contains
        :param str simulation__name__icontains: simulation__name__icontains
        :param str simulation__name__in: simulation__name__in
        :param str simulation__name__startswith: simulation__name__startswith
        :param str simulation__name__istartswith: simulation__name__istartswith
        :param str simulation__name__endswith: simulation__name__endswith
        :param str simulation__name__regex: simulation__name__regex
        :param str simulation__compute_cluster__name: simulation__compute_cluster__name
        :param str simulation__threedimodel__slug: simulation__threedimodel__slug
        :param str simulation__threedimodel__slug__iexact: simulation__threedimodel__slug__iexact
        :param str simulation__threedimodel__slug__contains: simulation__threedimodel__slug__contains
        :param str simulation__threedimodel__slug__icontains: simulation__threedimodel__slug__icontains
        :param str simulation__threedimodel__slug__in: simulation__threedimodel__slug__in
        :param str simulation__threedimodel__slug__startswith: simulation__threedimodel__slug__startswith
        :param str simulation__threedimodel__slug__istartswith: simulation__threedimodel__slug__istartswith
        :param str simulation__threedimodel__slug__endswith: simulation__threedimodel__slug__endswith
        :param str simulation__threedimodel__slug__regex: simulation__threedimodel__slug__regex
        :param str created: created
        :param str created__gt: created__gt
        :param str created__gte: created__gte
        :param str created__lt: created__lt
        :param str created__lte: created__lte
        :param str created__date: created__date
        :param str created__date__gt: created__date__gt
        :param str created__date__gte: created__date__gte
        :param str created__date__lt: created__date__lt
        :param str created__date__lte: created__date__lte
        :param str created__year: created__year
        :param str created__year__gt: created__year__gt
        :param str created__year__gte: created__year__gte
        :param str created__year__lt: created__year__lt
        :param str created__year__lte: created__year__lte
        :param str created__month: created__month
        :param str created__month__lte: created__month__lte
        :param str created__day: created__day
        :param str created__day__lt: created__day__lt
        :param str created__week: created__week
        :param str created__week_day: created__week_day
        :param str id: id
        :param str id__gt: id__gt
        :param str id__gte: id__gte
        :param str id__lt: id__lt
        :param str id__lte: id__lte
        :param str id__isnull: id__isnull
        :param str exit_code: exit_code
        :param str exit_code__gt: exit_code__gt
        :param str exit_code__gte: exit_code__gte
        :param str exit_code__lt: exit_code__lt
        :param str exit_code__lte: exit_code__lte
        :param str exit_code__isnull: exit_code__isnull
        :param str simulation_id__in: simulation_id__in
        :param str simulation__user__username: simulation__user__username
        :param str simulation__type__live: simulation__type__live
        :param str simulation__tags__contains: simulation_tags_contains
        :param str simulation__organisation__name__istartswith: simulation__organisation__name__istartswith
        :param str simulation__organisation__unique_id: simulation__organisation__unique_id
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20071
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.statuses_list_with_http_info(**kwargs)  # noqa: E501

    def statuses_list_with_http_info(self, **kwargs):  # noqa: E501
        """Show the latest status off all simulations.  # noqa: E501

        List all simulations that ever have finished successfully  ``` ?name=finished ```  List all simulations that have finished successfully during the week of the 1988 UEFA European Football Championship ``` ?name=finished&created__date__gte=1988-06-10&created__date__lte=1988-06-25 ```  The `created` field is of type date-time in ISO 8601 (UTC) format. To get all crashed simulations since St Nicolas 2018  ``` ?name=crashed&created__gte=2018-12-05T00:00:00Z ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.statuses_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: name
        :param str name__iexact: name__iexact
        :param str name__contains: name__contains
        :param str name__icontains: name__icontains
        :param str name__in: name__in
        :param str name__startswith: name__startswith
        :param str name__istartswith: name__istartswith
        :param str name__endswith: name__endswith
        :param str name__regex: name__regex
        :param str simulation__name: simulation__name
        :param str simulation__name__iexact: simulation__name__iexact
        :param str simulation__name__contains: simulation__name__contains
        :param str simulation__name__icontains: simulation__name__icontains
        :param str simulation__name__in: simulation__name__in
        :param str simulation__name__startswith: simulation__name__startswith
        :param str simulation__name__istartswith: simulation__name__istartswith
        :param str simulation__name__endswith: simulation__name__endswith
        :param str simulation__name__regex: simulation__name__regex
        :param str simulation__compute_cluster__name: simulation__compute_cluster__name
        :param str simulation__threedimodel__slug: simulation__threedimodel__slug
        :param str simulation__threedimodel__slug__iexact: simulation__threedimodel__slug__iexact
        :param str simulation__threedimodel__slug__contains: simulation__threedimodel__slug__contains
        :param str simulation__threedimodel__slug__icontains: simulation__threedimodel__slug__icontains
        :param str simulation__threedimodel__slug__in: simulation__threedimodel__slug__in
        :param str simulation__threedimodel__slug__startswith: simulation__threedimodel__slug__startswith
        :param str simulation__threedimodel__slug__istartswith: simulation__threedimodel__slug__istartswith
        :param str simulation__threedimodel__slug__endswith: simulation__threedimodel__slug__endswith
        :param str simulation__threedimodel__slug__regex: simulation__threedimodel__slug__regex
        :param str created: created
        :param str created__gt: created__gt
        :param str created__gte: created__gte
        :param str created__lt: created__lt
        :param str created__lte: created__lte
        :param str created__date: created__date
        :param str created__date__gt: created__date__gt
        :param str created__date__gte: created__date__gte
        :param str created__date__lt: created__date__lt
        :param str created__date__lte: created__date__lte
        :param str created__year: created__year
        :param str created__year__gt: created__year__gt
        :param str created__year__gte: created__year__gte
        :param str created__year__lt: created__year__lt
        :param str created__year__lte: created__year__lte
        :param str created__month: created__month
        :param str created__month__lte: created__month__lte
        :param str created__day: created__day
        :param str created__day__lt: created__day__lt
        :param str created__week: created__week
        :param str created__week_day: created__week_day
        :param str id: id
        :param str id__gt: id__gt
        :param str id__gte: id__gte
        :param str id__lt: id__lt
        :param str id__lte: id__lte
        :param str id__isnull: id__isnull
        :param str exit_code: exit_code
        :param str exit_code__gt: exit_code__gt
        :param str exit_code__gte: exit_code__gte
        :param str exit_code__lt: exit_code__lt
        :param str exit_code__lte: exit_code__lte
        :param str exit_code__isnull: exit_code__isnull
        :param str simulation_id__in: simulation_id__in
        :param str simulation__user__username: simulation__user__username
        :param str simulation__type__live: simulation__type__live
        :param str simulation__tags__contains: simulation_tags_contains
        :param str simulation__organisation__name__istartswith: simulation__organisation__name__istartswith
        :param str simulation__organisation__unique_id: simulation__organisation__unique_id
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20071, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'name__iexact',
            'name__contains',
            'name__icontains',
            'name__in',
            'name__startswith',
            'name__istartswith',
            'name__endswith',
            'name__regex',
            'simulation__name',
            'simulation__name__iexact',
            'simulation__name__contains',
            'simulation__name__icontains',
            'simulation__name__in',
            'simulation__name__startswith',
            'simulation__name__istartswith',
            'simulation__name__endswith',
            'simulation__name__regex',
            'simulation__compute_cluster__name',
            'simulation__threedimodel__slug',
            'simulation__threedimodel__slug__iexact',
            'simulation__threedimodel__slug__contains',
            'simulation__threedimodel__slug__icontains',
            'simulation__threedimodel__slug__in',
            'simulation__threedimodel__slug__startswith',
            'simulation__threedimodel__slug__istartswith',
            'simulation__threedimodel__slug__endswith',
            'simulation__threedimodel__slug__regex',
            'created',
            'created__gt',
            'created__gte',
            'created__lt',
            'created__lte',
            'created__date',
            'created__date__gt',
            'created__date__gte',
            'created__date__lt',
            'created__date__lte',
            'created__year',
            'created__year__gt',
            'created__year__gte',
            'created__year__lt',
            'created__year__lte',
            'created__month',
            'created__month__lte',
            'created__day',
            'created__day__lt',
            'created__week',
            'created__week_day',
            'id',
            'id__gt',
            'id__gte',
            'id__lt',
            'id__lte',
            'id__isnull',
            'exit_code',
            'exit_code__gt',
            'exit_code__gte',
            'exit_code__lt',
            'exit_code__lte',
            'exit_code__isnull',
            'simulation_id__in',
            'simulation__user__username',
            'simulation__type__live',
            'simulation__tags__contains',
            'simulation__organisation__name__istartswith',
            'simulation__organisation__unique_id',
            'ordering',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method statuses_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'name__iexact' in local_var_params and local_var_params['name__iexact'] is not None:  # noqa: E501
            query_params.append(('name__iexact', local_var_params['name__iexact']))  # noqa: E501
        if 'name__contains' in local_var_params and local_var_params['name__contains'] is not None:  # noqa: E501
            query_params.append(('name__contains', local_var_params['name__contains']))  # noqa: E501
        if 'name__icontains' in local_var_params and local_var_params['name__icontains'] is not None:  # noqa: E501
            query_params.append(('name__icontains', local_var_params['name__icontains']))  # noqa: E501
        if 'name__in' in local_var_params and local_var_params['name__in'] is not None:  # noqa: E501
            query_params.append(('name__in', local_var_params['name__in']))  # noqa: E501
        if 'name__startswith' in local_var_params and local_var_params['name__startswith'] is not None:  # noqa: E501
            query_params.append(('name__startswith', local_var_params['name__startswith']))  # noqa: E501
        if 'name__istartswith' in local_var_params and local_var_params['name__istartswith'] is not None:  # noqa: E501
            query_params.append(('name__istartswith', local_var_params['name__istartswith']))  # noqa: E501
        if 'name__endswith' in local_var_params and local_var_params['name__endswith'] is not None:  # noqa: E501
            query_params.append(('name__endswith', local_var_params['name__endswith']))  # noqa: E501
        if 'name__regex' in local_var_params and local_var_params['name__regex'] is not None:  # noqa: E501
            query_params.append(('name__regex', local_var_params['name__regex']))  # noqa: E501
        if 'simulation__name' in local_var_params and local_var_params['simulation__name'] is not None:  # noqa: E501
            query_params.append(('simulation__name', local_var_params['simulation__name']))  # noqa: E501
        if 'simulation__name__iexact' in local_var_params and local_var_params['simulation__name__iexact'] is not None:  # noqa: E501
            query_params.append(('simulation__name__iexact', local_var_params['simulation__name__iexact']))  # noqa: E501
        if 'simulation__name__contains' in local_var_params and local_var_params['simulation__name__contains'] is not None:  # noqa: E501
            query_params.append(('simulation__name__contains', local_var_params['simulation__name__contains']))  # noqa: E501
        if 'simulation__name__icontains' in local_var_params and local_var_params['simulation__name__icontains'] is not None:  # noqa: E501
            query_params.append(('simulation__name__icontains', local_var_params['simulation__name__icontains']))  # noqa: E501
        if 'simulation__name__in' in local_var_params and local_var_params['simulation__name__in'] is not None:  # noqa: E501
            query_params.append(('simulation__name__in', local_var_params['simulation__name__in']))  # noqa: E501
        if 'simulation__name__startswith' in local_var_params and local_var_params['simulation__name__startswith'] is not None:  # noqa: E501
            query_params.append(('simulation__name__startswith', local_var_params['simulation__name__startswith']))  # noqa: E501
        if 'simulation__name__istartswith' in local_var_params and local_var_params['simulation__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('simulation__name__istartswith', local_var_params['simulation__name__istartswith']))  # noqa: E501
        if 'simulation__name__endswith' in local_var_params and local_var_params['simulation__name__endswith'] is not None:  # noqa: E501
            query_params.append(('simulation__name__endswith', local_var_params['simulation__name__endswith']))  # noqa: E501
        if 'simulation__name__regex' in local_var_params and local_var_params['simulation__name__regex'] is not None:  # noqa: E501
            query_params.append(('simulation__name__regex', local_var_params['simulation__name__regex']))  # noqa: E501
        if 'simulation__compute_cluster__name' in local_var_params and local_var_params['simulation__compute_cluster__name'] is not None:  # noqa: E501
            query_params.append(('simulation__compute_cluster__name', local_var_params['simulation__compute_cluster__name']))  # noqa: E501
        if 'simulation__threedimodel__slug' in local_var_params and local_var_params['simulation__threedimodel__slug'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__slug', local_var_params['simulation__threedimodel__slug']))  # noqa: E501
        if 'simulation__threedimodel__slug__iexact' in local_var_params and local_var_params['simulation__threedimodel__slug__iexact'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__slug__iexact', local_var_params['simulation__threedimodel__slug__iexact']))  # noqa: E501
        if 'simulation__threedimodel__slug__contains' in local_var_params and local_var_params['simulation__threedimodel__slug__contains'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__slug__contains', local_var_params['simulation__threedimodel__slug__contains']))  # noqa: E501
        if 'simulation__threedimodel__slug__icontains' in local_var_params and local_var_params['simulation__threedimodel__slug__icontains'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__slug__icontains', local_var_params['simulation__threedimodel__slug__icontains']))  # noqa: E501
        if 'simulation__threedimodel__slug__in' in local_var_params and local_var_params['simulation__threedimodel__slug__in'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__slug__in', local_var_params['simulation__threedimodel__slug__in']))  # noqa: E501
        if 'simulation__threedimodel__slug__startswith' in local_var_params and local_var_params['simulation__threedimodel__slug__startswith'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__slug__startswith', local_var_params['simulation__threedimodel__slug__startswith']))  # noqa: E501
        if 'simulation__threedimodel__slug__istartswith' in local_var_params and local_var_params['simulation__threedimodel__slug__istartswith'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__slug__istartswith', local_var_params['simulation__threedimodel__slug__istartswith']))  # noqa: E501
        if 'simulation__threedimodel__slug__endswith' in local_var_params and local_var_params['simulation__threedimodel__slug__endswith'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__slug__endswith', local_var_params['simulation__threedimodel__slug__endswith']))  # noqa: E501
        if 'simulation__threedimodel__slug__regex' in local_var_params and local_var_params['simulation__threedimodel__slug__regex'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__slug__regex', local_var_params['simulation__threedimodel__slug__regex']))  # noqa: E501
        if 'created' in local_var_params and local_var_params['created'] is not None:  # noqa: E501
            query_params.append(('created', local_var_params['created']))  # noqa: E501
        if 'created__gt' in local_var_params and local_var_params['created__gt'] is not None:  # noqa: E501
            query_params.append(('created__gt', local_var_params['created__gt']))  # noqa: E501
        if 'created__gte' in local_var_params and local_var_params['created__gte'] is not None:  # noqa: E501
            query_params.append(('created__gte', local_var_params['created__gte']))  # noqa: E501
        if 'created__lt' in local_var_params and local_var_params['created__lt'] is not None:  # noqa: E501
            query_params.append(('created__lt', local_var_params['created__lt']))  # noqa: E501
        if 'created__lte' in local_var_params and local_var_params['created__lte'] is not None:  # noqa: E501
            query_params.append(('created__lte', local_var_params['created__lte']))  # noqa: E501
        if 'created__date' in local_var_params and local_var_params['created__date'] is not None:  # noqa: E501
            query_params.append(('created__date', local_var_params['created__date']))  # noqa: E501
        if 'created__date__gt' in local_var_params and local_var_params['created__date__gt'] is not None:  # noqa: E501
            query_params.append(('created__date__gt', local_var_params['created__date__gt']))  # noqa: E501
        if 'created__date__gte' in local_var_params and local_var_params['created__date__gte'] is not None:  # noqa: E501
            query_params.append(('created__date__gte', local_var_params['created__date__gte']))  # noqa: E501
        if 'created__date__lt' in local_var_params and local_var_params['created__date__lt'] is not None:  # noqa: E501
            query_params.append(('created__date__lt', local_var_params['created__date__lt']))  # noqa: E501
        if 'created__date__lte' in local_var_params and local_var_params['created__date__lte'] is not None:  # noqa: E501
            query_params.append(('created__date__lte', local_var_params['created__date__lte']))  # noqa: E501
        if 'created__year' in local_var_params and local_var_params['created__year'] is not None:  # noqa: E501
            query_params.append(('created__year', local_var_params['created__year']))  # noqa: E501
        if 'created__year__gt' in local_var_params and local_var_params['created__year__gt'] is not None:  # noqa: E501
            query_params.append(('created__year__gt', local_var_params['created__year__gt']))  # noqa: E501
        if 'created__year__gte' in local_var_params and local_var_params['created__year__gte'] is not None:  # noqa: E501
            query_params.append(('created__year__gte', local_var_params['created__year__gte']))  # noqa: E501
        if 'created__year__lt' in local_var_params and local_var_params['created__year__lt'] is not None:  # noqa: E501
            query_params.append(('created__year__lt', local_var_params['created__year__lt']))  # noqa: E501
        if 'created__year__lte' in local_var_params and local_var_params['created__year__lte'] is not None:  # noqa: E501
            query_params.append(('created__year__lte', local_var_params['created__year__lte']))  # noqa: E501
        if 'created__month' in local_var_params and local_var_params['created__month'] is not None:  # noqa: E501
            query_params.append(('created__month', local_var_params['created__month']))  # noqa: E501
        if 'created__month__lte' in local_var_params and local_var_params['created__month__lte'] is not None:  # noqa: E501
            query_params.append(('created__month__lte', local_var_params['created__month__lte']))  # noqa: E501
        if 'created__day' in local_var_params and local_var_params['created__day'] is not None:  # noqa: E501
            query_params.append(('created__day', local_var_params['created__day']))  # noqa: E501
        if 'created__day__lt' in local_var_params and local_var_params['created__day__lt'] is not None:  # noqa: E501
            query_params.append(('created__day__lt', local_var_params['created__day__lt']))  # noqa: E501
        if 'created__week' in local_var_params and local_var_params['created__week'] is not None:  # noqa: E501
            query_params.append(('created__week', local_var_params['created__week']))  # noqa: E501
        if 'created__week_day' in local_var_params and local_var_params['created__week_day'] is not None:  # noqa: E501
            query_params.append(('created__week_day', local_var_params['created__week_day']))  # noqa: E501
        if 'id' in local_var_params and local_var_params['id'] is not None:  # noqa: E501
            query_params.append(('id', local_var_params['id']))  # noqa: E501
        if 'id__gt' in local_var_params and local_var_params['id__gt'] is not None:  # noqa: E501
            query_params.append(('id__gt', local_var_params['id__gt']))  # noqa: E501
        if 'id__gte' in local_var_params and local_var_params['id__gte'] is not None:  # noqa: E501
            query_params.append(('id__gte', local_var_params['id__gte']))  # noqa: E501
        if 'id__lt' in local_var_params and local_var_params['id__lt'] is not None:  # noqa: E501
            query_params.append(('id__lt', local_var_params['id__lt']))  # noqa: E501
        if 'id__lte' in local_var_params and local_var_params['id__lte'] is not None:  # noqa: E501
            query_params.append(('id__lte', local_var_params['id__lte']))  # noqa: E501
        if 'id__isnull' in local_var_params and local_var_params['id__isnull'] is not None:  # noqa: E501
            query_params.append(('id__isnull', local_var_params['id__isnull']))  # noqa: E501
        if 'exit_code' in local_var_params and local_var_params['exit_code'] is not None:  # noqa: E501
            query_params.append(('exit_code', local_var_params['exit_code']))  # noqa: E501
        if 'exit_code__gt' in local_var_params and local_var_params['exit_code__gt'] is not None:  # noqa: E501
            query_params.append(('exit_code__gt', local_var_params['exit_code__gt']))  # noqa: E501
        if 'exit_code__gte' in local_var_params and local_var_params['exit_code__gte'] is not None:  # noqa: E501
            query_params.append(('exit_code__gte', local_var_params['exit_code__gte']))  # noqa: E501
        if 'exit_code__lt' in local_var_params and local_var_params['exit_code__lt'] is not None:  # noqa: E501
            query_params.append(('exit_code__lt', local_var_params['exit_code__lt']))  # noqa: E501
        if 'exit_code__lte' in local_var_params and local_var_params['exit_code__lte'] is not None:  # noqa: E501
            query_params.append(('exit_code__lte', local_var_params['exit_code__lte']))  # noqa: E501
        if 'exit_code__isnull' in local_var_params and local_var_params['exit_code__isnull'] is not None:  # noqa: E501
            query_params.append(('exit_code__isnull', local_var_params['exit_code__isnull']))  # noqa: E501
        if 'simulation_id__in' in local_var_params and local_var_params['simulation_id__in'] is not None:  # noqa: E501
            query_params.append(('simulation_id__in', local_var_params['simulation_id__in']))  # noqa: E501
        if 'simulation__user__username' in local_var_params and local_var_params['simulation__user__username'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username', local_var_params['simulation__user__username']))  # noqa: E501
        if 'simulation__type__live' in local_var_params and local_var_params['simulation__type__live'] is not None:  # noqa: E501
            query_params.append(('simulation__type__live', local_var_params['simulation__type__live']))  # noqa: E501
        if 'simulation__tags__contains' in local_var_params and local_var_params['simulation__tags__contains'] is not None:  # noqa: E501
            query_params.append(('simulation__tags__contains', local_var_params['simulation__tags__contains']))  # noqa: E501
        if 'simulation__organisation__name__istartswith' in local_var_params and local_var_params['simulation__organisation__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('simulation__organisation__name__istartswith', local_var_params['simulation__organisation__name__istartswith']))  # noqa: E501
        if 'simulation__organisation__unique_id' in local_var_params and local_var_params['simulation__organisation__unique_id'] is not None:  # noqa: E501
            query_params.append(('simulation__organisation__unique_id', local_var_params['simulation__organisation__unique_id']))  # noqa: E501
        if 'ordering' in local_var_params and local_var_params['ordering'] is not None:  # noqa: E501
            query_params.append(('ordering', local_var_params['ordering']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/statuses/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20071',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def statuses_read(self, id, **kwargs):  # noqa: E501
        """statuses_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.statuses_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation status. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SimulationStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.statuses_read_with_http_info(id, **kwargs)  # noqa: E501

    def statuses_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """statuses_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.statuses_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation status. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SimulationStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method statuses_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `statuses_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/statuses/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SimulationStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def statuses_statistics(self, **kwargs):  # noqa: E501
        """Count of (latest/final) simulation statuses. Combine with filters to get your weekly/monthly etc statistics  # noqa: E501

        For example, to get a count of finished simulations in 2020  ``` ?name=finished&created__year=2020  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.statuses_statistics(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: name
        :param str name__iexact: name__iexact
        :param str name__contains: name__contains
        :param str name__icontains: name__icontains
        :param str name__in: name__in
        :param str name__startswith: name__startswith
        :param str name__istartswith: name__istartswith
        :param str name__endswith: name__endswith
        :param str name__regex: name__regex
        :param str simulation__name: simulation__name
        :param str simulation__name__iexact: simulation__name__iexact
        :param str simulation__name__contains: simulation__name__contains
        :param str simulation__name__icontains: simulation__name__icontains
        :param str simulation__name__in: simulation__name__in
        :param str simulation__name__startswith: simulation__name__startswith
        :param str simulation__name__istartswith: simulation__name__istartswith
        :param str simulation__name__endswith: simulation__name__endswith
        :param str simulation__name__regex: simulation__name__regex
        :param str simulation__compute_cluster__name: simulation__compute_cluster__name
        :param str simulation__threedimodel__slug: simulation__threedimodel__slug
        :param str simulation__threedimodel__slug__iexact: simulation__threedimodel__slug__iexact
        :param str simulation__threedimodel__slug__contains: simulation__threedimodel__slug__contains
        :param str simulation__threedimodel__slug__icontains: simulation__threedimodel__slug__icontains
        :param str simulation__threedimodel__slug__in: simulation__threedimodel__slug__in
        :param str simulation__threedimodel__slug__startswith: simulation__threedimodel__slug__startswith
        :param str simulation__threedimodel__slug__istartswith: simulation__threedimodel__slug__istartswith
        :param str simulation__threedimodel__slug__endswith: simulation__threedimodel__slug__endswith
        :param str simulation__threedimodel__slug__regex: simulation__threedimodel__slug__regex
        :param str created: created
        :param str created__gt: created__gt
        :param str created__gte: created__gte
        :param str created__lt: created__lt
        :param str created__lte: created__lte
        :param str created__date: created__date
        :param str created__date__gt: created__date__gt
        :param str created__date__gte: created__date__gte
        :param str created__date__lt: created__date__lt
        :param str created__date__lte: created__date__lte
        :param str created__year: created__year
        :param str created__year__gt: created__year__gt
        :param str created__year__gte: created__year__gte
        :param str created__year__lt: created__year__lt
        :param str created__year__lte: created__year__lte
        :param str created__month: created__month
        :param str created__month__lte: created__month__lte
        :param str created__day: created__day
        :param str created__day__lt: created__day__lt
        :param str created__week: created__week
        :param str created__week_day: created__week_day
        :param str id: id
        :param str id__gt: id__gt
        :param str id__gte: id__gte
        :param str id__lt: id__lt
        :param str id__lte: id__lte
        :param str id__isnull: id__isnull
        :param str exit_code: exit_code
        :param str exit_code__gt: exit_code__gt
        :param str exit_code__gte: exit_code__gte
        :param str exit_code__lt: exit_code__lt
        :param str exit_code__lte: exit_code__lte
        :param str exit_code__isnull: exit_code__isnull
        :param str simulation_id__in: simulation_id__in
        :param str simulation__user__username: simulation__user__username
        :param str simulation__type__live: simulation__type__live
        :param str simulation__tags__contains: simulation_tags_contains
        :param str simulation__organisation__name__istartswith: simulation__organisation__name__istartswith
        :param str simulation__organisation__unique_id: simulation__organisation__unique_id
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[SimulationStatusStatistics]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.statuses_statistics_with_http_info(**kwargs)  # noqa: E501

    def statuses_statistics_with_http_info(self, **kwargs):  # noqa: E501
        """Count of (latest/final) simulation statuses. Combine with filters to get your weekly/monthly etc statistics  # noqa: E501

        For example, to get a count of finished simulations in 2020  ``` ?name=finished&created__year=2020  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.statuses_statistics_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: name
        :param str name__iexact: name__iexact
        :param str name__contains: name__contains
        :param str name__icontains: name__icontains
        :param str name__in: name__in
        :param str name__startswith: name__startswith
        :param str name__istartswith: name__istartswith
        :param str name__endswith: name__endswith
        :param str name__regex: name__regex
        :param str simulation__name: simulation__name
        :param str simulation__name__iexact: simulation__name__iexact
        :param str simulation__name__contains: simulation__name__contains
        :param str simulation__name__icontains: simulation__name__icontains
        :param str simulation__name__in: simulation__name__in
        :param str simulation__name__startswith: simulation__name__startswith
        :param str simulation__name__istartswith: simulation__name__istartswith
        :param str simulation__name__endswith: simulation__name__endswith
        :param str simulation__name__regex: simulation__name__regex
        :param str simulation__compute_cluster__name: simulation__compute_cluster__name
        :param str simulation__threedimodel__slug: simulation__threedimodel__slug
        :param str simulation__threedimodel__slug__iexact: simulation__threedimodel__slug__iexact
        :param str simulation__threedimodel__slug__contains: simulation__threedimodel__slug__contains
        :param str simulation__threedimodel__slug__icontains: simulation__threedimodel__slug__icontains
        :param str simulation__threedimodel__slug__in: simulation__threedimodel__slug__in
        :param str simulation__threedimodel__slug__startswith: simulation__threedimodel__slug__startswith
        :param str simulation__threedimodel__slug__istartswith: simulation__threedimodel__slug__istartswith
        :param str simulation__threedimodel__slug__endswith: simulation__threedimodel__slug__endswith
        :param str simulation__threedimodel__slug__regex: simulation__threedimodel__slug__regex
        :param str created: created
        :param str created__gt: created__gt
        :param str created__gte: created__gte
        :param str created__lt: created__lt
        :param str created__lte: created__lte
        :param str created__date: created__date
        :param str created__date__gt: created__date__gt
        :param str created__date__gte: created__date__gte
        :param str created__date__lt: created__date__lt
        :param str created__date__lte: created__date__lte
        :param str created__year: created__year
        :param str created__year__gt: created__year__gt
        :param str created__year__gte: created__year__gte
        :param str created__year__lt: created__year__lt
        :param str created__year__lte: created__year__lte
        :param str created__month: created__month
        :param str created__month__lte: created__month__lte
        :param str created__day: created__day
        :param str created__day__lt: created__day__lt
        :param str created__week: created__week
        :param str created__week_day: created__week_day
        :param str id: id
        :param str id__gt: id__gt
        :param str id__gte: id__gte
        :param str id__lt: id__lt
        :param str id__lte: id__lte
        :param str id__isnull: id__isnull
        :param str exit_code: exit_code
        :param str exit_code__gt: exit_code__gt
        :param str exit_code__gte: exit_code__gte
        :param str exit_code__lt: exit_code__lt
        :param str exit_code__lte: exit_code__lte
        :param str exit_code__isnull: exit_code__isnull
        :param str simulation_id__in: simulation_id__in
        :param str simulation__user__username: simulation__user__username
        :param str simulation__type__live: simulation__type__live
        :param str simulation__tags__contains: simulation_tags_contains
        :param str simulation__organisation__name__istartswith: simulation__organisation__name__istartswith
        :param str simulation__organisation__unique_id: simulation__organisation__unique_id
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[SimulationStatusStatistics], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'name__iexact',
            'name__contains',
            'name__icontains',
            'name__in',
            'name__startswith',
            'name__istartswith',
            'name__endswith',
            'name__regex',
            'simulation__name',
            'simulation__name__iexact',
            'simulation__name__contains',
            'simulation__name__icontains',
            'simulation__name__in',
            'simulation__name__startswith',
            'simulation__name__istartswith',
            'simulation__name__endswith',
            'simulation__name__regex',
            'simulation__compute_cluster__name',
            'simulation__threedimodel__slug',
            'simulation__threedimodel__slug__iexact',
            'simulation__threedimodel__slug__contains',
            'simulation__threedimodel__slug__icontains',
            'simulation__threedimodel__slug__in',
            'simulation__threedimodel__slug__startswith',
            'simulation__threedimodel__slug__istartswith',
            'simulation__threedimodel__slug__endswith',
            'simulation__threedimodel__slug__regex',
            'created',
            'created__gt',
            'created__gte',
            'created__lt',
            'created__lte',
            'created__date',
            'created__date__gt',
            'created__date__gte',
            'created__date__lt',
            'created__date__lte',
            'created__year',
            'created__year__gt',
            'created__year__gte',
            'created__year__lt',
            'created__year__lte',
            'created__month',
            'created__month__lte',
            'created__day',
            'created__day__lt',
            'created__week',
            'created__week_day',
            'id',
            'id__gt',
            'id__gte',
            'id__lt',
            'id__lte',
            'id__isnull',
            'exit_code',
            'exit_code__gt',
            'exit_code__gte',
            'exit_code__lt',
            'exit_code__lte',
            'exit_code__isnull',
            'simulation_id__in',
            'simulation__user__username',
            'simulation__type__live',
            'simulation__tags__contains',
            'simulation__organisation__name__istartswith',
            'simulation__organisation__unique_id',
            'ordering',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method statuses_statistics" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'name__iexact' in local_var_params and local_var_params['name__iexact'] is not None:  # noqa: E501
            query_params.append(('name__iexact', local_var_params['name__iexact']))  # noqa: E501
        if 'name__contains' in local_var_params and local_var_params['name__contains'] is not None:  # noqa: E501
            query_params.append(('name__contains', local_var_params['name__contains']))  # noqa: E501
        if 'name__icontains' in local_var_params and local_var_params['name__icontains'] is not None:  # noqa: E501
            query_params.append(('name__icontains', local_var_params['name__icontains']))  # noqa: E501
        if 'name__in' in local_var_params and local_var_params['name__in'] is not None:  # noqa: E501
            query_params.append(('name__in', local_var_params['name__in']))  # noqa: E501
        if 'name__startswith' in local_var_params and local_var_params['name__startswith'] is not None:  # noqa: E501
            query_params.append(('name__startswith', local_var_params['name__startswith']))  # noqa: E501
        if 'name__istartswith' in local_var_params and local_var_params['name__istartswith'] is not None:  # noqa: E501
            query_params.append(('name__istartswith', local_var_params['name__istartswith']))  # noqa: E501
        if 'name__endswith' in local_var_params and local_var_params['name__endswith'] is not None:  # noqa: E501
            query_params.append(('name__endswith', local_var_params['name__endswith']))  # noqa: E501
        if 'name__regex' in local_var_params and local_var_params['name__regex'] is not None:  # noqa: E501
            query_params.append(('name__regex', local_var_params['name__regex']))  # noqa: E501
        if 'simulation__name' in local_var_params and local_var_params['simulation__name'] is not None:  # noqa: E501
            query_params.append(('simulation__name', local_var_params['simulation__name']))  # noqa: E501
        if 'simulation__name__iexact' in local_var_params and local_var_params['simulation__name__iexact'] is not None:  # noqa: E501
            query_params.append(('simulation__name__iexact', local_var_params['simulation__name__iexact']))  # noqa: E501
        if 'simulation__name__contains' in local_var_params and local_var_params['simulation__name__contains'] is not None:  # noqa: E501
            query_params.append(('simulation__name__contains', local_var_params['simulation__name__contains']))  # noqa: E501
        if 'simulation__name__icontains' in local_var_params and local_var_params['simulation__name__icontains'] is not None:  # noqa: E501
            query_params.append(('simulation__name__icontains', local_var_params['simulation__name__icontains']))  # noqa: E501
        if 'simulation__name__in' in local_var_params and local_var_params['simulation__name__in'] is not None:  # noqa: E501
            query_params.append(('simulation__name__in', local_var_params['simulation__name__in']))  # noqa: E501
        if 'simulation__name__startswith' in local_var_params and local_var_params['simulation__name__startswith'] is not None:  # noqa: E501
            query_params.append(('simulation__name__startswith', local_var_params['simulation__name__startswith']))  # noqa: E501
        if 'simulation__name__istartswith' in local_var_params and local_var_params['simulation__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('simulation__name__istartswith', local_var_params['simulation__name__istartswith']))  # noqa: E501
        if 'simulation__name__endswith' in local_var_params and local_var_params['simulation__name__endswith'] is not None:  # noqa: E501
            query_params.append(('simulation__name__endswith', local_var_params['simulation__name__endswith']))  # noqa: E501
        if 'simulation__name__regex' in local_var_params and local_var_params['simulation__name__regex'] is not None:  # noqa: E501
            query_params.append(('simulation__name__regex', local_var_params['simulation__name__regex']))  # noqa: E501
        if 'simulation__compute_cluster__name' in local_var_params and local_var_params['simulation__compute_cluster__name'] is not None:  # noqa: E501
            query_params.append(('simulation__compute_cluster__name', local_var_params['simulation__compute_cluster__name']))  # noqa: E501
        if 'simulation__threedimodel__slug' in local_var_params and local_var_params['simulation__threedimodel__slug'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__slug', local_var_params['simulation__threedimodel__slug']))  # noqa: E501
        if 'simulation__threedimodel__slug__iexact' in local_var_params and local_var_params['simulation__threedimodel__slug__iexact'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__slug__iexact', local_var_params['simulation__threedimodel__slug__iexact']))  # noqa: E501
        if 'simulation__threedimodel__slug__contains' in local_var_params and local_var_params['simulation__threedimodel__slug__contains'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__slug__contains', local_var_params['simulation__threedimodel__slug__contains']))  # noqa: E501
        if 'simulation__threedimodel__slug__icontains' in local_var_params and local_var_params['simulation__threedimodel__slug__icontains'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__slug__icontains', local_var_params['simulation__threedimodel__slug__icontains']))  # noqa: E501
        if 'simulation__threedimodel__slug__in' in local_var_params and local_var_params['simulation__threedimodel__slug__in'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__slug__in', local_var_params['simulation__threedimodel__slug__in']))  # noqa: E501
        if 'simulation__threedimodel__slug__startswith' in local_var_params and local_var_params['simulation__threedimodel__slug__startswith'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__slug__startswith', local_var_params['simulation__threedimodel__slug__startswith']))  # noqa: E501
        if 'simulation__threedimodel__slug__istartswith' in local_var_params and local_var_params['simulation__threedimodel__slug__istartswith'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__slug__istartswith', local_var_params['simulation__threedimodel__slug__istartswith']))  # noqa: E501
        if 'simulation__threedimodel__slug__endswith' in local_var_params and local_var_params['simulation__threedimodel__slug__endswith'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__slug__endswith', local_var_params['simulation__threedimodel__slug__endswith']))  # noqa: E501
        if 'simulation__threedimodel__slug__regex' in local_var_params and local_var_params['simulation__threedimodel__slug__regex'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__slug__regex', local_var_params['simulation__threedimodel__slug__regex']))  # noqa: E501
        if 'created' in local_var_params and local_var_params['created'] is not None:  # noqa: E501
            query_params.append(('created', local_var_params['created']))  # noqa: E501
        if 'created__gt' in local_var_params and local_var_params['created__gt'] is not None:  # noqa: E501
            query_params.append(('created__gt', local_var_params['created__gt']))  # noqa: E501
        if 'created__gte' in local_var_params and local_var_params['created__gte'] is not None:  # noqa: E501
            query_params.append(('created__gte', local_var_params['created__gte']))  # noqa: E501
        if 'created__lt' in local_var_params and local_var_params['created__lt'] is not None:  # noqa: E501
            query_params.append(('created__lt', local_var_params['created__lt']))  # noqa: E501
        if 'created__lte' in local_var_params and local_var_params['created__lte'] is not None:  # noqa: E501
            query_params.append(('created__lte', local_var_params['created__lte']))  # noqa: E501
        if 'created__date' in local_var_params and local_var_params['created__date'] is not None:  # noqa: E501
            query_params.append(('created__date', local_var_params['created__date']))  # noqa: E501
        if 'created__date__gt' in local_var_params and local_var_params['created__date__gt'] is not None:  # noqa: E501
            query_params.append(('created__date__gt', local_var_params['created__date__gt']))  # noqa: E501
        if 'created__date__gte' in local_var_params and local_var_params['created__date__gte'] is not None:  # noqa: E501
            query_params.append(('created__date__gte', local_var_params['created__date__gte']))  # noqa: E501
        if 'created__date__lt' in local_var_params and local_var_params['created__date__lt'] is not None:  # noqa: E501
            query_params.append(('created__date__lt', local_var_params['created__date__lt']))  # noqa: E501
        if 'created__date__lte' in local_var_params and local_var_params['created__date__lte'] is not None:  # noqa: E501
            query_params.append(('created__date__lte', local_var_params['created__date__lte']))  # noqa: E501
        if 'created__year' in local_var_params and local_var_params['created__year'] is not None:  # noqa: E501
            query_params.append(('created__year', local_var_params['created__year']))  # noqa: E501
        if 'created__year__gt' in local_var_params and local_var_params['created__year__gt'] is not None:  # noqa: E501
            query_params.append(('created__year__gt', local_var_params['created__year__gt']))  # noqa: E501
        if 'created__year__gte' in local_var_params and local_var_params['created__year__gte'] is not None:  # noqa: E501
            query_params.append(('created__year__gte', local_var_params['created__year__gte']))  # noqa: E501
        if 'created__year__lt' in local_var_params and local_var_params['created__year__lt'] is not None:  # noqa: E501
            query_params.append(('created__year__lt', local_var_params['created__year__lt']))  # noqa: E501
        if 'created__year__lte' in local_var_params and local_var_params['created__year__lte'] is not None:  # noqa: E501
            query_params.append(('created__year__lte', local_var_params['created__year__lte']))  # noqa: E501
        if 'created__month' in local_var_params and local_var_params['created__month'] is not None:  # noqa: E501
            query_params.append(('created__month', local_var_params['created__month']))  # noqa: E501
        if 'created__month__lte' in local_var_params and local_var_params['created__month__lte'] is not None:  # noqa: E501
            query_params.append(('created__month__lte', local_var_params['created__month__lte']))  # noqa: E501
        if 'created__day' in local_var_params and local_var_params['created__day'] is not None:  # noqa: E501
            query_params.append(('created__day', local_var_params['created__day']))  # noqa: E501
        if 'created__day__lt' in local_var_params and local_var_params['created__day__lt'] is not None:  # noqa: E501
            query_params.append(('created__day__lt', local_var_params['created__day__lt']))  # noqa: E501
        if 'created__week' in local_var_params and local_var_params['created__week'] is not None:  # noqa: E501
            query_params.append(('created__week', local_var_params['created__week']))  # noqa: E501
        if 'created__week_day' in local_var_params and local_var_params['created__week_day'] is not None:  # noqa: E501
            query_params.append(('created__week_day', local_var_params['created__week_day']))  # noqa: E501
        if 'id' in local_var_params and local_var_params['id'] is not None:  # noqa: E501
            query_params.append(('id', local_var_params['id']))  # noqa: E501
        if 'id__gt' in local_var_params and local_var_params['id__gt'] is not None:  # noqa: E501
            query_params.append(('id__gt', local_var_params['id__gt']))  # noqa: E501
        if 'id__gte' in local_var_params and local_var_params['id__gte'] is not None:  # noqa: E501
            query_params.append(('id__gte', local_var_params['id__gte']))  # noqa: E501
        if 'id__lt' in local_var_params and local_var_params['id__lt'] is not None:  # noqa: E501
            query_params.append(('id__lt', local_var_params['id__lt']))  # noqa: E501
        if 'id__lte' in local_var_params and local_var_params['id__lte'] is not None:  # noqa: E501
            query_params.append(('id__lte', local_var_params['id__lte']))  # noqa: E501
        if 'id__isnull' in local_var_params and local_var_params['id__isnull'] is not None:  # noqa: E501
            query_params.append(('id__isnull', local_var_params['id__isnull']))  # noqa: E501
        if 'exit_code' in local_var_params and local_var_params['exit_code'] is not None:  # noqa: E501
            query_params.append(('exit_code', local_var_params['exit_code']))  # noqa: E501
        if 'exit_code__gt' in local_var_params and local_var_params['exit_code__gt'] is not None:  # noqa: E501
            query_params.append(('exit_code__gt', local_var_params['exit_code__gt']))  # noqa: E501
        if 'exit_code__gte' in local_var_params and local_var_params['exit_code__gte'] is not None:  # noqa: E501
            query_params.append(('exit_code__gte', local_var_params['exit_code__gte']))  # noqa: E501
        if 'exit_code__lt' in local_var_params and local_var_params['exit_code__lt'] is not None:  # noqa: E501
            query_params.append(('exit_code__lt', local_var_params['exit_code__lt']))  # noqa: E501
        if 'exit_code__lte' in local_var_params and local_var_params['exit_code__lte'] is not None:  # noqa: E501
            query_params.append(('exit_code__lte', local_var_params['exit_code__lte']))  # noqa: E501
        if 'exit_code__isnull' in local_var_params and local_var_params['exit_code__isnull'] is not None:  # noqa: E501
            query_params.append(('exit_code__isnull', local_var_params['exit_code__isnull']))  # noqa: E501
        if 'simulation_id__in' in local_var_params and local_var_params['simulation_id__in'] is not None:  # noqa: E501
            query_params.append(('simulation_id__in', local_var_params['simulation_id__in']))  # noqa: E501
        if 'simulation__user__username' in local_var_params and local_var_params['simulation__user__username'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username', local_var_params['simulation__user__username']))  # noqa: E501
        if 'simulation__type__live' in local_var_params and local_var_params['simulation__type__live'] is not None:  # noqa: E501
            query_params.append(('simulation__type__live', local_var_params['simulation__type__live']))  # noqa: E501
        if 'simulation__tags__contains' in local_var_params and local_var_params['simulation__tags__contains'] is not None:  # noqa: E501
            query_params.append(('simulation__tags__contains', local_var_params['simulation__tags__contains']))  # noqa: E501
        if 'simulation__organisation__name__istartswith' in local_var_params and local_var_params['simulation__organisation__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('simulation__organisation__name__istartswith', local_var_params['simulation__organisation__name__istartswith']))  # noqa: E501
        if 'simulation__organisation__unique_id' in local_var_params and local_var_params['simulation__organisation__unique_id'] is not None:  # noqa: E501
            query_params.append(('simulation__organisation__unique_id', local_var_params['simulation__organisation__unique_id']))  # noqa: E501
        if 'ordering' in local_var_params and local_var_params['ordering'] is not None:  # noqa: E501
            query_params.append(('ordering', local_var_params['ordering']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/statuses/statistics/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SimulationStatusStatistics]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_boundaryconditions_create(self, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_boundaryconditions_create  # noqa: E501

        A simple ViewSet for viewing boundary conditions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_boundaryconditions_create(threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param BoundaryCondition data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BoundaryCondition
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_boundaryconditions_create_with_http_info(threedimodel_pk, data, **kwargs)  # noqa: E501

    def threedimodels_boundaryconditions_create_with_http_info(self, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_boundaryconditions_create  # noqa: E501

        A simple ViewSet for viewing boundary conditions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_boundaryconditions_create_with_http_info(threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param BoundaryCondition data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BoundaryCondition, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'threedimodel_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_boundaryconditions_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_boundaryconditions_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_boundaryconditions_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/boundaryconditions/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BoundaryCondition',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_boundaryconditions_delete(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_boundaryconditions_delete  # noqa: E501

        A simple ViewSet for viewing boundary conditions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_boundaryconditions_delete(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this boundary condition. (required)
        :param str threedimodel_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_boundaryconditions_delete_with_http_info(id, threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_boundaryconditions_delete_with_http_info(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_boundaryconditions_delete  # noqa: E501

        A simple ViewSet for viewing boundary conditions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_boundaryconditions_delete_with_http_info(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this boundary condition. (required)
        :param str threedimodel_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_boundaryconditions_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_boundaryconditions_delete`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_boundaryconditions_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/boundaryconditions/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_boundaryconditions_list(self, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_boundaryconditions_list  # noqa: E501

        A simple ViewSet for viewing boundary conditions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_boundaryconditions_list(threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20074
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_boundaryconditions_list_with_http_info(threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_boundaryconditions_list_with_http_info(self, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_boundaryconditions_list  # noqa: E501

        A simple ViewSet for viewing boundary conditions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_boundaryconditions_list_with_http_info(threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20074, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'threedimodel_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_boundaryconditions_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_boundaryconditions_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/boundaryconditions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20074',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_boundaryconditions_partial_update(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_boundaryconditions_partial_update  # noqa: E501

        A simple ViewSet for viewing boundary conditions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_boundaryconditions_partial_update(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this boundary condition. (required)
        :param str threedimodel_pk: (required)
        :param BoundaryCondition data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BoundaryCondition
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_boundaryconditions_partial_update_with_http_info(id, threedimodel_pk, data, **kwargs)  # noqa: E501

    def threedimodels_boundaryconditions_partial_update_with_http_info(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_boundaryconditions_partial_update  # noqa: E501

        A simple ViewSet for viewing boundary conditions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_boundaryconditions_partial_update_with_http_info(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this boundary condition. (required)
        :param str threedimodel_pk: (required)
        :param BoundaryCondition data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BoundaryCondition, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_boundaryconditions_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_boundaryconditions_partial_update`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_boundaryconditions_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_boundaryconditions_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/boundaryconditions/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BoundaryCondition',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_boundaryconditions_read(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_boundaryconditions_read  # noqa: E501

        A simple ViewSet for viewing boundary conditions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_boundaryconditions_read(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this boundary condition. (required)
        :param str threedimodel_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BoundaryCondition
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_boundaryconditions_read_with_http_info(id, threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_boundaryconditions_read_with_http_info(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_boundaryconditions_read  # noqa: E501

        A simple ViewSet for viewing boundary conditions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_boundaryconditions_read_with_http_info(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this boundary condition. (required)
        :param str threedimodel_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BoundaryCondition, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_boundaryconditions_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_boundaryconditions_read`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_boundaryconditions_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/boundaryconditions/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BoundaryCondition',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_boundaryconditions_update(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_boundaryconditions_update  # noqa: E501

        A simple ViewSet for viewing boundary conditions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_boundaryconditions_update(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this boundary condition. (required)
        :param str threedimodel_pk: (required)
        :param BoundaryCondition data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BoundaryCondition
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_boundaryconditions_update_with_http_info(id, threedimodel_pk, data, **kwargs)  # noqa: E501

    def threedimodels_boundaryconditions_update_with_http_info(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_boundaryconditions_update  # noqa: E501

        A simple ViewSet for viewing boundary conditions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_boundaryconditions_update_with_http_info(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this boundary condition. (required)
        :param str threedimodel_pk: (required)
        :param BoundaryCondition data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BoundaryCondition, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_boundaryconditions_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_boundaryconditions_update`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_boundaryconditions_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_boundaryconditions_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/boundaryconditions/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BoundaryCondition',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_breaches_geojson_upload(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_breaches_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_breaches_geojson_upload(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_breaches_geojson_upload_with_http_info(id, data, **kwargs)  # noqa: E501

    def threedimodels_breaches_geojson_upload_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_breaches_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_breaches_geojson_upload_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_breaches_geojson_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_breaches_geojson_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_breaches_geojson_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/breaches/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_bulk_rasters_create(self, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_bulk_rasters_create  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_bulk_rasters_create(threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param list[Raster] data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[Raster]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_bulk_rasters_create_with_http_info(threedimodel_pk, data, **kwargs)  # noqa: E501

    def threedimodels_bulk_rasters_create_with_http_info(self, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_bulk_rasters_create  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_bulk_rasters_create_with_http_info(threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param list[Raster] data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[Raster], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'threedimodel_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_bulk_rasters_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_bulk_rasters_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_bulk_rasters_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/bulk_rasters/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Raster]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_cells_geojson_upload(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_cells_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_cells_geojson_upload(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_cells_geojson_upload_with_http_info(id, data, **kwargs)  # noqa: E501

    def threedimodels_cells_geojson_upload_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_cells_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_cells_geojson_upload_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_cells_geojson_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_cells_geojson_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_cells_geojson_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/cells/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_channels_geojson_upload(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_channels_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_channels_geojson_upload(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_channels_geojson_upload_with_http_info(id, data, **kwargs)  # noqa: E501

    def threedimodels_channels_geojson_upload_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_channels_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_channels_geojson_upload_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_channels_geojson_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_channels_geojson_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_channels_geojson_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/channels/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_create(self, data, **kwargs):  # noqa: E501
        """threedimodels_create  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ThreediModel data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ThreediModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_create_with_http_info(data, **kwargs)  # noqa: E501

    def threedimodels_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """threedimodels_create  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ThreediModel data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ThreediModel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreediModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_culverts_geojson_upload(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_culverts_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_culverts_geojson_upload(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_culverts_geojson_upload_with_http_info(id, data, **kwargs)  # noqa: E501

    def threedimodels_culverts_geojson_upload_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_culverts_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_culverts_geojson_upload_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_culverts_geojson_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_culverts_geojson_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_culverts_geojson_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/culverts/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_delete(self, id, **kwargs):  # noqa: E501
        """Soft-delete the threedimodel (sets disabled to True)  # noqa: E501

        If the model is already disabled and the user is a superuser, delete the threedimodel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_delete_with_http_info(id, **kwargs)  # noqa: E501

    def threedimodels_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """Soft-delete the threedimodel (sets disabled to True)  # noqa: E501

        If the model is already disabled and the user is a superuser, delete the threedimodel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_flowlines_geojson_upload(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_flowlines_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_flowlines_geojson_upload(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_flowlines_geojson_upload_with_http_info(id, data, **kwargs)  # noqa: E501

    def threedimodels_flowlines_geojson_upload_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_flowlines_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_flowlines_geojson_upload_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_flowlines_geojson_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_flowlines_geojson_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_flowlines_geojson_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/flowlines/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_geojson_breaches_download(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_breaches_download  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_breaches_download(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_geojson_breaches_download_with_http_info(id, **kwargs)  # noqa: E501

    def threedimodels_geojson_breaches_download_with_http_info(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_breaches_download  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_breaches_download_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_geojson_breaches_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_geojson_breaches_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/breaches/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_geojson_cells_download(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_cells_download  # noqa: E501

        Note that this is the subset of 2d open_water cells  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_cells_download(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_geojson_cells_download_with_http_info(id, **kwargs)  # noqa: E501

    def threedimodels_geojson_cells_download_with_http_info(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_cells_download  # noqa: E501

        Note that this is the subset of 2d open_water cells  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_cells_download_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_geojson_cells_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_geojson_cells_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/cells/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_geojson_channels_download(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_channels_download  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_channels_download(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_geojson_channels_download_with_http_info(id, **kwargs)  # noqa: E501

    def threedimodels_geojson_channels_download_with_http_info(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_channels_download  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_channels_download_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_geojson_channels_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_geojson_channels_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/channels/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_geojson_culverts_download(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_culverts_download  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_culverts_download(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_geojson_culverts_download_with_http_info(id, **kwargs)  # noqa: E501

    def threedimodels_geojson_culverts_download_with_http_info(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_culverts_download  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_culverts_download_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_geojson_culverts_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_geojson_culverts_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/culverts/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_geojson_download(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_download  # noqa: E501

        Endpoint for downloading geojson file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_download(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_geojson_download_with_http_info(id, **kwargs)  # noqa: E501

    def threedimodels_geojson_download_with_http_info(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_download  # noqa: E501

        Endpoint for downloading geojson file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_download_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_geojson_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_geojson_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/all/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_geojson_flowlines_download(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_flowlines_download  # noqa: E501

        Note that this is a subset of all lines  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_flowlines_download(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_geojson_flowlines_download_with_http_info(id, **kwargs)  # noqa: E501

    def threedimodels_geojson_flowlines_download_with_http_info(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_flowlines_download  # noqa: E501

        Note that this is a subset of all lines  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_flowlines_download_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_geojson_flowlines_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_geojson_flowlines_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/flowlines/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_geojson_levees_download(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_levees_download  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_levees_download(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_geojson_levees_download_with_http_info(id, **kwargs)  # noqa: E501

    def threedimodels_geojson_levees_download_with_http_info(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_levees_download  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_levees_download_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_geojson_levees_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_geojson_levees_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/levees/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_geojson_manholes_download(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_manholes_download  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_manholes_download(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_geojson_manholes_download_with_http_info(id, **kwargs)  # noqa: E501

    def threedimodels_geojson_manholes_download_with_http_info(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_manholes_download  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_manholes_download_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_geojson_manholes_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_geojson_manholes_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/manholes/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_geojson_orifices_download(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_orifices_download  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_orifices_download(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_geojson_orifices_download_with_http_info(id, **kwargs)  # noqa: E501

    def threedimodels_geojson_orifices_download_with_http_info(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_orifices_download  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_orifices_download_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_geojson_orifices_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_geojson_orifices_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/orifices/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_geojson_pipes_download(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_pipes_download  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_pipes_download(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_geojson_pipes_download_with_http_info(id, **kwargs)  # noqa: E501

    def threedimodels_geojson_pipes_download_with_http_info(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_pipes_download  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_pipes_download_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_geojson_pipes_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_geojson_pipes_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/pipes/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_geojson_pumps_download(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_pumps_download  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_pumps_download(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_geojson_pumps_download_with_http_info(id, **kwargs)  # noqa: E501

    def threedimodels_geojson_pumps_download_with_http_info(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_pumps_download  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_pumps_download_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_geojson_pumps_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_geojson_pumps_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/pumps/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_geojson_upload(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_geojson_upload  # noqa: E501

        Endpoint for uploading the geojson file Replaces the geojson file if there already exists one.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_upload(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_geojson_upload_with_http_info(id, data, **kwargs)  # noqa: E501

    def threedimodels_geojson_upload_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_geojson_upload  # noqa: E501

        Endpoint for uploading the geojson file Replaces the geojson file if there already exists one.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_upload_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_geojson_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_geojson_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_geojson_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/all/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_geojson_weirs_download(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_weirs_download  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_weirs_download(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_geojson_weirs_download_with_http_info(id, **kwargs)  # noqa: E501

    def threedimodels_geojson_weirs_download_with_http_info(self, id, **kwargs):  # noqa: E501
        """threedimodels_geojson_weirs_download  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geojson_weirs_download_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_geojson_weirs_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_geojson_weirs_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/weirs/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_geopackage_download(self, id, **kwargs):  # noqa: E501
        """threedimodels_geopackage_download  # noqa: E501

        Endpoint for downloading geopackage file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geopackage_download(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_geopackage_download_with_http_info(id, **kwargs)  # noqa: E501

    def threedimodels_geopackage_download_with_http_info(self, id, **kwargs):  # noqa: E501
        """threedimodels_geopackage_download  # noqa: E501

        Endpoint for downloading geopackage file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geopackage_download_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_geopackage_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_geopackage_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geopackage/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_geopackage_upload(self, id, data, **kwargs):  # noqa: E501
        """Endpoint for uploading the gridadmin file  # noqa: E501

        Replaces the gridadmin if there already exists one.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geopackage_upload(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_geopackage_upload_with_http_info(id, data, **kwargs)  # noqa: E501

    def threedimodels_geopackage_upload_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """Endpoint for uploading the gridadmin file  # noqa: E501

        Replaces the gridadmin if there already exists one.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_geopackage_upload_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_geopackage_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_geopackage_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_geopackage_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geopackage/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_gridadmin_download(self, id, **kwargs):  # noqa: E501
        """threedimodels_gridadmin_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_gridadmin_download(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_gridadmin_download_with_http_info(id, **kwargs)  # noqa: E501

    def threedimodels_gridadmin_download_with_http_info(self, id, **kwargs):  # noqa: E501
        """threedimodels_gridadmin_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_gridadmin_download_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_gridadmin_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_gridadmin_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/gridadmin/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_gridadmin_upload(self, id, data, **kwargs):  # noqa: E501
        """Endpoint for uploading the gridadmin file  # noqa: E501

        Replaces the gridadmin if there already exists one.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_gridadmin_upload(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_gridadmin_upload_with_http_info(id, data, **kwargs)  # noqa: E501

    def threedimodels_gridadmin_upload_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """Endpoint for uploading the gridadmin file  # noqa: E501

        Replaces the gridadmin if there already exists one.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_gridadmin_upload_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_gridadmin_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_gridadmin_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_gridadmin_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/gridadmin/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_initial_waterlevels_create(self, threedimodel_pk, data, **kwargs):  # noqa: E501
        """Add new initial waterlevels  # noqa: E501

        ### Adding (extra) 1D initial waterlevels Extra 1D initial waterlevels can be added by posting:  {\"dimension\": \"one_d\"}  Using the 'id' value from the response, a JSON file needs to be uploaded via the PUT_URL retrieved from `initial_waterlevels/{id}/upload/` in the following JSON format:  Python code:      import json     file_contents = json.dumps({         \"node_ids\": [node_id_1, node_id2, ....],         \"values\" : [value_for_node_id_1, value_for_node_id_2, ...]     })      # Notes:     # - Omitted values are considered dry.     # - `node_ids` need to be sorted and unique     # - Make sure that the positions of the node_id's and values match.  ### Adding (extra) 2D initial waterlevels 2D initial waterlevels can be added by uploading an 'initial_waterlevel_file' Geotiff raster via `rasters/{id}/upload/`. This automatically triggers the creation of a 2D initial waterlevel. The source raster is linked as 'source_raster'. The values in the `source_raster` are aggregated per node using max, min and mean operators. The resulting values are stored in a file linked under `file`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_initial_waterlevels_create(threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param InitialWaterlevel data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InitialWaterlevel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_initial_waterlevels_create_with_http_info(threedimodel_pk, data, **kwargs)  # noqa: E501

    def threedimodels_initial_waterlevels_create_with_http_info(self, threedimodel_pk, data, **kwargs):  # noqa: E501
        """Add new initial waterlevels  # noqa: E501

        ### Adding (extra) 1D initial waterlevels Extra 1D initial waterlevels can be added by posting:  {\"dimension\": \"one_d\"}  Using the 'id' value from the response, a JSON file needs to be uploaded via the PUT_URL retrieved from `initial_waterlevels/{id}/upload/` in the following JSON format:  Python code:      import json     file_contents = json.dumps({         \"node_ids\": [node_id_1, node_id2, ....],         \"values\" : [value_for_node_id_1, value_for_node_id_2, ...]     })      # Notes:     # - Omitted values are considered dry.     # - `node_ids` need to be sorted and unique     # - Make sure that the positions of the node_id's and values match.  ### Adding (extra) 2D initial waterlevels 2D initial waterlevels can be added by uploading an 'initial_waterlevel_file' Geotiff raster via `rasters/{id}/upload/`. This automatically triggers the creation of a 2D initial waterlevel. The source raster is linked as 'source_raster'. The values in the `source_raster` are aggregated per node using max, min and mean operators. The resulting values are stored in a file linked under `file`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_initial_waterlevels_create_with_http_info(threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param InitialWaterlevel data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InitialWaterlevel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'threedimodel_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_initial_waterlevels_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_initial_waterlevels_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_initial_waterlevels_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/initial_waterlevels/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InitialWaterlevel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_initial_waterlevels_delete(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_initial_waterlevels_delete  # noqa: E501

        Delete initial waterlevel  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_initial_waterlevels_delete(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial waterlevel. (required)
        :param str threedimodel_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_initial_waterlevels_delete_with_http_info(id, threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_initial_waterlevels_delete_with_http_info(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_initial_waterlevels_delete  # noqa: E501

        Delete initial waterlevel  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_initial_waterlevels_delete_with_http_info(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial waterlevel. (required)
        :param str threedimodel_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_initial_waterlevels_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_initial_waterlevels_delete`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_initial_waterlevels_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/initial_waterlevels/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_initial_waterlevels_download(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_initial_waterlevels_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_initial_waterlevels_download(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial waterlevel. (required)
        :param str threedimodel_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_initial_waterlevels_download_with_http_info(id, threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_initial_waterlevels_download_with_http_info(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_initial_waterlevels_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_initial_waterlevels_download_with_http_info(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial waterlevel. (required)
        :param str threedimodel_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_initial_waterlevels_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_initial_waterlevels_download`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_initial_waterlevels_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/initial_waterlevels/{id}/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_initial_waterlevels_list(self, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_initial_waterlevels_list  # noqa: E501

        ## Description Initial waterlevels on threedimodels can be used in a simulation to specify the initial waterlevels on the 1D and/or 2D domain.  ### Initial waterlevels from schematisation 1D and 2D initial waterlevels in the schematisation are automatically picked up during the creation of the threedimodel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_initial_waterlevels_list(threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20075
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_initial_waterlevels_list_with_http_info(threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_initial_waterlevels_list_with_http_info(self, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_initial_waterlevels_list  # noqa: E501

        ## Description Initial waterlevels on threedimodels can be used in a simulation to specify the initial waterlevels on the 1D and/or 2D domain.  ### Initial waterlevels from schematisation 1D and 2D initial waterlevels in the schematisation are automatically picked up during the creation of the threedimodel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_initial_waterlevels_list_with_http_info(threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20075, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'threedimodel_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_initial_waterlevels_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_initial_waterlevels_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/initial_waterlevels/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20075',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_initial_waterlevels_partial_update(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_initial_waterlevels_partial_update  # noqa: E501

        ## Description Initial waterlevels on threedimodels can be used in a simulation to specify the initial waterlevels on the 1D and/or 2D domain.  ### Initial waterlevels from schematisation 1D and 2D initial waterlevels in the schematisation are automatically picked up during the creation of the threedimodel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_initial_waterlevels_partial_update(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial waterlevel. (required)
        :param str threedimodel_pk: (required)
        :param InitialWaterlevel data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InitialWaterlevel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_initial_waterlevels_partial_update_with_http_info(id, threedimodel_pk, data, **kwargs)  # noqa: E501

    def threedimodels_initial_waterlevels_partial_update_with_http_info(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_initial_waterlevels_partial_update  # noqa: E501

        ## Description Initial waterlevels on threedimodels can be used in a simulation to specify the initial waterlevels on the 1D and/or 2D domain.  ### Initial waterlevels from schematisation 1D and 2D initial waterlevels in the schematisation are automatically picked up during the creation of the threedimodel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_initial_waterlevels_partial_update_with_http_info(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial waterlevel. (required)
        :param str threedimodel_pk: (required)
        :param InitialWaterlevel data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InitialWaterlevel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_initial_waterlevels_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_initial_waterlevels_partial_update`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_initial_waterlevels_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_initial_waterlevels_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/initial_waterlevels/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InitialWaterlevel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_initial_waterlevels_processed(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_initial_waterlevels_processed  # noqa: E501

        ## Description Initial waterlevels on threedimodels can be used in a simulation to specify the initial waterlevels on the 1D and/or 2D domain.  ### Initial waterlevels from schematisation 1D and 2D initial waterlevels in the schematisation are automatically picked up during the creation of the threedimodel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_initial_waterlevels_processed(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial waterlevel. (required)
        :param str threedimodel_pk: (required)
        :param BaseEventState data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_initial_waterlevels_processed_with_http_info(id, threedimodel_pk, data, **kwargs)  # noqa: E501

    def threedimodels_initial_waterlevels_processed_with_http_info(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_initial_waterlevels_processed  # noqa: E501

        ## Description Initial waterlevels on threedimodels can be used in a simulation to specify the initial waterlevels on the 1D and/or 2D domain.  ### Initial waterlevels from schematisation 1D and 2D initial waterlevels in the schematisation are automatically picked up during the creation of the threedimodel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_initial_waterlevels_processed_with_http_info(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial waterlevel. (required)
        :param str threedimodel_pk: (required)
        :param BaseEventState data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_initial_waterlevels_processed" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_initial_waterlevels_processed`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_initial_waterlevels_processed`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_initial_waterlevels_processed`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/initial_waterlevels/{id}/processed/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_initial_waterlevels_read(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_initial_waterlevels_read  # noqa: E501

        ## Description Initial waterlevels on threedimodels can be used in a simulation to specify the initial waterlevels on the 1D and/or 2D domain.  ### Initial waterlevels from schematisation 1D and 2D initial waterlevels in the schematisation are automatically picked up during the creation of the threedimodel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_initial_waterlevels_read(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial waterlevel. (required)
        :param str threedimodel_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InitialWaterlevel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_initial_waterlevels_read_with_http_info(id, threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_initial_waterlevels_read_with_http_info(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_initial_waterlevels_read  # noqa: E501

        ## Description Initial waterlevels on threedimodels can be used in a simulation to specify the initial waterlevels on the 1D and/or 2D domain.  ### Initial waterlevels from schematisation 1D and 2D initial waterlevels in the schematisation are automatically picked up during the creation of the threedimodel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_initial_waterlevels_read_with_http_info(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial waterlevel. (required)
        :param str threedimodel_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InitialWaterlevel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_initial_waterlevels_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_initial_waterlevels_read`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_initial_waterlevels_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/initial_waterlevels/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InitialWaterlevel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_initial_waterlevels_update(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_initial_waterlevels_update  # noqa: E501

        ## Description Initial waterlevels on threedimodels can be used in a simulation to specify the initial waterlevels on the 1D and/or 2D domain.  ### Initial waterlevels from schematisation 1D and 2D initial waterlevels in the schematisation are automatically picked up during the creation of the threedimodel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_initial_waterlevels_update(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial waterlevel. (required)
        :param str threedimodel_pk: (required)
        :param InitialWaterlevel data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InitialWaterlevel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_initial_waterlevels_update_with_http_info(id, threedimodel_pk, data, **kwargs)  # noqa: E501

    def threedimodels_initial_waterlevels_update_with_http_info(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_initial_waterlevels_update  # noqa: E501

        ## Description Initial waterlevels on threedimodels can be used in a simulation to specify the initial waterlevels on the 1D and/or 2D domain.  ### Initial waterlevels from schematisation 1D and 2D initial waterlevels in the schematisation are automatically picked up during the creation of the threedimodel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_initial_waterlevels_update_with_http_info(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial waterlevel. (required)
        :param str threedimodel_pk: (required)
        :param InitialWaterlevel data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InitialWaterlevel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_initial_waterlevels_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_initial_waterlevels_update`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_initial_waterlevels_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_initial_waterlevels_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/initial_waterlevels/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InitialWaterlevel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_initial_waterlevels_upload(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_initial_waterlevels_upload  # noqa: E501

        Endpoint for uploading an initial waterlevel file, see the POST endpoint for documentation about the file format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_initial_waterlevels_upload(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial waterlevel. (required)
        :param str threedimodel_pk: (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_initial_waterlevels_upload_with_http_info(id, threedimodel_pk, data, **kwargs)  # noqa: E501

    def threedimodels_initial_waterlevels_upload_with_http_info(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_initial_waterlevels_upload  # noqa: E501

        Endpoint for uploading an initial waterlevel file, see the POST endpoint for documentation about the file format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_initial_waterlevels_upload_with_http_info(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this initial waterlevel. (required)
        :param str threedimodel_pk: (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_initial_waterlevels_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_initial_waterlevels_upload`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_initial_waterlevels_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_initial_waterlevels_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/initial_waterlevels/{id}/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_levees_geojson_upload(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_levees_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_levees_geojson_upload(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_levees_geojson_upload_with_http_info(id, data, **kwargs)  # noqa: E501

    def threedimodels_levees_geojson_upload_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_levees_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_levees_geojson_upload_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_levees_geojson_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_levees_geojson_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_levees_geojson_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/levees/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_list(self, **kwargs):  # noqa: E501
        """threedimodels_list  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: name
        :param str name__iexact: name__iexact
        :param str name__contains: name__contains
        :param str name__icontains: name__icontains
        :param str name__in: name__in
        :param str name__startswith: name__startswith
        :param str name__istartswith: name__istartswith
        :param str name__endswith: name__endswith
        :param str name__regex: name__regex
        :param str slug: slug
        :param str slug__iexact: slug__iexact
        :param str slug__contains: slug__contains
        :param str slug__icontains: slug__icontains
        :param str slug__in: slug__in
        :param str slug__startswith: slug__startswith
        :param str slug__istartswith: slug__istartswith
        :param str slug__endswith: slug__endswith
        :param str slug__regex: slug__regex
        :param str epsg: epsg
        :param str id: id
        :param str is_valid: is_valid
        :param str inpy_version__slug: inpy_version__slug
        :param str inpy_version__slug__iexact: inpy_version__slug__iexact
        :param str inpy_version__slug__contains: inpy_version__slug__contains
        :param str inpy_version__slug__icontains: inpy_version__slug__icontains
        :param str inpy_version__slug__in: inpy_version__slug__in
        :param str inpy_version__slug__startswith: inpy_version__slug__startswith
        :param str inpy_version__slug__istartswith: inpy_version__slug__istartswith
        :param str inpy_version__slug__endswith: inpy_version__slug__endswith
        :param str inpy_version__slug__regex: inpy_version__slug__regex
        :param str inpy_version__threedi_version: inpy_version__threedi_version
        :param str inpy_version__threedi_version__iexact: inpy_version__threedi_version__iexact
        :param str inpy_version__threedi_version__contains: inpy_version__threedi_version__contains
        :param str inpy_version__threedi_version__icontains: inpy_version__threedi_version__icontains
        :param str inpy_version__threedi_version__in: inpy_version__threedi_version__in
        :param str inpy_version__threedi_version__startswith: inpy_version__threedi_version__startswith
        :param str inpy_version__threedi_version__istartswith: inpy_version__threedi_version__istartswith
        :param str inpy_version__threedi_version__endswith: inpy_version__threedi_version__endswith
        :param str inpy_version__threedi_version__regex: inpy_version__threedi_version__regex
        :param str inpy_version__threedicore_version: inpy_version__threedicore_version
        :param str inpy_version__threedicore_version__iexact: inpy_version__threedicore_version__iexact
        :param str inpy_version__threedicore_version__contains: inpy_version__threedicore_version__contains
        :param str inpy_version__threedicore_version__icontains: inpy_version__threedicore_version__icontains
        :param str inpy_version__threedicore_version__in: inpy_version__threedicore_version__in
        :param str inpy_version__threedicore_version__startswith: inpy_version__threedicore_version__startswith
        :param str inpy_version__threedicore_version__istartswith: inpy_version__threedicore_version__istartswith
        :param str inpy_version__threedicore_version__endswith: inpy_version__threedicore_version__endswith
        :param str inpy_version__threedicore_version__regex: inpy_version__threedicore_version__regex
        :param str revision__commit_user__username: revision__commit_user__username
        :param str revision__commit_user__username__istartswith: revision__commit_user__username__istartswith
        :param str revision__id: revision__id
        :param str revision__number: revision__number
        :param str revision__number__gt: revision__number__gt
        :param str revision__number__gte: revision__number__gte
        :param str revision__number__lt: revision__number__lt
        :param str revision__number__lte: revision__number__lte
        :param str revision__number__isnull: revision__number__isnull
        :param str revision__hash: revision__hash
        :param str revision__hash__iexact: revision__hash__iexact
        :param str revision__hash__contains: revision__hash__contains
        :param str revision__hash__icontains: revision__hash__icontains
        :param str revision__hash__in: revision__hash__in
        :param str revision__hash__startswith: revision__hash__startswith
        :param str revision__hash__istartswith: revision__hash__istartswith
        :param str revision__hash__endswith: revision__hash__endswith
        :param str revision__hash__regex: revision__hash__regex
        :param str revision__schematisation__isnull: revision__schematisation__isnull
        :param str revision__schematisation__name: revision__schematisation__name
        :param str revision__schematisation__name__iexact: revision__schematisation__name__iexact
        :param str revision__schematisation__name__contains: revision__schematisation__name__contains
        :param str revision__schematisation__name__icontains: revision__schematisation__name__icontains
        :param str revision__schematisation__name__in: revision__schematisation__name__in
        :param str revision__schematisation__name__startswith: revision__schematisation__name__startswith
        :param str revision__schematisation__name__istartswith: revision__schematisation__name__istartswith
        :param str revision__schematisation__name__endswith: revision__schematisation__name__endswith
        :param str revision__schematisation__name__regex: revision__schematisation__name__regex
        :param str revision__repository__organisation__unique_id: revision__repository__organisation__unique_id
        :param str revision__repository__organisation__unique_id__iexact: revision__repository__organisation__unique_id__iexact
        :param str revision__repository__organisation__unique_id__contains: revision__repository__organisation__unique_id__contains
        :param str revision__repository__organisation__unique_id__icontains: revision__repository__organisation__unique_id__icontains
        :param str revision__repository__organisation__unique_id__in: revision__repository__organisation__unique_id__in
        :param str revision__repository__organisation__unique_id__startswith: revision__repository__organisation__unique_id__startswith
        :param str revision__repository__organisation__unique_id__istartswith: revision__repository__organisation__unique_id__istartswith
        :param str revision__repository__organisation__unique_id__endswith: revision__repository__organisation__unique_id__endswith
        :param str revision__repository__organisation__unique_id__regex: revision__repository__organisation__unique_id__regex
        :param str revision__schematisation__owner__unique_id: revision__schematisation__owner__unique_id
        :param str revision__schematisation__id: revision__schematisation__id
        :param str created__range: created__range
        :param str created__date: created__date
        :param str created__date__gt: created__date__gt
        :param str created__date__gte: created__date__gte
        :param str created__date__lt: created__date__lt
        :param str created__date__lte: created__date__lte
        :param str created__year: created__year
        :param str created__year__gt: created__year__gt
        :param str created__year__gte: created__year__gte
        :param str created__year__lt: created__year__lt
        :param str created__year__lte: created__year__lte
        :param str created__month: created__month
        :param str created__month__lte: created__month__lte
        :param str created__day: created__day
        :param str created__day__lt: created__day__lt
        :param str created__week: created__week
        :param str created__week_day: created__week_day
        :param str created__quarter: created__quarter
        :param str created__time: created__time
        :param str created__hour: created__hour
        :param str created__minute: created__minute
        :param str created__second: created__second
        :param str created__isnull: created__isnull
        :param str revision__is_pinned: revision__is_pinned
        :param str revision__schematisation__tags__in: revision__schematisation__tags__in
        :param str disabled: disabled
        :param str inp_success: inp_success
        :param str inpy_version__active: inpy_version__active
        :param str is_generating: is_generating
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20073
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_list_with_http_info(**kwargs)  # noqa: E501

    def threedimodels_list_with_http_info(self, **kwargs):  # noqa: E501
        """threedimodels_list  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: name
        :param str name__iexact: name__iexact
        :param str name__contains: name__contains
        :param str name__icontains: name__icontains
        :param str name__in: name__in
        :param str name__startswith: name__startswith
        :param str name__istartswith: name__istartswith
        :param str name__endswith: name__endswith
        :param str name__regex: name__regex
        :param str slug: slug
        :param str slug__iexact: slug__iexact
        :param str slug__contains: slug__contains
        :param str slug__icontains: slug__icontains
        :param str slug__in: slug__in
        :param str slug__startswith: slug__startswith
        :param str slug__istartswith: slug__istartswith
        :param str slug__endswith: slug__endswith
        :param str slug__regex: slug__regex
        :param str epsg: epsg
        :param str id: id
        :param str is_valid: is_valid
        :param str inpy_version__slug: inpy_version__slug
        :param str inpy_version__slug__iexact: inpy_version__slug__iexact
        :param str inpy_version__slug__contains: inpy_version__slug__contains
        :param str inpy_version__slug__icontains: inpy_version__slug__icontains
        :param str inpy_version__slug__in: inpy_version__slug__in
        :param str inpy_version__slug__startswith: inpy_version__slug__startswith
        :param str inpy_version__slug__istartswith: inpy_version__slug__istartswith
        :param str inpy_version__slug__endswith: inpy_version__slug__endswith
        :param str inpy_version__slug__regex: inpy_version__slug__regex
        :param str inpy_version__threedi_version: inpy_version__threedi_version
        :param str inpy_version__threedi_version__iexact: inpy_version__threedi_version__iexact
        :param str inpy_version__threedi_version__contains: inpy_version__threedi_version__contains
        :param str inpy_version__threedi_version__icontains: inpy_version__threedi_version__icontains
        :param str inpy_version__threedi_version__in: inpy_version__threedi_version__in
        :param str inpy_version__threedi_version__startswith: inpy_version__threedi_version__startswith
        :param str inpy_version__threedi_version__istartswith: inpy_version__threedi_version__istartswith
        :param str inpy_version__threedi_version__endswith: inpy_version__threedi_version__endswith
        :param str inpy_version__threedi_version__regex: inpy_version__threedi_version__regex
        :param str inpy_version__threedicore_version: inpy_version__threedicore_version
        :param str inpy_version__threedicore_version__iexact: inpy_version__threedicore_version__iexact
        :param str inpy_version__threedicore_version__contains: inpy_version__threedicore_version__contains
        :param str inpy_version__threedicore_version__icontains: inpy_version__threedicore_version__icontains
        :param str inpy_version__threedicore_version__in: inpy_version__threedicore_version__in
        :param str inpy_version__threedicore_version__startswith: inpy_version__threedicore_version__startswith
        :param str inpy_version__threedicore_version__istartswith: inpy_version__threedicore_version__istartswith
        :param str inpy_version__threedicore_version__endswith: inpy_version__threedicore_version__endswith
        :param str inpy_version__threedicore_version__regex: inpy_version__threedicore_version__regex
        :param str revision__commit_user__username: revision__commit_user__username
        :param str revision__commit_user__username__istartswith: revision__commit_user__username__istartswith
        :param str revision__id: revision__id
        :param str revision__number: revision__number
        :param str revision__number__gt: revision__number__gt
        :param str revision__number__gte: revision__number__gte
        :param str revision__number__lt: revision__number__lt
        :param str revision__number__lte: revision__number__lte
        :param str revision__number__isnull: revision__number__isnull
        :param str revision__hash: revision__hash
        :param str revision__hash__iexact: revision__hash__iexact
        :param str revision__hash__contains: revision__hash__contains
        :param str revision__hash__icontains: revision__hash__icontains
        :param str revision__hash__in: revision__hash__in
        :param str revision__hash__startswith: revision__hash__startswith
        :param str revision__hash__istartswith: revision__hash__istartswith
        :param str revision__hash__endswith: revision__hash__endswith
        :param str revision__hash__regex: revision__hash__regex
        :param str revision__schematisation__isnull: revision__schematisation__isnull
        :param str revision__schematisation__name: revision__schematisation__name
        :param str revision__schematisation__name__iexact: revision__schematisation__name__iexact
        :param str revision__schematisation__name__contains: revision__schematisation__name__contains
        :param str revision__schematisation__name__icontains: revision__schematisation__name__icontains
        :param str revision__schematisation__name__in: revision__schematisation__name__in
        :param str revision__schematisation__name__startswith: revision__schematisation__name__startswith
        :param str revision__schematisation__name__istartswith: revision__schematisation__name__istartswith
        :param str revision__schematisation__name__endswith: revision__schematisation__name__endswith
        :param str revision__schematisation__name__regex: revision__schematisation__name__regex
        :param str revision__repository__organisation__unique_id: revision__repository__organisation__unique_id
        :param str revision__repository__organisation__unique_id__iexact: revision__repository__organisation__unique_id__iexact
        :param str revision__repository__organisation__unique_id__contains: revision__repository__organisation__unique_id__contains
        :param str revision__repository__organisation__unique_id__icontains: revision__repository__organisation__unique_id__icontains
        :param str revision__repository__organisation__unique_id__in: revision__repository__organisation__unique_id__in
        :param str revision__repository__organisation__unique_id__startswith: revision__repository__organisation__unique_id__startswith
        :param str revision__repository__organisation__unique_id__istartswith: revision__repository__organisation__unique_id__istartswith
        :param str revision__repository__organisation__unique_id__endswith: revision__repository__organisation__unique_id__endswith
        :param str revision__repository__organisation__unique_id__regex: revision__repository__organisation__unique_id__regex
        :param str revision__schematisation__owner__unique_id: revision__schematisation__owner__unique_id
        :param str revision__schematisation__id: revision__schematisation__id
        :param str created__range: created__range
        :param str created__date: created__date
        :param str created__date__gt: created__date__gt
        :param str created__date__gte: created__date__gte
        :param str created__date__lt: created__date__lt
        :param str created__date__lte: created__date__lte
        :param str created__year: created__year
        :param str created__year__gt: created__year__gt
        :param str created__year__gte: created__year__gte
        :param str created__year__lt: created__year__lt
        :param str created__year__lte: created__year__lte
        :param str created__month: created__month
        :param str created__month__lte: created__month__lte
        :param str created__day: created__day
        :param str created__day__lt: created__day__lt
        :param str created__week: created__week
        :param str created__week_day: created__week_day
        :param str created__quarter: created__quarter
        :param str created__time: created__time
        :param str created__hour: created__hour
        :param str created__minute: created__minute
        :param str created__second: created__second
        :param str created__isnull: created__isnull
        :param str revision__is_pinned: revision__is_pinned
        :param str revision__schematisation__tags__in: revision__schematisation__tags__in
        :param str disabled: disabled
        :param str inp_success: inp_success
        :param str inpy_version__active: inpy_version__active
        :param str is_generating: is_generating
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20073, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'name__iexact',
            'name__contains',
            'name__icontains',
            'name__in',
            'name__startswith',
            'name__istartswith',
            'name__endswith',
            'name__regex',
            'slug',
            'slug__iexact',
            'slug__contains',
            'slug__icontains',
            'slug__in',
            'slug__startswith',
            'slug__istartswith',
            'slug__endswith',
            'slug__regex',
            'epsg',
            'id',
            'is_valid',
            'inpy_version__slug',
            'inpy_version__slug__iexact',
            'inpy_version__slug__contains',
            'inpy_version__slug__icontains',
            'inpy_version__slug__in',
            'inpy_version__slug__startswith',
            'inpy_version__slug__istartswith',
            'inpy_version__slug__endswith',
            'inpy_version__slug__regex',
            'inpy_version__threedi_version',
            'inpy_version__threedi_version__iexact',
            'inpy_version__threedi_version__contains',
            'inpy_version__threedi_version__icontains',
            'inpy_version__threedi_version__in',
            'inpy_version__threedi_version__startswith',
            'inpy_version__threedi_version__istartswith',
            'inpy_version__threedi_version__endswith',
            'inpy_version__threedi_version__regex',
            'inpy_version__threedicore_version',
            'inpy_version__threedicore_version__iexact',
            'inpy_version__threedicore_version__contains',
            'inpy_version__threedicore_version__icontains',
            'inpy_version__threedicore_version__in',
            'inpy_version__threedicore_version__startswith',
            'inpy_version__threedicore_version__istartswith',
            'inpy_version__threedicore_version__endswith',
            'inpy_version__threedicore_version__regex',
            'revision__commit_user__username',
            'revision__commit_user__username__istartswith',
            'revision__id',
            'revision__number',
            'revision__number__gt',
            'revision__number__gte',
            'revision__number__lt',
            'revision__number__lte',
            'revision__number__isnull',
            'revision__hash',
            'revision__hash__iexact',
            'revision__hash__contains',
            'revision__hash__icontains',
            'revision__hash__in',
            'revision__hash__startswith',
            'revision__hash__istartswith',
            'revision__hash__endswith',
            'revision__hash__regex',
            'revision__schematisation__isnull',
            'revision__schematisation__name',
            'revision__schematisation__name__iexact',
            'revision__schematisation__name__contains',
            'revision__schematisation__name__icontains',
            'revision__schematisation__name__in',
            'revision__schematisation__name__startswith',
            'revision__schematisation__name__istartswith',
            'revision__schematisation__name__endswith',
            'revision__schematisation__name__regex',
            'revision__repository__organisation__unique_id',
            'revision__repository__organisation__unique_id__iexact',
            'revision__repository__organisation__unique_id__contains',
            'revision__repository__organisation__unique_id__icontains',
            'revision__repository__organisation__unique_id__in',
            'revision__repository__organisation__unique_id__startswith',
            'revision__repository__organisation__unique_id__istartswith',
            'revision__repository__organisation__unique_id__endswith',
            'revision__repository__organisation__unique_id__regex',
            'revision__schematisation__owner__unique_id',
            'revision__schematisation__id',
            'created__range',
            'created__date',
            'created__date__gt',
            'created__date__gte',
            'created__date__lt',
            'created__date__lte',
            'created__year',
            'created__year__gt',
            'created__year__gte',
            'created__year__lt',
            'created__year__lte',
            'created__month',
            'created__month__lte',
            'created__day',
            'created__day__lt',
            'created__week',
            'created__week_day',
            'created__quarter',
            'created__time',
            'created__hour',
            'created__minute',
            'created__second',
            'created__isnull',
            'revision__is_pinned',
            'revision__schematisation__tags__in',
            'disabled',
            'inp_success',
            'inpy_version__active',
            'is_generating',
            'ordering',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'name__iexact' in local_var_params and local_var_params['name__iexact'] is not None:  # noqa: E501
            query_params.append(('name__iexact', local_var_params['name__iexact']))  # noqa: E501
        if 'name__contains' in local_var_params and local_var_params['name__contains'] is not None:  # noqa: E501
            query_params.append(('name__contains', local_var_params['name__contains']))  # noqa: E501
        if 'name__icontains' in local_var_params and local_var_params['name__icontains'] is not None:  # noqa: E501
            query_params.append(('name__icontains', local_var_params['name__icontains']))  # noqa: E501
        if 'name__in' in local_var_params and local_var_params['name__in'] is not None:  # noqa: E501
            query_params.append(('name__in', local_var_params['name__in']))  # noqa: E501
        if 'name__startswith' in local_var_params and local_var_params['name__startswith'] is not None:  # noqa: E501
            query_params.append(('name__startswith', local_var_params['name__startswith']))  # noqa: E501
        if 'name__istartswith' in local_var_params and local_var_params['name__istartswith'] is not None:  # noqa: E501
            query_params.append(('name__istartswith', local_var_params['name__istartswith']))  # noqa: E501
        if 'name__endswith' in local_var_params and local_var_params['name__endswith'] is not None:  # noqa: E501
            query_params.append(('name__endswith', local_var_params['name__endswith']))  # noqa: E501
        if 'name__regex' in local_var_params and local_var_params['name__regex'] is not None:  # noqa: E501
            query_params.append(('name__regex', local_var_params['name__regex']))  # noqa: E501
        if 'slug' in local_var_params and local_var_params['slug'] is not None:  # noqa: E501
            query_params.append(('slug', local_var_params['slug']))  # noqa: E501
        if 'slug__iexact' in local_var_params and local_var_params['slug__iexact'] is not None:  # noqa: E501
            query_params.append(('slug__iexact', local_var_params['slug__iexact']))  # noqa: E501
        if 'slug__contains' in local_var_params and local_var_params['slug__contains'] is not None:  # noqa: E501
            query_params.append(('slug__contains', local_var_params['slug__contains']))  # noqa: E501
        if 'slug__icontains' in local_var_params and local_var_params['slug__icontains'] is not None:  # noqa: E501
            query_params.append(('slug__icontains', local_var_params['slug__icontains']))  # noqa: E501
        if 'slug__in' in local_var_params and local_var_params['slug__in'] is not None:  # noqa: E501
            query_params.append(('slug__in', local_var_params['slug__in']))  # noqa: E501
        if 'slug__startswith' in local_var_params and local_var_params['slug__startswith'] is not None:  # noqa: E501
            query_params.append(('slug__startswith', local_var_params['slug__startswith']))  # noqa: E501
        if 'slug__istartswith' in local_var_params and local_var_params['slug__istartswith'] is not None:  # noqa: E501
            query_params.append(('slug__istartswith', local_var_params['slug__istartswith']))  # noqa: E501
        if 'slug__endswith' in local_var_params and local_var_params['slug__endswith'] is not None:  # noqa: E501
            query_params.append(('slug__endswith', local_var_params['slug__endswith']))  # noqa: E501
        if 'slug__regex' in local_var_params and local_var_params['slug__regex'] is not None:  # noqa: E501
            query_params.append(('slug__regex', local_var_params['slug__regex']))  # noqa: E501
        if 'epsg' in local_var_params and local_var_params['epsg'] is not None:  # noqa: E501
            query_params.append(('epsg', local_var_params['epsg']))  # noqa: E501
        if 'id' in local_var_params and local_var_params['id'] is not None:  # noqa: E501
            query_params.append(('id', local_var_params['id']))  # noqa: E501
        if 'is_valid' in local_var_params and local_var_params['is_valid'] is not None:  # noqa: E501
            query_params.append(('is_valid', local_var_params['is_valid']))  # noqa: E501
        if 'inpy_version__slug' in local_var_params and local_var_params['inpy_version__slug'] is not None:  # noqa: E501
            query_params.append(('inpy_version__slug', local_var_params['inpy_version__slug']))  # noqa: E501
        if 'inpy_version__slug__iexact' in local_var_params and local_var_params['inpy_version__slug__iexact'] is not None:  # noqa: E501
            query_params.append(('inpy_version__slug__iexact', local_var_params['inpy_version__slug__iexact']))  # noqa: E501
        if 'inpy_version__slug__contains' in local_var_params and local_var_params['inpy_version__slug__contains'] is not None:  # noqa: E501
            query_params.append(('inpy_version__slug__contains', local_var_params['inpy_version__slug__contains']))  # noqa: E501
        if 'inpy_version__slug__icontains' in local_var_params and local_var_params['inpy_version__slug__icontains'] is not None:  # noqa: E501
            query_params.append(('inpy_version__slug__icontains', local_var_params['inpy_version__slug__icontains']))  # noqa: E501
        if 'inpy_version__slug__in' in local_var_params and local_var_params['inpy_version__slug__in'] is not None:  # noqa: E501
            query_params.append(('inpy_version__slug__in', local_var_params['inpy_version__slug__in']))  # noqa: E501
        if 'inpy_version__slug__startswith' in local_var_params and local_var_params['inpy_version__slug__startswith'] is not None:  # noqa: E501
            query_params.append(('inpy_version__slug__startswith', local_var_params['inpy_version__slug__startswith']))  # noqa: E501
        if 'inpy_version__slug__istartswith' in local_var_params and local_var_params['inpy_version__slug__istartswith'] is not None:  # noqa: E501
            query_params.append(('inpy_version__slug__istartswith', local_var_params['inpy_version__slug__istartswith']))  # noqa: E501
        if 'inpy_version__slug__endswith' in local_var_params and local_var_params['inpy_version__slug__endswith'] is not None:  # noqa: E501
            query_params.append(('inpy_version__slug__endswith', local_var_params['inpy_version__slug__endswith']))  # noqa: E501
        if 'inpy_version__slug__regex' in local_var_params and local_var_params['inpy_version__slug__regex'] is not None:  # noqa: E501
            query_params.append(('inpy_version__slug__regex', local_var_params['inpy_version__slug__regex']))  # noqa: E501
        if 'inpy_version__threedi_version' in local_var_params and local_var_params['inpy_version__threedi_version'] is not None:  # noqa: E501
            query_params.append(('inpy_version__threedi_version', local_var_params['inpy_version__threedi_version']))  # noqa: E501
        if 'inpy_version__threedi_version__iexact' in local_var_params and local_var_params['inpy_version__threedi_version__iexact'] is not None:  # noqa: E501
            query_params.append(('inpy_version__threedi_version__iexact', local_var_params['inpy_version__threedi_version__iexact']))  # noqa: E501
        if 'inpy_version__threedi_version__contains' in local_var_params and local_var_params['inpy_version__threedi_version__contains'] is not None:  # noqa: E501
            query_params.append(('inpy_version__threedi_version__contains', local_var_params['inpy_version__threedi_version__contains']))  # noqa: E501
        if 'inpy_version__threedi_version__icontains' in local_var_params and local_var_params['inpy_version__threedi_version__icontains'] is not None:  # noqa: E501
            query_params.append(('inpy_version__threedi_version__icontains', local_var_params['inpy_version__threedi_version__icontains']))  # noqa: E501
        if 'inpy_version__threedi_version__in' in local_var_params and local_var_params['inpy_version__threedi_version__in'] is not None:  # noqa: E501
            query_params.append(('inpy_version__threedi_version__in', local_var_params['inpy_version__threedi_version__in']))  # noqa: E501
        if 'inpy_version__threedi_version__startswith' in local_var_params and local_var_params['inpy_version__threedi_version__startswith'] is not None:  # noqa: E501
            query_params.append(('inpy_version__threedi_version__startswith', local_var_params['inpy_version__threedi_version__startswith']))  # noqa: E501
        if 'inpy_version__threedi_version__istartswith' in local_var_params and local_var_params['inpy_version__threedi_version__istartswith'] is not None:  # noqa: E501
            query_params.append(('inpy_version__threedi_version__istartswith', local_var_params['inpy_version__threedi_version__istartswith']))  # noqa: E501
        if 'inpy_version__threedi_version__endswith' in local_var_params and local_var_params['inpy_version__threedi_version__endswith'] is not None:  # noqa: E501
            query_params.append(('inpy_version__threedi_version__endswith', local_var_params['inpy_version__threedi_version__endswith']))  # noqa: E501
        if 'inpy_version__threedi_version__regex' in local_var_params and local_var_params['inpy_version__threedi_version__regex'] is not None:  # noqa: E501
            query_params.append(('inpy_version__threedi_version__regex', local_var_params['inpy_version__threedi_version__regex']))  # noqa: E501
        if 'inpy_version__threedicore_version' in local_var_params and local_var_params['inpy_version__threedicore_version'] is not None:  # noqa: E501
            query_params.append(('inpy_version__threedicore_version', local_var_params['inpy_version__threedicore_version']))  # noqa: E501
        if 'inpy_version__threedicore_version__iexact' in local_var_params and local_var_params['inpy_version__threedicore_version__iexact'] is not None:  # noqa: E501
            query_params.append(('inpy_version__threedicore_version__iexact', local_var_params['inpy_version__threedicore_version__iexact']))  # noqa: E501
        if 'inpy_version__threedicore_version__contains' in local_var_params and local_var_params['inpy_version__threedicore_version__contains'] is not None:  # noqa: E501
            query_params.append(('inpy_version__threedicore_version__contains', local_var_params['inpy_version__threedicore_version__contains']))  # noqa: E501
        if 'inpy_version__threedicore_version__icontains' in local_var_params and local_var_params['inpy_version__threedicore_version__icontains'] is not None:  # noqa: E501
            query_params.append(('inpy_version__threedicore_version__icontains', local_var_params['inpy_version__threedicore_version__icontains']))  # noqa: E501
        if 'inpy_version__threedicore_version__in' in local_var_params and local_var_params['inpy_version__threedicore_version__in'] is not None:  # noqa: E501
            query_params.append(('inpy_version__threedicore_version__in', local_var_params['inpy_version__threedicore_version__in']))  # noqa: E501
        if 'inpy_version__threedicore_version__startswith' in local_var_params and local_var_params['inpy_version__threedicore_version__startswith'] is not None:  # noqa: E501
            query_params.append(('inpy_version__threedicore_version__startswith', local_var_params['inpy_version__threedicore_version__startswith']))  # noqa: E501
        if 'inpy_version__threedicore_version__istartswith' in local_var_params and local_var_params['inpy_version__threedicore_version__istartswith'] is not None:  # noqa: E501
            query_params.append(('inpy_version__threedicore_version__istartswith', local_var_params['inpy_version__threedicore_version__istartswith']))  # noqa: E501
        if 'inpy_version__threedicore_version__endswith' in local_var_params and local_var_params['inpy_version__threedicore_version__endswith'] is not None:  # noqa: E501
            query_params.append(('inpy_version__threedicore_version__endswith', local_var_params['inpy_version__threedicore_version__endswith']))  # noqa: E501
        if 'inpy_version__threedicore_version__regex' in local_var_params and local_var_params['inpy_version__threedicore_version__regex'] is not None:  # noqa: E501
            query_params.append(('inpy_version__threedicore_version__regex', local_var_params['inpy_version__threedicore_version__regex']))  # noqa: E501
        if 'revision__commit_user__username' in local_var_params and local_var_params['revision__commit_user__username'] is not None:  # noqa: E501
            query_params.append(('revision__commit_user__username', local_var_params['revision__commit_user__username']))  # noqa: E501
        if 'revision__commit_user__username__istartswith' in local_var_params and local_var_params['revision__commit_user__username__istartswith'] is not None:  # noqa: E501
            query_params.append(('revision__commit_user__username__istartswith', local_var_params['revision__commit_user__username__istartswith']))  # noqa: E501
        if 'revision__id' in local_var_params and local_var_params['revision__id'] is not None:  # noqa: E501
            query_params.append(('revision__id', local_var_params['revision__id']))  # noqa: E501
        if 'revision__number' in local_var_params and local_var_params['revision__number'] is not None:  # noqa: E501
            query_params.append(('revision__number', local_var_params['revision__number']))  # noqa: E501
        if 'revision__number__gt' in local_var_params and local_var_params['revision__number__gt'] is not None:  # noqa: E501
            query_params.append(('revision__number__gt', local_var_params['revision__number__gt']))  # noqa: E501
        if 'revision__number__gte' in local_var_params and local_var_params['revision__number__gte'] is not None:  # noqa: E501
            query_params.append(('revision__number__gte', local_var_params['revision__number__gte']))  # noqa: E501
        if 'revision__number__lt' in local_var_params and local_var_params['revision__number__lt'] is not None:  # noqa: E501
            query_params.append(('revision__number__lt', local_var_params['revision__number__lt']))  # noqa: E501
        if 'revision__number__lte' in local_var_params and local_var_params['revision__number__lte'] is not None:  # noqa: E501
            query_params.append(('revision__number__lte', local_var_params['revision__number__lte']))  # noqa: E501
        if 'revision__number__isnull' in local_var_params and local_var_params['revision__number__isnull'] is not None:  # noqa: E501
            query_params.append(('revision__number__isnull', local_var_params['revision__number__isnull']))  # noqa: E501
        if 'revision__hash' in local_var_params and local_var_params['revision__hash'] is not None:  # noqa: E501
            query_params.append(('revision__hash', local_var_params['revision__hash']))  # noqa: E501
        if 'revision__hash__iexact' in local_var_params and local_var_params['revision__hash__iexact'] is not None:  # noqa: E501
            query_params.append(('revision__hash__iexact', local_var_params['revision__hash__iexact']))  # noqa: E501
        if 'revision__hash__contains' in local_var_params and local_var_params['revision__hash__contains'] is not None:  # noqa: E501
            query_params.append(('revision__hash__contains', local_var_params['revision__hash__contains']))  # noqa: E501
        if 'revision__hash__icontains' in local_var_params and local_var_params['revision__hash__icontains'] is not None:  # noqa: E501
            query_params.append(('revision__hash__icontains', local_var_params['revision__hash__icontains']))  # noqa: E501
        if 'revision__hash__in' in local_var_params and local_var_params['revision__hash__in'] is not None:  # noqa: E501
            query_params.append(('revision__hash__in', local_var_params['revision__hash__in']))  # noqa: E501
        if 'revision__hash__startswith' in local_var_params and local_var_params['revision__hash__startswith'] is not None:  # noqa: E501
            query_params.append(('revision__hash__startswith', local_var_params['revision__hash__startswith']))  # noqa: E501
        if 'revision__hash__istartswith' in local_var_params and local_var_params['revision__hash__istartswith'] is not None:  # noqa: E501
            query_params.append(('revision__hash__istartswith', local_var_params['revision__hash__istartswith']))  # noqa: E501
        if 'revision__hash__endswith' in local_var_params and local_var_params['revision__hash__endswith'] is not None:  # noqa: E501
            query_params.append(('revision__hash__endswith', local_var_params['revision__hash__endswith']))  # noqa: E501
        if 'revision__hash__regex' in local_var_params and local_var_params['revision__hash__regex'] is not None:  # noqa: E501
            query_params.append(('revision__hash__regex', local_var_params['revision__hash__regex']))  # noqa: E501
        if 'revision__schematisation__isnull' in local_var_params and local_var_params['revision__schematisation__isnull'] is not None:  # noqa: E501
            query_params.append(('revision__schematisation__isnull', local_var_params['revision__schematisation__isnull']))  # noqa: E501
        if 'revision__schematisation__name' in local_var_params and local_var_params['revision__schematisation__name'] is not None:  # noqa: E501
            query_params.append(('revision__schematisation__name', local_var_params['revision__schematisation__name']))  # noqa: E501
        if 'revision__schematisation__name__iexact' in local_var_params and local_var_params['revision__schematisation__name__iexact'] is not None:  # noqa: E501
            query_params.append(('revision__schematisation__name__iexact', local_var_params['revision__schematisation__name__iexact']))  # noqa: E501
        if 'revision__schematisation__name__contains' in local_var_params and local_var_params['revision__schematisation__name__contains'] is not None:  # noqa: E501
            query_params.append(('revision__schematisation__name__contains', local_var_params['revision__schematisation__name__contains']))  # noqa: E501
        if 'revision__schematisation__name__icontains' in local_var_params and local_var_params['revision__schematisation__name__icontains'] is not None:  # noqa: E501
            query_params.append(('revision__schematisation__name__icontains', local_var_params['revision__schematisation__name__icontains']))  # noqa: E501
        if 'revision__schematisation__name__in' in local_var_params and local_var_params['revision__schematisation__name__in'] is not None:  # noqa: E501
            query_params.append(('revision__schematisation__name__in', local_var_params['revision__schematisation__name__in']))  # noqa: E501
        if 'revision__schematisation__name__startswith' in local_var_params and local_var_params['revision__schematisation__name__startswith'] is not None:  # noqa: E501
            query_params.append(('revision__schematisation__name__startswith', local_var_params['revision__schematisation__name__startswith']))  # noqa: E501
        if 'revision__schematisation__name__istartswith' in local_var_params and local_var_params['revision__schematisation__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('revision__schematisation__name__istartswith', local_var_params['revision__schematisation__name__istartswith']))  # noqa: E501
        if 'revision__schematisation__name__endswith' in local_var_params and local_var_params['revision__schematisation__name__endswith'] is not None:  # noqa: E501
            query_params.append(('revision__schematisation__name__endswith', local_var_params['revision__schematisation__name__endswith']))  # noqa: E501
        if 'revision__schematisation__name__regex' in local_var_params and local_var_params['revision__schematisation__name__regex'] is not None:  # noqa: E501
            query_params.append(('revision__schematisation__name__regex', local_var_params['revision__schematisation__name__regex']))  # noqa: E501
        if 'revision__repository__organisation__unique_id' in local_var_params and local_var_params['revision__repository__organisation__unique_id'] is not None:  # noqa: E501
            query_params.append(('revision__repository__organisation__unique_id', local_var_params['revision__repository__organisation__unique_id']))  # noqa: E501
        if 'revision__repository__organisation__unique_id__iexact' in local_var_params and local_var_params['revision__repository__organisation__unique_id__iexact'] is not None:  # noqa: E501
            query_params.append(('revision__repository__organisation__unique_id__iexact', local_var_params['revision__repository__organisation__unique_id__iexact']))  # noqa: E501
        if 'revision__repository__organisation__unique_id__contains' in local_var_params and local_var_params['revision__repository__organisation__unique_id__contains'] is not None:  # noqa: E501
            query_params.append(('revision__repository__organisation__unique_id__contains', local_var_params['revision__repository__organisation__unique_id__contains']))  # noqa: E501
        if 'revision__repository__organisation__unique_id__icontains' in local_var_params and local_var_params['revision__repository__organisation__unique_id__icontains'] is not None:  # noqa: E501
            query_params.append(('revision__repository__organisation__unique_id__icontains', local_var_params['revision__repository__organisation__unique_id__icontains']))  # noqa: E501
        if 'revision__repository__organisation__unique_id__in' in local_var_params and local_var_params['revision__repository__organisation__unique_id__in'] is not None:  # noqa: E501
            query_params.append(('revision__repository__organisation__unique_id__in', local_var_params['revision__repository__organisation__unique_id__in']))  # noqa: E501
        if 'revision__repository__organisation__unique_id__startswith' in local_var_params and local_var_params['revision__repository__organisation__unique_id__startswith'] is not None:  # noqa: E501
            query_params.append(('revision__repository__organisation__unique_id__startswith', local_var_params['revision__repository__organisation__unique_id__startswith']))  # noqa: E501
        if 'revision__repository__organisation__unique_id__istartswith' in local_var_params and local_var_params['revision__repository__organisation__unique_id__istartswith'] is not None:  # noqa: E501
            query_params.append(('revision__repository__organisation__unique_id__istartswith', local_var_params['revision__repository__organisation__unique_id__istartswith']))  # noqa: E501
        if 'revision__repository__organisation__unique_id__endswith' in local_var_params and local_var_params['revision__repository__organisation__unique_id__endswith'] is not None:  # noqa: E501
            query_params.append(('revision__repository__organisation__unique_id__endswith', local_var_params['revision__repository__organisation__unique_id__endswith']))  # noqa: E501
        if 'revision__repository__organisation__unique_id__regex' in local_var_params and local_var_params['revision__repository__organisation__unique_id__regex'] is not None:  # noqa: E501
            query_params.append(('revision__repository__organisation__unique_id__regex', local_var_params['revision__repository__organisation__unique_id__regex']))  # noqa: E501
        if 'revision__schematisation__owner__unique_id' in local_var_params and local_var_params['revision__schematisation__owner__unique_id'] is not None:  # noqa: E501
            query_params.append(('revision__schematisation__owner__unique_id', local_var_params['revision__schematisation__owner__unique_id']))  # noqa: E501
        if 'revision__schematisation__id' in local_var_params and local_var_params['revision__schematisation__id'] is not None:  # noqa: E501
            query_params.append(('revision__schematisation__id', local_var_params['revision__schematisation__id']))  # noqa: E501
        if 'created__range' in local_var_params and local_var_params['created__range'] is not None:  # noqa: E501
            query_params.append(('created__range', local_var_params['created__range']))  # noqa: E501
        if 'created__date' in local_var_params and local_var_params['created__date'] is not None:  # noqa: E501
            query_params.append(('created__date', local_var_params['created__date']))  # noqa: E501
        if 'created__date__gt' in local_var_params and local_var_params['created__date__gt'] is not None:  # noqa: E501
            query_params.append(('created__date__gt', local_var_params['created__date__gt']))  # noqa: E501
        if 'created__date__gte' in local_var_params and local_var_params['created__date__gte'] is not None:  # noqa: E501
            query_params.append(('created__date__gte', local_var_params['created__date__gte']))  # noqa: E501
        if 'created__date__lt' in local_var_params and local_var_params['created__date__lt'] is not None:  # noqa: E501
            query_params.append(('created__date__lt', local_var_params['created__date__lt']))  # noqa: E501
        if 'created__date__lte' in local_var_params and local_var_params['created__date__lte'] is not None:  # noqa: E501
            query_params.append(('created__date__lte', local_var_params['created__date__lte']))  # noqa: E501
        if 'created__year' in local_var_params and local_var_params['created__year'] is not None:  # noqa: E501
            query_params.append(('created__year', local_var_params['created__year']))  # noqa: E501
        if 'created__year__gt' in local_var_params and local_var_params['created__year__gt'] is not None:  # noqa: E501
            query_params.append(('created__year__gt', local_var_params['created__year__gt']))  # noqa: E501
        if 'created__year__gte' in local_var_params and local_var_params['created__year__gte'] is not None:  # noqa: E501
            query_params.append(('created__year__gte', local_var_params['created__year__gte']))  # noqa: E501
        if 'created__year__lt' in local_var_params and local_var_params['created__year__lt'] is not None:  # noqa: E501
            query_params.append(('created__year__lt', local_var_params['created__year__lt']))  # noqa: E501
        if 'created__year__lte' in local_var_params and local_var_params['created__year__lte'] is not None:  # noqa: E501
            query_params.append(('created__year__lte', local_var_params['created__year__lte']))  # noqa: E501
        if 'created__month' in local_var_params and local_var_params['created__month'] is not None:  # noqa: E501
            query_params.append(('created__month', local_var_params['created__month']))  # noqa: E501
        if 'created__month__lte' in local_var_params and local_var_params['created__month__lte'] is not None:  # noqa: E501
            query_params.append(('created__month__lte', local_var_params['created__month__lte']))  # noqa: E501
        if 'created__day' in local_var_params and local_var_params['created__day'] is not None:  # noqa: E501
            query_params.append(('created__day', local_var_params['created__day']))  # noqa: E501
        if 'created__day__lt' in local_var_params and local_var_params['created__day__lt'] is not None:  # noqa: E501
            query_params.append(('created__day__lt', local_var_params['created__day__lt']))  # noqa: E501
        if 'created__week' in local_var_params and local_var_params['created__week'] is not None:  # noqa: E501
            query_params.append(('created__week', local_var_params['created__week']))  # noqa: E501
        if 'created__week_day' in local_var_params and local_var_params['created__week_day'] is not None:  # noqa: E501
            query_params.append(('created__week_day', local_var_params['created__week_day']))  # noqa: E501
        if 'created__quarter' in local_var_params and local_var_params['created__quarter'] is not None:  # noqa: E501
            query_params.append(('created__quarter', local_var_params['created__quarter']))  # noqa: E501
        if 'created__time' in local_var_params and local_var_params['created__time'] is not None:  # noqa: E501
            query_params.append(('created__time', local_var_params['created__time']))  # noqa: E501
        if 'created__hour' in local_var_params and local_var_params['created__hour'] is not None:  # noqa: E501
            query_params.append(('created__hour', local_var_params['created__hour']))  # noqa: E501
        if 'created__minute' in local_var_params and local_var_params['created__minute'] is not None:  # noqa: E501
            query_params.append(('created__minute', local_var_params['created__minute']))  # noqa: E501
        if 'created__second' in local_var_params and local_var_params['created__second'] is not None:  # noqa: E501
            query_params.append(('created__second', local_var_params['created__second']))  # noqa: E501
        if 'created__isnull' in local_var_params and local_var_params['created__isnull'] is not None:  # noqa: E501
            query_params.append(('created__isnull', local_var_params['created__isnull']))  # noqa: E501
        if 'revision__is_pinned' in local_var_params and local_var_params['revision__is_pinned'] is not None:  # noqa: E501
            query_params.append(('revision__is_pinned', local_var_params['revision__is_pinned']))  # noqa: E501
        if 'revision__schematisation__tags__in' in local_var_params and local_var_params['revision__schematisation__tags__in'] is not None:  # noqa: E501
            query_params.append(('revision__schematisation__tags__in', local_var_params['revision__schematisation__tags__in']))  # noqa: E501
        if 'disabled' in local_var_params and local_var_params['disabled'] is not None:  # noqa: E501
            query_params.append(('disabled', local_var_params['disabled']))  # noqa: E501
        if 'inp_success' in local_var_params and local_var_params['inp_success'] is not None:  # noqa: E501
            query_params.append(('inp_success', local_var_params['inp_success']))  # noqa: E501
        if 'inpy_version__active' in local_var_params and local_var_params['inpy_version__active'] is not None:  # noqa: E501
            query_params.append(('inpy_version__active', local_var_params['inpy_version__active']))  # noqa: E501
        if 'is_generating' in local_var_params and local_var_params['is_generating'] is not None:  # noqa: E501
            query_params.append(('is_generating', local_var_params['is_generating']))  # noqa: E501
        if 'ordering' in local_var_params and local_var_params['ordering'] is not None:  # noqa: E501
            query_params.append(('ordering', local_var_params['ordering']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20073',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_manholes_geojson_upload(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_manholes_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_manholes_geojson_upload(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_manholes_geojson_upload_with_http_info(id, data, **kwargs)  # noqa: E501

    def threedimodels_manholes_geojson_upload_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_manholes_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_manholes_geojson_upload_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_manholes_geojson_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_manholes_geojson_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_manholes_geojson_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/manholes/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_orifices_geojson_upload(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_orifices_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_orifices_geojson_upload(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_orifices_geojson_upload_with_http_info(id, data, **kwargs)  # noqa: E501

    def threedimodels_orifices_geojson_upload_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_orifices_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_orifices_geojson_upload_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_orifices_geojson_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_orifices_geojson_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_orifices_geojson_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/orifices/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_partial_update(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_partial_update  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param ThreediModel data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ThreediModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def threedimodels_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_partial_update  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param ThreediModel data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ThreediModel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreediModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_pipes_geojson_upload(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_pipes_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_pipes_geojson_upload(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_pipes_geojson_upload_with_http_info(id, data, **kwargs)  # noqa: E501

    def threedimodels_pipes_geojson_upload_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_pipes_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_pipes_geojson_upload_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_pipes_geojson_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_pipes_geojson_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_pipes_geojson_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/pipes/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_potentialbreaches_create(self, threedimodel_pk, data, **kwargs):  # noqa: E501
        """A simple ViewSet for viewing breaches  # noqa: E501

        To get the potential breach from the geojson use the `content_pk` parameter to filter the potential breaches endpoint: `/potential_breaches/?connected_pnt_id={content_pk}`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_potentialbreaches_create(threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param PotentialBreach data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PotentialBreach
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_potentialbreaches_create_with_http_info(threedimodel_pk, data, **kwargs)  # noqa: E501

    def threedimodels_potentialbreaches_create_with_http_info(self, threedimodel_pk, data, **kwargs):  # noqa: E501
        """A simple ViewSet for viewing breaches  # noqa: E501

        To get the potential breach from the geojson use the `content_pk` parameter to filter the potential breaches endpoint: `/potential_breaches/?connected_pnt_id={content_pk}`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_potentialbreaches_create_with_http_info(threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param PotentialBreach data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PotentialBreach, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'threedimodel_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_potentialbreaches_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_potentialbreaches_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_potentialbreaches_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/potentialbreaches/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PotentialBreach',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_potentialbreaches_list(self, threedimodel_pk, **kwargs):  # noqa: E501
        """A simple ViewSet for viewing breaches  # noqa: E501

        To get the potential breach from the geojson use the `content_pk` parameter to filter the potential breaches endpoint: `/potential_breaches/?connected_pnt_id={content_pk}`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_potentialbreaches_list(threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param str connected_pnt_id: connected_pnt_id
        :param str connected_pnt_id__gt: connected_pnt_id__gt
        :param str connected_pnt_id__gte: connected_pnt_id__gte
        :param str connected_pnt_id__lt: connected_pnt_id__lt
        :param str connected_pnt_id__lte: connected_pnt_id__lte
        :param str connected_pnt_id__isnull: connected_pnt_id__isnull
        :param str threedimodel__id: threedimodel__id
        :param str threedimodel__id__gt: threedimodel__id__gt
        :param str threedimodel__id__gte: threedimodel__id__gte
        :param str threedimodel__id__lt: threedimodel__id__lt
        :param str threedimodel__id__lte: threedimodel__id__lte
        :param str threedimodel__id__isnull: threedimodel__id__isnull
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20076
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_potentialbreaches_list_with_http_info(threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_potentialbreaches_list_with_http_info(self, threedimodel_pk, **kwargs):  # noqa: E501
        """A simple ViewSet for viewing breaches  # noqa: E501

        To get the potential breach from the geojson use the `content_pk` parameter to filter the potential breaches endpoint: `/potential_breaches/?connected_pnt_id={content_pk}`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_potentialbreaches_list_with_http_info(threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param str connected_pnt_id: connected_pnt_id
        :param str connected_pnt_id__gt: connected_pnt_id__gt
        :param str connected_pnt_id__gte: connected_pnt_id__gte
        :param str connected_pnt_id__lt: connected_pnt_id__lt
        :param str connected_pnt_id__lte: connected_pnt_id__lte
        :param str connected_pnt_id__isnull: connected_pnt_id__isnull
        :param str threedimodel__id: threedimodel__id
        :param str threedimodel__id__gt: threedimodel__id__gt
        :param str threedimodel__id__gte: threedimodel__id__gte
        :param str threedimodel__id__lt: threedimodel__id__lt
        :param str threedimodel__id__lte: threedimodel__id__lte
        :param str threedimodel__id__isnull: threedimodel__id__isnull
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20076, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'threedimodel_pk',
            'connected_pnt_id',
            'connected_pnt_id__gt',
            'connected_pnt_id__gte',
            'connected_pnt_id__lt',
            'connected_pnt_id__lte',
            'connected_pnt_id__isnull',
            'threedimodel__id',
            'threedimodel__id__gt',
            'threedimodel__id__gte',
            'threedimodel__id__lt',
            'threedimodel__id__lte',
            'threedimodel__id__isnull',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_potentialbreaches_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_potentialbreaches_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []
        if 'connected_pnt_id' in local_var_params and local_var_params['connected_pnt_id'] is not None:  # noqa: E501
            query_params.append(('connected_pnt_id', local_var_params['connected_pnt_id']))  # noqa: E501
        if 'connected_pnt_id__gt' in local_var_params and local_var_params['connected_pnt_id__gt'] is not None:  # noqa: E501
            query_params.append(('connected_pnt_id__gt', local_var_params['connected_pnt_id__gt']))  # noqa: E501
        if 'connected_pnt_id__gte' in local_var_params and local_var_params['connected_pnt_id__gte'] is not None:  # noqa: E501
            query_params.append(('connected_pnt_id__gte', local_var_params['connected_pnt_id__gte']))  # noqa: E501
        if 'connected_pnt_id__lt' in local_var_params and local_var_params['connected_pnt_id__lt'] is not None:  # noqa: E501
            query_params.append(('connected_pnt_id__lt', local_var_params['connected_pnt_id__lt']))  # noqa: E501
        if 'connected_pnt_id__lte' in local_var_params and local_var_params['connected_pnt_id__lte'] is not None:  # noqa: E501
            query_params.append(('connected_pnt_id__lte', local_var_params['connected_pnt_id__lte']))  # noqa: E501
        if 'connected_pnt_id__isnull' in local_var_params and local_var_params['connected_pnt_id__isnull'] is not None:  # noqa: E501
            query_params.append(('connected_pnt_id__isnull', local_var_params['connected_pnt_id__isnull']))  # noqa: E501
        if 'threedimodel__id' in local_var_params and local_var_params['threedimodel__id'] is not None:  # noqa: E501
            query_params.append(('threedimodel__id', local_var_params['threedimodel__id']))  # noqa: E501
        if 'threedimodel__id__gt' in local_var_params and local_var_params['threedimodel__id__gt'] is not None:  # noqa: E501
            query_params.append(('threedimodel__id__gt', local_var_params['threedimodel__id__gt']))  # noqa: E501
        if 'threedimodel__id__gte' in local_var_params and local_var_params['threedimodel__id__gte'] is not None:  # noqa: E501
            query_params.append(('threedimodel__id__gte', local_var_params['threedimodel__id__gte']))  # noqa: E501
        if 'threedimodel__id__lt' in local_var_params and local_var_params['threedimodel__id__lt'] is not None:  # noqa: E501
            query_params.append(('threedimodel__id__lt', local_var_params['threedimodel__id__lt']))  # noqa: E501
        if 'threedimodel__id__lte' in local_var_params and local_var_params['threedimodel__id__lte'] is not None:  # noqa: E501
            query_params.append(('threedimodel__id__lte', local_var_params['threedimodel__id__lte']))  # noqa: E501
        if 'threedimodel__id__isnull' in local_var_params and local_var_params['threedimodel__id__isnull'] is not None:  # noqa: E501
            query_params.append(('threedimodel__id__isnull', local_var_params['threedimodel__id__isnull']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/potentialbreaches/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20076',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_potentialbreaches_read(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """A simple ViewSet for viewing breaches  # noqa: E501

        To get the potential breach from the geojson use the `content_pk` parameter to filter the potential breaches endpoint: `/potential_breaches/?connected_pnt_id={content_pk}`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_potentialbreaches_read(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this potential breach. (required)
        :param str threedimodel_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PotentialBreach
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_potentialbreaches_read_with_http_info(id, threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_potentialbreaches_read_with_http_info(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """A simple ViewSet for viewing breaches  # noqa: E501

        To get the potential breach from the geojson use the `content_pk` parameter to filter the potential breaches endpoint: `/potential_breaches/?connected_pnt_id={content_pk}`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_potentialbreaches_read_with_http_info(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this potential breach. (required)
        :param str threedimodel_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PotentialBreach, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_potentialbreaches_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_potentialbreaches_read`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_potentialbreaches_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/potentialbreaches/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PotentialBreach',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_pumps_geojson_upload(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_pumps_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_pumps_geojson_upload(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_pumps_geojson_upload_with_http_info(id, data, **kwargs)  # noqa: E501

    def threedimodels_pumps_geojson_upload_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_pumps_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_pumps_geojson_upload_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_pumps_geojson_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_pumps_geojson_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_pumps_geojson_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/pumps/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_raster_options(self, id, **kwargs):  # noqa: E501
        """threedimodels_raster_options  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_raster_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RasterOptions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_raster_options_with_http_info(id, **kwargs)  # noqa: E501

    def threedimodels_raster_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """threedimodels_raster_options  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_raster_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RasterOptions, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_raster_options" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_raster_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/raster_options/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RasterOptions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_rasters_create(self, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_rasters_create  # noqa: E501

        View rasters for threedimodel  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_rasters_create(threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param Raster data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Raster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_rasters_create_with_http_info(threedimodel_pk, data, **kwargs)  # noqa: E501

    def threedimodels_rasters_create_with_http_info(self, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_rasters_create  # noqa: E501

        View rasters for threedimodel  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_rasters_create_with_http_info(threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param Raster data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Raster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'threedimodel_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_rasters_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_rasters_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_rasters_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/rasters/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Raster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_rasters_delete(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_rasters_delete  # noqa: E501

        View rasters for threedimodel  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_rasters_delete(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster. (required)
        :param str threedimodel_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_rasters_delete_with_http_info(id, threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_rasters_delete_with_http_info(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_rasters_delete  # noqa: E501

        View rasters for threedimodel  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_rasters_delete_with_http_info(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster. (required)
        :param str threedimodel_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_rasters_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_rasters_delete`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_rasters_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/rasters/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_rasters_download(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_rasters_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_rasters_download(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster. (required)
        :param str threedimodel_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_rasters_download_with_http_info(id, threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_rasters_download_with_http_info(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_rasters_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_rasters_download_with_http_info(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster. (required)
        :param str threedimodel_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_rasters_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_rasters_download`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_rasters_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/rasters/{id}/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_rasters_list(self, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_rasters_list  # noqa: E501

        View rasters for threedimodel  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_rasters_list(threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param str type: type
        :param str type__iexact: type__iexact
        :param str type__contains: type__contains
        :param str type__icontains: type__icontains
        :param str type__in: type__in
        :param str type__startswith: type__startswith
        :param str type__istartswith: type__istartswith
        :param str type__endswith: type__endswith
        :param str type__regex: type__regex
        :param str name: name
        :param str name__iexact: name__iexact
        :param str name__contains: name__contains
        :param str name__icontains: name__icontains
        :param str name__in: name__in
        :param str name__startswith: name__startswith
        :param str name__istartswith: name__istartswith
        :param str name__endswith: name__endswith
        :param str name__regex: name__regex
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20077
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_rasters_list_with_http_info(threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_rasters_list_with_http_info(self, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_rasters_list  # noqa: E501

        View rasters for threedimodel  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_rasters_list_with_http_info(threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param str type: type
        :param str type__iexact: type__iexact
        :param str type__contains: type__contains
        :param str type__icontains: type__icontains
        :param str type__in: type__in
        :param str type__startswith: type__startswith
        :param str type__istartswith: type__istartswith
        :param str type__endswith: type__endswith
        :param str type__regex: type__regex
        :param str name: name
        :param str name__iexact: name__iexact
        :param str name__contains: name__contains
        :param str name__icontains: name__icontains
        :param str name__in: name__in
        :param str name__startswith: name__startswith
        :param str name__istartswith: name__istartswith
        :param str name__endswith: name__endswith
        :param str name__regex: name__regex
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20077, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'threedimodel_pk',
            'type',
            'type__iexact',
            'type__contains',
            'type__icontains',
            'type__in',
            'type__startswith',
            'type__istartswith',
            'type__endswith',
            'type__regex',
            'name',
            'name__iexact',
            'name__contains',
            'name__icontains',
            'name__in',
            'name__startswith',
            'name__istartswith',
            'name__endswith',
            'name__regex',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_rasters_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_rasters_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'type__iexact' in local_var_params and local_var_params['type__iexact'] is not None:  # noqa: E501
            query_params.append(('type__iexact', local_var_params['type__iexact']))  # noqa: E501
        if 'type__contains' in local_var_params and local_var_params['type__contains'] is not None:  # noqa: E501
            query_params.append(('type__contains', local_var_params['type__contains']))  # noqa: E501
        if 'type__icontains' in local_var_params and local_var_params['type__icontains'] is not None:  # noqa: E501
            query_params.append(('type__icontains', local_var_params['type__icontains']))  # noqa: E501
        if 'type__in' in local_var_params and local_var_params['type__in'] is not None:  # noqa: E501
            query_params.append(('type__in', local_var_params['type__in']))  # noqa: E501
        if 'type__startswith' in local_var_params and local_var_params['type__startswith'] is not None:  # noqa: E501
            query_params.append(('type__startswith', local_var_params['type__startswith']))  # noqa: E501
        if 'type__istartswith' in local_var_params and local_var_params['type__istartswith'] is not None:  # noqa: E501
            query_params.append(('type__istartswith', local_var_params['type__istartswith']))  # noqa: E501
        if 'type__endswith' in local_var_params and local_var_params['type__endswith'] is not None:  # noqa: E501
            query_params.append(('type__endswith', local_var_params['type__endswith']))  # noqa: E501
        if 'type__regex' in local_var_params and local_var_params['type__regex'] is not None:  # noqa: E501
            query_params.append(('type__regex', local_var_params['type__regex']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'name__iexact' in local_var_params and local_var_params['name__iexact'] is not None:  # noqa: E501
            query_params.append(('name__iexact', local_var_params['name__iexact']))  # noqa: E501
        if 'name__contains' in local_var_params and local_var_params['name__contains'] is not None:  # noqa: E501
            query_params.append(('name__contains', local_var_params['name__contains']))  # noqa: E501
        if 'name__icontains' in local_var_params and local_var_params['name__icontains'] is not None:  # noqa: E501
            query_params.append(('name__icontains', local_var_params['name__icontains']))  # noqa: E501
        if 'name__in' in local_var_params and local_var_params['name__in'] is not None:  # noqa: E501
            query_params.append(('name__in', local_var_params['name__in']))  # noqa: E501
        if 'name__startswith' in local_var_params and local_var_params['name__startswith'] is not None:  # noqa: E501
            query_params.append(('name__startswith', local_var_params['name__startswith']))  # noqa: E501
        if 'name__istartswith' in local_var_params and local_var_params['name__istartswith'] is not None:  # noqa: E501
            query_params.append(('name__istartswith', local_var_params['name__istartswith']))  # noqa: E501
        if 'name__endswith' in local_var_params and local_var_params['name__endswith'] is not None:  # noqa: E501
            query_params.append(('name__endswith', local_var_params['name__endswith']))  # noqa: E501
        if 'name__regex' in local_var_params and local_var_params['name__regex'] is not None:  # noqa: E501
            query_params.append(('name__regex', local_var_params['name__regex']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/rasters/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20077',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_rasters_partial_update(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_rasters_partial_update  # noqa: E501

        View rasters for threedimodel  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_rasters_partial_update(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster. (required)
        :param str threedimodel_pk: (required)
        :param Raster data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Raster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_rasters_partial_update_with_http_info(id, threedimodel_pk, data, **kwargs)  # noqa: E501

    def threedimodels_rasters_partial_update_with_http_info(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_rasters_partial_update  # noqa: E501

        View rasters for threedimodel  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_rasters_partial_update_with_http_info(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster. (required)
        :param str threedimodel_pk: (required)
        :param Raster data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Raster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_rasters_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_rasters_partial_update`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_rasters_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_rasters_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/rasters/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Raster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_rasters_read(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_rasters_read  # noqa: E501

        View rasters for threedimodel  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_rasters_read(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster. (required)
        :param str threedimodel_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Raster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_rasters_read_with_http_info(id, threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_rasters_read_with_http_info(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_rasters_read  # noqa: E501

        View rasters for threedimodel  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_rasters_read_with_http_info(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster. (required)
        :param str threedimodel_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Raster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_rasters_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_rasters_read`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_rasters_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/rasters/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Raster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_rasters_update(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_rasters_update  # noqa: E501

        View rasters for threedimodel  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_rasters_update(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster. (required)
        :param str threedimodel_pk: (required)
        :param Raster data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Raster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_rasters_update_with_http_info(id, threedimodel_pk, data, **kwargs)  # noqa: E501

    def threedimodels_rasters_update_with_http_info(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_rasters_update  # noqa: E501

        View rasters for threedimodel  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_rasters_update_with_http_info(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster. (required)
        :param str threedimodel_pk: (required)
        :param Raster data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Raster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_rasters_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_rasters_update`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_rasters_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_rasters_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/rasters/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Raster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_rasters_upload(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_rasters_upload  # noqa: E501

        Endpoint for uploading a raster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_rasters_upload(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster. (required)
        :param str threedimodel_pk: (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_rasters_upload_with_http_info(id, threedimodel_pk, data, **kwargs)  # noqa: E501

    def threedimodels_rasters_upload_with_http_info(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_rasters_upload  # noqa: E501

        Endpoint for uploading a raster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_rasters_upload_with_http_info(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this raster. (required)
        :param str threedimodel_pk: (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_rasters_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_rasters_upload`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_rasters_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_rasters_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/rasters/{id}/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_read(self, id, **kwargs):  # noqa: E501
        """threedimodels_read  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ThreediModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_read_with_http_info(id, **kwargs)  # noqa: E501

    def threedimodels_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """threedimodels_read  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ThreediModel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreediModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_saved_states_delete(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_saved_states_delete  # noqa: E501

        View saved states created for this 3Di model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_saved_states_delete(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str threedimodel_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_saved_states_delete_with_http_info(id, threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_saved_states_delete_with_http_info(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_saved_states_delete  # noqa: E501

        View saved states created for this 3Di model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_saved_states_delete_with_http_info(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str threedimodel_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_saved_states_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_saved_states_delete`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_saved_states_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/saved_states/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_saved_states_list(self, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_saved_states_list  # noqa: E501

        View saved states created for this 3Di model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_saved_states_list(threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20078
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_saved_states_list_with_http_info(threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_saved_states_list_with_http_info(self, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_saved_states_list  # noqa: E501

        View saved states created for this 3Di model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_saved_states_list_with_http_info(threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20078, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'threedimodel_pk',
            'ordering',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_saved_states_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_saved_states_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []
        if 'ordering' in local_var_params and local_var_params['ordering'] is not None:  # noqa: E501
            query_params.append(('ordering', local_var_params['ordering']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/saved_states/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20078',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_saved_states_read(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_saved_states_read  # noqa: E501

        View saved states created for this 3Di model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_saved_states_read(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str threedimodel_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ThreediModelSavedState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_saved_states_read_with_http_info(id, threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_saved_states_read_with_http_info(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_saved_states_read  # noqa: E501

        View saved states created for this 3Di model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_saved_states_read_with_http_info(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this saved state. (required)
        :param str threedimodel_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ThreediModelSavedState, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_saved_states_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_saved_states_read`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_saved_states_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/saved_states/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreediModelSavedState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_tables_download(self, id, **kwargs):  # noqa: E501
        """threedimodels_tables_download  # noqa: E501

        Endpoint for downloading tables files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_tables_download(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_tables_download_with_http_info(id, **kwargs)  # noqa: E501

    def threedimodels_tables_download_with_http_info(self, id, **kwargs):  # noqa: E501
        """threedimodels_tables_download  # noqa: E501

        Endpoint for downloading tables files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_tables_download_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_tables_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_tables_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/tables/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_tables_upload(self, id, data, **kwargs):  # noqa: E501
        """Endpoint for uploading the tables.h5 file  # noqa: E501

        Replaces the tables file if there already exists one.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_tables_upload(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_tables_upload_with_http_info(id, data, **kwargs)  # noqa: E501

    def threedimodels_tables_upload_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """Endpoint for uploading the tables.h5 file  # noqa: E501

        Replaces the tables file if there already exists one.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_tables_upload_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_tables_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_tables_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_tables_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/tables/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_tasks_create(self, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_tasks_create  # noqa: E501

        View threedimodel tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_tasks_create(threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param ThreediModelTask data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ThreediModelTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_tasks_create_with_http_info(threedimodel_pk, data, **kwargs)  # noqa: E501

    def threedimodels_tasks_create_with_http_info(self, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_tasks_create  # noqa: E501

        View threedimodel tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_tasks_create_with_http_info(threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param ThreediModelTask data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ThreediModelTask, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'threedimodel_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_tasks_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_tasks_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_tasks_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/tasks/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreediModelTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_tasks_delete(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_tasks_delete  # noqa: E501

        View threedimodel tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_tasks_delete(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model task. (required)
        :param str threedimodel_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_tasks_delete_with_http_info(id, threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_tasks_delete_with_http_info(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_tasks_delete  # noqa: E501

        View threedimodel tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_tasks_delete_with_http_info(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model task. (required)
        :param str threedimodel_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_tasks_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_tasks_delete`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_tasks_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/tasks/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_tasks_list(self, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_tasks_list  # noqa: E501

        View threedimodel tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_tasks_list(threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20079
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_tasks_list_with_http_info(threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_tasks_list_with_http_info(self, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_tasks_list  # noqa: E501

        View threedimodel tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_tasks_list_with_http_info(threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str threedimodel_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20079, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'threedimodel_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_tasks_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_tasks_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/tasks/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20079',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_tasks_partial_update(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_tasks_partial_update  # noqa: E501

        View threedimodel tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_tasks_partial_update(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model task. (required)
        :param str threedimodel_pk: (required)
        :param ThreediModelTask data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ThreediModelTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_tasks_partial_update_with_http_info(id, threedimodel_pk, data, **kwargs)  # noqa: E501

    def threedimodels_tasks_partial_update_with_http_info(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_tasks_partial_update  # noqa: E501

        View threedimodel tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_tasks_partial_update_with_http_info(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model task. (required)
        :param str threedimodel_pk: (required)
        :param ThreediModelTask data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ThreediModelTask, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_tasks_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_tasks_partial_update`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_tasks_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_tasks_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/tasks/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreediModelTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_tasks_read(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_tasks_read  # noqa: E501

        View threedimodel tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_tasks_read(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model task. (required)
        :param str threedimodel_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ThreediModelTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_tasks_read_with_http_info(id, threedimodel_pk, **kwargs)  # noqa: E501

    def threedimodels_tasks_read_with_http_info(self, id, threedimodel_pk, **kwargs):  # noqa: E501
        """threedimodels_tasks_read  # noqa: E501

        View threedimodel tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_tasks_read_with_http_info(id, threedimodel_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model task. (required)
        :param str threedimodel_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ThreediModelTask, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_tasks_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_tasks_read`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_tasks_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/tasks/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreediModelTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_tasks_update(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_tasks_update  # noqa: E501

        View threedimodel tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_tasks_update(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model task. (required)
        :param str threedimodel_pk: (required)
        :param ThreediModelTask data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ThreediModelTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_tasks_update_with_http_info(id, threedimodel_pk, data, **kwargs)  # noqa: E501

    def threedimodels_tasks_update_with_http_info(self, id, threedimodel_pk, data, **kwargs):  # noqa: E501
        """threedimodels_tasks_update  # noqa: E501

        View threedimodel tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_tasks_update_with_http_info(id, threedimodel_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model task. (required)
        :param str threedimodel_pk: (required)
        :param ThreediModelTask data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ThreediModelTask, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'threedimodel_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_tasks_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_tasks_update`")  # noqa: E501
        # verify the required parameter 'threedimodel_pk' is set
        if self.api_client.client_side_validation and ('threedimodel_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['threedimodel_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `threedimodel_pk` when calling `threedimodels_tasks_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_tasks_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'threedimodel_pk' in local_var_params:
            path_params['threedimodel_pk'] = local_var_params['threedimodel_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{threedimodel_pk}/tasks/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreediModelTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_update(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_update  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param ThreediModel data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ThreediModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def threedimodels_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_update  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param ThreediModel data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ThreediModel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreediModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def threedimodels_weirs_geojson_upload(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_weirs_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_weirs_geojson_upload(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.threedimodels_weirs_geojson_upload_with_http_info(id, data, **kwargs)  # noqa: E501

    def threedimodels_weirs_geojson_upload_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """threedimodels_weirs_geojson_upload  # noqa: E501

        A simple ViewSet for viewing threedimodels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.threedimodels_weirs_geojson_upload_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this threedi model. (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method threedimodels_weirs_geojson_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `threedimodels_weirs_geojson_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `threedimodels_weirs_geojson_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/threedimodels/{id}/geojson/weirs/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def usage_list(self, **kwargs):  # noqa: E501
        """View to display overview of ran simulations.  # noqa: E501

        Only displays finished/crashed simulations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.usage_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str started__gt: started__gt
        :param str started__gte: started__gte
        :param str started__lt: started__lt
        :param str started__lte: started__lte
        :param str started__date: started__date
        :param str started__date__gt: started__date__gt
        :param str started__date__gte: started__date__gte
        :param str started__date__lt: started__date__lt
        :param str started__date__lte: started__date__lte
        :param str started__year: started__year
        :param str started__year__gt: started__year__gt
        :param str started__year__gte: started__year__gte
        :param str started__year__lt: started__year__lt
        :param str started__year__lte: started__year__lte
        :param str started__month: started__month
        :param str started__month__lte: started__month__lte
        :param str finished__gt: finished__gt
        :param str finished__gte: finished__gte
        :param str finished__lt: finished__lt
        :param str finished__lte: finished__lte
        :param str finished__date: finished__date
        :param str finished__date__gt: finished__date__gt
        :param str finished__date__gte: finished__date__gte
        :param str finished__date__lt: finished__date__lt
        :param str finished__date__lte: finished__date__lte
        :param str finished__year: finished__year
        :param str finished__year__gt: finished__year__gt
        :param str finished__year__gte: finished__year__gte
        :param str finished__year__lt: finished__year__lt
        :param str finished__year__lte: finished__year__lte
        :param str finished__month: finished__month
        :param str finished__month__lte: finished__month__lte
        :param str total_time: total_time
        :param str total_time__gt: total_time__gt
        :param str total_time__gte: total_time__gte
        :param str total_time__lt: total_time__lt
        :param str total_time__lte: total_time__lte
        :param str total_time__isnull: total_time__isnull
        :param str simulation__id: simulation__id
        :param str simulation__name: simulation__name
        :param str simulation__name__iexact: simulation__name__iexact
        :param str simulation__name__contains: simulation__name__contains
        :param str simulation__name__icontains: simulation__name__icontains
        :param str simulation__name__in: simulation__name__in
        :param str simulation__name__startswith: simulation__name__startswith
        :param str simulation__name__istartswith: simulation__name__istartswith
        :param str simulation__name__endswith: simulation__name__endswith
        :param str simulation__name__regex: simulation__name__regex
        :param str simulation__threedimodel__id: simulation__threedimodel__id
        :param str simulation__threedimodel__id__gt: simulation__threedimodel__id__gt
        :param str simulation__threedimodel__id__gte: simulation__threedimodel__id__gte
        :param str simulation__threedimodel__id__lt: simulation__threedimodel__id__lt
        :param str simulation__threedimodel__id__lte: simulation__threedimodel__id__lte
        :param str simulation__threedimodel__id__isnull: simulation__threedimodel__id__isnull
        :param str simulation__threedimodel__name: simulation__threedimodel__name
        :param str simulation__threedimodel__name__iexact: simulation__threedimodel__name__iexact
        :param str simulation__threedimodel__name__contains: simulation__threedimodel__name__contains
        :param str simulation__threedimodel__name__icontains: simulation__threedimodel__name__icontains
        :param str simulation__threedimodel__name__in: simulation__threedimodel__name__in
        :param str simulation__threedimodel__name__startswith: simulation__threedimodel__name__startswith
        :param str simulation__threedimodel__name__istartswith: simulation__threedimodel__name__istartswith
        :param str simulation__threedimodel__name__endswith: simulation__threedimodel__name__endswith
        :param str simulation__threedimodel__name__regex: simulation__threedimodel__name__regex
        :param str simulation__user__username: simulation__user__username
        :param str simulation__user__username__iexact: simulation__user__username__iexact
        :param str simulation__user__username__contains: simulation__user__username__contains
        :param str simulation__user__username__icontains: simulation__user__username__icontains
        :param str simulation__user__username__in: simulation__user__username__in
        :param str simulation__user__username__startswith: simulation__user__username__startswith
        :param str simulation__user__username__istartswith: simulation__user__username__istartswith
        :param str simulation__user__username__endswith: simulation__user__username__endswith
        :param str simulation__user__username__regex: simulation__user__username__regex
        :param str simulation__active_status__name: simulation__active_status__name
        :param str simulation__active_status__name__iexact: simulation__active_status__name__iexact
        :param str simulation__active_status__name__contains: simulation__active_status__name__contains
        :param str simulation__active_status__name__icontains: simulation__active_status__name__icontains
        :param str simulation__active_status__name__in: simulation__active_status__name__in
        :param str simulation__active_status__name__startswith: simulation__active_status__name__startswith
        :param str simulation__active_status__name__istartswith: simulation__active_status__name__istartswith
        :param str simulation__active_status__name__endswith: simulation__active_status__name__endswith
        :param str simulation__active_status__name__regex: simulation__active_status__name__regex
        :param str simulation__type__live: simulation__type__live
        :param str simulation__organisation__name__istartswith: simulation__organisation__name__istartswith
        :param str simulation__organisation__unique_id: simulation__organisation__unique_id
        :param str simulation__status: simulation__active_status__name
        :param str simulation__tags__in: simulation__tags__in
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20080
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.usage_list_with_http_info(**kwargs)  # noqa: E501

    def usage_list_with_http_info(self, **kwargs):  # noqa: E501
        """View to display overview of ran simulations.  # noqa: E501

        Only displays finished/crashed simulations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.usage_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str started__gt: started__gt
        :param str started__gte: started__gte
        :param str started__lt: started__lt
        :param str started__lte: started__lte
        :param str started__date: started__date
        :param str started__date__gt: started__date__gt
        :param str started__date__gte: started__date__gte
        :param str started__date__lt: started__date__lt
        :param str started__date__lte: started__date__lte
        :param str started__year: started__year
        :param str started__year__gt: started__year__gt
        :param str started__year__gte: started__year__gte
        :param str started__year__lt: started__year__lt
        :param str started__year__lte: started__year__lte
        :param str started__month: started__month
        :param str started__month__lte: started__month__lte
        :param str finished__gt: finished__gt
        :param str finished__gte: finished__gte
        :param str finished__lt: finished__lt
        :param str finished__lte: finished__lte
        :param str finished__date: finished__date
        :param str finished__date__gt: finished__date__gt
        :param str finished__date__gte: finished__date__gte
        :param str finished__date__lt: finished__date__lt
        :param str finished__date__lte: finished__date__lte
        :param str finished__year: finished__year
        :param str finished__year__gt: finished__year__gt
        :param str finished__year__gte: finished__year__gte
        :param str finished__year__lt: finished__year__lt
        :param str finished__year__lte: finished__year__lte
        :param str finished__month: finished__month
        :param str finished__month__lte: finished__month__lte
        :param str total_time: total_time
        :param str total_time__gt: total_time__gt
        :param str total_time__gte: total_time__gte
        :param str total_time__lt: total_time__lt
        :param str total_time__lte: total_time__lte
        :param str total_time__isnull: total_time__isnull
        :param str simulation__id: simulation__id
        :param str simulation__name: simulation__name
        :param str simulation__name__iexact: simulation__name__iexact
        :param str simulation__name__contains: simulation__name__contains
        :param str simulation__name__icontains: simulation__name__icontains
        :param str simulation__name__in: simulation__name__in
        :param str simulation__name__startswith: simulation__name__startswith
        :param str simulation__name__istartswith: simulation__name__istartswith
        :param str simulation__name__endswith: simulation__name__endswith
        :param str simulation__name__regex: simulation__name__regex
        :param str simulation__threedimodel__id: simulation__threedimodel__id
        :param str simulation__threedimodel__id__gt: simulation__threedimodel__id__gt
        :param str simulation__threedimodel__id__gte: simulation__threedimodel__id__gte
        :param str simulation__threedimodel__id__lt: simulation__threedimodel__id__lt
        :param str simulation__threedimodel__id__lte: simulation__threedimodel__id__lte
        :param str simulation__threedimodel__id__isnull: simulation__threedimodel__id__isnull
        :param str simulation__threedimodel__name: simulation__threedimodel__name
        :param str simulation__threedimodel__name__iexact: simulation__threedimodel__name__iexact
        :param str simulation__threedimodel__name__contains: simulation__threedimodel__name__contains
        :param str simulation__threedimodel__name__icontains: simulation__threedimodel__name__icontains
        :param str simulation__threedimodel__name__in: simulation__threedimodel__name__in
        :param str simulation__threedimodel__name__startswith: simulation__threedimodel__name__startswith
        :param str simulation__threedimodel__name__istartswith: simulation__threedimodel__name__istartswith
        :param str simulation__threedimodel__name__endswith: simulation__threedimodel__name__endswith
        :param str simulation__threedimodel__name__regex: simulation__threedimodel__name__regex
        :param str simulation__user__username: simulation__user__username
        :param str simulation__user__username__iexact: simulation__user__username__iexact
        :param str simulation__user__username__contains: simulation__user__username__contains
        :param str simulation__user__username__icontains: simulation__user__username__icontains
        :param str simulation__user__username__in: simulation__user__username__in
        :param str simulation__user__username__startswith: simulation__user__username__startswith
        :param str simulation__user__username__istartswith: simulation__user__username__istartswith
        :param str simulation__user__username__endswith: simulation__user__username__endswith
        :param str simulation__user__username__regex: simulation__user__username__regex
        :param str simulation__active_status__name: simulation__active_status__name
        :param str simulation__active_status__name__iexact: simulation__active_status__name__iexact
        :param str simulation__active_status__name__contains: simulation__active_status__name__contains
        :param str simulation__active_status__name__icontains: simulation__active_status__name__icontains
        :param str simulation__active_status__name__in: simulation__active_status__name__in
        :param str simulation__active_status__name__startswith: simulation__active_status__name__startswith
        :param str simulation__active_status__name__istartswith: simulation__active_status__name__istartswith
        :param str simulation__active_status__name__endswith: simulation__active_status__name__endswith
        :param str simulation__active_status__name__regex: simulation__active_status__name__regex
        :param str simulation__type__live: simulation__type__live
        :param str simulation__organisation__name__istartswith: simulation__organisation__name__istartswith
        :param str simulation__organisation__unique_id: simulation__organisation__unique_id
        :param str simulation__status: simulation__active_status__name
        :param str simulation__tags__in: simulation__tags__in
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20080, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'started__gt',
            'started__gte',
            'started__lt',
            'started__lte',
            'started__date',
            'started__date__gt',
            'started__date__gte',
            'started__date__lt',
            'started__date__lte',
            'started__year',
            'started__year__gt',
            'started__year__gte',
            'started__year__lt',
            'started__year__lte',
            'started__month',
            'started__month__lte',
            'finished__gt',
            'finished__gte',
            'finished__lt',
            'finished__lte',
            'finished__date',
            'finished__date__gt',
            'finished__date__gte',
            'finished__date__lt',
            'finished__date__lte',
            'finished__year',
            'finished__year__gt',
            'finished__year__gte',
            'finished__year__lt',
            'finished__year__lte',
            'finished__month',
            'finished__month__lte',
            'total_time',
            'total_time__gt',
            'total_time__gte',
            'total_time__lt',
            'total_time__lte',
            'total_time__isnull',
            'simulation__id',
            'simulation__name',
            'simulation__name__iexact',
            'simulation__name__contains',
            'simulation__name__icontains',
            'simulation__name__in',
            'simulation__name__startswith',
            'simulation__name__istartswith',
            'simulation__name__endswith',
            'simulation__name__regex',
            'simulation__threedimodel__id',
            'simulation__threedimodel__id__gt',
            'simulation__threedimodel__id__gte',
            'simulation__threedimodel__id__lt',
            'simulation__threedimodel__id__lte',
            'simulation__threedimodel__id__isnull',
            'simulation__threedimodel__name',
            'simulation__threedimodel__name__iexact',
            'simulation__threedimodel__name__contains',
            'simulation__threedimodel__name__icontains',
            'simulation__threedimodel__name__in',
            'simulation__threedimodel__name__startswith',
            'simulation__threedimodel__name__istartswith',
            'simulation__threedimodel__name__endswith',
            'simulation__threedimodel__name__regex',
            'simulation__user__username',
            'simulation__user__username__iexact',
            'simulation__user__username__contains',
            'simulation__user__username__icontains',
            'simulation__user__username__in',
            'simulation__user__username__startswith',
            'simulation__user__username__istartswith',
            'simulation__user__username__endswith',
            'simulation__user__username__regex',
            'simulation__active_status__name',
            'simulation__active_status__name__iexact',
            'simulation__active_status__name__contains',
            'simulation__active_status__name__icontains',
            'simulation__active_status__name__in',
            'simulation__active_status__name__startswith',
            'simulation__active_status__name__istartswith',
            'simulation__active_status__name__endswith',
            'simulation__active_status__name__regex',
            'simulation__type__live',
            'simulation__organisation__name__istartswith',
            'simulation__organisation__unique_id',
            'simulation__status',
            'simulation__tags__in',
            'ordering',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method usage_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'started__gt' in local_var_params and local_var_params['started__gt'] is not None:  # noqa: E501
            query_params.append(('started__gt', local_var_params['started__gt']))  # noqa: E501
        if 'started__gte' in local_var_params and local_var_params['started__gte'] is not None:  # noqa: E501
            query_params.append(('started__gte', local_var_params['started__gte']))  # noqa: E501
        if 'started__lt' in local_var_params and local_var_params['started__lt'] is not None:  # noqa: E501
            query_params.append(('started__lt', local_var_params['started__lt']))  # noqa: E501
        if 'started__lte' in local_var_params and local_var_params['started__lte'] is not None:  # noqa: E501
            query_params.append(('started__lte', local_var_params['started__lte']))  # noqa: E501
        if 'started__date' in local_var_params and local_var_params['started__date'] is not None:  # noqa: E501
            query_params.append(('started__date', local_var_params['started__date']))  # noqa: E501
        if 'started__date__gt' in local_var_params and local_var_params['started__date__gt'] is not None:  # noqa: E501
            query_params.append(('started__date__gt', local_var_params['started__date__gt']))  # noqa: E501
        if 'started__date__gte' in local_var_params and local_var_params['started__date__gte'] is not None:  # noqa: E501
            query_params.append(('started__date__gte', local_var_params['started__date__gte']))  # noqa: E501
        if 'started__date__lt' in local_var_params and local_var_params['started__date__lt'] is not None:  # noqa: E501
            query_params.append(('started__date__lt', local_var_params['started__date__lt']))  # noqa: E501
        if 'started__date__lte' in local_var_params and local_var_params['started__date__lte'] is not None:  # noqa: E501
            query_params.append(('started__date__lte', local_var_params['started__date__lte']))  # noqa: E501
        if 'started__year' in local_var_params and local_var_params['started__year'] is not None:  # noqa: E501
            query_params.append(('started__year', local_var_params['started__year']))  # noqa: E501
        if 'started__year__gt' in local_var_params and local_var_params['started__year__gt'] is not None:  # noqa: E501
            query_params.append(('started__year__gt', local_var_params['started__year__gt']))  # noqa: E501
        if 'started__year__gte' in local_var_params and local_var_params['started__year__gte'] is not None:  # noqa: E501
            query_params.append(('started__year__gte', local_var_params['started__year__gte']))  # noqa: E501
        if 'started__year__lt' in local_var_params and local_var_params['started__year__lt'] is not None:  # noqa: E501
            query_params.append(('started__year__lt', local_var_params['started__year__lt']))  # noqa: E501
        if 'started__year__lte' in local_var_params and local_var_params['started__year__lte'] is not None:  # noqa: E501
            query_params.append(('started__year__lte', local_var_params['started__year__lte']))  # noqa: E501
        if 'started__month' in local_var_params and local_var_params['started__month'] is not None:  # noqa: E501
            query_params.append(('started__month', local_var_params['started__month']))  # noqa: E501
        if 'started__month__lte' in local_var_params and local_var_params['started__month__lte'] is not None:  # noqa: E501
            query_params.append(('started__month__lte', local_var_params['started__month__lte']))  # noqa: E501
        if 'finished__gt' in local_var_params and local_var_params['finished__gt'] is not None:  # noqa: E501
            query_params.append(('finished__gt', local_var_params['finished__gt']))  # noqa: E501
        if 'finished__gte' in local_var_params and local_var_params['finished__gte'] is not None:  # noqa: E501
            query_params.append(('finished__gte', local_var_params['finished__gte']))  # noqa: E501
        if 'finished__lt' in local_var_params and local_var_params['finished__lt'] is not None:  # noqa: E501
            query_params.append(('finished__lt', local_var_params['finished__lt']))  # noqa: E501
        if 'finished__lte' in local_var_params and local_var_params['finished__lte'] is not None:  # noqa: E501
            query_params.append(('finished__lte', local_var_params['finished__lte']))  # noqa: E501
        if 'finished__date' in local_var_params and local_var_params['finished__date'] is not None:  # noqa: E501
            query_params.append(('finished__date', local_var_params['finished__date']))  # noqa: E501
        if 'finished__date__gt' in local_var_params and local_var_params['finished__date__gt'] is not None:  # noqa: E501
            query_params.append(('finished__date__gt', local_var_params['finished__date__gt']))  # noqa: E501
        if 'finished__date__gte' in local_var_params and local_var_params['finished__date__gte'] is not None:  # noqa: E501
            query_params.append(('finished__date__gte', local_var_params['finished__date__gte']))  # noqa: E501
        if 'finished__date__lt' in local_var_params and local_var_params['finished__date__lt'] is not None:  # noqa: E501
            query_params.append(('finished__date__lt', local_var_params['finished__date__lt']))  # noqa: E501
        if 'finished__date__lte' in local_var_params and local_var_params['finished__date__lte'] is not None:  # noqa: E501
            query_params.append(('finished__date__lte', local_var_params['finished__date__lte']))  # noqa: E501
        if 'finished__year' in local_var_params and local_var_params['finished__year'] is not None:  # noqa: E501
            query_params.append(('finished__year', local_var_params['finished__year']))  # noqa: E501
        if 'finished__year__gt' in local_var_params and local_var_params['finished__year__gt'] is not None:  # noqa: E501
            query_params.append(('finished__year__gt', local_var_params['finished__year__gt']))  # noqa: E501
        if 'finished__year__gte' in local_var_params and local_var_params['finished__year__gte'] is not None:  # noqa: E501
            query_params.append(('finished__year__gte', local_var_params['finished__year__gte']))  # noqa: E501
        if 'finished__year__lt' in local_var_params and local_var_params['finished__year__lt'] is not None:  # noqa: E501
            query_params.append(('finished__year__lt', local_var_params['finished__year__lt']))  # noqa: E501
        if 'finished__year__lte' in local_var_params and local_var_params['finished__year__lte'] is not None:  # noqa: E501
            query_params.append(('finished__year__lte', local_var_params['finished__year__lte']))  # noqa: E501
        if 'finished__month' in local_var_params and local_var_params['finished__month'] is not None:  # noqa: E501
            query_params.append(('finished__month', local_var_params['finished__month']))  # noqa: E501
        if 'finished__month__lte' in local_var_params and local_var_params['finished__month__lte'] is not None:  # noqa: E501
            query_params.append(('finished__month__lte', local_var_params['finished__month__lte']))  # noqa: E501
        if 'total_time' in local_var_params and local_var_params['total_time'] is not None:  # noqa: E501
            query_params.append(('total_time', local_var_params['total_time']))  # noqa: E501
        if 'total_time__gt' in local_var_params and local_var_params['total_time__gt'] is not None:  # noqa: E501
            query_params.append(('total_time__gt', local_var_params['total_time__gt']))  # noqa: E501
        if 'total_time__gte' in local_var_params and local_var_params['total_time__gte'] is not None:  # noqa: E501
            query_params.append(('total_time__gte', local_var_params['total_time__gte']))  # noqa: E501
        if 'total_time__lt' in local_var_params and local_var_params['total_time__lt'] is not None:  # noqa: E501
            query_params.append(('total_time__lt', local_var_params['total_time__lt']))  # noqa: E501
        if 'total_time__lte' in local_var_params and local_var_params['total_time__lte'] is not None:  # noqa: E501
            query_params.append(('total_time__lte', local_var_params['total_time__lte']))  # noqa: E501
        if 'total_time__isnull' in local_var_params and local_var_params['total_time__isnull'] is not None:  # noqa: E501
            query_params.append(('total_time__isnull', local_var_params['total_time__isnull']))  # noqa: E501
        if 'simulation__id' in local_var_params and local_var_params['simulation__id'] is not None:  # noqa: E501
            query_params.append(('simulation__id', local_var_params['simulation__id']))  # noqa: E501
        if 'simulation__name' in local_var_params and local_var_params['simulation__name'] is not None:  # noqa: E501
            query_params.append(('simulation__name', local_var_params['simulation__name']))  # noqa: E501
        if 'simulation__name__iexact' in local_var_params and local_var_params['simulation__name__iexact'] is not None:  # noqa: E501
            query_params.append(('simulation__name__iexact', local_var_params['simulation__name__iexact']))  # noqa: E501
        if 'simulation__name__contains' in local_var_params and local_var_params['simulation__name__contains'] is not None:  # noqa: E501
            query_params.append(('simulation__name__contains', local_var_params['simulation__name__contains']))  # noqa: E501
        if 'simulation__name__icontains' in local_var_params and local_var_params['simulation__name__icontains'] is not None:  # noqa: E501
            query_params.append(('simulation__name__icontains', local_var_params['simulation__name__icontains']))  # noqa: E501
        if 'simulation__name__in' in local_var_params and local_var_params['simulation__name__in'] is not None:  # noqa: E501
            query_params.append(('simulation__name__in', local_var_params['simulation__name__in']))  # noqa: E501
        if 'simulation__name__startswith' in local_var_params and local_var_params['simulation__name__startswith'] is not None:  # noqa: E501
            query_params.append(('simulation__name__startswith', local_var_params['simulation__name__startswith']))  # noqa: E501
        if 'simulation__name__istartswith' in local_var_params and local_var_params['simulation__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('simulation__name__istartswith', local_var_params['simulation__name__istartswith']))  # noqa: E501
        if 'simulation__name__endswith' in local_var_params and local_var_params['simulation__name__endswith'] is not None:  # noqa: E501
            query_params.append(('simulation__name__endswith', local_var_params['simulation__name__endswith']))  # noqa: E501
        if 'simulation__name__regex' in local_var_params and local_var_params['simulation__name__regex'] is not None:  # noqa: E501
            query_params.append(('simulation__name__regex', local_var_params['simulation__name__regex']))  # noqa: E501
        if 'simulation__threedimodel__id' in local_var_params and local_var_params['simulation__threedimodel__id'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__id', local_var_params['simulation__threedimodel__id']))  # noqa: E501
        if 'simulation__threedimodel__id__gt' in local_var_params and local_var_params['simulation__threedimodel__id__gt'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__id__gt', local_var_params['simulation__threedimodel__id__gt']))  # noqa: E501
        if 'simulation__threedimodel__id__gte' in local_var_params and local_var_params['simulation__threedimodel__id__gte'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__id__gte', local_var_params['simulation__threedimodel__id__gte']))  # noqa: E501
        if 'simulation__threedimodel__id__lt' in local_var_params and local_var_params['simulation__threedimodel__id__lt'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__id__lt', local_var_params['simulation__threedimodel__id__lt']))  # noqa: E501
        if 'simulation__threedimodel__id__lte' in local_var_params and local_var_params['simulation__threedimodel__id__lte'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__id__lte', local_var_params['simulation__threedimodel__id__lte']))  # noqa: E501
        if 'simulation__threedimodel__id__isnull' in local_var_params and local_var_params['simulation__threedimodel__id__isnull'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__id__isnull', local_var_params['simulation__threedimodel__id__isnull']))  # noqa: E501
        if 'simulation__threedimodel__name' in local_var_params and local_var_params['simulation__threedimodel__name'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__name', local_var_params['simulation__threedimodel__name']))  # noqa: E501
        if 'simulation__threedimodel__name__iexact' in local_var_params and local_var_params['simulation__threedimodel__name__iexact'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__name__iexact', local_var_params['simulation__threedimodel__name__iexact']))  # noqa: E501
        if 'simulation__threedimodel__name__contains' in local_var_params and local_var_params['simulation__threedimodel__name__contains'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__name__contains', local_var_params['simulation__threedimodel__name__contains']))  # noqa: E501
        if 'simulation__threedimodel__name__icontains' in local_var_params and local_var_params['simulation__threedimodel__name__icontains'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__name__icontains', local_var_params['simulation__threedimodel__name__icontains']))  # noqa: E501
        if 'simulation__threedimodel__name__in' in local_var_params and local_var_params['simulation__threedimodel__name__in'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__name__in', local_var_params['simulation__threedimodel__name__in']))  # noqa: E501
        if 'simulation__threedimodel__name__startswith' in local_var_params and local_var_params['simulation__threedimodel__name__startswith'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__name__startswith', local_var_params['simulation__threedimodel__name__startswith']))  # noqa: E501
        if 'simulation__threedimodel__name__istartswith' in local_var_params and local_var_params['simulation__threedimodel__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__name__istartswith', local_var_params['simulation__threedimodel__name__istartswith']))  # noqa: E501
        if 'simulation__threedimodel__name__endswith' in local_var_params and local_var_params['simulation__threedimodel__name__endswith'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__name__endswith', local_var_params['simulation__threedimodel__name__endswith']))  # noqa: E501
        if 'simulation__threedimodel__name__regex' in local_var_params and local_var_params['simulation__threedimodel__name__regex'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__name__regex', local_var_params['simulation__threedimodel__name__regex']))  # noqa: E501
        if 'simulation__user__username' in local_var_params and local_var_params['simulation__user__username'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username', local_var_params['simulation__user__username']))  # noqa: E501
        if 'simulation__user__username__iexact' in local_var_params and local_var_params['simulation__user__username__iexact'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username__iexact', local_var_params['simulation__user__username__iexact']))  # noqa: E501
        if 'simulation__user__username__contains' in local_var_params and local_var_params['simulation__user__username__contains'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username__contains', local_var_params['simulation__user__username__contains']))  # noqa: E501
        if 'simulation__user__username__icontains' in local_var_params and local_var_params['simulation__user__username__icontains'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username__icontains', local_var_params['simulation__user__username__icontains']))  # noqa: E501
        if 'simulation__user__username__in' in local_var_params and local_var_params['simulation__user__username__in'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username__in', local_var_params['simulation__user__username__in']))  # noqa: E501
        if 'simulation__user__username__startswith' in local_var_params and local_var_params['simulation__user__username__startswith'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username__startswith', local_var_params['simulation__user__username__startswith']))  # noqa: E501
        if 'simulation__user__username__istartswith' in local_var_params and local_var_params['simulation__user__username__istartswith'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username__istartswith', local_var_params['simulation__user__username__istartswith']))  # noqa: E501
        if 'simulation__user__username__endswith' in local_var_params and local_var_params['simulation__user__username__endswith'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username__endswith', local_var_params['simulation__user__username__endswith']))  # noqa: E501
        if 'simulation__user__username__regex' in local_var_params and local_var_params['simulation__user__username__regex'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username__regex', local_var_params['simulation__user__username__regex']))  # noqa: E501
        if 'simulation__active_status__name' in local_var_params and local_var_params['simulation__active_status__name'] is not None:  # noqa: E501
            query_params.append(('simulation__active_status__name', local_var_params['simulation__active_status__name']))  # noqa: E501
        if 'simulation__active_status__name__iexact' in local_var_params and local_var_params['simulation__active_status__name__iexact'] is not None:  # noqa: E501
            query_params.append(('simulation__active_status__name__iexact', local_var_params['simulation__active_status__name__iexact']))  # noqa: E501
        if 'simulation__active_status__name__contains' in local_var_params and local_var_params['simulation__active_status__name__contains'] is not None:  # noqa: E501
            query_params.append(('simulation__active_status__name__contains', local_var_params['simulation__active_status__name__contains']))  # noqa: E501
        if 'simulation__active_status__name__icontains' in local_var_params and local_var_params['simulation__active_status__name__icontains'] is not None:  # noqa: E501
            query_params.append(('simulation__active_status__name__icontains', local_var_params['simulation__active_status__name__icontains']))  # noqa: E501
        if 'simulation__active_status__name__in' in local_var_params and local_var_params['simulation__active_status__name__in'] is not None:  # noqa: E501
            query_params.append(('simulation__active_status__name__in', local_var_params['simulation__active_status__name__in']))  # noqa: E501
        if 'simulation__active_status__name__startswith' in local_var_params and local_var_params['simulation__active_status__name__startswith'] is not None:  # noqa: E501
            query_params.append(('simulation__active_status__name__startswith', local_var_params['simulation__active_status__name__startswith']))  # noqa: E501
        if 'simulation__active_status__name__istartswith' in local_var_params and local_var_params['simulation__active_status__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('simulation__active_status__name__istartswith', local_var_params['simulation__active_status__name__istartswith']))  # noqa: E501
        if 'simulation__active_status__name__endswith' in local_var_params and local_var_params['simulation__active_status__name__endswith'] is not None:  # noqa: E501
            query_params.append(('simulation__active_status__name__endswith', local_var_params['simulation__active_status__name__endswith']))  # noqa: E501
        if 'simulation__active_status__name__regex' in local_var_params and local_var_params['simulation__active_status__name__regex'] is not None:  # noqa: E501
            query_params.append(('simulation__active_status__name__regex', local_var_params['simulation__active_status__name__regex']))  # noqa: E501
        if 'simulation__type__live' in local_var_params and local_var_params['simulation__type__live'] is not None:  # noqa: E501
            query_params.append(('simulation__type__live', local_var_params['simulation__type__live']))  # noqa: E501
        if 'simulation__organisation__name__istartswith' in local_var_params and local_var_params['simulation__organisation__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('simulation__organisation__name__istartswith', local_var_params['simulation__organisation__name__istartswith']))  # noqa: E501
        if 'simulation__organisation__unique_id' in local_var_params and local_var_params['simulation__organisation__unique_id'] is not None:  # noqa: E501
            query_params.append(('simulation__organisation__unique_id', local_var_params['simulation__organisation__unique_id']))  # noqa: E501
        if 'simulation__status' in local_var_params and local_var_params['simulation__status'] is not None:  # noqa: E501
            query_params.append(('simulation__status', local_var_params['simulation__status']))  # noqa: E501
        if 'simulation__tags__in' in local_var_params and local_var_params['simulation__tags__in'] is not None:  # noqa: E501
            query_params.append(('simulation__tags__in', local_var_params['simulation__tags__in']))  # noqa: E501
        if 'ordering' in local_var_params and local_var_params['ordering'] is not None:  # noqa: E501
            query_params.append(('ordering', local_var_params['ordering']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/usage/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20080',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def usage_read(self, id, **kwargs):  # noqa: E501
        """View to display overview of ran simulations.  # noqa: E501

        Only displays finished/crashed simulations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.usage_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this usage. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Usage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.usage_read_with_http_info(id, **kwargs)  # noqa: E501

    def usage_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """View to display overview of ran simulations.  # noqa: E501

        Only displays finished/crashed simulations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.usage_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this usage. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Usage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method usage_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `usage_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/usage/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Usage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def usage_statistics(self, **kwargs):  # noqa: E501
        """Usage statistics like total session count, average session duration and such.  # noqa: E501

        This endpoint comes in handy if you want to aggregate usage number over a certain period of time, for a given user or organisation.  It is also possible to limit the result to a certain simulation type, e.g. to \"live\" sessions. Use the `simulation__type__live` filter with either `true` or `false` as input values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.usage_statistics(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str started__gt: started__gt
        :param str started__gte: started__gte
        :param str started__lt: started__lt
        :param str started__lte: started__lte
        :param str started__date: started__date
        :param str started__date__gt: started__date__gt
        :param str started__date__gte: started__date__gte
        :param str started__date__lt: started__date__lt
        :param str started__date__lte: started__date__lte
        :param str started__year: started__year
        :param str started__year__gt: started__year__gt
        :param str started__year__gte: started__year__gte
        :param str started__year__lt: started__year__lt
        :param str started__year__lte: started__year__lte
        :param str started__month: started__month
        :param str started__month__lte: started__month__lte
        :param str finished__gt: finished__gt
        :param str finished__gte: finished__gte
        :param str finished__lt: finished__lt
        :param str finished__lte: finished__lte
        :param str finished__date: finished__date
        :param str finished__date__gt: finished__date__gt
        :param str finished__date__gte: finished__date__gte
        :param str finished__date__lt: finished__date__lt
        :param str finished__date__lte: finished__date__lte
        :param str finished__year: finished__year
        :param str finished__year__gt: finished__year__gt
        :param str finished__year__gte: finished__year__gte
        :param str finished__year__lt: finished__year__lt
        :param str finished__year__lte: finished__year__lte
        :param str finished__month: finished__month
        :param str finished__month__lte: finished__month__lte
        :param str total_time: total_time
        :param str total_time__gt: total_time__gt
        :param str total_time__gte: total_time__gte
        :param str total_time__lt: total_time__lt
        :param str total_time__lte: total_time__lte
        :param str total_time__isnull: total_time__isnull
        :param str simulation__id: simulation__id
        :param str simulation__name: simulation__name
        :param str simulation__name__iexact: simulation__name__iexact
        :param str simulation__name__contains: simulation__name__contains
        :param str simulation__name__icontains: simulation__name__icontains
        :param str simulation__name__in: simulation__name__in
        :param str simulation__name__startswith: simulation__name__startswith
        :param str simulation__name__istartswith: simulation__name__istartswith
        :param str simulation__name__endswith: simulation__name__endswith
        :param str simulation__name__regex: simulation__name__regex
        :param str simulation__threedimodel__id: simulation__threedimodel__id
        :param str simulation__threedimodel__id__gt: simulation__threedimodel__id__gt
        :param str simulation__threedimodel__id__gte: simulation__threedimodel__id__gte
        :param str simulation__threedimodel__id__lt: simulation__threedimodel__id__lt
        :param str simulation__threedimodel__id__lte: simulation__threedimodel__id__lte
        :param str simulation__threedimodel__id__isnull: simulation__threedimodel__id__isnull
        :param str simulation__threedimodel__name: simulation__threedimodel__name
        :param str simulation__threedimodel__name__iexact: simulation__threedimodel__name__iexact
        :param str simulation__threedimodel__name__contains: simulation__threedimodel__name__contains
        :param str simulation__threedimodel__name__icontains: simulation__threedimodel__name__icontains
        :param str simulation__threedimodel__name__in: simulation__threedimodel__name__in
        :param str simulation__threedimodel__name__startswith: simulation__threedimodel__name__startswith
        :param str simulation__threedimodel__name__istartswith: simulation__threedimodel__name__istartswith
        :param str simulation__threedimodel__name__endswith: simulation__threedimodel__name__endswith
        :param str simulation__threedimodel__name__regex: simulation__threedimodel__name__regex
        :param str simulation__user__username: simulation__user__username
        :param str simulation__user__username__iexact: simulation__user__username__iexact
        :param str simulation__user__username__contains: simulation__user__username__contains
        :param str simulation__user__username__icontains: simulation__user__username__icontains
        :param str simulation__user__username__in: simulation__user__username__in
        :param str simulation__user__username__startswith: simulation__user__username__startswith
        :param str simulation__user__username__istartswith: simulation__user__username__istartswith
        :param str simulation__user__username__endswith: simulation__user__username__endswith
        :param str simulation__user__username__regex: simulation__user__username__regex
        :param str simulation__active_status__name: simulation__active_status__name
        :param str simulation__active_status__name__iexact: simulation__active_status__name__iexact
        :param str simulation__active_status__name__contains: simulation__active_status__name__contains
        :param str simulation__active_status__name__icontains: simulation__active_status__name__icontains
        :param str simulation__active_status__name__in: simulation__active_status__name__in
        :param str simulation__active_status__name__startswith: simulation__active_status__name__startswith
        :param str simulation__active_status__name__istartswith: simulation__active_status__name__istartswith
        :param str simulation__active_status__name__endswith: simulation__active_status__name__endswith
        :param str simulation__active_status__name__regex: simulation__active_status__name__regex
        :param str simulation__type__live: simulation__type__live
        :param str simulation__organisation__name__istartswith: simulation__organisation__name__istartswith
        :param str simulation__organisation__unique_id: simulation__organisation__unique_id
        :param str simulation__status: simulation__active_status__name
        :param str simulation__tags__in: simulation__tags__in
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UsageStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.usage_statistics_with_http_info(**kwargs)  # noqa: E501

    def usage_statistics_with_http_info(self, **kwargs):  # noqa: E501
        """Usage statistics like total session count, average session duration and such.  # noqa: E501

        This endpoint comes in handy if you want to aggregate usage number over a certain period of time, for a given user or organisation.  It is also possible to limit the result to a certain simulation type, e.g. to \"live\" sessions. Use the `simulation__type__live` filter with either `true` or `false` as input values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.usage_statistics_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str started__gt: started__gt
        :param str started__gte: started__gte
        :param str started__lt: started__lt
        :param str started__lte: started__lte
        :param str started__date: started__date
        :param str started__date__gt: started__date__gt
        :param str started__date__gte: started__date__gte
        :param str started__date__lt: started__date__lt
        :param str started__date__lte: started__date__lte
        :param str started__year: started__year
        :param str started__year__gt: started__year__gt
        :param str started__year__gte: started__year__gte
        :param str started__year__lt: started__year__lt
        :param str started__year__lte: started__year__lte
        :param str started__month: started__month
        :param str started__month__lte: started__month__lte
        :param str finished__gt: finished__gt
        :param str finished__gte: finished__gte
        :param str finished__lt: finished__lt
        :param str finished__lte: finished__lte
        :param str finished__date: finished__date
        :param str finished__date__gt: finished__date__gt
        :param str finished__date__gte: finished__date__gte
        :param str finished__date__lt: finished__date__lt
        :param str finished__date__lte: finished__date__lte
        :param str finished__year: finished__year
        :param str finished__year__gt: finished__year__gt
        :param str finished__year__gte: finished__year__gte
        :param str finished__year__lt: finished__year__lt
        :param str finished__year__lte: finished__year__lte
        :param str finished__month: finished__month
        :param str finished__month__lte: finished__month__lte
        :param str total_time: total_time
        :param str total_time__gt: total_time__gt
        :param str total_time__gte: total_time__gte
        :param str total_time__lt: total_time__lt
        :param str total_time__lte: total_time__lte
        :param str total_time__isnull: total_time__isnull
        :param str simulation__id: simulation__id
        :param str simulation__name: simulation__name
        :param str simulation__name__iexact: simulation__name__iexact
        :param str simulation__name__contains: simulation__name__contains
        :param str simulation__name__icontains: simulation__name__icontains
        :param str simulation__name__in: simulation__name__in
        :param str simulation__name__startswith: simulation__name__startswith
        :param str simulation__name__istartswith: simulation__name__istartswith
        :param str simulation__name__endswith: simulation__name__endswith
        :param str simulation__name__regex: simulation__name__regex
        :param str simulation__threedimodel__id: simulation__threedimodel__id
        :param str simulation__threedimodel__id__gt: simulation__threedimodel__id__gt
        :param str simulation__threedimodel__id__gte: simulation__threedimodel__id__gte
        :param str simulation__threedimodel__id__lt: simulation__threedimodel__id__lt
        :param str simulation__threedimodel__id__lte: simulation__threedimodel__id__lte
        :param str simulation__threedimodel__id__isnull: simulation__threedimodel__id__isnull
        :param str simulation__threedimodel__name: simulation__threedimodel__name
        :param str simulation__threedimodel__name__iexact: simulation__threedimodel__name__iexact
        :param str simulation__threedimodel__name__contains: simulation__threedimodel__name__contains
        :param str simulation__threedimodel__name__icontains: simulation__threedimodel__name__icontains
        :param str simulation__threedimodel__name__in: simulation__threedimodel__name__in
        :param str simulation__threedimodel__name__startswith: simulation__threedimodel__name__startswith
        :param str simulation__threedimodel__name__istartswith: simulation__threedimodel__name__istartswith
        :param str simulation__threedimodel__name__endswith: simulation__threedimodel__name__endswith
        :param str simulation__threedimodel__name__regex: simulation__threedimodel__name__regex
        :param str simulation__user__username: simulation__user__username
        :param str simulation__user__username__iexact: simulation__user__username__iexact
        :param str simulation__user__username__contains: simulation__user__username__contains
        :param str simulation__user__username__icontains: simulation__user__username__icontains
        :param str simulation__user__username__in: simulation__user__username__in
        :param str simulation__user__username__startswith: simulation__user__username__startswith
        :param str simulation__user__username__istartswith: simulation__user__username__istartswith
        :param str simulation__user__username__endswith: simulation__user__username__endswith
        :param str simulation__user__username__regex: simulation__user__username__regex
        :param str simulation__active_status__name: simulation__active_status__name
        :param str simulation__active_status__name__iexact: simulation__active_status__name__iexact
        :param str simulation__active_status__name__contains: simulation__active_status__name__contains
        :param str simulation__active_status__name__icontains: simulation__active_status__name__icontains
        :param str simulation__active_status__name__in: simulation__active_status__name__in
        :param str simulation__active_status__name__startswith: simulation__active_status__name__startswith
        :param str simulation__active_status__name__istartswith: simulation__active_status__name__istartswith
        :param str simulation__active_status__name__endswith: simulation__active_status__name__endswith
        :param str simulation__active_status__name__regex: simulation__active_status__name__regex
        :param str simulation__type__live: simulation__type__live
        :param str simulation__organisation__name__istartswith: simulation__organisation__name__istartswith
        :param str simulation__organisation__unique_id: simulation__organisation__unique_id
        :param str simulation__status: simulation__active_status__name
        :param str simulation__tags__in: simulation__tags__in
        :param str ordering: Which field to use when ordering the results.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UsageStatistics, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'started__gt',
            'started__gte',
            'started__lt',
            'started__lte',
            'started__date',
            'started__date__gt',
            'started__date__gte',
            'started__date__lt',
            'started__date__lte',
            'started__year',
            'started__year__gt',
            'started__year__gte',
            'started__year__lt',
            'started__year__lte',
            'started__month',
            'started__month__lte',
            'finished__gt',
            'finished__gte',
            'finished__lt',
            'finished__lte',
            'finished__date',
            'finished__date__gt',
            'finished__date__gte',
            'finished__date__lt',
            'finished__date__lte',
            'finished__year',
            'finished__year__gt',
            'finished__year__gte',
            'finished__year__lt',
            'finished__year__lte',
            'finished__month',
            'finished__month__lte',
            'total_time',
            'total_time__gt',
            'total_time__gte',
            'total_time__lt',
            'total_time__lte',
            'total_time__isnull',
            'simulation__id',
            'simulation__name',
            'simulation__name__iexact',
            'simulation__name__contains',
            'simulation__name__icontains',
            'simulation__name__in',
            'simulation__name__startswith',
            'simulation__name__istartswith',
            'simulation__name__endswith',
            'simulation__name__regex',
            'simulation__threedimodel__id',
            'simulation__threedimodel__id__gt',
            'simulation__threedimodel__id__gte',
            'simulation__threedimodel__id__lt',
            'simulation__threedimodel__id__lte',
            'simulation__threedimodel__id__isnull',
            'simulation__threedimodel__name',
            'simulation__threedimodel__name__iexact',
            'simulation__threedimodel__name__contains',
            'simulation__threedimodel__name__icontains',
            'simulation__threedimodel__name__in',
            'simulation__threedimodel__name__startswith',
            'simulation__threedimodel__name__istartswith',
            'simulation__threedimodel__name__endswith',
            'simulation__threedimodel__name__regex',
            'simulation__user__username',
            'simulation__user__username__iexact',
            'simulation__user__username__contains',
            'simulation__user__username__icontains',
            'simulation__user__username__in',
            'simulation__user__username__startswith',
            'simulation__user__username__istartswith',
            'simulation__user__username__endswith',
            'simulation__user__username__regex',
            'simulation__active_status__name',
            'simulation__active_status__name__iexact',
            'simulation__active_status__name__contains',
            'simulation__active_status__name__icontains',
            'simulation__active_status__name__in',
            'simulation__active_status__name__startswith',
            'simulation__active_status__name__istartswith',
            'simulation__active_status__name__endswith',
            'simulation__active_status__name__regex',
            'simulation__type__live',
            'simulation__organisation__name__istartswith',
            'simulation__organisation__unique_id',
            'simulation__status',
            'simulation__tags__in',
            'ordering',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method usage_statistics" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'started__gt' in local_var_params and local_var_params['started__gt'] is not None:  # noqa: E501
            query_params.append(('started__gt', local_var_params['started__gt']))  # noqa: E501
        if 'started__gte' in local_var_params and local_var_params['started__gte'] is not None:  # noqa: E501
            query_params.append(('started__gte', local_var_params['started__gte']))  # noqa: E501
        if 'started__lt' in local_var_params and local_var_params['started__lt'] is not None:  # noqa: E501
            query_params.append(('started__lt', local_var_params['started__lt']))  # noqa: E501
        if 'started__lte' in local_var_params and local_var_params['started__lte'] is not None:  # noqa: E501
            query_params.append(('started__lte', local_var_params['started__lte']))  # noqa: E501
        if 'started__date' in local_var_params and local_var_params['started__date'] is not None:  # noqa: E501
            query_params.append(('started__date', local_var_params['started__date']))  # noqa: E501
        if 'started__date__gt' in local_var_params and local_var_params['started__date__gt'] is not None:  # noqa: E501
            query_params.append(('started__date__gt', local_var_params['started__date__gt']))  # noqa: E501
        if 'started__date__gte' in local_var_params and local_var_params['started__date__gte'] is not None:  # noqa: E501
            query_params.append(('started__date__gte', local_var_params['started__date__gte']))  # noqa: E501
        if 'started__date__lt' in local_var_params and local_var_params['started__date__lt'] is not None:  # noqa: E501
            query_params.append(('started__date__lt', local_var_params['started__date__lt']))  # noqa: E501
        if 'started__date__lte' in local_var_params and local_var_params['started__date__lte'] is not None:  # noqa: E501
            query_params.append(('started__date__lte', local_var_params['started__date__lte']))  # noqa: E501
        if 'started__year' in local_var_params and local_var_params['started__year'] is not None:  # noqa: E501
            query_params.append(('started__year', local_var_params['started__year']))  # noqa: E501
        if 'started__year__gt' in local_var_params and local_var_params['started__year__gt'] is not None:  # noqa: E501
            query_params.append(('started__year__gt', local_var_params['started__year__gt']))  # noqa: E501
        if 'started__year__gte' in local_var_params and local_var_params['started__year__gte'] is not None:  # noqa: E501
            query_params.append(('started__year__gte', local_var_params['started__year__gte']))  # noqa: E501
        if 'started__year__lt' in local_var_params and local_var_params['started__year__lt'] is not None:  # noqa: E501
            query_params.append(('started__year__lt', local_var_params['started__year__lt']))  # noqa: E501
        if 'started__year__lte' in local_var_params and local_var_params['started__year__lte'] is not None:  # noqa: E501
            query_params.append(('started__year__lte', local_var_params['started__year__lte']))  # noqa: E501
        if 'started__month' in local_var_params and local_var_params['started__month'] is not None:  # noqa: E501
            query_params.append(('started__month', local_var_params['started__month']))  # noqa: E501
        if 'started__month__lte' in local_var_params and local_var_params['started__month__lte'] is not None:  # noqa: E501
            query_params.append(('started__month__lte', local_var_params['started__month__lte']))  # noqa: E501
        if 'finished__gt' in local_var_params and local_var_params['finished__gt'] is not None:  # noqa: E501
            query_params.append(('finished__gt', local_var_params['finished__gt']))  # noqa: E501
        if 'finished__gte' in local_var_params and local_var_params['finished__gte'] is not None:  # noqa: E501
            query_params.append(('finished__gte', local_var_params['finished__gte']))  # noqa: E501
        if 'finished__lt' in local_var_params and local_var_params['finished__lt'] is not None:  # noqa: E501
            query_params.append(('finished__lt', local_var_params['finished__lt']))  # noqa: E501
        if 'finished__lte' in local_var_params and local_var_params['finished__lte'] is not None:  # noqa: E501
            query_params.append(('finished__lte', local_var_params['finished__lte']))  # noqa: E501
        if 'finished__date' in local_var_params and local_var_params['finished__date'] is not None:  # noqa: E501
            query_params.append(('finished__date', local_var_params['finished__date']))  # noqa: E501
        if 'finished__date__gt' in local_var_params and local_var_params['finished__date__gt'] is not None:  # noqa: E501
            query_params.append(('finished__date__gt', local_var_params['finished__date__gt']))  # noqa: E501
        if 'finished__date__gte' in local_var_params and local_var_params['finished__date__gte'] is not None:  # noqa: E501
            query_params.append(('finished__date__gte', local_var_params['finished__date__gte']))  # noqa: E501
        if 'finished__date__lt' in local_var_params and local_var_params['finished__date__lt'] is not None:  # noqa: E501
            query_params.append(('finished__date__lt', local_var_params['finished__date__lt']))  # noqa: E501
        if 'finished__date__lte' in local_var_params and local_var_params['finished__date__lte'] is not None:  # noqa: E501
            query_params.append(('finished__date__lte', local_var_params['finished__date__lte']))  # noqa: E501
        if 'finished__year' in local_var_params and local_var_params['finished__year'] is not None:  # noqa: E501
            query_params.append(('finished__year', local_var_params['finished__year']))  # noqa: E501
        if 'finished__year__gt' in local_var_params and local_var_params['finished__year__gt'] is not None:  # noqa: E501
            query_params.append(('finished__year__gt', local_var_params['finished__year__gt']))  # noqa: E501
        if 'finished__year__gte' in local_var_params and local_var_params['finished__year__gte'] is not None:  # noqa: E501
            query_params.append(('finished__year__gte', local_var_params['finished__year__gte']))  # noqa: E501
        if 'finished__year__lt' in local_var_params and local_var_params['finished__year__lt'] is not None:  # noqa: E501
            query_params.append(('finished__year__lt', local_var_params['finished__year__lt']))  # noqa: E501
        if 'finished__year__lte' in local_var_params and local_var_params['finished__year__lte'] is not None:  # noqa: E501
            query_params.append(('finished__year__lte', local_var_params['finished__year__lte']))  # noqa: E501
        if 'finished__month' in local_var_params and local_var_params['finished__month'] is not None:  # noqa: E501
            query_params.append(('finished__month', local_var_params['finished__month']))  # noqa: E501
        if 'finished__month__lte' in local_var_params and local_var_params['finished__month__lte'] is not None:  # noqa: E501
            query_params.append(('finished__month__lte', local_var_params['finished__month__lte']))  # noqa: E501
        if 'total_time' in local_var_params and local_var_params['total_time'] is not None:  # noqa: E501
            query_params.append(('total_time', local_var_params['total_time']))  # noqa: E501
        if 'total_time__gt' in local_var_params and local_var_params['total_time__gt'] is not None:  # noqa: E501
            query_params.append(('total_time__gt', local_var_params['total_time__gt']))  # noqa: E501
        if 'total_time__gte' in local_var_params and local_var_params['total_time__gte'] is not None:  # noqa: E501
            query_params.append(('total_time__gte', local_var_params['total_time__gte']))  # noqa: E501
        if 'total_time__lt' in local_var_params and local_var_params['total_time__lt'] is not None:  # noqa: E501
            query_params.append(('total_time__lt', local_var_params['total_time__lt']))  # noqa: E501
        if 'total_time__lte' in local_var_params and local_var_params['total_time__lte'] is not None:  # noqa: E501
            query_params.append(('total_time__lte', local_var_params['total_time__lte']))  # noqa: E501
        if 'total_time__isnull' in local_var_params and local_var_params['total_time__isnull'] is not None:  # noqa: E501
            query_params.append(('total_time__isnull', local_var_params['total_time__isnull']))  # noqa: E501
        if 'simulation__id' in local_var_params and local_var_params['simulation__id'] is not None:  # noqa: E501
            query_params.append(('simulation__id', local_var_params['simulation__id']))  # noqa: E501
        if 'simulation__name' in local_var_params and local_var_params['simulation__name'] is not None:  # noqa: E501
            query_params.append(('simulation__name', local_var_params['simulation__name']))  # noqa: E501
        if 'simulation__name__iexact' in local_var_params and local_var_params['simulation__name__iexact'] is not None:  # noqa: E501
            query_params.append(('simulation__name__iexact', local_var_params['simulation__name__iexact']))  # noqa: E501
        if 'simulation__name__contains' in local_var_params and local_var_params['simulation__name__contains'] is not None:  # noqa: E501
            query_params.append(('simulation__name__contains', local_var_params['simulation__name__contains']))  # noqa: E501
        if 'simulation__name__icontains' in local_var_params and local_var_params['simulation__name__icontains'] is not None:  # noqa: E501
            query_params.append(('simulation__name__icontains', local_var_params['simulation__name__icontains']))  # noqa: E501
        if 'simulation__name__in' in local_var_params and local_var_params['simulation__name__in'] is not None:  # noqa: E501
            query_params.append(('simulation__name__in', local_var_params['simulation__name__in']))  # noqa: E501
        if 'simulation__name__startswith' in local_var_params and local_var_params['simulation__name__startswith'] is not None:  # noqa: E501
            query_params.append(('simulation__name__startswith', local_var_params['simulation__name__startswith']))  # noqa: E501
        if 'simulation__name__istartswith' in local_var_params and local_var_params['simulation__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('simulation__name__istartswith', local_var_params['simulation__name__istartswith']))  # noqa: E501
        if 'simulation__name__endswith' in local_var_params and local_var_params['simulation__name__endswith'] is not None:  # noqa: E501
            query_params.append(('simulation__name__endswith', local_var_params['simulation__name__endswith']))  # noqa: E501
        if 'simulation__name__regex' in local_var_params and local_var_params['simulation__name__regex'] is not None:  # noqa: E501
            query_params.append(('simulation__name__regex', local_var_params['simulation__name__regex']))  # noqa: E501
        if 'simulation__threedimodel__id' in local_var_params and local_var_params['simulation__threedimodel__id'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__id', local_var_params['simulation__threedimodel__id']))  # noqa: E501
        if 'simulation__threedimodel__id__gt' in local_var_params and local_var_params['simulation__threedimodel__id__gt'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__id__gt', local_var_params['simulation__threedimodel__id__gt']))  # noqa: E501
        if 'simulation__threedimodel__id__gte' in local_var_params and local_var_params['simulation__threedimodel__id__gte'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__id__gte', local_var_params['simulation__threedimodel__id__gte']))  # noqa: E501
        if 'simulation__threedimodel__id__lt' in local_var_params and local_var_params['simulation__threedimodel__id__lt'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__id__lt', local_var_params['simulation__threedimodel__id__lt']))  # noqa: E501
        if 'simulation__threedimodel__id__lte' in local_var_params and local_var_params['simulation__threedimodel__id__lte'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__id__lte', local_var_params['simulation__threedimodel__id__lte']))  # noqa: E501
        if 'simulation__threedimodel__id__isnull' in local_var_params and local_var_params['simulation__threedimodel__id__isnull'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__id__isnull', local_var_params['simulation__threedimodel__id__isnull']))  # noqa: E501
        if 'simulation__threedimodel__name' in local_var_params and local_var_params['simulation__threedimodel__name'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__name', local_var_params['simulation__threedimodel__name']))  # noqa: E501
        if 'simulation__threedimodel__name__iexact' in local_var_params and local_var_params['simulation__threedimodel__name__iexact'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__name__iexact', local_var_params['simulation__threedimodel__name__iexact']))  # noqa: E501
        if 'simulation__threedimodel__name__contains' in local_var_params and local_var_params['simulation__threedimodel__name__contains'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__name__contains', local_var_params['simulation__threedimodel__name__contains']))  # noqa: E501
        if 'simulation__threedimodel__name__icontains' in local_var_params and local_var_params['simulation__threedimodel__name__icontains'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__name__icontains', local_var_params['simulation__threedimodel__name__icontains']))  # noqa: E501
        if 'simulation__threedimodel__name__in' in local_var_params and local_var_params['simulation__threedimodel__name__in'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__name__in', local_var_params['simulation__threedimodel__name__in']))  # noqa: E501
        if 'simulation__threedimodel__name__startswith' in local_var_params and local_var_params['simulation__threedimodel__name__startswith'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__name__startswith', local_var_params['simulation__threedimodel__name__startswith']))  # noqa: E501
        if 'simulation__threedimodel__name__istartswith' in local_var_params and local_var_params['simulation__threedimodel__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__name__istartswith', local_var_params['simulation__threedimodel__name__istartswith']))  # noqa: E501
        if 'simulation__threedimodel__name__endswith' in local_var_params and local_var_params['simulation__threedimodel__name__endswith'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__name__endswith', local_var_params['simulation__threedimodel__name__endswith']))  # noqa: E501
        if 'simulation__threedimodel__name__regex' in local_var_params and local_var_params['simulation__threedimodel__name__regex'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__name__regex', local_var_params['simulation__threedimodel__name__regex']))  # noqa: E501
        if 'simulation__user__username' in local_var_params and local_var_params['simulation__user__username'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username', local_var_params['simulation__user__username']))  # noqa: E501
        if 'simulation__user__username__iexact' in local_var_params and local_var_params['simulation__user__username__iexact'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username__iexact', local_var_params['simulation__user__username__iexact']))  # noqa: E501
        if 'simulation__user__username__contains' in local_var_params and local_var_params['simulation__user__username__contains'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username__contains', local_var_params['simulation__user__username__contains']))  # noqa: E501
        if 'simulation__user__username__icontains' in local_var_params and local_var_params['simulation__user__username__icontains'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username__icontains', local_var_params['simulation__user__username__icontains']))  # noqa: E501
        if 'simulation__user__username__in' in local_var_params and local_var_params['simulation__user__username__in'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username__in', local_var_params['simulation__user__username__in']))  # noqa: E501
        if 'simulation__user__username__startswith' in local_var_params and local_var_params['simulation__user__username__startswith'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username__startswith', local_var_params['simulation__user__username__startswith']))  # noqa: E501
        if 'simulation__user__username__istartswith' in local_var_params and local_var_params['simulation__user__username__istartswith'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username__istartswith', local_var_params['simulation__user__username__istartswith']))  # noqa: E501
        if 'simulation__user__username__endswith' in local_var_params and local_var_params['simulation__user__username__endswith'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username__endswith', local_var_params['simulation__user__username__endswith']))  # noqa: E501
        if 'simulation__user__username__regex' in local_var_params and local_var_params['simulation__user__username__regex'] is not None:  # noqa: E501
            query_params.append(('simulation__user__username__regex', local_var_params['simulation__user__username__regex']))  # noqa: E501
        if 'simulation__active_status__name' in local_var_params and local_var_params['simulation__active_status__name'] is not None:  # noqa: E501
            query_params.append(('simulation__active_status__name', local_var_params['simulation__active_status__name']))  # noqa: E501
        if 'simulation__active_status__name__iexact' in local_var_params and local_var_params['simulation__active_status__name__iexact'] is not None:  # noqa: E501
            query_params.append(('simulation__active_status__name__iexact', local_var_params['simulation__active_status__name__iexact']))  # noqa: E501
        if 'simulation__active_status__name__contains' in local_var_params and local_var_params['simulation__active_status__name__contains'] is not None:  # noqa: E501
            query_params.append(('simulation__active_status__name__contains', local_var_params['simulation__active_status__name__contains']))  # noqa: E501
        if 'simulation__active_status__name__icontains' in local_var_params and local_var_params['simulation__active_status__name__icontains'] is not None:  # noqa: E501
            query_params.append(('simulation__active_status__name__icontains', local_var_params['simulation__active_status__name__icontains']))  # noqa: E501
        if 'simulation__active_status__name__in' in local_var_params and local_var_params['simulation__active_status__name__in'] is not None:  # noqa: E501
            query_params.append(('simulation__active_status__name__in', local_var_params['simulation__active_status__name__in']))  # noqa: E501
        if 'simulation__active_status__name__startswith' in local_var_params and local_var_params['simulation__active_status__name__startswith'] is not None:  # noqa: E501
            query_params.append(('simulation__active_status__name__startswith', local_var_params['simulation__active_status__name__startswith']))  # noqa: E501
        if 'simulation__active_status__name__istartswith' in local_var_params and local_var_params['simulation__active_status__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('simulation__active_status__name__istartswith', local_var_params['simulation__active_status__name__istartswith']))  # noqa: E501
        if 'simulation__active_status__name__endswith' in local_var_params and local_var_params['simulation__active_status__name__endswith'] is not None:  # noqa: E501
            query_params.append(('simulation__active_status__name__endswith', local_var_params['simulation__active_status__name__endswith']))  # noqa: E501
        if 'simulation__active_status__name__regex' in local_var_params and local_var_params['simulation__active_status__name__regex'] is not None:  # noqa: E501
            query_params.append(('simulation__active_status__name__regex', local_var_params['simulation__active_status__name__regex']))  # noqa: E501
        if 'simulation__type__live' in local_var_params and local_var_params['simulation__type__live'] is not None:  # noqa: E501
            query_params.append(('simulation__type__live', local_var_params['simulation__type__live']))  # noqa: E501
        if 'simulation__organisation__name__istartswith' in local_var_params and local_var_params['simulation__organisation__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('simulation__organisation__name__istartswith', local_var_params['simulation__organisation__name__istartswith']))  # noqa: E501
        if 'simulation__organisation__unique_id' in local_var_params and local_var_params['simulation__organisation__unique_id'] is not None:  # noqa: E501
            query_params.append(('simulation__organisation__unique_id', local_var_params['simulation__organisation__unique_id']))  # noqa: E501
        if 'simulation__status' in local_var_params and local_var_params['simulation__status'] is not None:  # noqa: E501
            query_params.append(('simulation__status', local_var_params['simulation__status']))  # noqa: E501
        if 'simulation__tags__in' in local_var_params and local_var_params['simulation__tags__in'] is not None:  # noqa: E501
            query_params.append(('simulation__tags__in', local_var_params['simulation__tags__in']))  # noqa: E501
        if 'ordering' in local_var_params and local_var_params['ordering'] is not None:  # noqa: E501
            query_params.append(('ordering', local_var_params['ordering']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer', 'OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/usage/statistics/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UsageStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
