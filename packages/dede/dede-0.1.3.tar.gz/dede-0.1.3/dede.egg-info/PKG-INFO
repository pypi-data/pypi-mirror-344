Metadata-Version: 2.1
Name: dede
Version: 0.1.3
Summary: Decouple and Decompose: Scaling Resource Allocation through a Different Lens
Home-page: https://github.com/harvard-cns/dede
Author: Zhiying Xu
Author-email: xuzhiying9510@gmail.com
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: cvxpy==1.4.0
Requires-Dist: ray

# DeDe

DeDe is a general, scalable, and theoretically grounded framework that accelerates resource allocation through **decouple** and **decompose**.

## Getting started

### Hardware requirements
- Linux OS
- A multi-core CPU instance

### Dependencies
- Python >= 3.8
- Run `pip install dede` to install `dede`

## Running DeDe
DeDe borrows the interface from `cvxpy` and inherits most of its methods, e.g. `Variable(.)`, `Minimize(.)`. 

Different from `cvxpy`,

- DeDe requires separate `resource_constraints` and `demand_constraints` when constructing a problem.
- DeDe has additional arguments in the `solve(.)` methods:
  - `enable_dede`: use DeDe if True; use `cvxpy` if False.
  - `num_cpus`: the number of CPU cores; if not specified, DeDe uses all available CPUs.
  - `rho`: the rho parameter in ADMM formulation.
  - `num_iter`: the number of iteration; if not specified, DeDe stops iterations when the improvement in accuracy is below 1%.

A toy example for resource allocation with DeDe is as follows. To run this example, run `PYTHONPATH=<PROJECT_ROOT> pytest` directly.
```
import dede as dd
N, M = 100, 100

# Create allocation variables.
x = dd.Variable((N, M), nonneg=True)

# Create the constraints.
resource_constraints = [x[i,:].sum() >= i for i in range(N)]
demand_constraints = [x[:,j].sum() <= j for j in range(M)]

# Create an objective.
objective = dd.Minimize(x.sum())

# Construct the problem.
prob = dd.Problem(objective, resource_constraints, demand_constraints)

# Solve the problem with DeDe on a 4-core CPU.
print(prob.solve(num_cpus=4, solver=dd.ECOS))

# Solve the problem with cvxpy
print(prob.solve(enable_dede=False))
```

## Citation
If you use our code in your research, please cite our paper:
```
@inproceedings{dede,
    title={Decouple and Decompose: Scaling Resource Allocation through a Different Lens},
    author={Xu, Zhiying and Yan, Francis Y. and Yu, Minlan},
    booktitle={Proceedings of the USENIX OSDI 2025 Conference},
    month=jul,
    year={2025}
}
```
