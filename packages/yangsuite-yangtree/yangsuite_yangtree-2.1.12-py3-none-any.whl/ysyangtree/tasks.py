# Copyright 2016-2021 Cisco Systems, Inc
"""Task handling for all transports."""
import os
import re
import shutil
import json
from collections import OrderedDict
from slugify import slugify
from jinja2 import Template
import yaml
import yamlordereddictloader
from yangsuite.paths import register_path, get_path
from yangsuite.logs import get_logger
from ysdevices import YSDeviceProfile
from distutils import dir_util
import lxml.etree as et
from copy import deepcopy

log = get_logger(__name__)

yang_template = """{{ task_name}}:
  source:
    pkg: genie.libs.sdk
    class: triggers.blitz.blitz.Blitz
  test_sections:{%- for key,task in yang_rpc.items() %}
  - {{ key }}:
    - yang:
        device: uut
        connection: {{ task['protocl'] }}
        operation: {{ task['operation'] }}
        protocol: {{ task['protocl'] }}
        datastore:
          type: ''
          lock: true
          retry: 40
        format:
          auto_validate: true
          negative_test: false
          pause: 0
          timeout: 30
          request_mode: '{{ task['request_mode'] }}'
          get_type: '{{ task['get_type'] }}'
          sub_mode: '{{ task['sub_mode'] }}'
          encoding: '{{ task['encoding'] }}'
          prefix: {{ task['prefix'] }}
          origin: '{{ task['origin'] }}'
          base64: {{ task['base64'] }}
          sample_interval: '{{ task['sample_interval'] }}'
          stream_max: 0
          sequence: false
        content:{% if  task['operation'] == 'rpc' %}
          rpc: |
            {{ task['content']|trim|indent(width=12,first=False, blank=False)}}
          {%- else %}
          {{ task['content']|trim|indent(width=10,first=False, blank=False)}}
          {%- endif %}
        log:
          name: {{ task['name'] }}
          category: {{ task['category'] }}
          module: {% if task['module'] == '' %}''{% else -%}
          {{task['module']}}{% endif %}
          revision: '{{ task['revision'] }}'
        banner: {{ task['banner'] }}
        {%- endfor %}
    """


class TaskException(Exception):
    """Base exception class for Tasks."""

    def __init__(self, msg=''):
        """Set default message if non given."""
        if not msg:
            msg = 'No task reply'
        super(TaskException, self).__init__(msg)


class TaskNotFoundException(TaskException):
    """Task name not found at path."""

    def __init__(self, name):
        """Return connect fail."""
        msg = 'Task "{0}" does not exist'.format(name)
        super(TaskNotFoundException, self).__init__(msg)


class TaskHandler(object):
    """Handle task actions like save, get, delete.

    .. automethod:: __init__
    """

    @classmethod
    def get_category_list(cls, path, generated_only=False):
        """Retrieve the list of available categories.

        Args:
          path (str): Directory containing category directories
          generated_only (bool): If True, only list categories that contain
            at least one autogenerated replay.

        Returns:
          list: of category names
        """
        categories = []

        for path, _, files in os.walk(path):
            for f in files:
                if f.endswith('.tsk'):
                    with open(os.path.join(path, f)) as fd:
                        try:
                            replay = json.load(fd)
                            if not generated_only:
                                categories.append(replay['category'])
                                break
                            elif (replay.get('autogenerated', False) or
                                  ('autogenerated' not in replay and
                                   re.match(r'^\d\d\d\d\d -', replay['name']))):
                                categories.append(replay['category'])
                                break
                        except json.JSONDecodeError as e:
                            log.error("Replay {0} JSON error:\n{1}"
                                      .format(f, str(e)))
                elif f.endswith('.yaml'):
                    with open(os.path.join(path, f)) as fd:
                        try:
                            data_yaml = yaml.load(
                                        fd,
                                        Loader=yamlordereddictloader.Loader)
                            cat_rep_data = get_value_for_key_from_yaml(
                                        data_yaml, 'log')
                            cat_rep = dict(cat_rep_data)
                            cat = ''
                            cat = set_default('', cat_rep['category'], '')
                            if cat and (not generated_only):
                                categories.append(cat)
                                break
                        except json.JSONDecodeError as e:
                            log.error("Replay {0} YAML error:\n{1}"
                                      .format(f, str(e)))
        return sorted(categories)

    @classmethod
    def get_task_list(cls, path):
        """Retrieve the list of categories with tasks.

        Args:
          path (str): Directory containing categories and replays.

        Returns:
          dict: ``{category: [[name, filename (, variables)], ...], ...}``
        """
        tasks = {}

        for path, sub, files in os.walk(path):
            for f in files:
                if f.endswith('.tsk'):
                    with open(os.path.join(path, f)) as fd:
                        try:
                            replay = json.load(fd)
                            if 'category' not in replay:
                                log.error(
                                    "Replay {0} missing category"
                                    .format(f)
                                )
                                continue
                            yaml_file = f.replace('.tsk', '.yaml')
                            if os.path.exists(os.path.join(path, yaml_file)):
                                f = yaml_file
                            cat = replay['category']
                            rep_name = replay['name']
                            if rep_name:
                                if cat in tasks:
                                    if (not any(rep_name in x for x
                                                in tasks[cat])):
                                        tasks[cat].append([rep_name, f])
                                else:
                                    tasks[cat] = [[rep_name, f]]
                        except json.JSONDecodeError as e:
                            log.error(
                                "Replay {0} JSON error:\n{1}"
                                .format(f, str(e))
                            )
                            continue
                elif f.endswith('.yaml'):
                    with open(os.path.join(path, f)) as fd:
                        try:
                            data_yaml = yaml.load(
                                        fd,
                                        Loader=yamlordereddictloader.Loader)
                            cat_rep = dict(get_value_for_key_from_yaml(
                                        data_yaml, 'log'))
                            cat, rep_name = '', ''
                            cat = cat_rep.get('category', '')
                            rep_name = cat_rep.get('name', '')
                            if cat in tasks:
                                if (not any(rep_name in x for x
                                            in tasks[cat])):
                                    tasks[cat].append([rep_name, f])
                            else:
                                tasks[cat] = [[rep_name, f]]
                        except json.JSONDecodeError as e:
                            log.error(
                                "Replay {0} YAML error:\n{1}"
                                .format(f, str(e))
                            )
                        continue
        sorted_tasks = OrderedDict()
        for category in sorted(tasks.keys()):
            if tasks[category]:
                if not tasks[category]:
                    del tasks[category]
                sorted_tasks[category] = sorted(tasks[category])
        return sorted_tasks

    @classmethod
    def delete_category(cls, user, category):
        """Delete the given category and all replays it contains.

        Args:
          category (str): Name of category to delete.

        Returns:
          dict: {"result": success message}

        Raises:
          TaskException: if the requested category doesn't exist.
        """
        path = get_path('replay_category_dir', user=user, category=category)
        if not os.path.isdir(path):
            raise TaskException("No such category")
        shutil.rmtree(path)
        return {"result": 'Successfully deleted "{0}"'.format(category)}

    @classmethod
    def replay_file_path(cls, path, category, replay):
        """Path to a replay file in a category under the given base path."""
        if not category:
            raise ValueError("Category must be specified")
        yaml_file = os.path.join(path, slugify(category),
                                 slugify(replay) + '.yaml')
        if yaml_file and os.path.isfile(yaml_file):
            return yaml_file
        else:
            return os.path.join(path, slugify(category),
                                slugify(replay) + '.tsk')

    @classmethod
    def get_replay(cls, path, category, replay, variables=None):
        """Retrieve the data dictionary describing the given replay.

        Args:
          path (str): Base tasks/replays directory
          category (str): Replay category name
          replay (str): Replay name
          variables (dict): Mapping variable names to values; if specified,
            these will be substituted into the replay dict before returning it.

        Returns:
          dict: describing the replay in question.

        Raises:
          TaskNotFoundException: if the requested replay does not exist.
        """

        file_path = cls.replay_file_path(path, category, replay)
        if not os.path.exists(file_path):
            raise TaskNotFoundException(replay)
        replay_dict = {}
        with open(file_path) as fd:
            if variables:
                vars_list = cls.get_xml_str_replay_variables(path, category,
                                                             replay)
                for list_item in vars_list['str_var']:
                    if list_item not in variables:
                        variables[list_item] = "{{" + list_item + "}}"

                for list_item in vars_list['xml_var']:
                    if list_item not in variables:
                        variables[list_item] = "_-" + list_item + "-_"

                tpl = Template(fd.read(),
                               variable_start_string="{{",
                               variable_end_string="}}")
                data = tpl.render(variables)
                tpl2 = Template(data,
                                variable_start_string="_-",
                                variable_end_string="-_")
                data = tpl2.render(variables)
                replay_dict_data = yaml.load(data, Loader=yamlordereddictloader.Loader)
                # Parsing the YAML file to load the tree
                # (making the segments component)
                replay_dict['category'] = category
                segment_replay = update_task_as_segment(replay_dict_data)
                replay_dict['segments'] = list(segment_replay['segments'])
                replay_dict['name'] = replay
                replay_dict['autogenerated'] = False
            else:
                if file_path.lower().endswith(('.yaml')):
                    replay_dict_data = yaml.load(
                        open(file_path),
                        Loader=yamlordereddictloader.Loader
                    )
                    replay_dict['category'] = category
                    segment_replay = update_task_as_segment(replay_dict_data)
                    replay_dict['segments'] = list(segment_replay['segments'])
                    replay_dict['name'] = replay
                    replay_dict['autogenerated'] = False
                else:
                    replay_dict = json.load(fd)
        # Clean up obsolete data if present
        if 'filename' in replay_dict:
            del replay_dict['filename']

        # Add newer data if absent
        if 'autogenerated' not in replay_dict:
            if re.match(r"^\d\d\d\d\d -", replay_dict['name']):
                replay_dict['autogenerated'] = True
            else:
                replay_dict['autogenerated'] = False
        return replay_dict

    VARIABLE_RE = re.compile(r'(?:{{|_-)\s*(\S+?)\s*(?:}}|-_)')
    VARIABLE_RE_STR = re.compile(r'(?:{{)\s*(\S+?)\s*(?:}})')
    VARIABLE_RE_XML = re.compile(r'(?:_-)\s*(\S+?)\s*(?:-_)')
    """Pattern matching a variable declaration in a replay."""

    @classmethod
    def get_yaml_replay(cls, path, category, replay, variables=None):
        """Retrieve the data dictionary describing the given replay.

        Args:
          path (str): Base tasks/replays directory
          category (str): Replay category name
          replay (str): Replay name
          variables (dict): Mapping variable names to values; if specified,
            these will be substituted into the replay dict before returning it.

        Returns:
          dict: describing the replay in question.

        Raises:
          TaskNotFoundException: if the requested replay does not exist.
        """
        file_path = cls.replay_file_path(path, category, replay)
        if not os.path.exists(file_path):
            raise TaskNotFoundException(replay)
        with open(file_path) as fd:
            if file_path.lower().endswith(('.yaml')):
                replay_dict = yaml.safe_load(fd)
            else:
                replay_dict = json.load(fd)
        return replay_dict

    @classmethod
    def get_replay_variables(cls, path, category, replay):
        """Get the list of variables applicable to the given replay.

        Args:
          path (str): Base tasks/replays directory
          category (str): Category name
          replay (str) Replay name

        Returns:
          list: of variable names
        """
        file_path = cls.replay_file_path(path, category, replay)
        if not os.path.exists(file_path):
            raise TaskNotFoundException(replay)
        with open(file_path) as fd:
            replay_text = fd.read()
        vars = cls.VARIABLE_RE.findall(replay_text)
        variables = set()
        for v in vars:
            variables.add(v.strip())
        return sorted(variables)

    @classmethod
    def get_xml_str_replay_variables(cls, path, category, replay):
        """Get the list of string and xml variables
           applicable to the given replay.

        Args:
          path (str): Base tasks/replays directory
          category (str): Category name
          replay (str) Replay name

        Returns:
          dict: of variable names
        """
        file_path = cls.replay_file_path(path, category, replay)
        if not os.path.exists(file_path):
            raise TaskNotFoundException(replay)
        with open(file_path) as fd:
            replay_text = fd.read()
        vars_xml = cls.VARIABLE_RE_XML.findall(replay_text)
        vars_str = cls.VARIABLE_RE_STR.findall(replay_text)
        var_dict = {}
        variables_xml = set()
        variables_str = set()

        for x in vars_xml:
            variables_xml.add(x.strip())
        var_dict["xml_var"] = sorted(variables_xml)

        for s in vars_str:
            variables_str.add(s.strip())
        var_dict["str_var"] = sorted(variables_str)

        return var_dict

    def __init__(self, name, path, cfg={}):

        """Initialize TaskHandler.

        Args:
          name (str): Task name.
          path (str): Path to local task directory.
          cfg (dict): Task configuration contains:

            - category (str): User defined category
              TODO: category should be split out into a top-level parameter,
              instead of a part of this dictionary, as the dictionary is
              otherwise optional for some APIs.
            - description (str): Description of task
            - autogenerated (bool): Is this an auto-generated replay?
            - devices (list): Devices this task was tested on
            - platforms (list): Platforms this task was tested on
            - images (list): Images this task was tested on
            - variables (dict): Variables and their assigned values
              (only used in retrieve_task() at present)
            - segments (list or str): List of dicts of info needed
              to form RPC(s), each with structure::

                {
                  'segment': '1',
                  'commit': '',
                  'cfgd': {
                    'proto-op': 'edit-config',
                    'modules': {
                      'revision': '2018-01-05',
                      'namespace_prefixes': { ... },
                      'configs': [ ... ],
                    }
                  }
                }

            **OR** a single string containing RPC XML.
        """
        self.name = name
        self.category = cfg['category']
        self.path = path
        self.description = cfg.get('description', 'No description')
        self.autogenerated = cfg.get('autogenerated', False)
        self.segments = cfg.get('segments', [])
        self.platforms = cfg.get('platforms', [])
        self.devices = cfg.get('devices', '')
        self.images = cfg.get('images', [])
        self.variables = cfg.get('variables', {})
        self.protocl = cfg.get('protocl', 'netconf')
        self.action = cfg.get('action', 'get')
        self.prefix = cfg.get('prefix', False)
        self.origin = cfg.get('origin', '')
        self.get_type = cfg.get('get_type', '')
        self.request_mode = cfg.get('request_mode', '')
        self.sub_mode = cfg.get('sub_mode', '')
        self.encoding = cfg.get('encoding', '')
        self.sample_interval = cfg.get('sample_interval', '')
        self.base64 = cfg.get('base64', False)
        self.operation = cfg.get('proto-op', 'get-config')

    @property
    def name(self):
        """Human-readable name of this replay."""
        return self._name

    @name.setter
    def name(self, name):
        self._name = name
        self._slug_name = slugify(name)

    @property
    def category(self):
        """Human-readable name of the category containing this replay."""
        return self._category

    @category.setter
    def category(self, cat):
        """NOTE: only call this at initialization time, as self.path
        will NOT be updated if the category is changed."""
        self._category = cat
        self._slug_category = slugify(cat)

    @property
    def path(self):
        """Path to category directory containing this replay file."""
        return self._path

    @path.setter
    def path(self, path):
        """NOTE: the provided `path` is the parent directory of `self.path`."""
        if path and os.path.isfile(path):
            raise TaskNotFoundException('\nPath is a file\n' + path)
        if not path or not os.path.isdir(path):
            raise TaskNotFoundException(path)

        self._path = os.path.join(path, self._slug_category)
        # need this if category changes
        self._base_path = path

    @property
    def file_path(self):
        """Path where replay file is/will be saved(Creating YAML File)."""
        return os.path.join(self.path, self._slug_name + '.tsk')

    @property
    def platforms(self):
        """List of platforms tested on.

        TODO: This is currently a list of
        YSDeviceProfile.netconf.device_variant strings, but it needs to
        be updated to be 1) protocol-agnostic and 2) more granular.
        """
        return list(self._platforms)

    @platforms.setter
    def platforms(self, platforms):
        self._platforms = set(platforms)

    @property
    def devices(self):
        """List of device profile names tested on."""
        return list(self._devices)

    @devices.setter
    def devices(self, devs=[]):
        self._devices = devs
        platforms = set()
        for dev in devs:
            try:
                profile = YSDeviceProfile.get(dev)
                if hasattr(profile, 'netconf'):
                    platforms.add(profile.netconf.device_variant)
            except Exception:
                continue
        # platform types will be saved to make the task portable
        if hasattr(self, "_platforms"):
            self._platforms.update(platforms)
        else:
            self._platforms = platforms

    @property
    def variables(self):
        """Dict of variables to values to insert when calling retrieve_task."""
        return self._variables

    @variables.setter
    def variables(self, var):
        if isinstance(var, (str, bytes)):
            self._variables = json.loads(var)
        elif isinstance(var, dict):
            self._variables = var
        else:
            self._variables = {}

    def retrieve_task(self):
        """Load the described replay from disk and return it as a dict.

        This will substitute in any variable values defined in self.variables.

        Returns:
          dict: ``{'task': (dict)}``

        Raises:
          TaskNotFoundException: if the task file does not exist
        """
        return {
            'task': self.get_replay(self._base_path,
                                    self.category,
                                    self.name,
                                    self.variables),
            'name': self.name,
            'category': self.category
        }

    def retrieve_replay(self):
        """Load the described replay from disk and return it as a dict.

        Returns:
          dict: ``{'task': (dict)}``

        Raises:
          TaskNotFoundException: if the task file does not exist
        """
        return {
            'task': self.get_yaml_replay(self._base_path,
                                         self.category,
                                         self.name,
                                         self.variables),
            'category': self.category,
            'name': self.name
        }

    def save_task(self, overwrite=False):
        """Save the data that this instance contains to a file on disk.

        Raises:
          TaskException: if ``self.segments`` is unset
          TaskException: if the target file already exists
        """
        if not self.segments:
            raise TaskException('No RPCs for {0} task.'.format(
                self.name))

        try:
            if not os.path.exists(self.path):
                os.makedirs(self.path)
            elif not os.path.isdir(self._path):
                raise TaskException('File exists with same name as category')
            if os.path.isfile(self.file_path) and not overwrite:
                log.warning('{0} already exists.'.format(self.name))
                raise TaskException('{0} already exists.'.format(self.name))

            task = {'name': self.name,
                    'description': self.description,
                    'category': self.category,
                    'autogenerated': self.autogenerated,
                    'platforms': self.platforms,
                    'images': self.images,
                    'protocl': self.protocl,
                    'action': self.action,
                    'prefix': self.prefix,
                    'origin': self.origin,
                    'get_type': self.get_type,
                    'request_mode': self.request_mode,
                    'sub_mode': self.sub_mode,
                    'encoding': self.encoding,
                    'sample_interval': self.sample_interval,
                    'base64': self.base64,
                    'operation': self.operation,
                    'segments': []}

            rpcs = self.segments

            if isinstance(rpcs, list) or isinstance(rpcs, tuple):
                for rpc in rpcs:
                    if 'cfgd' not in rpc:
                        # Assuming this segment is constructed correctly
                        # as shown in segment dicts below.
                        task['segments'].append(rpc)
                    elif 'cfgd' in rpc:
                        # Need to build this segment based on format of GUI
                        # TODO: GUI should be converted to same format used
                        #       in backend which adjusted for multiple models
                        cfgd = rpc['cfgd']

                        segment = {
                            'segment': rpc['segment'],
                            'description': self.description,
                            'commit': rpc['commit'],
                            'cli': rpc.get('cli', ''),
                            'cli_verify': rpc.get('cli_verify', ''),
                            'yang': {
                                'proto-op': cfgd['proto-op'],
                                'modules': cfgd['modules']
                            }
                        }

                        task['segments'].append(segment)
                        task['operation'] = cfgd['proto-op']
            elif hasattr(rpcs, 'splitlines'):
                #  custom RPC string saved to task
                rpc = ''
                ctr = 1
                for line in rpcs.splitlines():
                    rpc += line + '\n'
                    if line.endswith('rpc>'):
                        segment = {
                            'segment': ctr,
                            'description': self.description,
                            'commit': '',
                            'yang': {
                                'proto-op': 'rpc',
                                'rpc': rpc
                            }
                        }

                        task['segments'].append(segment)
                        task['operation'] = 'rpc'
                        ctr += 1
                        rpc = ''
            else:
                raise TaskException('Unexpected data type for "rpcs": {0}'
                                    .format(type(rpcs)))

            with open(self.file_path, 'w') as fd:
                json.dump(task, fd, indent=2, sort_keys=True)

            return '{0} saved.'.format(self.name)

        except Exception as e:
            log.error('Save task {0} at {1} failed'.format(
                self.name, self.path))
            raise e

    def edit_task(self, name, category):
        """Edit metadata of an existing replay.

        Can update the replay's:

         - name (as provided in the args)
         - category (as provided in the args)
         - description (using self.description)
         - platforms (using self.platforms)
         - images (using self.images)

        Use save_task_data to update segments, autogenerated, variables.

        Args:
         name (str): Task name (may be new)
         category (str): Task category (may be new)

        Raises:
         TaskNotFoundException: if no existing task file is found
        """
        try:
            file_path = ''
            oldfile = ''

            if os.path.isfile(self.file_path):
                file_path = self.file_path
            elif os.path.isfile(self.file_path.replace('.tsk', '.yaml')):
                file_path = self.file_path.replace('.tsk', '.yaml')
            else:
                log.error('{0} does not exist'.format(self.name))
                raise TaskNotFoundException(self.name)
            if file_path.endswith(".tsk"):
                with open(file_path) as fd:
                    task = json.load(fd)
            elif file_path.endswith(".yaml"):
                with open(file_path) as fd:
                    task = yaml.full_load(fd)
            if file_path.endswith(".tsk"):
                task['name'] = name
                task['category'] = category
                task['description'] = self.description
                task['platforms'] = self.platforms
                task['images'] = self.images

            elif file_path.endswith(".yaml"):
                set_name = ''
                set_category = ''
                # retrieving old to to replace with new key
                key = [*task][0]
                if key:
                    task[category+'-'+name] = task.pop(key)
                # replacing new name and category with old ones
                set_name = set_value_for_key_in_yaml(task, 'name', name)
                set_category = set_value_for_key_in_yaml(task,
                                                         'category',
                                                         category)
                if name != set_name:
                    raise KeyError("Error occurred while changing "
                                   "the name '{0}' ".format(name))
                if category != set_category:
                    raise KeyError("Error occurred while changing "
                                   "the category '{0}' ".format(category))
            # new name or new category - file changes are needed
            if (name, category) != (self.name, self.category):
                if file_path.endswith(".tsk"):
                    newfile = os.path.join(self._base_path, slugify(category),
                                           slugify(name) + '.tsk')
                elif file_path.endswith(".yaml"):
                    newfile = os.path.join(self._base_path, slugify(category),
                                           slugify(name) + '.yaml')

                if os.path.isfile(newfile):
                    log.warning('{0} already exists.'.format(self.name))
                    raise TaskException('{0} already exists.'.format(
                        self.name))

                # when modify works we will get rid of this one
                oldfile = file_path

                file_path = newfile

                # new category?
                if not os.path.exists(os.path.join(self._base_path,
                                                   slugify(category))):
                    os.makedirs(os.path.join(self._base_path,
                                             slugify(category)))

            # write new task contents
            if file_path.endswith(".tsk"):
                with open(file_path, 'w') as fd:
                    json.dump(task, fd, indent=2, sort_keys=True)
            elif file_path.endswith(".yaml"):
                with open(file_path, 'w') as fd:
                    yaml.dump(task, fd,
                              default_flow_style=False,
                              sort_keys=False)

            if os.path.isfile(oldfile):
                # name or category was changed so get rid of old file
                os.remove(oldfile)

            if file_path.endswith(".yaml"):
                if not os.listdir(self.path):
                    shutil.rmtree(self.path)

            return_msg = '{0} modified.'.format(self.name)
            self.name = name
            self.category = category
            self.path = self._base_path

            return return_msg

        except Exception as e:
            log.error('Edit task {0} at {1} failed'.format(
                self.name, self.path))
            raise e

    def del_task(self):
        """Delete this replay's file from disk, and possibly the category too.
        Raises:
          TaskNotFoundException: if no such replay file exists
        """
        try:
            file_path = self.file_path
            # get the '.yaml' file if exist,self.file_path is '.tsk'
            yaml_file_path = file_path.replace('.tsk', '.yaml')
            if os.path.isfile(self.file_path):
                file_path = self.file_path
            elif os.path.isfile(yaml_file_path):
                file_path = yaml_file_path
            else:
                log.error('{0} does not exist'.format(self.name))
                raise TaskNotFoundException(self.name)

            os.remove(file_path)
            if file_path.endswith('.yaml'):
                if not [f for f in os.listdir(self.path) if f.endswith(
                                                            '.yaml')]:
                    shutil.rmtree(self.path)
            else:
                if not [f for f in os.listdir(self.path) if f.endswith(
                                                            '.tsk')]:
                    shutil.rmtree(self.path)

            return 'Deleted replay "{0}"'.format(self.name)
        except Exception as e:
            log.error('Delete of replay "{0}" at {1} failed'.format(
                self.name, self.path))
            raise e

    def save_task_data(self, task):
        """Update an existing replay with new contents.
        Args:
          task (str): JSON string describing the data to be saved
        Raises:
          TaskNotFoundException: if ``self.name`` is unset (TODO?)
          TaskException: if ``task`` is not set
          TaskNotFoundException: if no previous replay file exists
        """
        if not self.name:
            raise TaskNotFoundException(self.name)
        if not task:
            raise TaskException("No RPCs to save")
        file_path = ''
        if os.path.isfile(self.file_path):
            file_path = self.file_path
        else:
            log.error('{0} does not exist'.format(self.name))
            raise TaskNotFoundException(self.name)

        with open(file_path, 'w') as fd:
            task = json.loads(task)
            json.dump(task, fd, indent=2, sort_keys=True)

        return '{0} data saved'.format(self.name)

    def save_replay(self, overwrite=False):
        """Save the replay data that this instance contains to a file on disk.

        Raises:
          TaskException: if ``self.segments`` is unset
          TaskException: if the target file already exists
        """
        try:
            if not os.path.exists(self.path):
                os.makedirs(self.path)
            elif not os.path.isdir(self._path):
                raise TaskException('File exists with same name as category')
            if os.path.isfile(self.file_path) and not overwrite:
                log.warning('{0} already exists.'.format(self.name))
                raise TaskException('{0} already exists.'.format(self.name))
            task = {'name': self.name,
                    'description': self.description,
                    'category': self.category,
                    'autogenerated': self.autogenerated,
                    'platforms': self.platforms,
                    'images': self.images,
                    'protocl': self.protocl,
                    'action': self.action,
                    'prefix': self.prefix,
                    'origin': self.origin,
                    'get_type': self.get_type,
                    'request_mode': self.request_mode,
                    'sub_mode': self.sub_mode,
                    'encoding': self.encoding,
                    'sample_interval': self.sample_interval,
                    'base64': self.base64,
                    'operation': self.operation,
                    'segments': []}

            rpcs = self.segments
            if isinstance(rpcs, list) or isinstance(rpcs, tuple):
                for rpc in rpcs:
                    if 'cfgd' not in rpc:
                        # Assuming this segment is constructed correctly
                        # as shown in segment dicts below.
                        task['segments'].append(rpc)
                        operation = rpc['yang']['proto-op']
                        task['operation'] = operation
                        task['banner'] = 'YANG ' + str(operation
                                                       ).upper()
                    elif 'cfgd' in rpc:
                        # Need to build this segment based on format of GUI
                        # TODO: GUI should be converted to same format used
                        #       in backend which adjusted for multiple models
                        cfgd = rpc['cfgd']
                        segment = {
                            'segment': rpc['segment'],
                            'description': self.description,
                            'commit': rpc['commit'],
                            'cli': rpc.get('cli', ''),
                            'cli_verify': rpc.get('cli_verify', ''),
                            'yang': {
                                'proto-op': cfgd['proto-op'],
                                'modules': cfgd['modules']
                            }
                        }

                        task['segments'].append(segment)
                        task['operation'] = cfgd['proto-op']
                        task['banner'] = 'YANG ' + str(cfgd['proto-op']
                                                       ).upper()
            elif hasattr(rpcs, 'splitlines'):
                #  custom RPC string saved to task
                rpc = ''
                ctr = 1
                for line in rpcs.splitlines():
                    rpc += line
                    if line.endswith('rpc>'):
                        segment = {
                            'segment': ctr,
                            'description': self.description,
                            'commit': '',
                            'yang': {
                                'proto-op': 'rpc',
                                'rpc': rpc.strip()
                            }
                        }
                        task['segments'].append(segment)
                        task['operation'] = 'rpc'
                        task['banner'] = 'YANG CUSTOM'
                        ctr += 1
                        rpc = ''
            else:
                raise TaskException('Unexpected data type for "rpcs": {0}'
                                    .format(type(rpcs)))

            self.save_replay_yaml(task, self.file_path)
            return '{0} saved.'.format(self.name)

        except Exception as e:
            log.error('Save task {0} at {1} failed'.format(
                self.name, self.path))
            raise e

    def save_replay_yaml(self, task, yaml_file_path=''):
        """Save the replay data this instance contains to a yaml file on
            disk or returning the content.

        Args:
          task (str): JSON string describing the data to be saved
          yaml_file_path(str): path to save the yaml content.
            if path is not supplied, then return contents.
        Raises:
          TaskException: if any issue while converting the data.
        """
        try:
            task_name = str(task['category']) + '-' + str(task['name'])
            section_name = slugify(task_name, separator='_')
            segments = modify_segment_data_for_save_replay(task)
            test_sections = {}
            top_data = deepcopy(task)
            top_data.pop('segments')

            if segments:
                for counter, segment in enumerate(segments):
                    new_top_data = {}
                    new_top_data.update(top_data)
                    new_top_data['module'] = segment['module_name']
                    new_top_data['revision'] = segment['revision']
                    if counter:
                        section_name = section_name + '_' + str(counter)
                    test_sections[section_name] = new_top_data
                    if segment['operation'] == 'rpc':
                        rpc_str = re.sub(r">\s+<+", '><', segment['content'])
                        rpcobj = et.fromstring((rpc_str).strip())
                        rpc_str = et.tostring(rpcobj, pretty_print=True)
                        rpc_str = rpc_str.decode()
                        content_yaml = rpc_str
                    else:
                        content_yaml = segment['content_yaml']
                    test_sections[section_name]['content'] = content_yaml
                    test_sections[section_name]['type'] = 'n'

            if yaml_file_path:
                # getting the .yaml file for saving replay.
                if yaml_file_path.endswith(".tsk"):
                    yaml_file_path = yaml_file_path.replace('.tsk', '.yaml')
            with open(yaml_file_path, mode="w+") as file:
                tplt = Template(yang_template)
                yang_custom = tplt.render({
                                            'task_name': task_name,
                                            'yang_rpc': test_sections
                                            })
                file.write(yang_custom)
        except Exception as e:
            log.error("Yaml data save/return failed.")
            raise e


def set_replay_path(replay_dir):
    """Set replay path to an alternative base.

    """
    register_path('replay_base_dir', replay_dir, replace=True)
    register_path('replays_dir', 'replays',
                  parent='replay_base_dir', autocreate=True, replace=True)
    # Deprecated, to be removed:
    register_path('tasks_dir', 'replays',
                  parent='replay_base_dir', autocreate=True, replace=True)

    log.info("Replay path set to %s", replay_dir)


def reset_replay_path(user):
    """Set replay path to default base."""
    register_path('replays_dir', 'replays',
                  parent='testing_dir', autocreate=True, replace=True)
    # Deprecated, to be removed:
    register_path('tasks_dir', 'replays',
                  parent='testing_dir', autocreate=True, replace=True)

    log.info("Replay path set to default")

    return get_path('replays_dir', user=user)


def check_replays_subdir(replay_dir_path):
    """Check if replays sub directory exist under top directory"""
    dir_name = os.path.basename(replay_dir_path)

    if dir_name.lower() == 'replays':
        return True
    else:
        return False


def check_default_replay_dir(replay_dir_path, request):
    """Check if it is default replay directory path"""
    dir_name = os.path.basename(replay_dir_path)

    if dir_name.lower() == 'tasks':
        # Check if directory ending with tasks is the default replay directory.
        default_dir_path = get_path('tasks_dir', user=request.user.username)
        if replay_dir_path == default_dir_path:
            return True
        else:
            return False
    else:
        return False


def migrate_replay_files(target_path):
    """Migrate replay files from ../../tasks to ../../testing/replays.

    Args:
      target_path: Directory path ending in "testing/replays"
    """
    if os.path.basename(target_path) != 'replays':
        return
    if os.path.basename(os.path.dirname(target_path)) != 'testing':
        return
    base_path = os.path.dirname(os.path.dirname(target_path))

    legacy_path = os.path.join(base_path, 'tasks')
    if not os.path.isdir(legacy_path):
        return

    dir_util.copy_tree(legacy_path, target_path)
    dir_util.remove_tree(legacy_path)


def refactor_nodes(nodes):
    """
    Decomposes the xpath values into separate node_list
    Args:
      nodes: Each node item from yaml file"
      Return: Updated structure of list, key (Separate Entry) to pass ui.

    """
    try:
        xtra_nodes = []
        for node_item in nodes:
            xtra_nodes.append(dict(node_item))
        return xtra_nodes
    except Exception as e:
        log.error("Leaf node creation failed.")
        raise e


def modify_segment_data_for_save_replay(task):
    """Getting the values for generating replay in YAML file.

    Args:
      task: json data of replay"
      Return: Dynamic content data for YAML File

    """
    yang_set = []
    for i, seg in enumerate(task['segments']):
        content_datas = {}
        content_data = {}
        operation = ''
        module_name = ''
        revision_val = ''
        try:
            yang = set_default(seg, 'yang')
            if yang:
                modules = set_default(yang, 'modules')
                operation = set_default(yang, 'proto-op', 'rpc')
                if operation == 'rpc':
                    content_data = set_default(yang, 'rpc')
                elif modules:
                    for mod, data in yang.get('modules', {}).items():
                        content_data['namespace'] = data['namespace_prefixes']
                        revision_val = data['revision']
                        configs = data['configs']
                        module_name = mod
                    node_list = []
                    if configs:
                        for node in configs:
                            node_data = {}
                            node_data['edit-op'] = set_default(node, 'edit-op')
                            node_data['nodetype'] = set_default(node,
                                                                'nodetype')
                            node_data['datatype'] = set_default(node,
                                                                'datatype')
                            node_data['value'] = set_default(node, 'value')
                            node_data['default'] = set_default(node, 'default')
                            node_data['xpath'] = set_default(node, 'xpath')
                            node_list.append(node_data)
                    content_data['nodes'] = node_list
        except Exception as e:
            log.error("Segment traversal failed.")
            raise e
        content_datas['operation'] = operation
        content_datas['content'] = content_data
        content_datas['content_yaml'] = yaml.safe_dump(
                                                content_data,
                                                default_flow_style=False,
                                                sort_keys=False
                                                )
        content_datas['module_name'] = module_name
        content_datas['revision'] = revision_val
        yang_set.append(content_datas)
    return yang_set


def set_default(dict_node, value, default=''):
    """Checking the value is set.if not updating with default value

    Args:
      dict_node: Dictionary to be check for key"
      value: If dict_node is not null , then key to be checked.
            if dict_node is null, then check value is null or not.
    Return: if value is null, then return the default, Else the value.

    """
    try:
        if isinstance(dict_node, dict):
            if value in dict_node.keys() and dict_node[value]:
                return dict_node[value]
            else:
                return default
        elif value:
            return value
        else:
            return default
    except Exception as e:
        log.error(" Default value set check failed.")
        raise e


def update_task_as_segment(task):
    """
        Rearranging replay file data in the segment format to load the tree.
        Args:
         task: Task data from the replay
        Return: Modified format of task data.

    """
    try:
        segments = []
        test_sections = get_value_for_key_from_yaml(task, 'test_sections')
        for test_section in test_sections:
            cat, rep_name, module_name, revision_val = '', '', '', ''
            yang = {}
            modules = {}
            module = {}
            segment = {'cli': '', 'cli_verify': '', 'commit': '',
                       'description': '', 'segment': 1}
            log_data = get_value_for_key_from_yaml(test_section, 'log')
            operation = get_value_for_key_from_yaml(test_section, 'operation')
            if log_data:
                rep_name = set_default('', log_data['name'], '')
                cat = set_default('', log_data['category'], '')
                module_name = set_default('', log_data['module'], '')
                revision_val = set_default('', log_data['revision'], '')
            if operation == 'rpc':
                yang['rpc'] = get_value_for_key_from_yaml(
                                test_section, 'rpc')
            else:
                content = get_value_for_key_from_yaml(test_section, 'content')
                format = get_value_for_key_from_yaml(test_section, 'format')
                if isinstance(content, OrderedDict):
                    for key, node in content.items():
                        if key == 'nodes':
                            node_updated = refactor_nodes(node)
                            modules['configs'] = node_updated
                        if key == 'namespace':
                            modules['namespace_prefixes'] = node
                            modules['revision'] = revision_val
                module[module_name] = modules
                yang['modules'] = module
                yang['format'] = format
            yang['proto-op'] = operation
            segment['yang'] = yang
            segments.append(segment)
        return ({'segments': segments,
                 'replay_name': rep_name,
                 'category': cat})
    except Exception as e:
        log.error("Updating into Segment failed.")
        raise e


def get_value_for_key_from_yaml(replay_yaml, yaml_key):
    """
        Getting the value from yaml file with key
        Args:
         replay_yaml: Replay YAML File
         yaml_key : The key for feching the value from yaml file
        Return: value of the key.

    """
    yaml_val = ''
    try:
        for k, v in replay_yaml.items():
            if k == yaml_key:
                yaml_val = v
                return yaml_val
            elif isinstance(v, OrderedDict):
                yaml_val = get_value_for_key_from_yaml(v, yaml_key)
                if yaml_val is not None:
                    return yaml_val
            elif isinstance(v, list):
                for list_key_replay in v:
                    yaml_val = get_value_for_key_from_yaml(
                                list_key_replay,
                                yaml_key
                                )
                    if yaml_val is not None:
                        return yaml_val
            else:
                continue
    except Exception:
        log.error("Error occured for "+str(yaml_key)+" in yaml.")
        return yaml_val


def set_value_for_key_in_yaml(replay_yaml, yaml_key, value):
    """
        Setting the value in yaml file for the key
        Args:
         replay_yaml: Replay YAML File.
         yaml_key : The key for feching the value from yaml file.
         value= The value which will replace the old value for desired key.
    """
    set_val = ''
    try:
        for k, v in replay_yaml.items():
            if k == yaml_key:
                replay_yaml[k] = value
                set_val = value
                break
            elif isinstance(v, dict):
                set_val = set_value_for_key_in_yaml(v, yaml_key, value)
            elif isinstance(v, list):
                for list_key_replay in v:
                    set_val = set_value_for_key_in_yaml(
                                list_key_replay,
                                yaml_key,
                                value
                                )
            else:
                continue
        return set_val
    except Exception:
        log.error("Error occured while setting value \
                   for " + str(yaml_key) + " in yaml.")
        raise KeyError(yaml_key)
