# coding: utf-8

"""
    Majordomo AI

    This is a API specification for Majordomo AI

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from majordomo_ai.models.app_types import AppTypes
from typing import Optional, Set
from typing_extensions import Self

class AppProfile(BaseModel):
    """
    Application Profile Information. 
    """ # noqa: E501
    name: StrictStr = Field(description="Name of the application profile.")
    workspace: StrictStr = Field(description="The workspace that contains the model profile.")
    app_type: AppTypes
    access_info: Dict[str, Any] = Field(description="Key value pairs with information required to access the application. The possible values for the different types are given below.  APP_TYPE_DOCKER_REGISTRY<br>   registry_name : Name of the registry<br>  APP_TYPE_ACR     registry_name : Name of the registry    APP_TYPE_ECR   registry_name : Name of the registry  APP_TYPE_AWS_S3   access_key : The AWS access key for accessing S3.   secret_token : The AWS secret token for accessing S3.   region :  AWS region.  APP_TYPE_AZURE_BLOB   client_id : The Azure client ID.   client_secret : The Azure client secret.   tenant_id : The Azure tenant ID.  APP_TYPE_WEBPAGE   None  APP_TYPE_PINECONE   cloud : The cloud in which the vector database is running.   region : The region in which the vector database is running.   api_key : API Key for accessing the Pinecone.  APP_TYPE_MONGO_VECTORDB   connect_string : The connect string to contact the Mongo Vector database.   database_name : The database name.  APP_TYPE_POSTGRES_VECTORDB   connect_string : The connect string to contact the Mongo Vector database.   database_name : The database name.  APP_TYPE_SQL   connect_string : The connect string to contact the Mongo Vector database.                     Format: postgres://   database_name : The database name.  APP_TYPE_MONGODB   connect_string : The connect string to contact the Mongo Vector database.   database_name : The database name.  APP_TYPE_CONFLUENCE   user_name : The user name for accessing the Confluence server.   api_token : API Token for accessing the server.   space_key : The key required to access the Confluence space.  APP_TYPE_ELASTIC_SEARCH   None ")
    shared_users: Optional[List[StrictStr]] = Field(default=None, description="The list of users this profile is shared with.")
    __properties: ClassVar[List[str]] = ["name", "workspace", "app_type", "access_info", "shared_users"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AppProfile from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AppProfile from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "name": obj.get("name"),
            "workspace": obj.get("workspace"),
            "app_type": obj.get("app_type"),
            "access_info": obj.get("access_info"),
            "shared_users": obj.get("shared_users")
        })
        return _obj


